#c *********************************************************************
#c
#c $Id: cpp.mac,v 1.61 2009/06/10 13:14:07 stuart_hc Exp $ $Name: V116 $
#c
#c The contents of this file are subject to the AAF SDK Public Source
#c License Agreement Version 2.0 (the "License"); You may not use this
#c file except in compliance with the License.  The License is available
#c in AAFSDKPSL.TXT, or you may obtain a copy of the License from the
#c Advanced Media Workflow Association, Inc., or its successor.
#c
#c Software distributed under the License is distributed on an "AS IS"
#c basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
#c the License for the specific language governing rights and limitations
#c under the License.  Refer to Section 3.3 of the License for proper use
#c of this Exhibit.
#c
#c WARNING:  Please contact the Advanced Media Workflow Association,
#c Inc., for more information about any additional licenses to
#c intellectual property covering the AAF Standard that may be required
#c to create and distribute AAF compliant products.
#c (http://www.amwa.tv/policies).
#c
#c Copyright Notices:
#c The Original Code of this file is Copyright 1998-2009, licensor of the
#c Advanced Media Workflow Association.  All rights reserved.
#c
#c The Initial Developer of the Original Code of this file and the
#c licensor of the Advanced Media Workflow Association is
#c Avid Technology.
#c All rights reserved.
#c
#c *********************************************************************


#ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
#c
#c AutoDodo macro file for use in generating C++ API implementation
#c files.
#c
#ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


#import macros/base.mac


#ccccccccccccccccccccccccccc
#c
#c Pass through argument if for idl otherwise omit it.
#c
#c This macro is generally used to specify IDL options that would
#c make since to emit to c++.
#c To allow proper marshalling code generation of a struct: |
#c typedef struct
#c {
#c     aafInt32 length;
#c     AD_IDL([length_is(length)]) aafWchar *str;
#c } aafString_t;
#c
#startm AD_IDL 01
#endm


#ccccccccccccccccccccccccccc
#c
#c Includes another file.
#c
#c Argument: Base filename
#c
#c Note: it is not necessary to expand it here, since it was already
#c included in this module's header file.
#c
#startm AD_INCLUDE 01
#endm


#ccccccccccccccccccccccccccc
#c
#c Includes another file in implementation (not header).
#c
#c Argument: Base filename
#c
#startm AD_CPPINCLUDE 01
#include "%01.h"
#endm


#ccccccccccccccccccccccccccc
#c
#c Adds quoted header include statement to idl file
#c
#c Argument1: Filename file to be included.
#c
#c
#startm AD_CPP_QUOTE_INCLUDE 01
#endm


#ccccccccccccccccccccccccccc
#c
#c Types definitions should only be used by idl and c++ & impl headers
#c
#c Argument: Pieces of UUID
#c
#c Example:
#c AD_TYPES_BEGIN(b1a21372, 1a7d, 11d2, bf, 78, 00, 10, 4b, c9, 15, 6d)
#c
#c TomR:980716: Added
#c
#startm AD_TYPES_BEGIN 11
#endm


#ccccccccccccccccccccccccccc
#c
#c Ends a types definition
#c
#c Types definitions should only be used by idl and c++ & impl headers
#c
#c Arguments: none
#c
#startm AD_TYPES_END 00
#endm


#ccccccccccccccccccccccccccc
#c
#c Argument1: base name to be converted to output type.
#c
#startm AD_AAFTYPES 01
%01\
#endm


#ccccccccccccccccccccccccccc
#c
#c Argument1: base name to be converted to output type.
#c
#startm AD_DECLARE_FORWARD_AAFTYPES 01
#endm


#ccccccccccccccccccccccccccc
#c
#c Argument1: text to be quoted.
#c
#c Ignore input this was already processed in the header file. 
#c
#startm AD_CPP_QUOTE 01
#endm


#ccccccccccccccccccccccccccc
#c
#c We need to include the class file here since it was only declared as
#c a class in the header.
#c
#c Argument: class name
#c
#startm AD_FORWARD_DECLARATION 01
#ifndef __%01_h__
#include "%01.h"
#endif

#ifndef __Impl%01_h__
#include "Impl%01.h"
#endif
#endm


#ccccccccccccccccccccccccccc
#c
#c Class UUID.
#c
#c Argument: Pieces of UUID
#c
#startm AD_CLASS_UUID 11
#endm


#ccccccccccccccccccccccccccc
#c
#c Default UUID.
#c
#c Argument: Pieces of UUID
#c
#startm AD_DEFAULT_UUID 11
#endm


#ccccccccccccccccccccccccccc
#c
#c Goes at the head of the file.
#c
#c Arguments: none
#c
#startm AD_HEAD 00
.copyright-message
#endm


#ccccccccccccccccccccccccccc
#c
#c AAFTypes support for IDL
#c
#c Arguments: none
#c
#startm AD_TYPES_HEAD 00
#endm


#ccccccccccccccccccccccccccc
#c
#c Starts a class definition
#c
#c Arguments: none
#c
#startm AD_CLASS_BEGIN 00
#ifndef __.this-module_h__
#include ".this-module.h"
#endif

#ifndef __Impl.this-module_h__
#include "Impl.this-module.h"
#endif

#include <assert.h>

.this-module::.this-module (aafBool doInit)
: .parent-module (kAAFFalse)
{
  if (doInit)
    {
#ifdef BOB_TEST
      Impl.this-module * newRep;
      newRep = new Impl.this-module;
      assert (newRep);
      InitRep (newRep);
#endif
    }
}


.this-module::~.this-module ()
{
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Ends a class definition for classes which support more than the
#c primary COM interface.
#c
#c Arguments: additional interface name
#c
#startm AD_COM_EXT_CLASS_BEGIN 01
AD_CLASS_BEGIN\
#endm


#ccccccccccccccccccccccccccc
#c
#c Ends a class definition for classes which support more than the
#c primary COM interface.
#c
#c Arguments: additional interface name
#c
#startm AD_COM_EXT2_CLASS_BEGIN 02
AD_CLASS_BEGIN\
#endm

#ccccccccccccccccccccccccccc
#c
#c Ends a class definition for classes which support more than the
#c primary COM interface.
#c
#c Arguments: additional interface name
#c
#startm AD_COM_EXT3_CLASS_BEGIN 03
AD_CLASS_BEGIN\
#endm

#ccccccccccccccccccccccccccc
#c
#c Ends a class definition for classes which support more than the
#c primary COM interface.
#c
#c Arguments: additional interface name
#c
#startm AD_COM_EXT4_CLASS_BEGIN 04
AD_CLASS_BEGIN\
#endm


#ccccccccccccccccccccccccccc
#c
#c Starts a class definition with no parent class
#c
#c Arguments: none
#c
#startm AD_ROOT_CLASS_BEGIN 00
#ifndef __.this-module_h__
#include ".this-module.h"
#endif

#ifndef __Impl.this-module_h__
#include "Impl.this-module.h"
#endif

#include <assert.h>

#if defined(WIN32)
// Include declarations for InterlockedIncrement() and InterlockcedDecrment().
#include <windows.h>
#endif


.this-module::.this-module (aafBool doInit)
  : _rep((Impl.this-module *)NULL),
    _refCount(1)
{
  if (doInit)
    {
#ifdef BOB_TEST
      Impl.this-module * newRep;
      newRep = new Impl.this-module;
      assert (newRep);
      InitRep (newRep);
#endif
    }
}


.this-module::~.this-module ()
{
#ifdef BOB_TEST
  // The base class destructor of Impl.this-module must be declared as virtual.
  // Eventhough the Impl.this-module is reference counted we call delete 
  // directly since the Impl.this-module::ReleaseReference() delegates its
  // release to .this-module::Release().
  if (_rep)
  {
    delete _rep;
    _rep = 0;
  } 
#endif
}


// Increment the object reference count.
aafUInt32 .this-module::AcquireReference() const
{ // inforce conceptual 'constness'
  return InterlockedIncrement(reinterpret_cast<long *>(&(const_cast<.this-module *>(this)->_refCount)));
}

// Decrement the object reference count and delete the container.
aafUInt32 .this-module::ReleaseReference()
{
  long count = InterlockedDecrement(reinterpret_cast<long *>(&_refCount));
  if (0 == count)
    delete this;
  
  return count;
}

// Just return the count. (this could be inline in the header...)
aafUInt32 .this-module::ReferenceCount() const
{
  return _refCount;
}


void .this-module::InitRep (Impl.this-module * newRep)
{
#ifdef BOB_TEST
  assert (newRep);
  assert (!_rep);
  _rep = newRep;
  newRep->InitContainer (this);
#endif
}


Impl.this-module * .this-module::GetRepObject ()
{
#ifdef BOB_TEST
  assert (_rep);
  return _rep;
#else
    return ((Impl.this-module *)NULL);
#endif
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes no arguments.
#c
#c Argument1: method name
#c Argument2: method description
#c
#startm AD_METHOD0 02
AAFRESULT STDMETHODCALLTYPE
    .this-module::%01 ()
{
#ifdef BOB_TEST
  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);
  return ptr->%01();
#else
    return AAFRESULT_NOT_IMPLEMENTED;
#endif
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes one argument.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c
#c Macro Arg 07: method description
#c
#startm AD_XMETHOD1 07
AAFRESULT STDMETHODCALLTYPE
    .this-module::%01 (%04 .%03-indirection %05)
{
#ifdef BOB_TEST
  AAFRESULT stat;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05)
  stat = ptr->%01 (.%03-internalname(%05));
.%03-cleanup(%04, %05)
  return stat;
#else
  return AAFRESULT_NOT_IMPLEMENTED;
#endif
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes two arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c
#c Macro Arg 12: method description
#c
#startm AD_XMETHOD2 12
AAFRESULT STDMETHODCALLTYPE
    .this-module::%01 (%04 .%03-indirection %05,
        %09 .%08-indirection %10)
{
#ifdef BOB_TEST
  AAFRESULT stat;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05)
.%08-setup(%09, %10)
  stat = ptr->%01 (.%03-internalname(%05),
    .%08-internalname(%10));
.%03-cleanup(%04, %05)
.%08-cleanup(%09, %10)
  return stat;
#else
  return AAFRESULT_NOT_IMPLEMENTED;
#endif
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes three arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c
#c Macro Arg 17: method description
#c
#startm AD_XMETHOD3 17
AAFRESULT STDMETHODCALLTYPE
    .this-module::%01 (%04 .%03-indirection %05,
        %09 .%08-indirection %10,
        %14 .%13-indirection %15)
{
#ifdef BOB_TEST
  AAFRESULT stat;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05)
.%08-setup(%09, %10)
.%13-setup(%14, %15)
  stat = ptr->%01 (.%03-internalname(%05),
    .%08-internalname(%10),
    .%13-internalname(%15));
.%03-cleanup(%04, %05)
.%08-cleanup(%09, %10)
.%13-cleanup(%14, %15)
  return stat;
#else
  return AAFRESULT_NOT_IMPLEMENTED;
#endif
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes four arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c
#c Macro Arg 22: method description
#c
#startm AD_XMETHOD4 22
AAFRESULT STDMETHODCALLTYPE
    .this-module::%01 (%04 .%03-indirection %05,
        %09 .%08-indirection %10,
        %14 .%13-indirection %15,
        %19 .%18-indirection %20)
{
#ifdef BOB_TEST
  AAFRESULT stat;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05)
.%08-setup(%09, %10)
.%13-setup(%14, %15)
.%18-setup(%19, %20)
  stat = ptr->%01 (.%03-internalname(%05),
    .%08-internalname(%10),
    .%13-internalname(%15),
    .%18-internalname(%20));
.%03-cleanup(%04, %05)
.%08-cleanup(%09, %10)
.%13-cleanup(%14, %15)
.%18-cleanup(%19, %20)
  return stat;
#else
  return AAFRESULT_NOT_IMPLEMENTED;
#endif
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes five arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c metharg 5    22           23          24      25      26
#c
#c Macro Arg 27: method description
#c
#startm AD_XMETHOD5 27
AAFRESULT STDMETHODCALLTYPE
    .this-module::%01 (%04 .%03-indirection %05,
        %09 .%08-indirection %10,
        %14 .%13-indirection %15,
        %19 .%18-indirection %20,
        %24 .%23-indirection %25)
{
#ifdef BOB_TEST
  AAFRESULT stat;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05)
.%08-setup(%09, %10)
.%13-setup(%14, %15)
.%18-setup(%19, %20)
.%23-setup(%24, %25)
  stat = ptr->%01 (.%03-internalname(%05),
    .%08-internalname(%10),
    .%13-internalname(%15),
    .%18-internalname(%20),
    .%23-internalname(%25));
.%03-cleanup(%04, %05)
.%08-cleanup(%09, %10)
.%13-cleanup(%14, %15)
.%18-cleanup(%19, %20)
.%23-cleanup(%24, %25)
  return stat;
#else
  return AAFRESULT_NOT_IMPLEMENTED;
#endif
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes six arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c metharg 5    22           23          24      25      26
#c metharg 6    27           28          29      30      31
#c
#c Macro Arg 32: method description
#c
#startm AD_XMETHOD6 32
AAFRESULT STDMETHODCALLTYPE
    .this-module::%01 (%04 .%03-indirection %05,
        %09 .%08-indirection %10,
        %14 .%13-indirection %15,
        %19 .%18-indirection %20,
        %24 .%23-indirection %25,
        %29 .%28-indirection %30)
{
#ifdef BOB_TEST
  AAFRESULT stat;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05)
.%08-setup(%09, %10)
.%13-setup(%14, %15)
.%18-setup(%19, %20)
.%23-setup(%24, %25)
.%28-setup(%29, %30)
  stat = ptr->%01 (.%03-internalname(%05),
    .%08-internalname(%10),
    .%13-internalname(%15),
    .%18-internalname(%20),
    .%23-internalname(%25),
    .%28-internalname(%30));
.%03-cleanup(%04, %05)
.%08-cleanup(%09, %10)
.%13-cleanup(%14, %15)
.%18-cleanup(%19, %20)
.%23-cleanup(%24, %25)
.%28-cleanup(%29, %30)
  return stat;
#else
  return AAFRESULT_NOT_IMPLEMENTED;
#endif
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes seven arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c metharg 5    22           23          24      25      26
#c metharg 6    27           28          29      30      31
#c metharg 7    32           33          34      35      36
#c
#c Macro Arg 37: method description
#c
#startm AD_XMETHOD7 37
AAFRESULT STDMETHODCALLTYPE
    .this-module::%01 (%04 .%03-indirection %05,
        %09 .%08-indirection %10,
        %14 .%13-indirection %15,
        %19 .%18-indirection %20,
        %24 .%23-indirection %25,
        %29 .%28-indirection %30,
        %34 .%33-indirection %35)
{
#ifdef BOB_TEST
  AAFRESULT stat;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05)
.%08-setup(%09, %10)
.%13-setup(%14, %15)
.%18-setup(%19, %20)
.%23-setup(%24, %25)
.%28-setup(%29, %30)
.%33-setup(%34, %35)
  stat = ptr->%01 (.%03-internalname(%05),
    .%08-internalname(%10),
    .%13-internalname(%15),
    .%18-internalname(%20),
    .%23-internalname(%25),
    .%28-internalname(%30),
    .%33-internalname(%35));
.%03-cleanup(%04, %05)
.%08-cleanup(%09, %10)
.%13-cleanup(%14, %15)
.%18-cleanup(%19, %20)
.%23-cleanup(%24, %25)
.%28-cleanup(%29, %30)
.%33-cleanup(%34, %35)
  return stat;
#else
  return AAFRESULT_NOT_IMPLEMENTED;
#endif
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes eight arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c metharg 5    22           23          24      25      26
#c metharg 6    27           28          29      30      31
#c metharg 7    32           33          34      35      36
#c metharg 8    37           38          39      40      41
#c
#c Macro Arg 42: method description
#c
#startm AD_XMETHOD8 42
AAFRESULT STDMETHODCALLTYPE
    .this-module::%01 (%04 .%03-indirection %05,
        %09 .%08-indirection %10,
        %14 .%13-indirection %15,
        %19 .%18-indirection %20,
        %24 .%23-indirection %25,
        %29 .%28-indirection %30,
        %34 .%33-indirection %35,
        %39 .%38-indirection %40)
{
#ifdef BOB_TEST
  AAFRESULT stat;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05)
.%08-setup(%09, %10)
.%13-setup(%14, %15)
.%18-setup(%19, %20)
.%23-setup(%24, %25)
.%28-setup(%29, %30)
.%33-setup(%34, %35)
.%38-setup(%39, %40)
  stat = ptr->%01 (.%03-internalname(%05),
    .%08-internalname(%10),
    .%13-internalname(%15),
    .%18-internalname(%20),
    .%23-internalname(%25),
    .%28-internalname(%30),
    .%33-internalname(%35),
    .%38-internalname(%40));
.%03-cleanup(%04, %05)
.%08-cleanup(%09, %10)
.%13-cleanup(%14, %15)
.%18-cleanup(%19, %20)
.%23-cleanup(%24, %25)
.%28-cleanup(%29, %30)
.%33-cleanup(%34, %35)
.%38-cleanup(%39, %40)
  return stat;
#else
  return AAFRESULT_NOT_IMPLEMENTED;
#endif
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes nine arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c metharg 5    22           23          24      25      26
#c metharg 6    27           28          29      30      31
#c metharg 7    32           33          34      35      36
#c metharg 8    37           38          39      40      41
#c metharg 9    42           43          44      45      46
#c
#c Macro Arg 47: method description
#c
#startm AD_XMETHOD9 47
AAFRESULT STDMETHODCALLTYPE
    .this-module::%01 (%04 .%03-indirection %05,
        %09 .%08-indirection %10,
        %14 .%13-indirection %15,
        %19 .%18-indirection %20,
        %24 .%23-indirection %25,
        %29 .%28-indirection %30,
        %34 .%33-indirection %35,
        %39 .%38-indirection %40,
        %44 .%43-indirection %45)
{
#ifdef BOB_TEST
  AAFRESULT stat;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05)
.%08-setup(%09, %10)
.%13-setup(%14, %15)
.%18-setup(%19, %20)
.%23-setup(%24, %25)
.%28-setup(%29, %30)
.%33-setup(%34, %35)
.%38-setup(%39, %40)
.%43-setup(%44, %45)
  stat = ptr->%01 (.%03-internalname(%05),
    .%08-internalname(%10),
    .%13-internalname(%15),
    .%18-internalname(%20),
    .%23-internalname(%25),
    .%28-internalname(%30),
    .%33-internalname(%35),
    .%38-internalname(%40),
    .%43-internalname(%45));
.%03-cleanup(%04, %05)
.%08-cleanup(%09, %10)
.%13-cleanup(%14, %15)
.%18-cleanup(%19, %20)
.%23-cleanup(%24, %25)
.%28-cleanup(%29, %30)
.%33-cleanup(%34, %35)
.%38-cleanup(%39, %40)
.%43-cleanup(%44, %45)
  return stat;
#else
  return AAFRESULT_NOT_IMPLEMENTED;
#endif
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes ten arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c metharg 5    22           23          24      25      26
#c metharg 6    27           28          29      30      31
#c metharg 7    32           33          34      35      36
#c metharg 8    37           38          39      40      41
#c metharg 9    42           43          44      45      46
#c metharg 10   47           48          49      50      51
#c
#c Macro Arg 52: method description
#c
#startm AD_XMETHOD_10 52
AAFRESULT STDMETHODCALLTYPE
    .this-module::%01 (%04 .%03-indirection %05,
        %09 .%08-indirection %10,
        %14 .%13-indirection %15,
        %19 .%18-indirection %20,
        %24 .%23-indirection %25,
        %29 .%28-indirection %30,
        %34 .%33-indirection %35,
        %39 .%38-indirection %40,
        %44 .%43-indirection %45,
        %49 .%48-indirection %50)
{
#ifdef BOB_TEST
  AAFRESULT stat;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05)
.%08-setup(%09, %10)
.%13-setup(%14, %15)
.%18-setup(%19, %20)
.%23-setup(%24, %25)
.%28-setup(%29, %30)
.%33-setup(%34, %35)
.%38-setup(%39, %40)
.%43-setup(%44, %45)
.%48-setup(%49, %50)
  stat = ptr->%01 (.%03-internalname(%05),
    .%08-internalname(%10),
    .%13-internalname(%15),
    .%18-internalname(%20),
    .%23-internalname(%25),
    .%28-internalname(%30),
    .%33-internalname(%35),
    .%38-internalname(%40),
    .%43-internalname(%45),
    .%48-internalname(%50));
.%03-cleanup(%04, %05)
.%08-cleanup(%09, %10)
.%13-cleanup(%14, %15)
.%18-cleanup(%19, %20)
.%23-cleanup(%24, %25)
.%28-cleanup(%29, %30)
.%33-cleanup(%34, %35)
.%38-cleanup(%39, %40)
.%43-cleanup(%44, %45)
.%48-cleanup(%49, %50)
  return stat;
#else
  return AAFRESULT_NOT_IMPLEMENTED;
#endif
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes eleven arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c metharg 5    22           23          24      25      26
#c metharg 6    27           28          29      30      31
#c metharg 7    32           33          34      35      36
#c metharg 8    37           38          39      40      41
#c metharg 9    42           43          44      45      46
#c metharg 10   47           48          49      50      51
#c metharg 11   52           53          54      55      56
#c
#c Macro Arg 57: method description
#c
#startm AD_XMETHOD_11 57
AAFRESULT STDMETHODCALLTYPE
    .this-module::%01 (%04 .%03-indirection %05,
        %09 .%08-indirection %10,
        %14 .%13-indirection %15,
        %19 .%18-indirection %20,
        %24 .%23-indirection %25,
        %29 .%28-indirection %30,
        %34 .%33-indirection %35,
        %39 .%38-indirection %40,
        %44 .%43-indirection %45,
        %49 .%48-indirection %50,
        %54 .%53-indirection %55)
{
#ifdef BOB_TEST
  AAFRESULT stat;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05)
.%08-setup(%09, %10)
.%13-setup(%14, %15)
.%18-setup(%19, %20)
.%23-setup(%24, %25)
.%28-setup(%29, %30)
.%33-setup(%34, %35)
.%38-setup(%39, %40)
.%43-setup(%44, %45)
.%48-setup(%49, %50)
.%53-setup(%54, %55)
  stat = ptr->%01 (.%03-internalname(%05),
    .%08-internalname(%10),
    .%13-internalname(%15),
    .%18-internalname(%20),
    .%23-internalname(%25),
    .%28-internalname(%30),
    .%33-internalname(%35),
    .%38-internalname(%40),
    .%43-internalname(%45),
    .%48-internalname(%50),
    .%53-internalname(%55));
.%03-cleanup(%04, %05)
.%08-cleanup(%09, %10)
.%13-cleanup(%14, %15)
.%18-cleanup(%19, %20)
.%23-cleanup(%24, %25)
.%28-cleanup(%29, %30)
.%33-cleanup(%34, %35)
.%38-cleanup(%39, %40)
.%43-cleanup(%44, %45)
.%48-cleanup(%49, %50)
.%53-cleanup(%54, %55)
  return stat;
#else
  return AAFRESULT_NOT_IMPLEMENTED;
#endif
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes three arguments.
#c Allows two additional macro argument per method argument to let
#c macro caller pass more info.  For example:
#c
#c For type           Arg1 is						arg2 is
#c     ----           ------						----
#c     objInArray     array size					-
#c     objOutArray    alloc'd array size			fetched array size
#c     objInCustom    custom input "marshal" code	-
#c     objOutCustom   custom output "marshal" code	-
#c     all else       -								-
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt aux1	aux2
#c ----------   ----------   ---------   ----    ----    -------- ----  ----
#c metharg 1    02           03          04      05      06       07	08
#c metharg 2    09           10          11      12      13       14	15
#c metharg 3    16           17          18      19      20       21	22
#c
#c Macro Arg 23: method description
#c
#startm AD_X2METHOD3 23
AAFRESULT STDMETHODCALLTYPE
    .this-module::%01 (%04 .%03-indirection %05,
        %11 .%10-indirection %12,
        %18 .%17-indirection %19)
{
#ifdef BOB_TEST
  AAFRESULT stat;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05)
.%10-setup(%11, %12)
.%17-setup(%18, %19)
  stat = ptr->%01 (.%03-internalname(%05),
    .%10-internalname(%12),
    .%17-internalname(%19));
.%03-cleanup(%04, %05)
.%10-cleanup(%11, %12)
.%17-cleanup(%18, %19)
  return stat;
#else
  return AAFRESULT_NOT_IMPLEMENTED;
#endif
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes four arguments.
#c Allows two additional macro argument per method argument to let
#c macro caller pass more info.  For example:
#c
#c For type           Arg1 is						arg2 is
#c     ----           ------						----
#c     objInArray     array size					-
#c     objOutArray    alloc'd array size			fetched array size
#c     objInCustom    custom input "marshal" code	-
#c     objOutCustom   custom output "marshal" code	-
#c     all else       -								-
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt aux1	aux2
#c ----------   ----------   ---------   ----    ----    -------- --
#c metharg 1    02           03          04      05      06       07	08
#c metharg 2    09           10          11      12      13       14	15
#c metharg 3    16           17          18      19      20       21	22
#c metharg 4    23           24          25      26      27       28	29
#c
#c Macro Arg 30: method description
#c
#startm AD_X2METHOD4 30
AAFRESULT STDMETHODCALLTYPE
    .this-module::%01 (%04 .%03-indirection %05,
        %11 .%10-indirection %12,
        %18 .%17-indirection %19,
        %25 .%24-indirection %26)
{
#ifdef BOB_TEST
  AAFRESULT stat;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05)
.%10-setup(%11, %12)
.%17-setup(%18, %19)
.%24-setup(%25, %26)
  stat = ptr->%01 (.%03-internalname(%05),
    .%10-internalname(%12),
    .%17-internalname(%19),
    .%24-internalname(%26));
.%03-cleanup(%04, %05)
.%10-cleanup(%11, %12)
.%17-cleanup(%18, %19)
.%24-cleanup(%25, %26)
  return stat;
#else
  return AAFRESULT_NOT_IMPLEMENTED;
#endif
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes five arguments.
#c Allows two additional macro argument per method argument to let
#c macro caller pass more info.  For example:
#c
#c For type           Arg1 is						arg2 is
#c     ----           ------						----
#c     objInArray     array size					-
#c     objOutArray    alloc'd array size			fetched array size
#c     objInCustom    custom input "marshal" code	-
#c     objOutCustom   custom output "marshal" code	-
#c     all else       -								-
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt aux1	aux2
#c ----------   ----------   ---------   ----    ----    -------- --
#c metharg 1    02           03          04      05      06       07	08
#c metharg 2    09           10          11      12      13       14	15
#c metharg 3    16           17          18      19      20       21	22
#c metharg 4    23           24          25      26      27       28	29
#c metharg 5    30           31          32      33      34       35	36
#c
#c Macro Arg 37: method description
#c
#startm AD_X2METHOD5 37
AAFRESULT STDMETHODCALLTYPE
    .this-module::%01 (%04 .%03-indirection %05,
        %11 .%10-indirection %12,
        %18 .%17-indirection %19,
        %25 .%24-indirection %26)
        %32 .%31-indirection %33)
{
#ifdef BOB_TEST
  AAFRESULT stat;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05)
.%10-setup(%11, %12)
.%17-setup(%18, %19)
.%24-setup(%25, %26)
.%31-setup(%32, %33)
  stat = ptr->%01 (.%03-internalname(%05),
    .%10-internalname(%12),
    .%17-internalname(%19),
    .%24-internalname(%26));
    .%31-internalname(%33));
.%03-cleanup(%04, %05)
.%10-cleanup(%11, %12)
.%17-cleanup(%18, %19)
.%24-cleanup(%25, %26)
.%31-cleanup(%32, %33)
  return stat;
#else
  return AAFRESULT_NOT_IMPLEMENTED;
#endif
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Ends a class definition
#c
#c Arguments: none
#c
#startm AD_CLASS_END 00
#endm


#ccccccccccccccccccccccccccc
#c
#c Ends a class definition for classes which support more than the
#c primary COM interface.
#c
#c Arguments: additional interface name
#c
#startm AD_COM_EXT_CLASS_END 01
AD_CLASS_END\
#endm


#ccccccccccccccccccccccccccc
#c
#c Ends a class definition for classes which support more than the
#c primary COM interface.
#c
#c Arguments: additional interface name
#c
#startm AD_COM_EXT2_CLASS_END 02
AD_CLASS_END\
#endm


#ccccccccccccccccccccccccccc
#c
#c Ends a class definition for classes which support more than the
#c primary COM interface.
#c
#c Arguments: additional interface name
#c
#startm AD_COM_EXT3_CLASS_END 03
AD_CLASS_END\
#endm


#ccccccccccccccccccccccccccc
#c
#c Ends a class definition for classes which support more than the
#c primary COM interface.
#c
#c Arguments: additional interface name
#c
#startm AD_COM_EXT4_CLASS_END 04
AD_CLASS_END\
#endm


#ccccccccccccccccccccccccccc
#c
#c Ends a class definition
#c
#c Arguments: none
#c
#startm AD_ROOT_CLASS_END 00
#endm


#ccccccccccccccccccccccccccc
#c
#c Specifies an overridden method
#c
#c Argument: method declaration
#c
#startm AD_OVERRIDE 01
%01-cpp(.this-module)
#endm


#ccccccccccccccccccccccccccc
#c
#c Specifies a method in a separate COM interface.
#c
#c Argument: method declaration
#c
#startm AD_COM_METH 01
%01-com-meth-cpp(.this-module)
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a constructor which takes one argument.
#c Constructor name is assumed to be .this-module.
#c
#c Macro arguments 01+:
#c
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    01           02          03      04      05
#c
#c Macro Arg 06: method description
#c
#startm AD_XCONSTRUCTOR1 06
.this-module::.this-module (%03 .%02-indirection %04)
{
#ifdef BOB_TEST
.%02-setup(%03, %04)
  Impl.this-module * newRep;
  newRep = new Impl.this-module (.%02-internalname(%04));
  assert (newRep);
  InitRep (newRep);
.%02-cleanup(%03, %04)
#else
  // return AAFRESULT_NOT_IMPLEMENTED;
#endif
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a constructor which takes two arguments.
#c Constructor name is assumed to be .this-module.
#c
#c Macro arguments 01+:
#c
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    01           02          03      04      05
#c metharg 2    06           07          08      09      10
#c
#c Macro Arg 11: method description
#c
#startm AD_XCONSTRUCTOR2 11
.this-module::.this-module (%03 .%02-indirection %04,
    %08 .%07-indirection %09)
{
#ifdef BOB_TEST
.%02-setup(%03, %04)
.%07-setup(%08, %09)
  Impl.this-module * newRep;
  newRep = new Impl.this-module (.%02-internalname(%04),
    .%07-internalname(%09));
  assert (newRep);
  InitRep (newRep);
.%02-cleanup(%03, %04)
.%07-cleanup(%08, %09)
#else
  // return AAFRESULT_NOT_IMPLEMENTED;
#endif
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a constructor which takes three arguments.
#c Constructor name is assumed to be .this-module.
#c
#c Macro arguments 01+:
#c
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    01           02          03      04      05
#c metharg 2    06           07          08      09      10
#c metharg 3    11           12          13      14      15
#c
#c Macro Arg 16: method description
#c
#startm AD_XCONSTRUCTOR3 16
.this-module::.this-module (%03 .%02-indirection %04,
    %08 .%07-indirection %09,
    %13 .%12-indirection %14)
{
#ifdef BOB_TEST
.%02-setup(%03, %04)
.%07-setup(%08, %09)
.%12-setup(%13, %14)
  Impl.this-module * newRep;
  newRep = new Impl.this-module (.%02-internalname(%04),
    .%07-internalname(%09),
    .%12-internalname(%14));
  assert (newRep);
  InitRep (newRep);
.%02-cleanup(%03, %04)
.%07-cleanup(%08, %09)
.%12-cleanup(%13, %14)
#else
  // return AAFRESULT_NOT_IMPLEMENTED;
#endif
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a constructor which takes four arguments.
#c Constructor name is assumed to be .this-module.
#c
#c Macro arguments 01+:
#c
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    01           02          03      04      05
#c metharg 2    06           07          08      09      10
#c metharg 3    11           12          13      14      15
#c metharg 4    16           17          18      19      20
#c
#c Macro Arg 21: method description
#c
#startm AD_XCONSTRUCTOR4 21
.this-module::.this-module (%03 .%02-indirection %04,
    %08 .%07-indirection %09,
    %13 .%12-indirection %14,
    %18 .%17-indirection %19)
{
#ifdef BOB_TEST
.%02-setup(%03, %04)
.%07-setup(%08, %09)
.%12-setup(%13, %14)
.%17-setup(%18, %19)
  Impl.this-module * newRep;
  newRep = new Impl.this-module (.%02-internalname(%04),
    .%07-internalname(%09),
    .%12-internalname(%14),
    .%17-internalname(%19));
  assert (newRep);
  InitRep (newRep);
.%02-cleanup(%03, %04)
.%07-cleanup(%08, %09)
.%12-cleanup(%13, %14)
.%17-cleanup(%18, %19)
#else
  // return AAFRESULT_NOT_IMPLEMENTED;
#endif
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a static method used to bootstrap an AAF
#c session by creating the first session object.
#c
#startm AD_BEGIN_SESSION 00

#include "ImplAAFObjectCreation.h"

extern "C" const aafClassID_t CLSID_AAFSession;

AAFRESULT STDMETHODCALLTYPE
    AAFSession::BeginSession (aafProductIdentification_t * pIdent,
        AAFSession ** ppSession)
{
#ifdef BOB_TEST

  assert(ppSession);
  ImplAAFSession* pSession = static_cast<ImplAAFSession*>(CreateImpl(CLSID_AAFSession));
  assert(pSession);
  *ppSession = static_cast<AAFSession*>(pSession->GetContainer());

  pSession->BeginSession(pIdent);

  return AAFRESULT_SUCCESS;

#else
  return AAFRESULT_NOT_IMPLEMENTED;
#endif
}
#endm

#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a static method used for a container to create
#c its contained objects in the cpp API.
#c
#startm AD_STATIC_CREATE 00
AAFRESULT STDMETHODCALLTYPE
    .this-module::CreateObject (.this-module ** result)
{
#ifdef BOB_TEST
  .this-module * pObj;
  pObj = new .this-module;
  assert (pObj);
  assert (result);
  *result = pObj;
  return AAFRESULT_SUCCESS;
#else
  return AAFRESULT_NOT_IMPLEMENTED;
#endif
}
#endm

#ccccccccccccccccccccccccccc
#c
#c The following macros assist in passing arguments to methods of the
#c contained implementation class:
#c
#c The objIn macros are for use with pointers to objects that are
#c passed into the method.  The Type argument is the base type, with
#c no indirection specified.  For example, if you're passing in
#c AObject*, AObject should be specified for the Type argument.#c
#c
#c The objOut macros are for use with pointers to pointers to objects
#c that are passed out of the method.  The Type argument is the base
#c type, with no indirection specified.  For example, if you're
#c passing in AObject**, AObject should be specified for the Type
#c argument.
#c
#c The objPass macros are for use with any kind of data which is
#c passed exactly into or out of the method.
#c


#ccccccccccccccccccccccccccc
#c
#c #define .objIn-setup(T, externArg, internArg)
#c
#c arg1 = unadorned type
#c arg2 = external arg name
#c
#startm .objIn-setup 02
  Impl%01 * internal%02 = (Impl%01*)NULL;
  if (%02)
    {
      internal%02 = static_cast<Impl%01*>(%02->GetRepObject());
      assert (internal%02);
    }
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .objPass-setup(T, externArg, internArg)      /* nothing */
#c
#c arg1 = unadorned type
#c arg2 = external arg name
#c
#startm .objPass-setup 02
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .objOut-setup(T, externArg, internArg)
#c
#c arg1 = unadorned type
#c arg2 = external arg name
#c
#startm .objOut-setup 02
  Impl%01 * internal%02;
  Impl%01 ** pinternal%02 = (Impl%01**)NULL;
  if (%02)
    {
      pinternal%02 = &internal%02;
    }
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .objIn-internalname(externArg, internArg)    (internArg)
#c
#c arg1 = external arg name
#c
#startm .objIn-internalname 01
internal%01\
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .objPass-internalname(externArg, internArg)  (internArg)
#c
#c arg1 = external arg name
#c
#startm .objPass-internalname 01
%01\
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .objOut-internalname(externArg, internArg)   (internArg)
#c
#c arg1 = external arg name
#c
#startm .objOut-internalname 01
pinternal%01\
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .objIn-cleanup(T, externArg, internArg)      /* nothing */
#c
#c arg1 = unadorned type
#c arg2 = external arg name
#c
#startm .objIn-cleanup 02
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .objPass-cleanup(T, externArg, internArg)    /* nothing */
#c
#c arg1 = unadorned type
#c arg2 = external arg name
#c
#startm .objPass-cleanup 02
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .objOut-cleanup(T, externArg, internArg)
#c
#c arg1 = unadorned type
#c arg2 = external arg name
#c
#startm .objOut-cleanup 02
  if (internal%02)
    {
      assert (%02);
      *%02 = static_cast<%01*>(internal%02->GetContainer());
      assert (*%02);
    }
  else
    {
      *%02 = (%01*)NULL;
    }
#endm


#ccccccccccccccccccccccccccc
#c
#c Hack to quote the .this-module macro and keep it out of export
#c files.  Do not define this macro in exp.mac!!!
#c
#startm AD_EXPORT_THIS_MODULE 00
.this-module\
#endm


#ccccccccccccccccccccccccccc
#c
#c Starts a class definition
#c
#c Argument1: Abstract or Concrete
#c Argument2: Transient or StoredObject
#c            special cases:CommonBase and StoredObjectBase
#c
#c Note: Concrete-StoredObject means Persistent. In other words
#c Concrete-StoredObject objects (and derived objects) are the 
#c only types of objects that should ever be found in an AAF
#c file.
#c
#c Valid combiniations:          examples
#c -----------------------       ---------------
#c   Abstract-CommonBase         AAFRoot 
#c   Abstract-Transient          ????
#c   Abstract-StoredObjectBase   AAFObject
#c   Abstract-StoredObject       AAFSourceReference, AAFComponent, ...
#c   Concrete-Transient          EnumAAFMobs, EnumAAFMobSlots, ...
#c   Concrete-StoredObject       AAFSegment, AAFSourceClip, ...
#c
#startm AD_XCLASS_BEGIN 02
.begin-%01-%02
#endm


#ccccccccccccccccccccccccccc
#c
#c Ends a class definition
#c
#c Argument1: Abstract or Concrete
#c Argument2: Transient or StoredObject
#c            special cases:CommonBase and StoredObjectBase
#c
#c Note: Concrete-StoredObject means Persistent. In other words
#c Concrete-StoredObject objects (and derived objects) are the 
#c only types of objects that should ever be found in an AAF
#c file.
#c
#c Valid combiniations:          examples
#c -----------------------       ---------------
#c   Abstract-CommonBase         AAFRoot 
#c   Abstract-Transient          ????
#c   Abstract-StoredObjectBase   AAFObject
#c   Abstract-StoredObject       AAFSourceReference, AAFComponent, ...
#c   Concrete-Transient          EnumAAFMobs, EnumAAFMobSlots, ...
#c   Concrete-StoredObject       AAFSegment, AAFSourceClip, ...
#c
#startm AD_XCLASS_END 02
.end-%01-%02
#endm


#ccccccccccccccccccccccccccc
#c
#c The following macros implement all of the allowable
#c combinations of the AD_XCLASS_BEGIN and AD_XCLASS_END
#c


#ccccccccccccccccccccccccccc
#c Abstract-CommonBase
#c Special case for the common base class for all AAF objects,
#c Transient and StoredObject classes.
#c (first version defined backwords compatibility)

#startm .begin-Abstract-CommonBase 00
AD_ROOT_CLASS_BEGIN\
#endm

#startm .end-Abstract-CommonBase 00
AD_ROOT_CLASS_END\
#endm


#ccccccccccccccccccccccccccc
#c Abstract-StoredObjectBase
#c Special case for the base class for all AAF stored objects
#c (first version defined backwords compatibility)

#startm .begin-Abstract-StoredObjectBase 00
AD_CLASS_BEGIN\
#endm

#startm .end-Abstract-StoredObjectBase 00
AD_CLASS_END\
#endm


#ccccccccccccccccccccccccccc
#c Abstract-Transient
#c (first version defined backwords compatibility)

#startm .begin-Abstract-Transient 00
AD_CLASS_BEGIN\
#endm

#startm .end-Abstract-Transient 00
AD_CLASS_END\
#endm


#ccccccccccccccccccccccccccc
#c Abstract-StoredObject
#c (first version defined backwords compatibility)

#startm .begin-Abstract-StoredObject 00
AD_CLASS_BEGIN\
#endm

#startm .end-Abstract-StoredObject 00
AD_CLASS_END\
#endm


#ccccccccccccccccccccccccccc
#c Concrete-Transient
#c (first version defined backwords compatibility)

#startm .begin-Concrete-Transient 00
AD_CLASS_BEGIN\
#endm

#startm .end-Concrete-Transient 00
AD_CLASS_END\
#endm


#ccccccccccccccccccccccccccc
#c Concrete-StoredObject
#c Note: These are the persistent classes.
#c (first version defined backwords compatibility)

#startm .begin-Concrete-StoredObject 00
AD_CLASS_BEGIN\
#endm

#startm .end-Concrete-StoredObject 00
AD_CLASS_END\
#endm



#ccccccccccccccccccccccccccc
#c
#c Declaration for the dictionary's factory method.
#c
#startm AD_DICTIONARY_FACTORY 02

#ifndef __ImplAAFBaseClassFactory_h__
#include "ImplAAFBaseClassFactory.h"
#endif


// %02
AAFRESULT STDMETHODCALLTYPE 
  .this-module::%01 (
    // Class identifier (AUID) of the stored object. This is the
    // corresponding SMPTE identifier (as a GUID) for all predefined
    // built-in classes.
    const aafUID_t & id,

    // Address of output variable that receives the 
    // object pointer requested in pAUID
    AAFObject ** ppvObject)
{
  AAFRESULT result = AAFRESULT_SUCCESS;

  // Validate the input arguments.
  if (NULL == pAUID || NULL == ppvObject)
    return AAFRESULT_NULL_PARAM;

  // Find the factory on the corresponding impl class.
  Impl.this-module * pImpl.this-module = GetRepObject();
  assert(pImpl.this-module);

  // Create the corresponding impl object.
  ImplAAFObject *pObject = NULL;
  result = pImpl.this-module->CreateInstance(pAUID, &pObject);
  if (AAFRESULT_SUCCESS != result)
    return result;

  // Get the C++ container for the new Impl object
  *ppvObject = pObject->GetContainer();
  
  // Release the impl object pointer. 
  if (NULL == *ppvObject)
    pObject->ReleaseReference();

  return result;
}
#endm



#ccccccccccccccccccccccccccc
#c
#c Declaration for the dictionary's meta factory method.
#c
#startm AD_DICTIONARY_METAFACTORY 02

#ifndef __ImplAAFBaseClassFactory_h__
#include "ImplAAFBaseClassFactory.h"
#endif


// %02
AAFRESULT STDMETHODCALLTYPE 
  .this-module::%01 (
    // Identifier (id) of a class or type definition. This is the
    // corresponding SMPTE identifier (as a GUID) for all predefined
    // built-in definitions.
    const aafUID_t & id,

    // Address of output variable that receives the 
    // object pointer requested in pAUID
    AAFMetaDefinition ** ppMetaDefinition)
{
  AAFRESULT result = AAFRESULT_SUCCESS;

  // Validate the input arguments.
  if (NULL == pAUID || NULL == ppMetaDefinition)
    return AAFRESULT_NULL_PARAM;

  // Find the factory on the corresponding impl class.
  Impl.this-module * pImpl.this-module = GetRepObject();
  assert(pImpl.this-module);

  // Create the corresponding impl object.
  ImplAAFMetaDefinition *pObject = NULL;
  result = pImpl.this-module->CreateMetaInstance(pAUID, &pObject);
  if (AAFRESULT_SUCCESS != result)
    return result;

  // Get the C++ container for the new Impl object
  *ppMetaDefinition = pObject->GetContainer();
  
  // Release the impl object pointer. 
  if (NULL == *ppMetaDefinition)
    pObject->ReleaseReference();

  return result;
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Declaration for the class definition's factory method.
#c
#startm AD_CLASSDEF_FACTORY 02

#ifndef __ImplAAFBaseClassFactory_h__
#include "ImplAAFBaseClassFactory.h"
#endif


// %02
AAFRESULT STDMETHODCALLTYPE 
  .this-module::%01 (
    // Address of output variable that receives the 
    // object pointer requested in pAUID
    AAFObject ** ppvObject)
{
  AAFRESULT result = AAFRESULT_SUCCESS;

  // BobT NOTE 12/21/1999! This won't compile since we've changed the
  // class ID from AUID to pointer-to-class-def.  If we ever use these
  // things (that is C++ api) again, we'll have to fix.

  // Validate the input argument.
  if (NULL == ppvObject)
    return AAFRESULT_NULL_PARAM;

  // Find the factory on the corresponding impl class.
  Impl.this-module * pImpl.this-module = GetRepObject();
  assert(pImpl.this-module);

  // Create the corresponding impl object.
  ImplAAFObject *pObject = NULL;
  result = pImpl.this-module->CreateInstance(&pObject);
  if (AAFRESULT_SUCCESS != result)
    return result;

  // Get the C++ container for the new Impl object
  *ppvObject = pObject->GetContainer();
  
  // Release the impl object pointer. 
  if (NULL == *ppvObject)
    pObject->ReleaseReference();

  return result;
}
#endm


#ccccccccccccccccccccccccccc
#c Beginning of the module definitions
#c
#startm AD_MODULE_BEGIN 02
#endm


#ccccccccccccccccccccccccccc
#c End of the module definitions
#c
#startm AD_MODULE_END 00
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a function which takes no arguments.
#c
#c Argument1: function name
#c Argument2: function description
#c
#startm AD_FUNCTION0 02
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a function which takes one argument.
#c
#c Macro Arg 01: function name
#c
#c Macro arguments 02+:
#c
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt	
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c
#c Macro Arg 07: function description
#c
#startm AD_XFUNCTION1 07
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a function which takes two arguments.
#c
#c Macro Arg 01: function name
#c
#c Macro arguments 02+:
#c
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c
#c Macro Arg 12: function description
#c
#startm AD_XFUNCTION2 12
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a function which takes three arguments.
#c
#c Macro Arg 01: function name
#c
#c Macro arguments 02+:
#c
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c
#c Macro Arg 17: function description
#c
#startm AD_XFUNCTION3 17
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a function which takes four arguments.
#c
#c Macro Arg 01: function name
#c
#c Macro arguments 02+:
#c
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c
#c Macro Arg 22: function description
#c
#startm AD_XFUNCTION4 22
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a function which takes five arguments.
#c
#c Macro Arg 01: function name
#c
#c Macro arguments 02+:
#c
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c metharg 5    22           23          24      25      26
#c
#c Macro Arg 27: function description
#c
#startm AD_XFUNCTION5 27
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a function which takes six arguments.
#c
#c Macro Arg 01: function name
#c
#c Macro arguments 02+:
#c
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c metharg 5    22           23          24      25      26
#c metharg 6    27           28          29      30      31
#c
#c Macro Arg 32: function description
#c
#startm AD_XFUNCTION6 32
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a function which takes seven arguments.
#c
#c Macro Arg 01: function name
#c
#c Macro arguments 02+:
#c
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c metharg 5    22           23          24      25      26
#c metharg 6    27           28          29      30      31
#c metharg 7    32           33          34      35      36
#c
#c Macro Arg 37: function description
#c
#startm AD_XFUNCTION7 37
#endm


#ccccccccccccccccccccccccccc
#c
#c macro for things which are not to be exported.
#c
#startm AD_NO_EXPORT 01
%01\
#endm

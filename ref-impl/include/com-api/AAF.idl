cpp_quote("//=---------------------------------------------------------------------=")
cpp_quote("//")
cpp_quote("// This file was GENERATED for the AAF SDK")
cpp_quote("//")
cpp_quote("// $Id: AAF.idl,v 1.64 2012/06/26 20:54:40 jptrainor Exp $ $Name: V116 $")
cpp_quote("//")
cpp_quote("// The contents of this file are subject to the AAF SDK Public Source")
cpp_quote("// License Agreement Version 2.0 (the \"License\"); You may not use this")
cpp_quote("// file except in compliance with the License.  The License is available")
cpp_quote("// in AAFSDKPSL.TXT, or you may obtain a copy of the License from the")
cpp_quote("// Advanced Media Workflow Association, Inc., or its successor.")
cpp_quote("//")
cpp_quote("// Software distributed under the License is distributed on an \"AS IS\"")
cpp_quote("// basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See")
cpp_quote("// the License for the specific language governing rights and limitations")
cpp_quote("// under the License.  Refer to Section 3.3 of the License for proper use")
cpp_quote("// of this Exhibit.")
cpp_quote("//")
cpp_quote("// WARNING:  Please contact the Advanced Media Workflow Association,")
cpp_quote("// Inc., for more information about any additional licenses to")
cpp_quote("// intellectual property covering the AAF Standard that may be required")
cpp_quote("// to create and distribute AAF compliant products.")
cpp_quote("// (http://www.amwa.tv/policies).")
cpp_quote("//")
cpp_quote("// Copyright Notices:")
cpp_quote("// The Original Code of this file is Copyright 1998-2012, licensor of the")
cpp_quote("// Advanced Media Workflow Association.  All rights reserved.")
cpp_quote("//")
cpp_quote("// The Initial Developer of the Original Code of this file and the")
cpp_quote("// licensor of the Advanced Media Workflow Association is")
cpp_quote("// Avid Technology.")
cpp_quote("// All rights reserved.")
cpp_quote("//")
cpp_quote("//=---------------------------------------------------------------------=")

cpp_quote("//=--------------------------------------------------------------------------=")
cpp_quote("// AAF Interfaces.")
cpp_quote("//=--------------------------------------------------------------------------=")
cpp_quote("//")

#ifndef DO_NO_IMPORTS
import "unknwn.idl";
#endif

#ifndef DO_NO_IMPORTS
import "objidl.idl";
#endif

#ifndef DO_NO_IMPORTS
import "AAFTypes.idl";
#endif

interface IAAFAES3PCMDescriptor;
interface IAAFAIFCDescriptor;
interface IAAFAuxiliaryDescriptor;
interface IAAFBWFImportDescriptor;
interface IAAFCDCIDescriptor;
interface IAAFCachePageAllocator;
interface IAAFClassDef;
interface IAAFCodecDef;
interface IAAFCommentMarker;
interface IAAFComponent;
interface IAAFCompositionMob;
interface IAAFConstantValue;
interface IAAFContainerDef;
interface IAAFContentStorage;
interface IAAFControlPoint;
interface IAAFDataDef;
interface IAAFDataEssenceDescriptor;
interface IAAFDefObject;
interface IAAFDescriptiveClip;
interface IAAFDescriptiveFramework;
interface IAAFDescriptiveMarker;
interface IAAFDescriptiveObject;
interface IAAFDictionary;
interface IAAFDigitalImageDescriptor;
interface IAAFEdgecode;
interface IAAFEssenceAccess;
interface IAAFEssenceData;
interface IAAFEssenceDescriptor;
interface IAAFEssenceFormat;
interface IAAFEssenceGroup;
interface IAAFEvent;
interface IAAFEventMobSlot;
interface IAAFFile;
interface IAAFFileDescriptor;
interface IAAFFileEncoding;
interface IAAFFiller;
interface IAAFFilmDescriptor;
interface IAAFFindSourceInfo;
interface IAAFGPITrigger;
interface IAAFGetFileBits;
interface IAAFHeader;
interface IAAFIdentification;
interface IAAFImportDescriptor;
interface IAAFInterpolationDef;
interface IAAFKLVData;
interface IAAFKLVDataDefinition;
interface IAAFLocator;
interface IAAFMasterMob;
interface IAAFMetaDefinition;
interface IAAFMob;
interface IAAFMobSlot;
interface IAAFMPEGVideoDescriptor;
interface IAAFMultipleDescriptor;
interface IAAFNestedScope;
interface IAAFNetworkLocator;
interface IAAFObject;
interface IAAFOperationDef;
interface IAAFOperationGroup;
interface IAAFPCMDescriptor;
interface IAAFParameter;
interface IAAFParameterDef;
interface IAAFPhysicalDescriptor;
interface IAAFPlainEssenceData;
interface IAAFPlainStreamData;
interface IAAFPluginDef;
interface IAAFPluginManager;
interface IAAFProperty;
interface IAAFPropertyDef;
interface IAAFPropertyValue;
interface IAAFPulldown;
interface IAAFRGBADescriptor;
interface IAAFRandomFile;
interface IAAFRandomRawStorage;
interface IAAFRawStorage;
interface IAAFRIFFChunk;
interface IAAFRecordingDescriptor;
interface IAAFScopeReference;
interface IAAFSegment;
interface IAAFSelector;
interface IAAFSequence;
interface IAAFSetFileBits;
interface IAAFSoundDescriptor;
interface IAAFSourceClip;
interface IAAFSourceMob;
interface IAAFSourceReference;
interface IAAFStaticMobSlot;
interface IAAFTIFFDescriptor;
interface IAAFTaggedValue;
interface IAAFTaggedValueDefinition;
interface IAAFTapeDescriptor;
interface IAAFTextLocator;
interface IAAFTimecode;
interface IAAFTimecodeStream;
interface IAAFTimecodeStream12M;
interface IAAFTimelineMobSlot;
interface IAAFTransition;
interface IAAFTypeDef;
interface IAAFTypeDefCharacter;
interface IAAFTypeDefEnum;
interface IAAFTypeDefExtEnum;
interface IAAFTypeDefFixedArray;
interface IAAFTypeDefIndirect;
interface IAAFTypeDefInt;
interface IAAFTypeDefObjectRef;
interface IAAFTypeDefOpaque;
interface IAAFTypeDefRecord;
interface IAAFTypeDefRename;
interface IAAFTypeDefSet;
interface IAAFTypeDefStream;
interface IAAFTypeDefString;
interface IAAFTypeDefStrongObjRef;
interface IAAFTypeDefVariableArray;
interface IAAFTypeDefWeakObjRef;
interface IAAFVaryingValue;
interface IAAFWAVEDescriptor;
interface IEnumAAFClassDefs;
interface IEnumAAFCodecDefs;
interface IEnumAAFCodecFlavours;
interface IEnumAAFComponents;
interface IEnumAAFContainerDefs;
interface IEnumAAFControlPoints;
interface IEnumAAFDataDefs;
interface IEnumAAFEssenceData;
interface IEnumAAFFileDescriptors;
interface IEnumAAFFileEncodings;
interface IEnumAAFIdentifications;
interface IEnumAAFInterpolationDefs;
interface IEnumAAFKLVData;
interface IEnumAAFKLVDataDefs;
interface IEnumAAFLoadedPlugins;
interface IEnumAAFLocators;
interface IEnumAAFMobSlots;
interface IEnumAAFMobs;
interface IEnumAAFOperationDefs;
interface IEnumAAFParameterDefs;
interface IEnumAAFParameters;
interface IEnumAAFPluginDefs;
interface IEnumAAFPluginLocators;
interface IEnumAAFProperties;
interface IEnumAAFPropertyDefs;
interface IEnumAAFPropertyValues;
interface IEnumAAFRIFFChunks;
interface IEnumAAFSegments;
interface IEnumAAFTaggedValueDefs;
interface IEnumAAFTaggedValues;
interface IEnumAAFTypeDefs;
interface IAAFAES3PCMDescriptor2;
interface IAAFCDCIDescriptor2;
interface IAAFComponent2;
interface IAAFCompositionMob2;
interface IAAFDataDef2;
interface IAAFDataDef3;
interface IAAFDiagnosticOutput;
interface IAAFDictionary2;
interface IAAFDigitalImageDescriptor2;
interface IAAFEndian;
interface IAAFEssenceDataEx;
interface IAAFEssenceData2;
interface IAAFEssenceMultiAccess;
interface IAAFEventMobSlot2;
interface IAAFFileDescriptor2;
interface IAAFHeader2;
interface IAAFKLVEssenceDataParameters;
interface IAAFKLVStreamParameters;
interface IAAFMasterMob2;
interface IAAFMasterMob3;
interface IAAFMasterMobEx;
interface IAAFMob2;
interface IAAFProgress;
interface IAAFRGBADescriptor2;
interface IAAFSearchSource;
interface IAAFSourceReference2;
interface IAAFStreamAccess;
interface IAAFTimelineMobSlot2;
interface IAAFTypeDefStreamEx;
interface IAAFTypeDefStream3;
interface IAAFTypeDefVariableArrayEx;


// ************************
//
// Interface IAAFAES3PCMDescriptor
//
// ************************
///
/// The IAAFAES3PCMDescriptor is DEPRECATED, please use IAAFAES3PCMDescriptor2
///
/// The IAAFAES3PCMDescriptor interface is implemented by objects which
/// describe video essence formatted with one luminance component and 
/// two color-difference components.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///


///
/// Objects that implement IAAFAES3PCMDescriptor also implement the following interfaces:
///  - IAAFAES3PCMDescriptor2
///  - IAAFPCMDescriptor
///  - IAAFSoundDescriptor
///  - IAAFFileDescriptor
///  - IAAFFileDescriptor2
///  - IAAFEssenceDescriptor
///  - IAAFObject
[
    object,
    uuid(2EBFFDE0-5997-414D-808B-6BAA4A74F40F),
    helpstring("IAAFAES3PCMDescriptor Interface"),
    pointer_default(unique)
]
interface IAAFAES3PCMDescriptor : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, IAAFAES3PCMDescriptor-supporting
  /// object. This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  /// 
  HRESULT Initialize ();

















}


// ************************
//
// Interface IAAFAIFCDescriptor
//
// ************************
///
/// The IAAFAIFCDescriptor interface is implemented by objects which
/// describe audio content data formatted according to the AIFC compressed
/// Audio File Format.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
///
/// Objects that implement IAAFAIFCDescriptor also implement the following interfaces:
///  - IAAFFileDescriptor
///  - IAAFFileDescriptor2
///  - IAAFEssenceDescriptor
///  - IAAFObject
[
    object,
    uuid(e684d774-b935-11d2-bf9d-00104bc9156d),
    helpstring("IAAFAIFCDescriptor Interface"),
    pointer_default(unique)
]
interface IAAFAIFCDescriptor : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty
  /// IAAFAIFCDescriptor-supporting object.  This method must be
  /// called after allocation, and before any other method can be
  /// called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  /// 
  HRESULT Initialize ();


  //***********************************************************
  //
  // GetSummary()
  //
  /// Gets a copy of the AIFC file information without the media.
  /// 
  /// Succeeds if all of the following are true:
  /// - pSummary is a valid pointer.
  /// - The size of the buffer is large enough to hold the AIFC file information.
  /// 
  /// If this method fails pSummary will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSummary arg is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - The buffer is too small to hold the AIFC file information.
  ///
  /// 
  /// @param size [in] Size of preallocated buffer
  /// @param pSummary [out, size_is(size)] Preallocated buffer to hold the AIFC file information
  ///
  HRESULT GetSummary (
    [in] aafUInt32  size,
    [out, size_is(size)] aafDataValue_t  pSummary);

  //***********************************************************
  //
  // GetSummaryBufferSize()
  //
  /// Returns the size of the buffer required for the GetSummary()
  /// method.  The value is placed into the location specified by pSize.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSize pointer is valid.
  ///
  /// If this method fails nothing will be written to *pSize.
  ///
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSize arg is NULL.
  ///
  /// 
  /// @param pSize [out] required buffer size
  ///
  HRESULT GetSummaryBufferSize (
    [out] aafUInt32 *  pSize);

  //***********************************************************
  //
  // SetSummary()
  //
  /// Sets the AIFC file information.
  /// 
  /// Succeeds if all of the following are true:
  /// - pSummary is a valid pointer
  /// 
  /// If this method fails the summary property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSummary arg is NULL.
  ///
  /// 
  /// @param size [in] Size of preallocated buffer
  /// @param pSummary [in, size_is(size)] buffer containing value
  ///
  HRESULT SetSummary (
    [in] aafUInt32  size,
    [in, size_is(size)] aafDataValue_t  pSummary);


}



// ************************
//
// Interface IAAFAuxiliaryDescriptor
//
// ************************

///
/// The IAAFAuxiliaryDescriptor interface is implemented by objects that
/// describe a file source which has no physical source.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
///
/// Objects that implement IAAFAuxiliaryDescriptor also implement the following interfaces:
///  - IAAFPhysicalDescriptor
///  - IAAFEssenceDescriptor
///  - IAAFObject
[
    object,
    uuid(197a9cb2-48de-40a3-b965-59531d3fcf23),
    helpstring("IAAFAuxiliaryDescriptor Interface"),
    pointer_default(unique)
]

interface IAAFAuxiliaryDescriptor : IUnknown
{


  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated,
  /// IAAFAuxiliaryDescriptor object.  This method must be called
  /// after allocation, and before any other method can be called.
  ///
  /// Return codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  /// 
  HRESULT Initialize ();

  //***********************************************************
  //
  // SetMimeType()
  //
  /// Sets The registered mime type of the data per RFC 2046 and RFC 2048.
  ///
  /// Set the MimeType property to the value specified in
  /// pMimeType.  A copy is made of the data so the caller
  /// retains ownership of the *pMimeType buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pMimeType pointer is valid.
  /// 
  /// If this method fails the MimeType property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMimeType arg is NULL.
  /// 
  /// @param pMimeType [in, string] buffer from which MimeType is to be read
  ///
  HRESULT SetMimeType (
    [in, string] aafCharacter_constptr  pMimeType);


  //***********************************************************
  //
  // GetMimeType()
  //
  /// Gets The registered mime type of the data per RFC 2046 and RFC 2048.
  /// 
  /// Writes the MimeType property, with a trailing null
  /// character, into the pMimeType buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the MimeType property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetMimeTypeBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pMimeType.
  /// 
  /// Succeeds if:
  /// - The pMimeType pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   MimeType.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMimeType arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold MimeType.
  /// 
  /// @param pMimeType [out, string, size_is(bufSize)] buffer into which MimeType is to be written
  /// @param bufSize [in] size of *pMimeType buffer in bytes
  ///
  HRESULT GetMimeType (
    [out, string, size_is(bufSize)] aafCharacter *  pMimeType,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetMimeTypeBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetMimeType().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetMimeTypeBufLen (
    [out] aafUInt32 *  pBufSize);

  //***********************************************************
  //
  // SetCharSet()
  //
  /// Sets The registered character set per RFC 2048.
  ///
  /// Set the CharSet property to the value specified in
  /// pCharSet.  A copy is made of the data so the caller
  /// retains ownership of the *pCharSet buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pCharSet pointer is valid.
  /// 
  /// If this method fails the CharSet property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCharSet arg is NULL.
  /// 
  /// @param pCharSet [in, string] buffer from which CharSet is to be read
  ///
  HRESULT SetCharSet (
    [in, string] aafCharacter_constptr  pCharSet);


  //***********************************************************
  //
  // GetCharSet()
  //
  /// Gets The registered character set per RFC 2048.
  /// 
  /// Writes the CharSet property, with a trailing null
  /// character, into the pCharSet buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the CharSet property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetCharSetBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pCharSet.
  /// 
  /// Succeeds if:
  /// - The pCharSet pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   CharSet.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCharSet arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold CharSet.
  /// 
  /// @param pCharSet [out, string, size_is(bufSize)] buffer into which CharSet is to be written
  /// @param bufSize [in] size of *pCharSet buffer in bytes
  ///
  HRESULT GetCharSet (
    [out, string, size_is(bufSize)] aafCharacter *  pCharSet,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetCharSetBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetCharSet().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetCharSetBufLen (
    [out] aafUInt32 *  pBufSize);

}



// ************************
//
// Interface IAAFBWFImportDescriptor
//
// ************************
///
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - Insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it.
///
///
/// Objects that implement IAAFBWFImportDescriptor also implement the following interfaces:
///  - IAAFImportDescriptor
///  - IAAFPhysicalDescriptor
///  - IAAFEssenceDescriptor
///  - IAAFObject
[
    object,
    uuid(480b4328-da10-44d4-bb50-1bafbfbaf86a),
    helpstring("IAAFBWFImportDescriptor Interface"),
    pointer_default(unique)
]

interface IAAFBWFImportDescriptor : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty
  /// IAAFBWFImportDescriptor-supporting object.  This method must be
  /// called after allocation, and before any other method can be
  /// called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  /// 
  HRESULT Initialize ();


  //***********************************************************
  //
  // SetFileSecurityReport()
  //
  /// Sets the fileSecurityReport property. This is an optional property.
  /// 
  /// If this method fails, the FileSecurityReport property will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// 
  /// @param fileSecurityReport [in] value to assign to the FileSecurityReport property
  ///
  HRESULT SetFileSecurityReport (
    [in] aafUInt32  fileSecurityReport);


  //***********************************************************
  //
  // GetFileSecurityReport()
  //
  /// Gets the FileSecurityReport property.
  ///
  /// Succeeds if all of the following are true:
  /// - pFileSecurityReport is a valid pointer
  /// - the property is present.
  ///
  /// If this method fails, pFileSecurityReport will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFileSecurityReport is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pFileSecurityReport [out] value of the FileSecurityReport property
  ///
  HRESULT GetFileSecurityReport (
    [out] aafUInt32 *  pFileSecurityReport);


  //***********************************************************
  //
  // SetFileSecurityWave()
  //
  /// Sets the FileSecurityWave property. This is an optional property.
  /// 
  /// If this method fails, the FileSecurityWave property will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// 
  /// @param fileSecurityWave [in] value to assign to the FileSecurityWave property
  ///
  HRESULT SetFileSecurityWave (
    [in] aafUInt32  fileSecurityWave);


  //***********************************************************
  //
  // GetFileSecurityWave()
  //
  /// Gets the FileSecurityWave property.
  ///
  /// Succeeds if all of the following are true:
  /// - pFileSecurityWave is a valid pointer
  /// - the property is present.
  ///
  /// If this method fails, pFileSecurityWave will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFileSecurityWave is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pFileSecurityWave [out] value of the FileSecurityWave property
  ///
  HRESULT GetFileSecurityWave (
    [out] aafUInt32 *  pFileSecurityWave);


  //***********************************************************
  //
  // CountUnknownBWFChunks()
  //
  /// Return total number of RIFFChunk objects attached to this component.
  ///
  /// Succeeds if all of the following are true:
  /// - the pNumData pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pNumComments.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumData arg is NULL.
  /// 
  /// @param pNumData [out] Number  of RIFFChunk objects
  ///
  HRESULT CountUnknownBWFChunks (
    [out] aafUInt32 *  pNumData);

  //***********************************************************
  //
  // AppendUnknownBWFChunk()
  //
  /// Appends a pre-existing RIFFChunk object to end of this
  /// BWFImportDescriptor's list of UnknownBWFChunks.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pData pointer is valid.
  /// - the pData pointer indicates an object which is not already
  ///   owned by any object
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - the pData arg is NULL.
  ///
  /// AAFRESULT_OBJECT_ALREADY_ATTACHED
  ///   - the object pointed to by pData is already owned by this
  ///      or another object.
  /// 
  /// @param pData [in] RIFFChunk object to append
  ///
  HRESULT AppendUnknownBWFChunk (
    [in] IAAFRIFFChunk * pData);
  

  //***********************************************************
  //
  // PrependUnknownBWFChunk()
  //
  /// Prepends a pre-existing RIFFChunk object to the
  /// beginning of this BWFImportDescriptor's list of UnknownBWFChunks.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pData pointer is valid.
  /// - the pData pointer indicates an object which is not already
  ///   owned by any object
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pData is null.
  ///
  /// AAFRESULT_OBJECT_ALREADY_ATTACHED
  ///   - the object pointed to by pData is already owned by this
  ///      or another object.
  /// 
  /// @param pData [in] RIFFChunk object to prepend
  ///
  HRESULT PrependUnknownBWFChunk (
    [in] IAAFRIFFChunk * pData);



  //***********************************************************
  //
  // InsertUnknownBWFChunkAt()
  //
  /// Inserts the given RIFFChunk at the given index in this 
  /// BWFImportDescriptor's list of UnknownBWFChunks.  Chunks already
  /// existing at the given and higher indices will be moved to the
  /// next higher index to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pData pointer is valid.
  /// - the pData pointer indicates an object which is not already
  ///   owned by any object
  /// - index is less than or equal to the value returned by
  ///   CountUnknownBWFChunks().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pData is null.
  ///
  /// AAFRESULT_OBJECT_ALREADY_ATTACHED
  ///   - the object pointed to by pData is already owned by this
  ///      or another object.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than the value returned by
  ///     CountUnknownBWFChunks().
  /// 
  /// @param index [in] index at which chunk is to be inserted
  /// @param pData [in] RIFFChunk to append
  ///
  HRESULT InsertUnknownBWFChunkAt (
    [in] aafUInt32  index,
    [in] IAAFRIFFChunk * pData);


  //***********************************************************
  //
  // GetUnknownBWFChunkAt()
  //
  /// Retrieves the RIFFChunk at the given index in this BWFImportDescriptor's
  /// list of UnknownBWFChunks.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pData pointer is valid.
  /// - index is less than the value returned by CountUnknownBWFChunks().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppData is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than or equal to the value returned by
  ///     CountUnknownBWFChunks().
  /// 
  /// @param index [in] index of chunk to retrieve
  /// @param ppData [out, retval] returned RIFFChunk
  ///
  HRESULT GetUnknownBWFChunkAt (
    [in] aafUInt32  index,
    [out, retval] IAAFRIFFChunk ** ppData);


  //***********************************************************
  //
  // RemoveUnknownBWFChunkAt()
  //
  /// Removes the RIFFChunk at the given index in this BWFImportDescriptor's
  /// list of UnknownBWFChunks.  Chunks already
  /// existing at indices higher than the given index will be moved to
  /// the next lower index to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - index is less than the value returned by CountUnknownBWFChunks().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than or equal to the value returned by
  ///     CountUnknownBWFChunks().
  /// 
  /// @param index [in] index of chunk to remove
  ///
  HRESULT RemoveUnknownBWFChunkAt (
    [in] aafUInt32  index);


  //***********************************************************
  //
  // GetUnknownBWFChunks()
  //
  /// Return the enumeration for all RIFFChunk objects on this component.  The returned
  /// enumerator is AddRef()ed before it is returned.  The enumerator
  /// is implemented as an EnumAAFRIFFChunks.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  /// 
  /// @param ppEnum [out] RIFFChunk objects
  ///
  HRESULT GetUnknownBWFChunks (
    [out] IEnumAAFRIFFChunks ** ppEnum);


  //***********************************************************
  //
  // SetCodingHistory()
  //
  /// Sets the CodingHistory string property.
  ///
  /// Set the CodingHistory property to the value specified in
  /// pCodingHistory.  A copy is made of the data so the caller
  /// retains ownership of the *pCodingHistory buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pCodingHistory pointer is valid.
  /// 
  /// If this method fails the CodingHistory property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCodingHistory arg is NULL.
  /// 
  /// @param pCodingHistory [in, string] buffer from which CodingHistory is to be read
  ///
  HRESULT SetCodingHistory (
    [in, string] aafCharacter_constptr  pCodingHistory);


  //***********************************************************
  //
  // GetCodingHistory()
  //
  /// Gets the CodingHistory string property.
  /// 
  /// Writes the CodingHistory property, with a trailing null
  /// character, into the pCodingHistory buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the CodingHistory property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetCodingHistoryBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pCodingHistory.
  /// 
  /// Succeeds if:
  /// - The pCodingHistory pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   CodingHistory.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCodingHistory arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold CodingHistory.
  /// 
  /// @param pCodingHistory [out, string, size_is(bufSize)] buffer into which CodingHistory is to be written
  /// @param bufSize [in] size of *pCodingHistory buffer in bytes
  ///
  HRESULT GetCodingHistory (
    [out, string, size_is(bufSize)] aafCharacter *  pCodingHistory,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetCodingHistoryBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetCodingHistory().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetCodingHistoryBufLen (
    [out] aafUInt32 *  pBufSize);
     
  //***********************************************************
  //
  // SetBasicData()
  //
  /// Sets the BasicData string property.
  ///
  /// Set the BasicData property to the value specified in
  /// pBasicData.  A copy is made of the data so the caller
  /// retains ownership of the *pBasicData buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pBasicData pointer is valid.
  /// 
  /// If this method fails the BasicData property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBasicData arg is NULL.
  /// 
  /// @param pBasicData [in, string] buffer from which BasicData is to be read
  ///
  HRESULT SetBasicData (
    [in, string] aafCharacter_constptr  pBasicData);


  //***********************************************************
  //
  // GetBasicData()
  //
  /// Gets the BasicData string property.
  /// 
  /// Writes the BasicData property, with a trailing null
  /// character, into the pBasicData buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the BasicData property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetBasicDataBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pBasicData.
  /// 
  /// Succeeds if:
  /// - The pBasicData pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   BasicData.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBasicData arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold BasicData.
  /// 
  /// @param pBasicData [out, string, size_is(bufSize)] buffer into which BasicData is to be written
  /// @param bufSize [in] size of *pBasicData buffer in bytes
  ///
  HRESULT GetBasicData (
    [out, string, size_is(bufSize)] aafCharacter *  pBasicData,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetBasicDataBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetBasicData().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetBasicDataBufLen (
    [out] aafUInt32 *  pBufSize);

  //***********************************************************
  //
  // SetStartOfModulation()
  //
  /// Sets the StartOfModulation string property.
  ///
  /// Set the StartOfModulation property to the value specified in
  /// pStartOfModulation.  A copy is made of the data so the caller
  /// retains ownership of the *pStartOfModulation buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pStartOfModulation pointer is valid.
  /// 
  /// If this method fails the StartOfModulation property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pStartOfModulation arg is NULL.
  /// 
  /// @param pStartOfModulation [in, string] buffer from which StartOfModulation is to be read
  ///
  HRESULT SetStartOfModulation (
    [in, string] aafCharacter_constptr  pStartOfModulation);


  //***********************************************************
  //
  // GetStartOfModulation()
  //
  /// Gets the StartOfModulation string property.
  /// 
  /// Writes the StartOfModulation property, with a trailing null
  /// character, into the pStartOfModulation buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the StartOfModulation property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetStartOfModulationBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pStartOfModulation.
  /// 
  /// Succeeds if:
  /// - The pStartOfModulation pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   StartOfModulation.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pStartOfModulation arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold StartOfModulation.
  /// 
  /// @param pStartOfModulation [out, string, size_is(bufSize)] buffer into which StartOfModulation is to be written
  /// @param bufSize [in] size of *pStartOfModulation buffer in bytes
  ///
  HRESULT GetStartOfModulation (
    [out, string, size_is(bufSize)] aafCharacter *  pStartOfModulation,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetStartOfModulationBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetStartOfModulation().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetStartOfModulationBufLen (
    [out] aafUInt32 *  pBufSize);
     
  //***********************************************************
  //
  // SetQualityEvent()
  //
  /// Sets the QualityEvent string property.
  ///
  /// Set the QualityEvent property to the value specified in
  /// pQualityEvent.  A copy is made of the data so the caller
  /// retains ownership of the *pQualityEvent buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pQualityEvent pointer is valid.
  /// 
  /// If this method fails the QualityEvent property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pQualityEvent arg is NULL.
  /// 
  /// @param pQualityEvent [in, string] buffer from which QualityEvent is to be read
  ///
  HRESULT SetQualityEvent (
    [in, string] aafCharacter_constptr  pQualityEvent);


  //***********************************************************
  //
  // GetQualityEvent()
  //
  /// Gets the QualityEvent string property.
  /// 
  /// Writes the QualityEvent property, with a trailing null
  /// character, into the pQualityEvent buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the QualityEvent property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetQualityEventBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pQualityEvent.
  /// 
  /// Succeeds if:
  /// - The pQualityEvent pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   QualityEvent.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pQualityEvent arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold QualityEvent.
  /// 
  /// @param pQualityEvent [out, string, size_is(bufSize)] buffer into which QualityEvent is to be written
  /// @param bufSize [in] size of *pQualityEvent buffer in bytes
  ///
  HRESULT GetQualityEvent (
    [out, string, size_is(bufSize)] aafCharacter *  pQualityEvent,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetQualityEventBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetQualityEvent().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetQualityEventBufLen (
    [out] aafUInt32 *  pBufSize);

  //***********************************************************
  //
  // SetEndOfModulation()
  //
  /// Sets the EndOfModulation string property.
  ///
  /// Set the EndOfModulation property to the value specified in
  /// pEndOfModulation.  A copy is made of the data so the caller
  /// retains ownership of the *pEndOfModulation buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pEndOfModulation pointer is valid.
  /// 
  /// If this method fails the EndOfModulation property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEndOfModulation arg is NULL.
  /// 
  /// @param pEndOfModulation [in, string] buffer from which EndOfModulation is to be read
  ///
  HRESULT SetEndOfModulation (
    [in, string] aafCharacter_constptr  pEndOfModulation);


  //***********************************************************
  //
  // GetEndOfModulation()
  //
  /// Gets the EndOfModulation string property.
  /// 
  /// Writes the EndOfModulation property, with a trailing null
  /// character, into the pEndOfModulation buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the EndOfModulation property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetEndOfModulationBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pEndOfModulation.
  /// 
  /// Succeeds if:
  /// - The pEndOfModulation pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   EndOfModulation.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEndOfModulation arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold EndOfModulation.
  /// 
  /// @param pEndOfModulation [out, string, size_is(bufSize)] buffer into which EndOfModulation is to be written
  /// @param bufSize [in] size of *pEndOfModulation buffer in bytes
  ///
  HRESULT GetEndOfModulation (
    [out, string, size_is(bufSize)] aafCharacter *  pEndOfModulation,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetEndOfModulationBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetEndOfModulation().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetEndOfModulationBufLen (
    [out] aafUInt32 *  pBufSize);
     
  //***********************************************************
  //
  // SetQualityParameter()
  //
  /// Sets the QualityParameter string property.
  ///
  /// Set the QualityParameter property to the value specified in
  /// pQualityParameter.  A copy is made of the data so the caller
  /// retains ownership of the *pQualityParameter buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pQualityParameter pointer is valid.
  /// 
  /// If this method fails the QualityParameter property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pQualityParameter arg is NULL.
  /// 
  /// @param pQualityParameter [in, string] buffer from which QualityParameter is to be read
  ///
  HRESULT SetQualityParameter (
    [in, string] aafCharacter_constptr  pQualityParameter);


  //***********************************************************
  //
  // GetQualityParameter()
  //
  /// Gets the QualityParameter string property.
  /// 
  /// Writes the QualityParameter property, with a trailing null
  /// character, into the pQualityParameter buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the QualityParameter property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetQualityParameterBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pQualityParameter.
  /// 
  /// Succeeds if:
  /// - The pQualityParameter pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   QualityParameter.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pQualityParameter arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold QualityParameter.
  /// 
  /// @param pQualityParameter [out, string, size_is(bufSize)] buffer into which QualityParameter is to be written
  /// @param bufSize [in] size of *pQualityParameter buffer in bytes
  ///
  HRESULT GetQualityParameter (
    [out, string, size_is(bufSize)] aafCharacter *  pQualityParameter,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetQualityParameterBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetQualityParameter().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetQualityParameterBufLen (
    [out] aafUInt32 *  pBufSize);
     
  //***********************************************************
  //
  // SetOperatorComment()
  //
  /// Sets the OperatorComment string property.
  ///
  /// Set the OperatorComment property to the value specified in
  /// pOperatorComment.  A copy is made of the data so the caller
  /// retains ownership of the *pOperatorComment buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pOperatorComment pointer is valid.
  /// 
  /// If this method fails the OperatorComment property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pOperatorComment arg is NULL.
  /// 
  /// @param pOperatorComment [in, string] buffer from which OperatorComment is to be read
  ///
  HRESULT SetOperatorComment (
    [in, string] aafCharacter_constptr  pOperatorComment);


  //***********************************************************
  //
  // GetOperatorComment()
  //
  /// Gets the OperatorComment string property.
  /// 
  /// Writes the OperatorComment property, with a trailing null
  /// character, into the pOperatorComment buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the OperatorComment property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetOperatorCommentBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pOperatorComment.
  /// 
  /// Succeeds if:
  /// - The pOperatorComment pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   OperatorComment.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pOperatorComment arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold OperatorComment.
  /// 
  /// @param pOperatorComment [out, string, size_is(bufSize)] buffer into which OperatorComment is to be written
  /// @param bufSize [in] size of *pOperatorComment buffer in bytes
  ///
  HRESULT GetOperatorComment (
    [out, string, size_is(bufSize)] aafCharacter *  pOperatorComment,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetOperatorCommentBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetOperatorComment().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetOperatorCommentBufLen (
    [out] aafUInt32 *  pBufSize);
     
  //***********************************************************
  //
  // SetCueSheet()
  //
  /// Sets the CueSheet string property.
  ///
  /// Set the CueSheet property to the value specified in
  /// pCueSheet.  A copy is made of the data so the caller
  /// retains ownership of the *pCueSheet buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pCueSheet pointer is valid.
  /// 
  /// If this method fails the CueSheet property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCueSheet arg is NULL.
  /// 
  /// @param pCueSheet [in, string] buffer from which CueSheet is to be read
  ///
  HRESULT SetCueSheet (
    [in, string] aafCharacter_constptr  pCueSheet);


  //***********************************************************
  //
  // GetCueSheet()
  //
  /// Gets the CueSheet string property.
  /// 
  /// Writes the CueSheet property, with a trailing null
  /// character, into the pCueSheet buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the CueSheet property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetCueSheetBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pCueSheet.
  /// 
  /// Succeeds if:
  /// - The pCueSheet pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   CueSheet.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCueSheet arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold CueSheet.
  /// 
  /// @param pCueSheet [out, string, size_is(bufSize)] buffer into which CueSheet is to be written
  /// @param bufSize [in] size of *pCueSheet buffer in bytes
  ///
  HRESULT GetCueSheet (
    [out, string, size_is(bufSize)] aafCharacter *  pCueSheet,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetCueSheetBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetCueSheet().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetCueSheetBufLen (
    [out] aafUInt32 *  pBufSize);

}



// ************************
//
// Interface IAAFCDCIDescriptor
//
// ************************
///
/// IAAFCDCIDescriptor is DEPRECATED.
/// Please use IAAFCDCIDescriptor2.
///
/// The IAAFCDCIDescriptor interface is implemented by objects which
/// describe video essence formatted with one luminance component and 
/// two color-difference components.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///


///
/// Objects that implement IAAFCDCIDescriptor also implement the following interfaces:
///  - IAAFCDCIDescriptor2
///  - IAAFDigitalImageDescriptor
///  - IAAFDigitalImageDescriptor2
///  - IAAFFileDescriptor
///  - IAAFFileDescriptor2
///  - IAAFEssenceDescriptor
///  - IAAFObject
[
    object,
    uuid(44861703-8AEA-11d2-813C-006097310172),
    helpstring("IAAFCDCIDescriptor Interface"),
    pointer_default(unique)
]

interface IAAFCDCIDescriptor : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty
  /// IAAFCDCIDescriptor-supporting object.  This method must be called
  /// after allocation, and before any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  /// 
  HRESULT Initialize ();


  //***********************************************************
  //
  // SetComponentWidth()
  //
  /// Sets the ComponentWidth property.  Specifies the number of bits
  /// used to store each component.  Typical values can be 8, 10,
  /// 12, 14, or 16, but others are permitted by the reference
  /// implementation.  Each component in a sample is packed
  /// contiguously; the sample is filled with the number of bits
  /// specified by the optional PaddingBits property.  If  the
  /// PaddingBits property is omitted, samples are packed
  /// contiguously.
  ///
  /// If this method fails, the ComponentWidth property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param ComponentWidth [in] Number of bits.
  ///
  HRESULT SetComponentWidth (
    [in] aafInt32  ComponentWidth);


  //***********************************************************
  //
  // GetComponentWidth()
  //
  /// Gets the ComponentWidth property.  Specifies the number of bits
  /// used to store each component.  Typical values can be 8, 10,
  /// 12, 14, or 16, but others are permitted by the reference
  /// implementation.  Each component in a sample is packed
  /// contiguously; the sample is filled with the number of bits
  /// specified by the optional PaddingBits property.  If the
  /// PaddingBits property is omitted, samples are packed
  /// contiguously.
  ///
  /// Succeeds if all of the following are true:
  /// - pComponentWidth is a valid pointer.
  /// 
  /// If this method fails, *pComponentWidth will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pComponentWidth arg is NULL.
  /// 
  /// @param pComponentWidth [out] Address to store the number of bits.
  ///
  HRESULT GetComponentWidth (
    [out] aafInt32 *  pComponentWidth);


  //***********************************************************
  //
  // SetHorizontalSubsampling()
  //
  /// Sets the HorizontalSubsampling property.  Specifies the ratio of
  /// luminance sampling to chrominance sampling in the horizontal direction.
  /// For 4:2:2 video, the value is 2, which means that there are twice as
  /// many luminance values as there are color-difference values.
  /// Another typical value is 1; however other values are permitted by
  /// the reference implementation.
  ///
  /// If this method fails, the HorizontalSubsampling property will
  /// not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param HorizontalSubsampling [in] Integer value.
  ///
  HRESULT SetHorizontalSubsampling (
    [in] aafUInt32  HorizontalSubsampling);


  //***********************************************************
  //
  // GetHorizontalSubsampling()
  //
  /// Gets the HorizontalSubsampling property.  Specifies the ratio of
  /// luminance sampling to chrominance sampling in the horizontal
  /// direction.  For 4:2:2 video, the value is 2, which means that
  /// there are twice as many luminance values as there are
  /// color-difference values.  Another typical value is 1; however
  /// other values are permitted by the reference implementation.
  ///
  /// Succeeds if all of the following are true:
  /// - pHorizontalSubsampling is a valid pointer.
  /// 
  /// If this method fails, *pHorizontalSubsampling will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pHorizontalSubsampling arg is NULL.
  /// 
  /// @param pHorizontalSubsampling [out] Address to store the integer value.
  ///
  HRESULT GetHorizontalSubsampling (
    [out] aafUInt32 *  pHorizontalSubsampling);


  //***********************************************************
  //
  // SetVerticalSubsampling()
  //
  /// Sets the VerticalSubsampling property.  Specifies the ratio of
  /// luminance sampling to chrominance sampling in the vertical direction.
  /// For 4:2:2 video, the value is 2, which means that there are twice as
  /// many luminance values as there are color-difference values.
  /// Another typical value is 1; however other values are permitted by
  /// the reference implementation.
  ///
  /// If this method fails, the VerticalSubsampling property will
  /// not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param VerticalSubsampling [in] Integer value.
  ///
  HRESULT SetVerticalSubsampling (
    [in] aafUInt32  VerticalSubsampling);


  //***********************************************************
  //
  // GetVerticalSubsampling()
  //
  /// Gets the VerticalSubsampling property.  Specifies the ratio of
  /// luminance sampling to chrominance sampling in the vertical
  /// direction.  For 4:2:2 video, the value is 2, which means that
  /// there are twice as many luminance values as there are
  /// color-difference values.  Another typical value is 1; however
  /// other values are permitted by the reference implementation.
  ///
  /// Succeeds if all of the following are true:
  /// - pVerticalSubsampling is a valid pointer.
  /// 
  /// If this method fails, *pVerticalSubsampling will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pVerticalSubsampling arg is NULL.
  /// 
  /// @param pVerticalSubsampling [out] Address to store the integer value.
  ///
  HRESULT GetVerticalSubsampling (
    [out] aafUInt32 *  pVerticalSubsampling);


  //***********************************************************
  //
  // SetColorSiting()
  //
  /// Sets the ColorSiting property.  Specifies how to compute subsampled
  /// chrominance values.
  ///
  /// Valid values are:
  ///
  ///     kCoSiting  - To calculate subsampled pixels, take the preceding's pixels
  ///                  color value, discard the other color values and cosite the
  ///                  color with the first luminance value.
  ///
  ///     kAveraging - To calculate subsampled pixels, take the average of the two
  ///                  adjacent pixels' color values and site the color in the center
  ///                  of the luminance pixels.
  ///
  ///     kThreeTap  - To calculate subsampled pixels, take 25 percent of the the previous
  ///                  pixel's color value, 50 percent of the first value and 25 percent
  ///                  of the second value.  For the first value in a row, use 75 percent
  ///                  of that value since there is no previous value.  The kThreeTap value
  ///                  is only meaningful when the HorizontalSubsampling propert has a value
  ///                  of 2.
  ///
  /// This property is optional.  The default value is kCoSiting.
  ///
  /// Succeeds if all of the following are true:
  /// - ColorSiting is valid
  ///
  /// If this method fails, the ColorSiting property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param ColorSiting [in] Color siting value.
  ///
  HRESULT SetColorSiting (
    [in] aafColorSiting_t  ColorSiting);


  //***********************************************************
  //
  // GetColorSiting()
  //
  /// Gets the ColorSiting property.  Specifies how to compute
  /// subsampled chrominance values.
  ///
  /// Valid values are:
  ///
  ///     kCoSiting  - To calculate subsampled pixels, take the
  ///                  preceding's pixels color value, discard the
  ///                  other color values and cosite the color with the
  ///                  first luminance value.
  ///
  ///     kAveraging - To calculate subsampled pixels, take the
  ///                  average of the two adjacent pixels' color values
  ///                  and site the color in the center of the
  ///                  luminance pixels.
  ///
  ///     kThreeTap  - To calculate subsampled pixels, take 25 percent
  ///                  of the the previous pixel's color value, 50
  ///                  percent of the first value and 25 percent of the
  ///                  second value.  For the first value in a row,
  ///                  use 75 percent of that value since there is no
  ///                  previous value.  The kThreeTap value is only
  ///                  meaningful when the HorizontalSubsampling
  ///                  propert has a value of 2.
  ///
  /// Succeeds if all of the following are true:
  /// - pColorSiting is a valid pointer.
  ///
  /// If this method fails, *pColorSiting will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pColorSiting arg is NULL.
  /// 
  /// @param pColorSiting [out] Address to store the color siting value.
  ///
  HRESULT GetColorSiting (
    [out] aafColorSiting_t *  pColorSiting);


  //***********************************************************
  //
  // SetBlackReferenceLevel()
  //
  /// Sets the BlackReferenceLevel property.  Specifies the digital luminance
  /// component component value associated with black.
  ///
  /// For CCIR-601/2, the value is 16 for 8-bit video and 64 for
  /// 10-bit video.  For YUV, the value is 0.  These are typical
  /// values; other values will not be disallowed by the reference
  /// implementation.
  ///
  /// The same value is used in CDCI and RGBA when standard colorspace
  /// conversion is used.
  ///
  /// This property is optional.  The default value is 0.
  ///
  /// If this method fails, the BlackReferenceLevel property will not
  /// be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param BlackReferenceLevel [in] Integer value.
  ///
  HRESULT SetBlackReferenceLevel (
    [in] aafUInt32  BlackReferenceLevel);


  //***********************************************************
  //
  // GetBlackReferenceLevel()
  //
  /// Gets the BlackReferenceLevel property.  Specifies the digital
  /// luminance component value associated with black.
  ///
  /// For CCIR-601/2, the value is 16 for 8-bit video and 64 for
  /// 10-bit video.  For YUV, the value is 0.  These are typical
  /// values; other values will not be disallowed by the reference
  /// implementation.
  ///
  /// The same value is used in CDCI and RGBA when standard colorspace
  /// conversion is used.
  ///
  /// Succeeds if all of the following are true:
  /// - pBlackReferenceLevel is a valid pointer.
  /// 
  /// If this method fails, *pBlackReferenceLevel will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBlackReferenceLevel arg is NULL.
  /// 
  /// @param pBlackReferenceLevel [out] Address to store the integer value.
  ///
  HRESULT GetBlackReferenceLevel (
    [out] aafUInt32 *  pBlackReferenceLevel);


  //***********************************************************
  //
  // SetWhiteReferenceLevel()
  //
  /// Sets the WhiteReferenceLevel property.  Specifies the digital
  /// luminance component component value associated with white.
  ///
  /// For CCIR-601/2, the value is 235 for 8-bit video and 940 for
  /// 10-bit video.  For YUV, the value is 255 for 8-bit video and
  /// 1023 for 10-bit video.  These are typical values; other values
  /// will not be disallowed by the reference implementation.
  ///
  /// This property is optional.  The default value is the maximum
  /// unsigned interger value for component size.
  ///
  /// If this method fails, the WhiteReferenceLevel property will not
  /// be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param WhiteReferenceLevel [in] Integer value.
  ///
  HRESULT SetWhiteReferenceLevel (
    [in] aafUInt32  WhiteReferenceLevel);


  //***********************************************************
  //
  // GetWhiteReferenceLevel()
  //
  /// Gets the WhiteReferenceLevel property.  Specifies the digital
  /// luminance component component value associated with white.
  ///
  /// For CCIR-601/2, the value is 235 for 8-bit video and 940 for
  /// 10-bit video.  For YUV, the value is 255 for 8-bit video and
  /// 1023 for 10-bit video.  These are typical values; other values
  /// will not be disallowed by the reference implementation.
  ///
  /// Succeeds if all of the following are true:
  /// - pWhiteReferenceLevel is a valid pointer.
  /// 
  /// If this method fails, *pWhiteReferenceLevel will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pWhiteReferenceLevel arg is NULL.
  /// 
  /// @param pWhiteReferenceLevel [out] Address to store the integer value.
  ///
  HRESULT GetWhiteReferenceLevel (
    [out] aafUInt32 *  pWhiteReferenceLevel);


  //***********************************************************
  //
  // SetColorRange()
  //
  /// Sets the ColorRange property.  Specifies the range of allowable
  /// digital chrominance component values.  Chrominance values are
  /// unsigned and the range is centered on 128 for 8-bit video and 512
  /// for 10-bit video.  This value is used for both chrominance
  /// components.
  ///
  /// For CCIR-601/2, the range is 225 for 8-bit video and 897 for
  /// 10-bit video.  For YUV, the range is 255 for 8-bit video and
  /// 1023 for 10-bit video.  These are typical values; other values will
  /// not be disallowed by the reference implementation.
  ///
  /// This property is optional.  The default value is the maximum
  /// unsigned integer value for component size.
  ///
  /// Succeeds if all of the following are true:
  /// 
  /// If this method fails, the ColorRange property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param ColorRange [in] Integer value.
  ///
  HRESULT SetColorRange (
    [in] aafUInt32  ColorRange);


  //***********************************************************
  //
  // GetColorRange()
  //
  /// Gets the ColorRange property.  Specifies the range of allowable
  /// digital chrominance component values.  Chrominance values are
  /// unsigned and the range is centered on 128 for 8-bit video and 512
  /// for 10-bit video.  This value is used for both chrominance
  /// components.
  ///
  /// For CCIR-601/2, the range is 225 for 8-bit video and 897 for
  /// 10-bit video.  For YUV, the range is 255 for 8-bit video and
  /// 1023 for 10-bit video.  These are typical values; other values will
  /// not be disallowed by the reference implementation.
  ///
  /// Succeeds if all of the following are true:
  /// - pColorRange is a valid pointer.
  /// 
  /// If this method fails, *pColorRange will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pColorRange arg is NULL.
  /// 
  /// @param pColorRange [out] Address to store the integer value.
  ///
  HRESULT GetColorRange (
    [out] aafUInt32 *  pColorRange);


  //***********************************************************
  //
  // SetPaddingBits()
  //
  /// Sets the PaddingBits property.  Specifies the number of bits
  /// padded to each pixel.
  ///
  /// This property is optional.  The default value is 0.
  ///
  /// If this method fails, the PaddingBits property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param PaddingBits [in] Number of bits.
  ///
  HRESULT SetPaddingBits (
    [in] aafInt16  PaddingBits);


  //***********************************************************
  //
  // GetPaddingBits()
  //
  /// Gets the PaddingBits property.  Specifies the number of bits
  /// padded to each pixel.
  ///
  ///
  /// Succeeds if all of the following are true:
  /// - pPaddingBits is a valid pointer.
  /// 
  /// If this method fails, pPaddingBits will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPaddingBits arg is NULL.
  /// 
  /// @param pPaddingBits [out] Address to store the number of bits.
  ///
  HRESULT GetPaddingBits (
    [out] aafInt16 *  pPaddingBits);






}


// ************************
//
// Interface IAAFCachePageAllocator
//
// ************************
///
/// This interface is used by the toolkit for allocation and
/// deallocation of pages in a page cache.
/// It is typically implemented by clients requiring control
/// over how memory is allocated. By implementing this interface clients are
/// able to control aspects of memory allocation such as the source from which
/// the memory is obtained, how the memory is aligned etc.
///
/// Notes for implementers -
///
///  - Allocate() will be called a maximum of pageCount times, it
///    may be called fewer times.
///
///  - Deallocate() will be called the same number of times as
///    Allocate().
///
///  - Some uses of this interface never call Allocate()
///    after Deallocate(), implementors of this interface should not
///    assume that this is always the case.
///
///  - Allocate() should indicate failure by returning AAFRESULT_NOMEMORY
///    (and not by returning a NULL pointer.)
///
///  - Deallocate() should accept a NULL pointer (and do nothing) as does
///    operator delete.
///
///  - It is valid to allocate all the pages during Initialize() or during
///    the first call to Allocate().
///    For example, if aligned pages are required, allocating all the pages
///    contiguously mans paying the space cost of alignment once instead of
///    per-page.
///
///  - Initialize() will be called only once.
///
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.


[
    object,
    uuid(23630652-56E9-4A17-AC31-796FE6E26E80),
    helpstring("IAAFCachePageAllocator Interface"),
    pointer_default(unique)
]
interface IAAFCachePageAllocator : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Initialize.
  /// 
  /// @param pageCount [in] Maximum number of pages to allocate
  /// @param pageSize [in] Size in bytes of each page
  ///
  HRESULT Initialize (
    [in] aafUInt32  pageCount,
    [in] aafUInt32  pageSize);

  //***********************************************************
  //
  // Allocate()
  //
  /// Allocate a cache page.
  /// 
  /// @param pPage [out] Pointer to the newly allocated page
  ///
  HRESULT Allocate (
    [out] aafMemPtr_t *  pPage);

  //***********************************************************
  //
  // Deallocate()
  //
  /// Dellocate a cache page.
  /// 
  /// @param page [in] Pointer to the page to deallocate
  ///
  HRESULT Deallocate (
    [in] aafMemPtr_t  page);

}



// ************************
//
// Interface IAAFClassDef
//
// ************************
///
/// This interface is used with an object representing an AAF class
/// definition.  The operations on a class definition include managing
/// the position of the class within the class heirarchy, and
/// accessing property definitions associated with the class.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// Objects that implement IAAFClassDef also implement the following interfaces:
///  - IAAFMetaDefinition
[
    object,
    uuid(dfbd6525-1d81-11d2-bf96-006097116212),
    helpstring("IAAFClassDef Interface"),
    pointer_default(unique)
]
interface IAAFClassDef : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes this class definition object to inherit from the
  /// given parent class.  If isConcrete is set to AAFTrue, objects of
  /// this class can be instantiated; otherwise, it will be illegal to
  /// instantiate such objects.
  /// 
  /// Succeeds if:
  /// - The pID pointer is valid.
  /// - The pParentClass pointer is valid.
  /// - The pTypeName pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pID, pParentClass, or pTypeName arg is NULL.
  /// 
  /// @param classID [in, ref] auid to be used to identify this type
  /// @param pParentClass [in] existing class from which this one inherits
  /// @param pClassName [in, string] friendly name of this type definition
  /// @param isConcrete [in] can objects of this class be instantiated
  ///
  HRESULT Initialize (
    [in, ref] aafUID_constref  classID,
    [in] IAAFClassDef * pParentClass,
    [in, string] aafCharacter_constptr  pClassName,
    [in] aafBoolean_t  isConcrete);


  //***********************************************************
  //
  // GetPropertyDefs()
  //
  /// Returns an enumerator over all of the aaf property definitions
  /// attached to the current class.
  /// 
  /// Succeeds if:
  /// - The ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  /// 
  /// @param ppEnum [out, retval] Property Definition enumeration
  ///
  HRESULT GetPropertyDefs (
    [out, retval] IEnumAAFPropertyDefs ** ppEnum);


  //***********************************************************
  //
  // CountPropertyDefs()
  //
  /// Returns number of property definitions in this class.
  /// 
  /// Succeeds if:
  /// - The pCount pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCount arg is NULL.
  /// 
  /// @param pCount [out] number of properties contained in this class definition
  ///
  HRESULT CountPropertyDefs (
    [out] aafUInt32 *  pCount);


  //***********************************************************
  //
  // RegisterNewPropertyDef()
  //
  /// Creates a new property definition and registers it in this class
  /// definition.  If ppPropDef is non-NULL, will return the new
  /// property definition in ppPropDef.
  /// 
  /// Note that it is illegal to add mandatory properties to an
  /// existing (registered) class.  This method will allow adding
  /// either optional or mandatory properties to a class, but they must
  /// be added to a class which has not yet been registered in the
  /// dictionary.  If this class has already been registered, it is
  /// possible to add optional properties, but not through this
  /// method.  Optional properties added to an existing (registered)
  /// class may be added through the RegisterOptionalPropertyDef()
  /// method.
  /// 
  /// Succeeds if:
  /// - The pID pointer is valid.
  /// - The pName pointer is valid.
  /// - The pTypeDef pointer is valid.
  /// - This class has not already been registered in the dictionary.
  /// - The auid specified by pID has not already been registered.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pName or pTypeDef arg is NULL.
  ///
  /// AAFRESULT_OBJECT_ALREADY_ATTACHED
  ///   - This class has already been registered.
  ///
  /// AAFRESULT_ALREADY_UNIQUELY_INDENTIFED
  ///   - This class already has a unique indentifier property.
  ///
  /// AAFRESULT_BAD_PARAM
  ///   - The given ID has already been registered.
  /// 
  /// @param id [in, ref] auid to be used to identify this property
  /// @param pName [in, string] name of the new property
  /// @param pTypeDef [in] type of the new property
  /// @param isOptional [in] true if new property is to be optional
  /// @param isUniqueIdentifier [in] true if new property is to be the unique identifier of the class
  /// @param ppPropDef [out] return pointer to newly created property def
  ///
  HRESULT RegisterNewPropertyDef (
    [in, ref] aafUID_constref  id,
    [in, string] aafCharacter_constptr  pName,
    [in] IAAFTypeDef * pTypeDef,
    [in] aafBoolean_t  isOptional,
    [in] aafBoolean_t  isUniqueIdentifier,
    [out] IAAFPropertyDef ** ppPropDef);


  //***********************************************************
  //
  // RegisterOptionalPropertyDef()
  //
  /// Creates a new property definition and registers it in this class
  /// definition.  If ppPropDef is non-NULL, will return the new
  /// property definition in ppPropDef.
  ///
  /// Note that it is illegal to add mandatory properties to an already
  /// existing (registered) class.  It is assumed that this property is
  /// being added to a class which is already registered.  If so, it
  /// must be optional and this method will declare it so.  If it is
  /// wished to add a mandatory property, that may be done through the
  /// RegisterNewPropertyDef() method, but that must be called on a class
  /// which is not yet registered.
  /// 
  /// Succeeds if:
  /// - The pID pointer is valid.
  /// - The pName pointer is valid.
  /// - The pTypeDef pointer is valid.
  /// - The auid specified by pID has not already been registered.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pName or pTypeDef arg is NULL.
  ///
  /// AAFRESULT_BAD_PARAM
  ///   - The given ID has already been registered.
  /// 
  /// @param id [in, ref] auid to be used to identify this property
  /// @param pName [in, string] name of the new property
  /// @param pTypeDef [in] type of the new property
  /// @param ppPropDef [out] return pointer to newly created property def
  ///
  HRESULT RegisterOptionalPropertyDef (
    [in, ref] aafUID_constref  id,
    [in, string] aafCharacter_constptr  pName,
    [in] IAAFTypeDef * pTypeDef,
    [out] IAAFPropertyDef ** ppPropDef);


  //***********************************************************
  //
  // LookupPropertyDef()
  //
  /// Looks up the property definition corresponding to the named auid
  /// and returns a pointer to that property definition in ppPropDef.
  /// 
  /// Succeeds if:
  /// - The pPropID pointer is valid.
  /// - The ppPropDef pointer is valid.
  /// - the auid specified by pID has been registered as a property
  ///   definition for this class definition.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppPropDef arg is NULL.
  ///
  /// AAFRESULT_BAD_PARAM
  ///   - The given ID has not been registered as a property
  ///     definition.
  /// 
  /// @param propID [in, ref] auid reprepresenting property to look up
  /// @param ppPropDef [out] resulting property definition
  ///
  HRESULT LookupPropertyDef (
    [in, ref] aafUID_constref  propID,
    [out] IAAFPropertyDef ** ppPropDef);


  //***********************************************************
  //
  // GetName()
  //
  /// Gets Accesses a human-readable name for the class.  This name is not
  /// meant to be a way for programs to refer to the class, as it is
  /// of undetermined length, and is not checked to guarantee
  /// uniqueness.
  /// 
  /// Writes the Name property, with a trailing null
  /// character, into the pName buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the Name property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetNameBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pName.
  /// 
  /// Succeeds if:
  /// - The pName pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   Name.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold Name.
  /// 
  /// @param pName [out, string, size_is(bufSize)] buffer into which Name is to be written
  /// @param bufSize [in] size of *pName buffer in bytes
  ///
  HRESULT GetName (
    [out, string, size_is(bufSize)] aafCharacter *  pName,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetNameBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetName().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetNameBufLen (
    [out] aafUInt32 *  pBufSize);


  //***********************************************************
  //
  // GetParent()
  //
  /// Gets the Parent class for this object.  If there is no parent,
  /// returns the result AAFRESULT_NO_PARENT.  The only class which has no parent will
  /// be AAFObject.
  /// 
  /// Succeeds if:
  /// - The ppClassDef pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pClassDef arg is NULL.
  /// 
  /// @param ppClassDef [out, retval] parent class definition
  ///
  HRESULT GetParent (
    [out, retval] IAAFClassDef ** ppClassDef);


  //***********************************************************
  //
  // IsConcrete()
  //
  /// Returns true if this class can be instantiated; returns false
  /// otherwise. 
  /// 
  /// Succeeds if:
  /// - The ppClassDef pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult arg is NULL.
  /// 
  /// @param pResult [out, retval] Can this class be instantiated
  ///
  HRESULT IsConcrete (
    [out, retval] aafBoolean_t*  pResult);


  //***********************************************************
  //
  // IsRoot()
  //
  /// Returns true if this class is the base of the inheritance
  /// hierarchy; returns false otherwise.
  /// 
  /// Succeeds if:
  /// - The ppClassDef pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - isRoot arg is NULL.
  /// 
  /// @param isRoot [out, retval] Is this a root (base) class
  ///
  HRESULT IsRoot (
    [out, retval] aafBoolean_t*  isRoot);


  //***********************************************************
  //
  // IsUniquelyIdentified()
  //
  /// Returns true if this class is uniquely identified.
  /// 
  /// Succeeds if:
  /// - The pIsUniquelyIdentified pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pIsUniquelyIdentified arg is NULL.
  /// 
  /// @param pIsUniquelyIdentified [out, retval] Is this a UniquelyIdentified class
  ///
  HRESULT IsUniquelyIdentified (
    [out, retval] aafBoolean_t*  pIsUniquelyIdentified);


  //***********************************************************
  //
  // GetUniqueIdentifier()
  //
  /// Returns the property definition corresponding to this class'
  /// unique identifier.
  /// 
  /// Succeeds if:
  /// - The ppUniqueIdentifier pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppUniqueIdentifier arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - If this class definition does not have a unique identifier
  ///     property definition.
  /// 
  /// @param ppUniqueIdentifier [out, retval] The unique identifier
  ///
  HRESULT GetUniqueIdentifier (
    [out, retval] IAAFPropertyDef ** ppUniqueIdentifier);


  //***********************************************************
  //
  // CreateInstance()
  //
  /// Creates an object of this class, and returns it by reference in
  /// the location specified by the ppObject argument.
  /// 
  /// Succeeds if:
  /// - The ppObject pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppObject arg is NULL. 
  /// 
  /// @param[in] riid Reference to the identifier of the interface
  /// @param[out] ppvObject Address of output variable that receives the
  ///                       interface pointer requested in riid
  ///
  HRESULT CreateInstance(
    [in, ref] REFIID riid,
    [out, iid_is(riid)] IUnknown ** ppvObject);

}



// ************************
//
// Interface IAAFCodecDef
//
// ************************
///
/// This interface is used with an object representing a particular
/// kind of essence codec, which may be implemented by one or more
/// AAFPluginDescriptors.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
///
/// Objects that implement IAAFCodecDef also implement the following interfaces:
///  - IAAFDefObject
///  - IAAFObject
[
    object,
    uuid(AD1BB856-DBB2-11d2-809C-006008143E6F),
    helpstring("IAAFCodecDef Interface"),
    pointer_default(unique)
]
interface IAAFCodecDef : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Init all fields of a definition object.
  /// 
  /// @param id [in, ref] AUID for new DefObject
  /// @param pName [in, string] Name for new DefObject
  /// @param pDescription [in, string] Description for new DefObject
  ///
  HRESULT Initialize (
    [in, ref] aafUID_constref  id,
    [in, string] aafCharacter_constptr  pName,
    [in, string] aafCharacter_constptr  pDescription);


  //***********************************************************
  //
  // IsEssenceKindSupported()
  //
  /// Returns AAFTrue if the given codec support transfers to essence
  /// of the given essence kind.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pEssenceKind pointer is valid.
  /// - the pIsSupported pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pIsSupported.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEssenceKind or pIsSupported is null.
  /// 
  /// @param pEssenceKind [in] The essence kind
  /// @param pIsSupported [out,retval] Is this type supported
  ///
  HRESULT IsEssenceKindSupported (
    [in] IAAFDataDef * pEssenceKind,
    [out,retval] aafBoolean_t*  pIsSupported);

 
  //***********************************************************
  //
  // AddEssenceKind()
  //
  /// Appends the given essence kind to those supported by the codec.
  /// This is dependant upon the format, not an incomplete implementation.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEssenceKind is null.
  ///
  /// AAFRESULT_DUPLICATE_ESSENCE_KIND
  ///   - the given essenceKind is already contained.
  /// 
  /// @param pEssenceKind [in] The essence kind
  ///
  HRESULT AddEssenceKind (
    [in] IAAFDataDef * pEssenceKind);


  //***********************************************************
  //
  // RemoveEssenceKind()
  //
  /// Removes the given essence kind from the list of those supported
  /// by the codec.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEssenceKind is null.
  ///
  /// AAFRESULT_OBJECT_NOT_FOUND
  ///   - the given essenceKind is not already contained.
  /// 
  /// @param pEssenceKind [in] The essence kind to remove
  ///
  HRESULT RemoveEssenceKind (
    [in] IAAFDataDef * pEssenceKind);


  //***********************************************************
  //
  // CountEssenceKinds()
  //
  /// Places the number of supported essence kinds into *pResult.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is NULL.
  /// 
  /// @param pResult [out, retval] The number of essence kinds
  ///
  HRESULT CountEssenceKinds (
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // GetEssenceKinds()
  //
  /// Places an IEnumAAFDataDefs enumerator for the essence kinds
  /// contained in the sequence into the *ppEnum argument.
  /// 
  /// The returned enumerator is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// E_FAIL
  ///   - Failed to create the enumerator.
  /// 
  /// @param ppEnum [out, retval] Essence Kind Enumeration
  ///
  HRESULT GetEssenceKinds (
    [out, retval] IEnumAAFDataDefs ** ppEnum);


  //***********************************************************
  //
  // AreThereFlavours()
  //
  /// Find out whether its worth iterating over flavours.  Flavours are
  /// used when a single codec can support multiple formats.  An
  /// example would be a codec which would accept a "resolution ID"
  /// for a particular manufacturer and set up all of the parameters.
  /// When a new resolution ID is released, then a new codec plugin
  /// would give users the ability to use the new resolutions without
  /// upgrading the application.
  ///
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - if Result is null.
  /// 
  /// @param pResult [out,retval] True if there are flavours of this codec
  ///
  HRESULT AreThereFlavours (
    [out,retval] aafBoolean_t *  pResult);


  //***********************************************************
  //
  // GetFileDescriptorClass()
  //
  /// Places the file descriptor class object associated with this
  /// codec into the *ppClass argument.  If none exists yet, NULL is
  /// placed into the*ppClass argument.
  ///
  /// The returned class object, if it exists, is
  /// AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppClass pointer is valid.
  /// - A valid file descriptor class exists.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppClass is null.
  /// 
  /// @param ppClass [out] Returned file descriptor class object
  ///
  HRESULT GetFileDescriptorClass (
    [out] IAAFClassDef ** ppClass);


  //***********************************************************
  //
  // SetFileDescriptorClass()
  //
  /// Sets the file descriptor class associated with this codec to be
  /// the given one. 
  ///
  /// Succeeds if all of the following are true:
  /// - the pClass pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pClass is null.
  /// 
  /// @param pClass [in] File descriptor class object
  ///
  HRESULT SetFileDescriptorClass (
    [in] IAAFClassDef * pClass);


  //***********************************************************
  //
  // EnumCodecFlavours()
  //
  /// Places an enumerator for codec flavour into the *ppEnum argument.
  /// The returned enumerator is AddRef()ed before it is returned.
  /// 
  /// Flavours are used when a single codec can support multiple
  /// formats.  An example would be a codec which would accept a
  /// "resolution ID" for a particular manufacturer and set up all of
  /// the parameters.  When a new resolution ID is released, then a
  /// new codec plugin would give users the ability to use the new
  /// resolutions without upgrading the application.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - if ppEnum is null.
  /// 
  /// @param ppEnum [out,retval] Codec flavour Enumeration
  ///
  HRESULT EnumCodecFlavours (
    [out,retval] IEnumAAFCodecFlavours ** ppEnum);
  
}



// ************************
//
// Interface IAAFCommentMarker
//
// ************************

///
/// The IAAFCommentMarker interface is implemented by objects which represent
/// a user comment associated with a point in time. A CommentMarker may
/// have a SourceReference that specifies a text or audio annotation.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it through
///     this object's primary interface.  Note that IAAFMobSlot is a
///     primary interface for an abstract class, so it is not
///     appropriate for the Initialize() method to exist in this
///     interface.  The Initialize() method is available through the
///     concrete object's primary interface.
/// 
///
///
/// Objects that implement IAAFCommentMarker also implement the following interfaces:
///  - IAAFEvent
///  - IAAFSegment
///  - IAAFComponent
///  - IAAFComponent2
///  - IAAFObject
[
    object,
    uuid(e684d78a-b935-11d2-bf9d-00104bc9156d),
    helpstring("IAAFCommentMarker Interface"),
    pointer_default(unique)
]
interface IAAFCommentMarker : IUnknown
{


  //***********************************************************
  //
  // GetAnnotation()
  //
  /// This method will get the annotation for this comment marker and place an
  /// interface for it into the **ppResult argument. 
  ///
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult arg is NULL.
  /// 
  /// @param ppResult [out,retval] Annotation property value
  ///
  HRESULT GetAnnotation (
    [out,retval] IAAFSourceReference ** ppResult);

  //***********************************************************
  //
  // SetAnnotation()
  //
  /// This method will set the Annotation for this comment marker.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param pAnnotation [in] Annotation property value
  ///
  HRESULT SetAnnotation (
    [in] IAAFSourceReference * pAnnotation);

}



// ************************
//
// Interface IAAFComponent
//
// ************************
///
/// IAAFComponent is DEPRECATED, please use IAAFComponent2.
///
/// The component class represents an essence element.  A Component is
/// an abastract class with two subclasses: Segment and Transition.
/// The GetLength and SetLength only aplies to time-varying media and
/// it is an  optional property. Non time-varying objects DO NOT
/// support this property.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it through
///     this object's primary interface.  Note that IAAFComponent is a
///     primary interface for an abstract class, so it is not
///     appropriate for the Initialize() method to exist in this
///     interface.  The Initialize() method is available through the
///     concrete object's primary interface.
///
///
/// Objects that implement IAAFComponent also implement the following interfaces:
///  - IAAFComponent2
///  - IAAFObject
[
    object,
    uuid(38e6f8a1-2a2c-11d2-8411-00600832acb8),
    helpstring("IAAFComponent Interface"),
    pointer_default(unique)
]
interface IAAFComponent : IUnknown
{
  //***********************************************************
  //
  // SetLength()
  //
  /// Sets the length property value on this component object.
  /// 
  /// Succeeds if all of the following are true:
  /// - the optional length property is present for this object.
  ///
  /// This method deals with an optional property, which will only be
  /// present for time-varying media.
  /// 
  /// If this method fails the length property will not be
  /// changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_BAD_PROP
  ///   - the optional length property is not present for this object.
  /// 
  /// @param length [in] The duration in edit units of this component
  ///
  HRESULT SetLength (
    [in] aafLength_constref  length);


  //***********************************************************
  //
  // GetLength()
  //
  /// Gets the duration in edit units of this component.
  ///	
  /// Succeeds if all of the following are true:
  /// - the pLength pointer is valid.
  /// - the optional length property is present for this object.
  ///
  /// This method deals with an optional property, which will only be
  /// present for time-varying media.
  /// 
  /// If this method fails nothing will be written to *pLength.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLength arg is NULL.
  ///
  /// AAFRESULT_BAD_PROP
  ///   - the optional length property is not present for this object.
  /// 
  /// @param pLength [retval][out] Length of this component
  ///
  HRESULT GetLength (
    [retval][out] aafLength_t *  pLength);
	

  //***********************************************************
  //
  // SetDataDef()
  //
  /// Sets the data definition property AUID on this component.
  /// 
  /// If this method fails the Data Definition property will not be
  /// changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDataDef arg is NULL.
  /// 
  /// @param pDataDef [in] DataDef of this object
  ///
  HRESULT SetDataDef (
    [in] IAAFDataDef * pDataDef);


  //***********************************************************
  //
  // GetDataDef()
  //
  /// Returns data definition object.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppDatadef pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppDatadef.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDatadef arg is NULL.
  /// 
  /// @param ppDatadef [out, retval] DataDef of this object
  ///
  HRESULT GetDataDef (
    [out, retval] IAAFDataDef ** ppDatadef);

  //***********************************************************
  //
  // AppendKLVData()
  //
  /// Appends a pre-existing KLV Data object to the specified
  /// component.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pKLV pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - the pData arg is NULL.
  /// 
  /// @param pData [in] KLV object
  ///
  HRESULT AppendKLVData (
    [in] IAAFKLVData * pData);


  //***********************************************************
  //
  // CountKLVData()
  //
  /// Return total number of KLV data objects attached to this component.
  ///
  /// Succeeds if all of the following are true:
  /// - the pNumData pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pNumComments.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumData arg is NULL.
  /// 
  /// @param pNumData [out] Number  of KLV data objects
  ///
  HRESULT CountKLVData (
    [out] aafUInt32 *  pNumData);


  //***********************************************************
  //
  // GetKLVData()
  //
  /// Return the enumeration for all KLV data objects on this component.  The returned
  /// enumerator is AddRef()ed before it is returned.  The enumerator
  /// is implemented as a EnumAAFKLVData.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  /// 
  /// @param ppEnum [out] KLV data objects
  ///
  HRESULT GetKLVData (
    [out] IEnumAAFKLVData ** ppEnum);


  //***********************************************************
  //
  // RemoveKLVData()
  //
  /// Removes the given KLV data object from this component.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pData pointer is valid.
  /// - the given KLV data object is present in the component.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pData is null.
  ///
  /// AAFRESULT_OBJECT_NOT_FOUND
  ///   - the given KLV data object is not in this component.
  /// 
  /// @param pData [in] KLV data object to remove
  ///
  HRESULT RemoveKLVData (
    [in] IAAFKLVData * pData);











}



// ************************
//
// Interface IAAFCompositionMob
//
// ************************
///
/// IAAFCompositionMob is DEPRECATED, please use IAAFCompositionMob2.
///
/// The IAAFCompositionMob interface is implemented on objects which
/// can specify how to combine content data elements into a sequence,
/// how to modify content data elements, and how to synchronize content
/// data elements.	   
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///


///
/// Objects that implement IAAFCompositionMob also implement the following interfaces:
///  - IAAFCompositionMob2
///  - IAAFMob
///  - IAAFMob2
///  - IAAFObject
[
    object,
    uuid(91920d63-2a2e-11D2-bfA3-006097116212),
    helpstring("IAAFCompositionMob Interface"),
    pointer_default(unique)
]
interface IAAFCompositionMob : IUnknown
{
  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes this object with the given name.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has not yet been initialized.
  /// - the pName pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName argument is NULL.
  /// 
  /// @param pName [in, string] Mob name [optional]
  ///
  HRESULT Initialize (
    [in, string] aafCharacter_constptr  pName);


  //***********************************************************
  //
  // GetDefaultFade()
  //
  /// Get the default fade for this composition.  If there is no
  /// default fade, this function returns with no error, but the VALID
  /// field of the structure is false.  This allows you to pass this
  /// struct to SourceClip::GetFade() in all cases.
  ///
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the pResult pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult argument is NULL.
  /// 
  /// @param pResult [out] a default fade struct
  ///
  HRESULT GetDefaultFade (
    [out] aafDefaultFade_t *  pResult);
	

  //***********************************************************
  //
  // SetDefaultFade()
  //
  /// Adds the default crossfade properties to the Mob.
  ///
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_BAD_TYPE
  ///   - invalid fadeType.
  ///
  /// AAFRESULT_BAD_LENGTH
  ///   - invalid fadeLength.
  /// 
  /// @param fadeLength [in] Default fade length
  /// @param fadeType [in] default fade type
  /// @param fadeEditUnit [in] default fade edit unit
  ///
  HRESULT SetDefaultFade (
    [in] aafLength_t  fadeLength,
    [in] aafFadeType_t  fadeType,
    [in] aafRational_t  fadeEditUnit);





}


// ************************
//
// Interface IAAFConstantValue
//
// ************************
///
/// The IAAFConstantValue interface is implemented by objects that
/// specify a parameter whose value is constant for an entire operation
/// group.  Use IAAFVaryingValue and one or more IAAFControlPoints for
/// parameters which change in value during the operation group.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
///
/// Objects that implement IAAFConstantValue also implement the following interfaces:
///  - IAAFParameter
///  - IAAFObject
[
    object,
    uuid(b8ddc080-2afa-11D2-bfA5-006097116212),
    helpstring("IAAFConstantValue Interface"),
    pointer_default(unique)
]
interface IAAFConstantValue : IUnknown
{


  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a new constant value object to be identified with the
  /// given the given type, and with the given human-legible name.
  ///
  /// This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  /// - pParameterDef and pValue are a valid pointers.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - This object has already had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pParameterDef or pValue arg is NULL.
  /// 
  /// 
  /// @param pParameterDef [in] Parameter definition for this object (this determines the type of the constant value)
  /// @param valueSize [in] Size of preallocated buffer
  /// @param pValue [in, size_is(valueSize)] buffer containing value
  ///
  HRESULT Initialize (
    [in] IAAFParameterDef * pParameterDef,
    [in] aafUInt32  valueSize,
    [in, size_is(valueSize)] aafDataBuffer_t  pValue);


  //***********************************************************
  //
  // GetValue()
  //
  /// Writes the value into the pValue buffer.  The buffer is allocated
  /// by the caller, and the size of the buffer is given by
  /// valueSize.
  /// 
  /// Caller may call GetValueBufLen() to determine the
  /// required buffer size.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pValue pointer is valid.
  /// - valueSize indicates the buffer is large enough to hold the
  ///   name.
  /// 
  /// If this method fails nothing will be written to *pValue.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pValue arg is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - valueSize indicates the buffer is too small to hold the
  ///     value.
  /// 
  /// @param valueSize [in] Size of preallocated buffer
  /// @param pValue [out, size_is(valueSize),length_is(*bytesRead)] Preallocated buffer to hold value
  /// @param bytesRead [out] Number of actual bytes read
  ///
  HRESULT GetValue (
    [in] aafUInt32  valueSize,
    [out, size_is(valueSize),length_is(*bytesRead)] aafDataBuffer_t  pValue,
    [out] aafUInt32*  bytesRead);


  //***********************************************************
  //
  // GetValueBufLen()
  //
  /// Returns the length of buffer required for the GetValue()
  /// method.  The value is placed into the location specified by
  /// pLen.
  ///
  /// Succeeds if all of the following are true:
  /// - the pLen pointer is valid.
  ///
  /// If this method fails nothing will be written to *pLen.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLen arg is NULL.
  /// 
  /// @param pLen [out] Pointer to an variable used to return the length
  ///
  HRESULT GetValueBufLen (
    [out] aafUInt32 *  pLen);

  //***********************************************************
  //
  // GetTypeDefinition()
  //
  /// Places the type definition of the dataval inside this parameter into the
  /// *ppTypeDef argument.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTypeDef is null.
  /// 
  /// @param ppTypeDef [out,retval] Type Definition of the dataval inside of this object
  ///
  HRESULT GetTypeDefinition (
    [out,retval] IAAFTypeDef ** ppTypeDef);

  //***********************************************************
  //
  // SetValue()
  //
  /// The data value is set from a buffer of size valueSize and type.
  ///
  /// Succeeds if all of the following are true:
  /// - pTypeDef is valid and registered with the object's dictionary.
  /// - the pValue pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTypeDef is null.
  /// 
  /// @param valueSize [in] Size of preallocated buffer
  /// @param pValue [in, size_is(valueSize)] buffer containing value
  ///
  HRESULT SetValue (
    [in] aafUInt32  valueSize,
    [in, size_is(valueSize)] aafDataBuffer_t  pValue);

}



// ************************
//
// Interface IAAFContainerDef
//
// ************************
///
/// This interface is used with an object representing a particular
/// kind of essence stream factory object, which may be implemented by
/// one or more AAFPluginDescriptors.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///


///
/// Objects that implement IAAFContainerDef also implement the following interfaces:
///  - IAAFDefObject
///  - IAAFObject
[
    object,
    uuid(AD1BB858-DBB2-11d2-809C-006008143E6F),
    helpstring("IAAFContainerDef Interface"),
    pointer_default(unique)
]
interface IAAFContainerDef : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Init all fields of a definition object.
  /// 
  /// @param id [in, ref] AUID for new DefObject
  /// @param pName [in, string] Name for new DefObject
  /// @param pDescription [in, string] Description for new DefObject
  ///
  HRESULT Initialize (
    [in, ref] aafUID_constref  id,
    [in, string] aafCharacter_constptr  pName,
    [in, string] aafCharacter_constptr  pDescription);


  //***********************************************************
  //
  // EssenceIsIdentified()
  //
  /// Tells whether the given plugin is capable of supporting
  /// authentication.  The methods for authenticating a plugin are
  /// still <tbd>.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pEssenceIsIdentified pointer is valid.
  /// 
  /// If this method fails nothing will be written to
  /// *pEssenceIsIdentified.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEssenceIsIdentified arg is NULL.
  /// 
  /// @param pEssenceIsIdentified [out] The EssenceIsIdentified
  ///
  HRESULT EssenceIsIdentified (
    [out] aafBoolean_t *  pEssenceIsIdentified);


  //***********************************************************
  //
  // SetEssenceIsIdentified()
  //
  /// Tells whether the given plugin is capable of supporting
  /// authentication.  The methods for authenticating a plugin are
  /// still <tbd>.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param EssenceIsIdentified [in] The EssenceIsIdentified flag
  ///
  HRESULT SetEssenceIsIdentified (
    [in] aafBoolean_t  EssenceIsIdentified);
}



// ************************
//
// Interface IAAFContentStorage
//
// ************************


///
/// Objects that implement IAAFContentStorage also implement the following interfaces:
///  - IAAFObject
[
    object,
    uuid(54D4C482-5F8B-11d2-8073-006008143E6F),
    helpstring("IAAFContentStorage Interface"),
    pointer_default(unique)
]



interface IAAFContentStorage : IUnknown
{


  //***********************************************************
  //
  // LookupMob()
  //
  /// Looks up the Mob that matches the given mob id and puts it into
  /// the ppMob argument.  The returned mob interface is AddRef()ed
  /// before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppMob pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppMob.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppMob is null
  ///
  /// AAFRESULT_MOB_NOT_FOUND
  ///   - the requested mob wasn't found.
  /// 
  /// @param mobID [in, ref] The Mob ID
  /// @param ppMob [out,retval] Matching Mob
  ///
  HRESULT LookupMob (
    [in, ref] aafMobID_constref  mobID,
    [out,retval] IAAFMob ** ppMob);


  //***********************************************************
  //
  // CountMobs()
  //
  /// Writes the number of matches for the given mob kind into the
  /// *pNumMobs argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pNumMobs pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pNumMobs.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumMobs is null.
  /// 
  /// @param mobKind [in] The mob kind to count
  /// @param pResult [out, retval] Total number of mobs of kind mobKind
  ///
  HRESULT CountMobs (
    [in] aafMobKind_t  mobKind,
    [out, retval] aafNumSlots_t *  pResult);


  //***********************************************************
  //
  // GetMobs()
  //
  /// Places an enumerator for mobs that apply to the criteria into the
  /// *ppEnum argument.  If pSearchCriteria is null, all mobs are
  /// returned.   The searchTag field of pSearchCriteria, and exactly
  /// ONE of the fields in the union (tags.mobID, tags.name, etc. )
  /// must be set.  Only one search criterion may be specified.  The
  /// returned enumerator is AddRef()ed before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  /// 
  /// @param pSearchCriteria [in] Search Criteria for enumeration
  /// @param ppEnum [out, retval] Mob Enumeration
  ///
  HRESULT GetMobs (
    [in] aafSearchCrit_t *  pSearchCriteria,
    [out, retval] IEnumAAFMobs ** ppEnum);


  //***********************************************************
  //
  // AddMob()
  //
  /// Appends the given mob to the header.  If the given mob is already
  /// contained this method will do nothing and will return success.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pMob pointer is valid.
  /// - the given mob is not already part of this collection.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMob is null.
  ///
  /// AAFRESULT_DUPLICATE_MOBID
  ///   - the given mob is already contained.
  /// 
  /// @param pMob [in] Mob to add
  ///
  HRESULT AddMob (
    [in] IAAFMob * pMob);


  //***********************************************************
  //
  // RemoveMob()
  //
  /// Removes the given mob from the header.
  ///
  /// Succeeds if all of the following are true:
  /// - the pMob pointer is valid.
  /// - the given mob is currently in the collection.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMob is null.
  ///
  /// AAFRESULT_MOB_NOT_FOUND
  ///   - the given mob is not already contained.
  /// 
  /// @param pMob [in] Mob to remove
  ///
  HRESULT RemoveMob (
    [in] IAAFMob * pMob);


  //***********************************************************
  //
  // CountEssenceData()
  //
  /// Writes the total number of essence data into the *pNumEssenceData
  /// argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pNumEssenceData pointer is valid.
  /// 
  /// If this method fails nothing will be written to
  /// *pNumEssenceData.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumEssenceData is null.
  /// 
  /// @param pResult [out, retval] Total number of essence data
  ///
  HRESULT CountEssenceData (
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // IsEssenceDataPresent()
  //
  /// Returns true if essence is found.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  /// 
  /// @param fileMobID [in, ref] A Unique File Mob ID
  /// @param fmt [in] The Essence File Format
  /// @param pResult [out,retval] True if the essence is found
  ///
  HRESULT IsEssenceDataPresent (
    [in, ref] aafMobID_constref  fileMobID,
    [in] aafFileFormat_t  fmt,
    [out,retval] aafBoolean_t *  pResult);


  //***********************************************************
  //
  // EnumEssenceData()
  //
  /// Places an enumerator for essence that applies to the criteria
  /// into the *ppEnum argument.  The returned enumerator is
  /// AddRef()ed before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pMediaCriteria pointer is valid.
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pMediaCriteria or ppEnum is null.
  /// 
  /// @param ppEnum [out,retval] Essence Enumeration
  ///
  HRESULT EnumEssenceData (
    [out,retval] IEnumAAFEssenceData ** ppEnum);


  //***********************************************************
  //
  // AddEssenceData()
  //
  /// Appends the given essence data object to the header.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pEssenceData pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_DUPLICATE_MOBID
  ///   - The given mob has already been added.  The validation is done by comparing
  ///     mobIDs, which should be unique.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEssenceData is null.
  /// 
  /// @param pEssenceData [in] Essence data object to append
  ///
  HRESULT AddEssenceData (
    [in] IAAFEssenceData * pEssenceData);

  //***********************************************************
  //
  // RemoveEssenceData()
  //
  /// Removes the given EssenceData from the header.
  ///
  /// Succeeds if all of the following are true:
  /// - the pEssenceData pointer is valid.
  /// - the given EssenceData is currently in the collection.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEssenceData is null.
  ///
  /// AAFRESULT_ESSENCE_NOT_FOUND
  ///   - the given EssenceData is not already contained.
  /// 
  /// @param pEssenceData [in] EssenceData to remove
  ///
  HRESULT RemoveEssenceData (
    [in] IAAFEssenceData * pEssenceData);

  //***********************************************************
  //
  // LookupEssenceData()
  //
  /// Looks up the EssenceData that matches the given mob id and puts it into
  /// the ppEssenceData argument.  The returned EssenceData interface is AddRef()ed
  /// before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEssenceData pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEssenceData.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEssenceData is null
  ///
  /// AAFRESULT_MOB_NOT_FOUND
  ///   - the requested EssenceData wasn't found.
  /// 
  /// @param mobID [in, ref] The Mob ID
  /// @param ppEssenceData [out,retval] Matching EssenceData
  ///
  HRESULT LookupEssenceData (
    [in, ref] aafMobID_constref  mobID,
    [out,retval] IAAFEssenceData ** ppEssenceData);

}



// ************************
//
// Interface IAAFControlPoint
//
// ************************
///
/// The IAAFControlPoint interface is implemented by objects that store an individual point value
/// of a parameter whose value changes during the operation group.  IAAFControlPoints must be added to
/// an object which implements IAAFVaryingValue, which is then added to the IAAFOperationGroup.
///
/// For parameters which are constant in value during the operation group, use IAAFConstantValue.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
///
/// Objects that implement IAAFControlPoint also implement the following interfaces:
///  - IAAFObject
[
    object,
    uuid(86192db1-2a23-11D2-BFa3-006097116212),
    helpstring("IAAFControlPoint Interface"),
    pointer_default(unique)
]
interface IAAFControlPoint : IUnknown
{


  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a new control point object to be 
  ///
  /// This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  /// - pVaryingValue is a valid pointer.
  /// - time is a valid rational.
  /// - pValue is a valid pointer
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - This object has already had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName or pValue arg is NULL.
  /// 
  /// 
  /// @param pVaryingValue [in] A varying value (this determines the type of this control point through the parameter definition)
  /// @param time [in] Control Point time
  /// @param valueSize [in] Size of preallocated buffer
  /// @param pValue [in, size_is(valueSize)] buffer containing value
  ///
  HRESULT Initialize (
    [in] IAAFVaryingValue * pVaryingValue,
    [in] aafRational_constref  time,
    [in] aafUInt32  valueSize,
    [in, size_is(valueSize)] aafDataBuffer_t  pValue);

  //***********************************************************
  //
  // GetTime()
  //
  /// Returns the position of the control point within an operation group, expressed as a rational
  /// running from 0 to 1.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pTime pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pTime.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - This property does not exist in the file.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTime arg is NULL.
  /// 
  /// @param pTime [out,retval] Pointer to an aafRational_t
  ///
  HRESULT GetTime (
    [out,retval] aafRational_t *  pTime);

  //***********************************************************
  //
  // GetEditHint()
  //
  /// Returns the edit hint of the control point, which describes how to alter the
  /// position if the AAFOperationGroup is made longer or shorter.
  ///
  /// Succeeds if all of the following are true:
  /// - the pEditHint pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pEditHint.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - This property does not exist in the file.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEditHint arg is NULL.
  /// 
  /// @param pEditHint [out,retval] Pointer to an aafEditHint_t
  ///
  HRESULT GetEditHint (
    [out,retval] aafEditHint_t *  pEditHint);

  //***********************************************************
  //
  // GetValueBufLen()
  //
  /// Returns the length of buffer required for the GetValue() method.
  /// The value is placed into the location specified by pLen.
  ///
  /// Succeeds if all of the following are true:
  /// - the pLen pointer is valid.
  ///
  /// If this method fails nothing will be written to *pLen.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLen arg is NULL.
  /// 
  /// @param pLen [out] Pointer to an variable used to return the length
  ///
  HRESULT GetValueBufLen (
    [out] aafUInt32 *  pLen);

  //***********************************************************
  //
  // GetValue()
  //
  /// Writes the value into the pValue buffer.  The buffer is allocated by the caller,
  /// and the size of the buffer is given by valueSize.
  /// 
  /// Caller may call GetValueBufLen() to determine the
  /// required buffer size.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pValue pointer is valid.
  /// - valueSize indicates the buffer is large enough to hold the name.
  /// 
  /// If this method fails nothing will be written to *pValue.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pValue arg is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - valueSize indicates the buffer is too small to hold the value.
  /// 
  /// @param valueSize [in] Size of preallocated buffer
  /// @param pValue [out, size_is(valueSize),length_is(*bytesRead)] Preallocated buffer to hold value
  /// @param bytesRead [out] Number of actual bytes read
  ///
  HRESULT GetValue (
    [in] aafUInt32  valueSize,
    [out, size_is(valueSize),length_is(*bytesRead)] aafDataBuffer_t  pValue,
    [out] aafUInt32*  bytesRead);

  //***********************************************************
  //
  // SetTime()
  //
  /// Sets the position of the control point within an operation group, expressed as a rational
  /// running from 0 to 1.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param pTime [in] Control Point time
  ///
  HRESULT SetTime (
    [in] aafRational_t  pTime);

  //***********************************************************
  //
  // SetEditHint()
  //
  /// Sets the control point Edit hint value, which describes how to alter the
  /// position if the AAFOperationGroup is made longer or shorter.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param editHint [in] Control Point Edit hint
  ///
  HRESULT SetEditHint (
    [in] aafEditHint_t  editHint);

  //***********************************************************
  //
  // GetTypeDefinition()
  //
  /// Places the type definition of the dataval inside this parameter into the
  /// *ppTypeDef argument.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTypeDef is null.
  /// 
  /// @param ppTypeDef [out,retval] Type Definition of the dataval inside of this object
  ///
  HRESULT GetTypeDefinition (
    [out,retval] IAAFTypeDef ** ppTypeDef);

  //***********************************************************
  //
  // SetValue()
  //
  /// The data value is set from a buffer of size valueSize and type.
  ///
  /// Succeeds if all of the following are true:
  /// - pTypeDef is valid and registered with the object's dictionary.
  /// - the pValue pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTypeDef is null.
  /// 
  /// @param valueSize [in] Size of preallocated buffer
  /// @param pValue [in, size_is(valueSize)] buffer containing value
  ///
  HRESULT SetValue (
    [in] aafUInt32  valueSize,
    [in, size_is(valueSize)] aafDataBuffer_t  pValue);

}




// ************************
//
// Interface IAAFDataDef
//
// ************************
///
/// IAAFDataDef is DEPRECATED,  Please use IAAFDataDef2.
///
///
/// Objects that implement IAAFDataDef also implement the following interfaces:
///  - IAAFDefObject
///  - IAAFObject
[
    object,
    uuid(dfbd6529-1d81-11d2-bf96-006097116212),
    helpstring("IAAFDataDef Interface"),
    pointer_default(unique)
]
interface IAAFDataDef : IUnknown
{
  //***********************************************************
  //
  // Initialize()
  //
  /// Init all fields of a definition object.
  /// 
  /// @param id [in, ref] AUID for new DefObject
  /// @param pName [in, string] Name for new DefObject
  /// @param pDescription [in, string] Description for new DefObject
  ///
  HRESULT Initialize (
    [in, ref] aafUID_constref  id,
    [in, string] aafCharacter_constptr  pName,
    [in, string] aafCharacter_constptr  pDescription);


  //***********************************************************
  //
  // IsPictureKind()
  //
  /// Sets return value to TRUE if DataDef is a picture.
  /// 
  /// @param bIsPictureKind [retval,out] pointer to the return value
  ///
  HRESULT IsPictureKind (
    [retval,out] aafBoolean_t *  bIsPictureKind);


  //***********************************************************
  //
  // IsMatteKind()
  //
  /// Sets return value to TRUE if DataDef is a matte.
  /// 
  /// @param bIsMatteKind [retval,out] pointer to the return value
  ///
  HRESULT IsMatteKind (
    [retval,out] aafBoolean_t *  bIsMatteKind);


  //***********************************************************
  //
  // IsPictureWithMatteKind()
  //
  /// Sets return value to TRUE if DataDef is a picture with matte.
  /// 
  /// @param bIsPictureWithMatteKind [retval,out] pointer to the return value
  ///
  HRESULT IsPictureWithMatteKind (
    [retval,out] aafBoolean_t *  bIsPictureWithMatteKind);


  //***********************************************************
  //
  // IsSoundKind()
  //
  /// Sets return value to TRUE if DataDef is a sound.
  /// 
  /// @param bIsSoundKind [retval,out] pointer to the return value
  ///
  HRESULT IsSoundKind (
    [retval,out] aafBoolean_t *  bIsSoundKind);


  //***********************************************************
  //
  // DoesDataDefConvertTo()
  //
  /// Sets return value to TRUE if the DataDef of the given object
  /// can be converted to the DataDef specified in the IN 
  /// parameter with the DataDefName string.
  /// 
  /// @param id [in] data def to compare against
  /// @param bDoesConvertTo [retval, out] pointer to result
  ///
  HRESULT DoesDataDefConvertTo (
    [in] IAAFDataDef * id,
    [retval, out] aafBoolean_t *  bDoesConvertTo);
		   

  //***********************************************************
  //
  // IsDataDefOf()
  //
  /// Sets the value to TRUE if the DataDef of the given object
  /// matches the DataDef specified in the IN parameter with the
  /// DataDefName string.
  /// 
  /// @param pDataDef [in] data def to compare against
  /// @param bIsDataDefOf [retval, out] pointer to result
  ///
  HRESULT IsDataDefOf (
    [in] IAAFDataDef * pDataDef,
    [retval, out] aafBoolean_t *  bIsDataDefOf);


  //***********************************************************
  //
  // DoesDataDefConvertFrom()
  //
  /// Sets return value to TRUE if the DataDef of the given object
  /// can be converted from the DataDef specified in the IN 
  /// parameter specified with the DataDefName string.
  /// 
  /// @param pDataDef [in] data def to compare against
  /// @param bDoesConvertFrom [retval, out] pointer to result
  ///
  HRESULT DoesDataDefConvertFrom (
    [in] IAAFDataDef * pDataDef,
    [retval, out] aafBoolean_t *  bDoesConvertFrom);







}


// ************************
//
// Interface IAAFDataEssenceDescriptor
//
// ************************
///

/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it.
///
///
/// Objects that implement IAAFDataEssenceDescriptor also implement the following interfaces:
///  - IAAFFileDescriptor
///  - IAAFFileDescriptor2
///  - IAAFEssenceDescriptor
///  - IAAFObject
[
    object,
    uuid(28aef97c-5127-4435-98c8-baf906b5a6a9),
    helpstring("IAAFDataEssenceDescriptor Interface"),
    pointer_default(unique)
]

interface IAAFDataEssenceDescriptor : IUnknown
{



  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty IAAFDataEssenceDescriptor-supporting
  /// object.  This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  /// 
  HRESULT Initialize ();

  //***********************************************************
  //
  // SetDataEssenceCoding()
  //
  /// Sets the DataEssenceCoding property
  /// This property is optional.  
  /// 
  /// If this method fails the Data Definition property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param dataEssenceCoding [in] Optional.
  ///
  HRESULT SetDataEssenceCoding (
    [in] aafUID_constref  dataEssenceCoding);


  //***********************************************************
  //
  // GetDataEssenceCoding()
  //
  /// Gets the DataEssenceCoding property
  /// information of the video essence data.  This property is
  /// optional.
  ///
  /// Succeeds if all of the following are true:
  /// - the pDataEssenceCoding pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pDataEssenceCoding.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDataEssenceCoding arg is NULL.
  /// 
  /// @param pDataEssenceCoding [out] Optional.
  ///
  HRESULT GetDataEssenceCoding (
    [out] aafUID_t *  pDataEssenceCoding);

}



// ************************
//
// Interface IAAFDefObject
//
// ************************
///
/// This interface is defines an item to be referenced in the AAF file.
/// It specifies the AUID unique identifier used to define types used
/// in AAF persistent objects.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it through
///     this object's primary interface.  Note that IAAFObject is a
///     primary interface for an abstract class, so it is not
///     appropriate for the Initialize() method to exist in this
///     interface.  The Initialize() method is available through the
///     concrete object's primary interface.
///
/// Objects that implement IAAFDefObject also implement the following interfaces:
///  - IAAFObject
[
    object,
    uuid(dfbd6527-1d81-11d2-bf96-006097116212),
    helpstring("IAAFDefObject Interface"),
    pointer_default(unique)
]
interface IAAFDefObject : IUnknown
{

  //***********************************************************
  //
  // SetName()
  //
  /// Sets the Name of this definition.
  ///
  /// Set the Name property to the value specified in
  /// pName.  A copy is made of the data so the caller
  /// retains ownership of the *pName buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pName pointer is valid.
  /// 
  /// If this method fails the Name property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  /// 
  /// @param pName [in, string] buffer from which Name is to be read
  ///
  HRESULT SetName (
    [in, string] aafCharacter_constptr  pName);


  //***********************************************************
  //
  // GetName()
  //
  /// Gets the Name of this definition.
  /// 
  /// Writes the Name property, with a trailing null
  /// character, into the pName buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the Name property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetNameBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pName.
  /// 
  /// Succeeds if:
  /// - The pName pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   Name.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold Name.
  /// 
  /// @param pName [out, string, size_is(bufSize)] buffer into which Name is to be written
  /// @param bufSize [in] size of *pName buffer in bytes
  ///
  HRESULT GetName (
    [out, string, size_is(bufSize)] aafCharacter *  pName,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetNameBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetName().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetNameBufLen (
    [out] aafUInt32 *  pBufSize);


  //***********************************************************
  //
  // SetDescription()
  //
  /// Sets the Description of this definition.
  ///
  /// Set the Description property to the value specified in
  /// pDescription.  A copy is made of the data so the caller
  /// retains ownership of the *pDescription buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pDescription pointer is valid.
  /// 
  /// If this method fails the Description property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDescription arg is NULL.
  /// 
  /// @param pDescription [in, string] buffer from which Description is to be read
  ///
  HRESULT SetDescription (
    [in, string] aafCharacter_constptr  pDescription);


  //***********************************************************
  //
  // GetDescription()
  //
  /// Gets the Description of this definition.
  /// 
  /// Writes the Description property, with a trailing null
  /// character, into the pDescription buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the Description property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetDescriptionBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pDescription.
  /// 
  /// Succeeds if:
  /// - The pDescription pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   Description.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDescription arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold Description.
  /// 
  /// @param pDescription [out, string, size_is(bufSize)] buffer into which Description is to be written
  /// @param bufSize [in] size of *pDescription buffer in bytes
  ///
  HRESULT GetDescription (
    [out, string, size_is(bufSize)] aafCharacter *  pDescription,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetDescriptionBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetDescription().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetDescriptionBufLen (
    [out] aafUInt32 *  pBufSize);


  //***********************************************************
  //
  // Initialize()
  //
  /// Init all fields of a definition object.
  /// 
  /// @param id [in, ref] AUID for new DefObject
  /// @param pName [in, string] Name for new DefObject
  ///
  HRESULT Initialize (
    [in, ref] aafUID_constref  id,
    [in, string] aafCharacter_constptr  pName);


  //***********************************************************
  //
  // GetAUID()
  //
  /// Gets the AUID for this object.
  /// 
  /// @param pAuid [retval,out] Pointer to an AUID reference
  ///
  HRESULT GetAUID (
    [retval,out] aafUID_t *  pAuid);

}



// ************************
//
// Interface IAAFDescriptiveClip
//
// ************************
///

/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it through
///     this object's primary interface.  Note that IAAFMobSlot is a
///     primary interface for an abstract class, so it is not
///     appropriate for the Initialize() method to exist in this
///     interface.  The Initialize() method is available through the
///     concrete object's primary interface.
/// 
///
///
/// Objects that implement IAAFDescriptiveClip also implement the following interfaces:
///  - IAAFSourceClip
///  - IAAFSourceReference
///  - IAAFSourceReference2
///  - IAAFSegment
///  - IAAFComponent
///  - IAAFComponent2
///  - IAAFObject
[
    object,
    uuid(2e777356-b7e4-43ba-bfd4-f964d90bc5e3),
    helpstring("IAAFDescriptiveClip Interface"),
    pointer_default(unique)
]

interface IAAFDescriptiveClip : IUnknown
{


  //***********************************************************
  //
  // Initialize()
  //
  /// This method initializes a source clip object with
  /// the given properties.  Only required properties are set.
  /// Optional properties are added with separate functions.
  ///
  /// Succeds if:
  /// - This object has not already been Initialize()d.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDataDef argument is NULL.
  /// 
  /// @param pDataDef [in] Data Definition object
  /// @param length [in] Length property value
  /// @param sourceRef [in] Source Reference
  ///
  HRESULT Initialize (
    [in] IAAFDataDef * pDataDef,
    [in] aafLength_constref  length,
    [in] aafSourceRef_t  sourceRef);


  //***********************************************************
  //
  // CountDescribedSlotIDs()
  //
  /// Gets the total number of described slot IDs present in
  /// the list of described slot IDs referenced by this DescriptiveClip.
  ///
  /// Succeeds if all of the following are true:
  /// - the pCount pointer is valid;
  /// - the DescribedSlotIDs property is present.
  ///
  /// If this method fails nothing will be written to *pCount.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCount arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the DescribedSlotIDs property is not present.
  /// 
  /// @param pCount [out, retval] Number of described slot IDs
  ///
  HRESULT CountDescribedSlotIDs (
    [out, retval] aafUInt32*  pCount);


  //***********************************************************
  //
  // GetDescribedSlotIDs()
  //
  /// Gets all the described slot IDs in the list of
  /// described slot IDs referenced by this DescriptiveClip.
  ///
  /// The values are written to the array specified by pDescribedSlotIDs,
  /// which is of size maxDescribedSlotIDCount. The required size may be found
  /// by calling CountDescribedSlotIDs().
  /// 
  /// Succeeds if all of the following are true:
  /// - pDescribedSlotIDs is a valid pointer;
  /// - maxDescribedSlotIDCount indicates the array is large enough to hold the
  ///   data;
  /// - the DescribedSlotIDs property is present.
  /// 
  /// If this method fails, the property will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDescribedSlotIDs is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - maxDescribedSlotIDCount indicates that the array is too small to hold
  ///     all the referenced described slot IDs.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the DescribedSlotIDs property is not present.
  /// 
  /// @param maxDescribedSlotIDCount [in] The size of the given pDescribedSlotIDs buffer
  /// @param pDescribedSlotIDs [out, size_is(maxDescribedSlotIDCount)] Array to hold the described slot IDs
  ///
  HRESULT GetDescribedSlotIDs (
    [in] aafUInt32  maxDescribedSlotIDCount,
    [out, size_is(maxDescribedSlotIDCount)] aafUInt32 *  pDescribedSlotIDs);


  //***********************************************************
  //
  // IsDescribedSlotIDPresent()
  //
  /// Determines if the given described slot ID is present in
  /// the list of described slot IDs referenced by this DescriptiveClip.
  ///
  ///
  /// Succeeds if all of the following are true:
  /// - the pIsPresent pointer is valid;
  /// - the DescribedSlotIDs property is present.
  ///
  /// If this method fails nothing will be written to *pIsPresent.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pIsPresent arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the DescribedSlotIDs property is not present.
  /// 
  /// @param DescribedSlotID [in] described slot ID whose presence is to be queried
  /// @param pIsPresent [out,retval] True if DescribedSlotID is present
  ///
  HRESULT IsDescribedSlotIDPresent (
    [in] aafUInt32  DescribedSlotID,
    [out,retval] aafBoolean_t*  pIsPresent);


  //***********************************************************
  //
  // AddDescribedSlotID()
  //
  /// Appends the given described slot ID to the list of
  /// described slot IDs referenced by this DescriptiveClip.
  ///
  /// Succeeds if all of the following are true:
  /// - the given described slot ID is not already contained in the list
  ///   of described slot IDs referenced by this DescriptiveClip.
  ///
  /// If this method fails, the property will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given described slot ID is already contained in the list
  ///     of described slot IDs referenced by this DescriptiveClip.
  /// 
  /// @param DescribedSlotID [in] described slot ID to add.
  ///
  HRESULT AddDescribedSlotID (
    [in] aafUInt32  DescribedSlotID);


  //***********************************************************
  //
  // RemoveDescribedSlotID()
  //
  /// Removes the given described slot ID from
  /// the list of described slot IDs referenced by this DescriptiveClip.
  ///
  /// If the removed ID was the last ID in the list, the list is removed
  /// from this DescriptiveClip (the property is removed).
  ///
  /// Succeeds if all of the following are true:
  /// - the DescribedSlotIDs property is present;
  /// - the given described slot ID is present in the list
  ///   of described slot IDs referenced by this DescriptiveClip.
  ///
  /// If this method fails, the property will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - property not present.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given described slot ID is not present in the list
  ///     of described slot IDs referenced by this DescriptiveClip.
  /// 
  /// @param DescribedSlotID [in] described slot ID to remove.
  ///
  HRESULT RemoveDescribedSlotID (
    [in] aafUInt32  DescribedSlotID);


}



// ************************
//
// Interface IAAFDescriptiveFramework
//
// ************************

///

/// The IAAFDescriptiveFramework interface is implemented by objects
/// that represent descriptive metadata.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
///
/// Objects that implement IAAFDescriptiveFramework also implement the following interfaces:
///  - IAAFObject
[
    object,
    uuid(1cded29f-b8f0-437d-abb0-2144dd35b4aa),
    helpstring("IAAFDescriptiveFramework Interface"),
    pointer_default(unique)
]
interface IAAFDescriptiveFramework : IUnknown
{


}



// ************************
//
// Interface IAAFDescriptiveMarker
//
// ************************

///

/// The IAAFDescriptiveMarker interface is implemented by objects which represent
/// a descriptive metadata associated with a point in time.   A DescriptiveMarker
/// may contain a DescriptiveFramework object that specifies the metadata.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it through
///     this object's primary interface.  Note that IAAFMobSlot is a
///     primary interface for an abstract class, so it is not
///     appropriate for the Initialize() method to exist in this
///     interface.  The Initialize() method is available through the
///     concrete object's primary interface.
/// 
///
///
/// Objects that implement IAAFDescriptiveMarker also implement the following interfaces:
///  - IAAFCommentMarker
///  - IAAFEvent
///  - IAAFSegment
///  - IAAFComponent
///  - IAAFComponent2
///  - IAAFObject
[
    object,
    uuid(c377b78e-591f-4ba9-a069-18438c626e34),
    helpstring("IAAFDescriptiveMarker Interface"),
    pointer_default(unique)
]

interface IAAFDescriptiveMarker : IUnknown
{


  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated,
  /// IAAFDescriptiveFrame object.  This method must be called
  /// after allocation, and before any other method can be called.
  ///
  /// Return codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  /// 
  HRESULT Initialize ();


  //***********************************************************
  //
  // SetDescribedSlotIDs()
  //
  /// Specifies the slot IDs in the Mob to which the DescriptiveFramework refers.
  /// 
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMonoSourceSlotIDs is null 
  ///
  /// This interface is not currently implemented.
  /// 
  /// @param numberElements [in] Number of elements in the pDescribedSlotIDs array
  /// @param pDescribedSlotIDs [in] Array of slot IDs
  ///
  HRESULT SetDescribedSlotIDs (
    [in] aafUInt32  numberElements,
    [in] aafUInt32*  pDescribedSlotIDs);


  //***********************************************************
  //
  // GetDescribedSlotIDs()
  //
  /// Get the described slot IDs that are referenced by this object.  Refer to
  /// SetDescribedSlotIDs for a description of pDescribedSlotIDs.
  ///
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDescribedSlotIDs is null
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present
  ///
  /// AAFRESULT_SMALLBUF
  ///   - pDescribedSlotIDs is too small
  ///
  /// This interface is not currently implemented.
  /// 
  /// @param numberElements [in] Number of elements in the pDescribedSlotIDs array
  /// @param pDescribedSlotIDs [in] Array of channel IDs
  ///
  HRESULT GetDescribedSlotIDs (
    [in] aafUInt32  numberElements,
    [in] aafUInt32*  pDescribedSlotIDs);

  //***********************************************************
  //
  // GetDescribedSlotIDsSize()
  //
  /// Get the number of slot IDs stored by this DescriptiveMarker.
  ///
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDescribedSlotIDs is null 
  /// 
  /// @param numberElements [out] Number of elements in the pDescribedSlotIDs array
  ///
  HRESULT GetDescribedSlotIDsSize (
    [out] aafUInt32 *  numberElements);

  //***********************************************************
  //
  // SetDescriptiveFramework()
  //
  /// Sets the DescriptiveFramework that describes this DescriptiveMarker.
  ///
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///	- succeeded
  ///
  /// AAFRESULT_NULL_PARAM
  ///	- pDescriptorFramework is null
  /// 
  /// @param pDescriptiveFramework [in] DescriptorFramework object to set
  ///
  HRESULT SetDescriptiveFramework (
    [in] IAAFDescriptiveFramework * pDescriptiveFramework);

  //***********************************************************
  //
  // GetDescriptiveFramework()
  //
  /// Gets the DescriptiveFramework that describes this DescriptiveMarker.
  ///
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///	- succeeded
  ///
  /// AAFRESULT_NULL_PARAM
  ///	- ppDescriptorFramework is null
  /// 
  /// @param ppDescriptiveFramework [out,retval] DescriptorFramework object to return
  ///
  HRESULT GetDescriptiveFramework (
    [out,retval] IAAFDescriptiveFramework ** ppDescriptiveFramework);

}



// ************************
//
// Interface IAAFDescriptiveObject
//
// ************************

///

/// The IAAFDescriptiveObject interface is implemented by objects
/// that represent descriptive metadata.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
///
/// Objects that implement IAAFDescriptiveObject also implement the following interfaces:
///  - IAAFObject
[
    object,
    uuid(08a98e21-8995-4bb9-98d4-166f24a5ac66),
    helpstring("IAAFDescriptiveObject Interface"),
    pointer_default(unique)
]

interface IAAFDescriptiveObject : IUnknown
{


}



// ************************
//
// Interface IAAFDictionary
//
// ************************
///
/// This interface is used to access dictionary services in an AAF
/// file.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// Objects that implement IAAFDictionary also implement the following interfaces:
///  - IAAFDictionary2
///  - IAAFObject
[
    object,
    uuid(B1A21398-1A7D-11D2-BF78-00104BC9156D),
    helpstring("IAAFDictionary Interface"),
    pointer_default(unique)
]

interface IAAFDictionary : IUnknown
{

  //***********************************************************
  //
  // CreateInstance()
  //
  /// Creates a single uninitialized AAF object of the class associated 
  /// with a specified stored object id. 
  ///
  /// @param[in] id Class identifier (id) of the stored object. This is the
  ///               corresponding SMPTE identifier (as a GUID) for all
  ///               predefined built-in classes.
  /// @param[in] riid Reference to the identifier of the interface
  /// @param[out] ppvObject Address of output variable that receives the
  ///                       interface pointer requested in riid
  ///
  HRESULT CreateInstance(
    [in, ref] aafUID_constref id,
    [in, ref] REFIID riid,
    [out, iid_is(riid)] IUnknown ** ppvObject);


  //***********************************************************
  //
  // CreateMetaInstance()
  //
  /// Creates a single uninitialized AAF meta class or type associated 
  /// with a specified stored object id. 
  /// 
  /// @param[in] id Identifier (id) of a class or type definition. This is
  ///               the corresponding SMPTE identifier (as a GUID) for all
  ///               predefined built-in definitions.
  /// @param[in] riid Reference to the identifier of the interface
  /// @param[out] ppMetaDefinition Address of output variable that receives
  ///                              the interface pointer requested in riid
  ///
  HRESULT CreateMetaInstance(
    [in, ref] aafUID_constref id,
    [in, ref] REFIID riid,
    [out, iid_is(riid)] IUnknown ** ppMetaDefinition);



  //***********************************************************
  //
  // RegisterClassDef()
  //
  /// Add the class definition object to the dictionary.
  /// 
  /// Succeeds if:
  /// - The pClassDef pointer is valid.
  /// - the ID contained in the class def is not already been
  ///   registered.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pClassDef arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The class def ID has already been registered.
  /// 
  /// @param pClassDef [in] Class Definition
  ///
  HRESULT RegisterClassDef (
    [in] IAAFClassDef * pClassDef);


  //***********************************************************
  //
  // LookupClassDef()
  //
  /// Return the class definition with the given id.
  /// 
  /// Succeeds if:
  /// - The pClassID pointer is valid.
  /// - The ppClassDef pointer is valid.
  /// - the ID is a recognized id for a class definition.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pClassID or ppClassDef arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given ID is not recognized as a class definition ID.
  /// 
  /// @param classId [in, ref] Class Unique ID
  /// @param ppClassDef [out,retval] Class Definition
  ///
  HRESULT LookupClassDef (
    [in, ref] aafUID_constref  classId,
    [out,retval] IAAFClassDef ** ppClassDef);


  //***********************************************************
  //
  // GetClassDefs()
  //
  /// Return an enumerator for all class definitions.
  ///
  /// Succeeds if:
  /// - The ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  /// 
  /// @param ppEnum [out,retval] Class Definition Enumeration
  ///
  HRESULT GetClassDefs (
    [out,retval] IEnumAAFClassDefs ** ppEnum);


  //***********************************************************
  //
  // CountClassDefs()
  //
  /// Writes the number of class definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  /// 
  /// @param pResult [out, retval] Total number of class definition objects
  ///
  HRESULT CountClassDefs (
    [out, retval] aafUInt32 *  pResult);

  //***********************************************************
  //
  // CreateForwardClassReference()
  //
  /// Return the class definition with the given id.
  /// 
  /// Succeeds if:
  /// - The classId does not represent an existing forward class reference
  ///   or a class definition that has already been successfully registered.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given ID is not recognized as a class definition ID.
  /// 
  /// @param classId [in, ref] Class Unique ID
  ///
  HRESULT CreateForwardClassReference (
    [in, ref] aafUID_constref  classId);

  //***********************************************************
  //
  // HasForwardClassReference()
  //
  /// Return kAAFTrue if the given class identification is a forward reference.
  /// 
  /// Succeeds if:
  /// - The pClassID pointer is valid.
  /// - The ppClassDef pointer is valid.
  /// - the ID is a recognized id for a class definition.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pClassID or ppClassDef arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given ID is not recognized as a class definition ID.
  /// 
  /// @param classId [in, ref] Class Unique ID
  /// @param pResult [out,retval] true if forward class reference; false if not a forward class reference
  ///
  HRESULT HasForwardClassReference (
    [in, ref] aafUID_constref  classId,
    [out,retval] aafBoolean_t *  pResult);

  //***********************************************************
  //
  // RegisterTypeDef()
  //
  /// Add the type definition object to the dictionary.
  /// 
  /// Succeeds if:
  /// - The pTypeDef pointer is valid.
  /// - the ID is not already been registered.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pClassDef arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given type has already been registered.
  /// 
  /// @param pTypeDef [in] Type Definition Object
  ///
  HRESULT RegisterTypeDef (
    [in] IAAFTypeDef * pTypeDef);


  //***********************************************************
  //
  // LookupTypeDef()
  //
  /// Return the type definition object with the given id.
  /// 
  /// Succeeds if:
  /// - The pTypeID pointer is valid.
  /// - The ppTypeDef pointer is valid.
  /// - the ID is a recognized id for a type definition.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pTypeID or ppTypeDef arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given ID is not recognized as a type definition ID.
  /// 
  /// @param typeId [in, ref] Type Unique ID
  /// @param ppTypeDef [out,retval] Type Definition Object
  ///
  HRESULT LookupTypeDef (
    [in, ref] aafUID_constref  typeId,
    [out,retval] IAAFTypeDef ** ppTypeDef);


  //***********************************************************
  //
  // GetTypeDefs()
  //
  /// Return an enumerator for all type definitions.
  ///
  /// Succeeds if:
  /// - The ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  /// 
  /// @param ppEnum [out,retval] Type Def Enumeration
  ///
  HRESULT GetTypeDefs (
    [out,retval] IEnumAAFTypeDefs ** ppEnum);


  //***********************************************************
  //
  // CountTypeDefs()
  //
  /// Writes the number of type definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  /// 
  /// @param pResult [out, retval] Total number of type definition objects
  ///
  HRESULT CountTypeDefs (
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // RegisterOpaqueTypeDef()
  //
  /// Add the opaquetype definition object to the dictionary.
  /// 
  /// Succeeds if:
  /// - The pTypeDef pointer is valid.
  /// - the definition is not already been registered with RegisterTypeDef.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTypeDef arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given type has already been registered.
  /// 
  /// @param pTypeDef [in] Type Definition Object
  ///
  HRESULT RegisterOpaqueTypeDef (
    [in] IAAFTypeDef * pTypeDef);


  //***********************************************************
  //
  // LookupOpaqueTypeDef()
  //
  /// Return the opaque type definition object with the given id.
  /// 
  /// Succeeds if:
  /// - The pTypeID pointer is valid.
  /// - The ppTypeDef pointer is valid.
  /// - the ID is a recognized id for an opaque type definition.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either typeId or ppTypeDef arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given ID is not recognized as a type definition ID.
  /// 
  /// @param typeId [in, ref] Type Unique ID
  /// @param ppTypeDef [out,retval] Type Definition Object
  ///
  HRESULT LookupOpaqueTypeDef (
    [in, ref] aafUID_constref  typeId,
    [out,retval] IAAFTypeDef ** ppTypeDef);


  //***********************************************************
  //
  // GetOpaqueTypeDefs()
  //
  /// Return an enumerator for all registered opaque type definitions.
  ///
  /// Succeeds if:
  /// - The ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  /// 
  /// @param ppEnum [out,retval] Type Def Enumeration
  ///
  HRESULT GetOpaqueTypeDefs (
    [out,retval] IEnumAAFTypeDefs ** ppEnum);


  //***********************************************************
  //
  // CountOpaqueTypeDefs()
  //
  /// Writes the number of opaque type definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  /// 
  /// @param pResult [out, retval] Total number of opaque type definition objects
  ///
  HRESULT CountOpaqueTypeDefs (
    [out, retval] aafUInt32 *  pResult);

  //***********************************************************
  //
  // RegisterKLVDataKey()
  //
  /// Add the definition for the given KLV key to the runtime dictionary.
  /// The pTypeDef will often be kAAFTypeID_UInt8Array,
  /// but may be something else.
  /// 
  /// Succeeds if:
  /// - The pTypeDef pointer is valid.
  /// - the definition is not already been registered with RegisterTypeDef.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTypeDef arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given type has already been registered.
  /// 
  /// @param pUID [in] Key to define
  /// @param pTypeDef [in] Type Definition Object
  ///
  HRESULT RegisterKLVDataKey (
    [in] aafUID_t  pUID,
    [in] IAAFTypeDef * pTypeDef);

  //***********************************************************
  //
  // RegisterDataDef()
  //
  /// Add the data definition object to the header's list of definitions.
  /// 
  /// @param pDataDef [in] Data Definition Object
  ///
  HRESULT RegisterDataDef (
    [in] IAAFDataDef * pDataDef);


  //***********************************************************
  //
  // LookupDataDef()
  //
  /// Return the data definition object with the given id.
  /// 
  /// @param dataDefinitionId [in, ref] Data Definition Unique ID
  /// @param ppDataDef [out,retval] Data Definition Object
  ///
  HRESULT LookupDataDef (
    [in, ref] aafUID_constref  dataDefinitionId,
    [out,retval] IAAFDataDef ** ppDataDef);


  //***********************************************************
  //
  // GetDataDefs()
  //
  /// Return an enumerator for aff data definitions.
  /// 
  /// @param ppEnum [out,retval] Definition Enumeration
  ///
  HRESULT GetDataDefs (
    [out,retval] IEnumAAFDataDefs ** ppEnum);


  //***********************************************************
  //
  // CountDataDefs()
  //
  /// Writes the number of data definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  /// 
  /// @param pResult [out, retval] Total number of data definition objects
  ///
  HRESULT CountDataDefs (
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // RegisterOperationDef()
  //
  /// Add the operation definition object to the header's list of definitions.
  /// 
  /// @param pOperationDef [in] Operation Definition Object
  ///
  HRESULT RegisterOperationDef (
    [in] IAAFOperationDef * pOperationDef);


  //***********************************************************
  //
  // LookupOperationDef()
  //
  /// Return the operation definition object with the given id.
  /// 
  /// @param operationId [in, ref] Operation Def Unique ID
  /// @param ppOperationDef [out,retval] Operation definition object
  ///
  HRESULT LookupOperationDef (
    [in, ref] aafUID_constref  operationId,
    [out,retval] IAAFOperationDef ** ppOperationDef);


  //***********************************************************
  //
  // GetOperationDefs()
  //
  /// Return an enumerator for all operation definitions.
  /// 
  /// @param ppEnum [out,retval] Definition Enumeration
  ///
  HRESULT GetOperationDefs (
    [out,retval] IEnumAAFOperationDefs ** ppEnum);


  //***********************************************************
  //
  // CountOperationDefs()
  //
  /// Writes the number of operation definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  /// 
  /// @param pResult [out, retval] Total number of operation definition objects
  ///
  HRESULT CountOperationDefs (
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // RegisterParameterDef()
  //
  /// Add the parameter definition object to the header's list of definitions.
  /// 
  /// @param pParmDef [in] Parameter Definition Object
  ///
  HRESULT RegisterParameterDef (
    [in] IAAFParameterDef * pParmDef);


  //***********************************************************
  //
  // LookupParameterDef()
  //
  /// Return the parameter definition object with the given id.
  /// 
  /// @param parameterId [in, ref] Parameter Unique ID
  /// @param ppParmDef [out,retval] Parameter definition object
  ///
  HRESULT LookupParameterDef (
    [in, ref] aafUID_constref  parameterId,
    [out,retval] IAAFParameterDef ** ppParmDef);


  //***********************************************************
  //
  // GetParameterDefs()
  //
  /// Return an enumerator for all parameter definitions.
  /// 
  /// @param ppEnum [out,retval] Definition Enumeration
  ///
  HRESULT GetParameterDefs (
    [out,retval] IEnumAAFParameterDefs ** ppEnum);


  //***********************************************************
  //
  // CountParameterDefs()
  //
  /// Writes the number of parameter definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  /// 
  /// @param pResult [out, retval] Total number of parameter definition objects
  ///
  HRESULT CountParameterDefs (
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // RegisterCodecDef()
  //
  /// Add the codec definition object to the header's list of definitions.
  /// 
  /// @param pParmDef [in] Codec Definition Object
  ///
  HRESULT RegisterCodecDef (
    [in] IAAFCodecDef * pParmDef);


  //***********************************************************
  //
  // LookupCodecDef()
  //
  /// Return the codec definition object with the given id.
  /// 
  /// @param parameterId [in, ref] Parameter Unique ID
  /// @param ppParmDef [out,retval] Codec definition object
  ///
  HRESULT LookupCodecDef (
    [in, ref] aafUID_constref  parameterId,
    [out,retval] IAAFCodecDef ** ppParmDef);


  //***********************************************************
  //
  // GetCodecDefs()
  //
  /// Return an enumerator for all codec definitions.
  /// 
  /// @param ppEnum [out,retval] Definition Enumeration
  ///
  HRESULT GetCodecDefs (
    [out,retval] IEnumAAFCodecDefs ** ppEnum);


  //***********************************************************
  //
  // CountCodecDefs()
  //
  /// Writes the number of codec definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  /// 
  /// @param pResult [out, retval] Total number of codec definition objects
  ///
  HRESULT CountCodecDefs (
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // RegisterContainerDef()
  //
  /// Add the container definition object to the header's list of definitions.
  /// 
  /// @param pParmDef [in] Container Definition Object
  ///
  HRESULT RegisterContainerDef (
    [in] IAAFContainerDef * pParmDef);


  //***********************************************************
  //
  // LookupContainerDef()
  //
  /// Return the container definition object with the given id.
  /// 
  /// @param parameterId [in, ref] Parameter Unique ID
  /// @param ppParmDef [out,retval] Container definition object
  ///
  HRESULT LookupContainerDef (
    [in, ref] aafUID_constref  parameterId,
    [out,retval] IAAFContainerDef ** ppParmDef);


  //***********************************************************
  //
  // GetContainerDefs()
  //
  /// Return an enumerator for all container definitions.
  /// 
  /// @param ppEnum [out,retval] Definition Enumeration
  ///
  HRESULT GetContainerDefs (
    [out,retval] IEnumAAFContainerDefs ** ppEnum);


  //***********************************************************
  //
  // CountContainerDefs()
  //
  /// Writes the number of container definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  /// 
  /// @param pResult [out, retval] Total number of container definition objects
  ///
  HRESULT CountContainerDefs (
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // RegisterInterpolationDef()
  //
  /// Add the Interpolation definition object to the header's list of definitions.
  /// 
  /// @param pInterpolationDef [in] Interpolation Definition Object
  ///
  HRESULT RegisterInterpolationDef (
    [in] IAAFInterpolationDef * pInterpolationDef);


  //***********************************************************
  //
  // LookupInterpolationDef()
  //
  /// Return the Interpolation definition object with the given id.
  /// 
  /// @param parameterId [in, ref] Parameter Unique ID
  /// @param ppInterpolationDef [out,retval] Interpolation definition object
  ///
  HRESULT LookupInterpolationDef (
    [in, ref] aafUID_constref  parameterId,
    [out,retval] IAAFInterpolationDef ** ppInterpolationDef);


  //***********************************************************
  //
  // GetInterpolationDefs()
  //
  /// Return an enumerator for aff Interpolation definitions.
  /// 
  /// @param ppEnum [out,retval] Definition Enumeration
  ///
  HRESULT GetInterpolationDefs (
    [out,retval] IEnumAAFInterpolationDefs ** ppEnum);


  //***********************************************************
  //
  // CountInterpolationDefs()
  //
  /// Writes the number of interpolation definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  /// 
  /// @param pResult [out, retval] Total number of interpolation definition objects
  ///
  HRESULT CountInterpolationDefs (
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // RegisterPluginDef()
  //
  /// Add the plugin definition object to the header's list of definitions.
  /// 
  /// @param pPlugDef [in] plugin definition Object
  ///
  HRESULT RegisterPluginDef (
    [in] IAAFPluginDef * pPlugDef);


  //***********************************************************
  //
  // LookupPluginDef()
  //
  /// Return the plugin descriptor object with the given id.
  /// 
  /// @param parameterId [in, ref] Parameter Unique ID
  /// @param ppPlugDef [out,retval] plugin descriptor object
  ///
  HRESULT LookupPluginDef (
    [in, ref] aafUID_constref  parameterId,
    [out,retval] IAAFPluginDef ** ppPlugDef);


  //***********************************************************
  //
  // GetPluginDefs()
  //
  /// Return an enumerator for all plugin descriptors.
  /// 
  /// @param ppEnum [out,retval] Definition Enumeration
  ///
  HRESULT GetPluginDefs (
    [out,retval] IEnumAAFPluginDefs ** ppEnum);


  //***********************************************************
  //
  // CountPluginDefs()
  //
  /// Writes the number of plugin definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  /// 
  /// @param pResult [out, retval] Total number of plugin definition objects
  ///
  HRESULT CountPluginDefs (
    [out, retval] aafUInt32 *  pResult);
























}


// ************************
//
// Interface IAAFDigitalImageDescriptor
//
// ************************
///
/// IAAFDigitalImageDescriptor is DEPRECATED.
/// Please use IAAFDigitalImageDescriptor2.
///
/// The IAAFDigitalImageDescriptor interface is implemented by objects
/// which describe video content data formatted either using RGBA or
/// luminance/chrominance formatting.
///
/// The geometry properties accessed by Set/GetStoredView(),
/// Set/GetSampledView(), and Set/GetDisplayView() describe the
/// dimensions and meaning of the stored pixels in the image.  The
/// geometry describes the pixels of an uncompressed image.
/// Consequently, the geometry properties are independent of the
/// compression and subsampling.
///
/// Three separate geometries - stored, sampled, and display views -
/// are used to define a set of different views on uncompressed digital
/// data. All views are constrained to rectangular regions, which means
/// that storage and sampling has to be rectangular.
/// 
/// The relationships among the views can be shown by the following
/// rectangles, representing areas of a video image:
/// 
/// +------------------+
/// |                  |
/// |   Stored View    |
/// |                  |           +--------------+
/// +------------------+ <-------- |              |
/// |                  |  Sample   | Analog Video |
/// |   Sampled View   |  Process  |    Source    |
/// |                  |           | Information  |
/// | +--------------+ |           |              |
/// | |              | |           |              |
/// | | Display View | |           |              |
/// | |              | |           |              |
/// | +--------------+ |           |              |
/// |                  |           |              |
/// +------------------+ <-------- |              |
///                                +--------------+
///
/// The stored view is the entire data region corresponding to a single
/// uncompressed frame or field of the image, and is defined by its
/// horizontal and vertical dimension properties. The stored view may
/// include data that is not derived from, and would not usually be
/// translated back to, analog data.
///
/// The sampled view is defined to be the rectangular dimensions in
/// pixels corresponding to the digital data derived from an analog or
/// digital source. These pixels reside within the rectangle defined by
/// the stored view. This would include the image and auxiliary
/// information included in the analog or digital source. For the
/// capture of video signals, the mapping of these views to the
/// original signal is determined by the VideoLineMap property.
///
/// The display view is the rectangular size in pixels corresponding to
/// the viewable area. These pixels contain image data suitable for
/// scaling, display, warping, and other image processing. The display
/// view offsets are relative to the stored view, not to the sampled
/// view.
///
/// Although typically the display view is a subset of the sampled
/// view, it is possible that the viewable area may not be a subset of
/// the sampled data. It may overlap or even encapsulate the sampled
/// data. For example, a subset of the input image might be centered in
/// a computer-generated blue screen for use in a chroma key effect. In
/// this case the viewable pixels on disk would contain more than the
/// sampled image.
///
/// Each of these data views will have a width and height value. Both
/// the sampled view and the display view also have offsets relative to
/// the top left corner of the stored view.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it through
///     this object's primary interface.  Note that
///     IAAFDigitalImageDescriptor is a primary interface for an
///     abstract class, so it is not appropriate for the
///     Initialize() method to exist in this interface.  The
///     Initialize() method is available through the concrete
///     object's primary interface.
///


///
/// Objects that implement IAAFDigitalImageDescriptor also implement the following interfaces:
///  - IAAFDigitalImageDescriptor2
///  - IAAFFileDescriptor
///  - IAAFFileDescriptor2
///  - IAAFEssenceDescriptor
///  - IAAFObject
[
    object,
    uuid(44861701-8AEA-11d2-813C-006097310172),
    helpstring("IAAFDigitalImageDescriptor Interface"),
    pointer_default(unique)
]

interface IAAFDigitalImageDescriptor : IUnknown
{

  //***********************************************************
  //
  // SetCompression()
  //
  /// Sets the kind of compression and format of compression
  /// information of the video essence data.  This property is
  /// optional.  If there is no compression, the property is omitted.
  /// 
  /// If this method fails the Data Definition property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param compression [in] Optional.
  ///
  HRESULT SetCompression (
    [in] aafUID_constref  compression);


  //***********************************************************
  //
  // GetCompression()
  //
  /// Gets the kind of compression and format of compression
  /// information of the video essence data.  This property is
  /// optional.
  ///
  /// Succeeds if all of the following are true:
  /// - the pCompression pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pCompression.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pComporession arg is NULL.
  /// 
  /// @param pCompression [out] Optional.
  ///
  HRESULT GetCompression (
    [out] aafUID_t *  pCompression);


  //***********************************************************
  //
  // SetStoredView()
  //
  /// Sets the dimension of the stored view.  Typically this includes
  /// leading blank video lines, any VITC lines, as well as the active
  /// picture area.
  /// 
  /// If this method fails the Stored Height and Stored Width
  /// properties will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param StoredHeight [in] Number of pixels in vertical dimension of stored view.
  /// @param StoredWidth [in] Number of pixels in horizontal dimension of stored view.
  ///
  HRESULT SetStoredView (
    [in] aafUInt32  StoredHeight,
    [in] aafUInt32  StoredWidth);


  //***********************************************************
  //
  // GetStoredView()
  //
  /// Gets the dimension of the stored view.  Typically this includes
  /// leading blank video lines, any VITC lines, as well as the active
  /// picture area.
  /// 
  /// Succeeds if all of the following are true:
  /// - pStoredHieght and pStoredWidth are valid pointers.
  /// 
  /// If this method fails, the *pStoredHieght and *pStoredWidth will
  /// not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pStoredHeight or pStoredWidth is NULL.
  /// 
  /// @param pStoredHeight [out] Number of pixels in vertical dimension of stored view.
  /// @param pStoredWidth [out] Number of pixels in horizontal dimension of stored view.
  ///
  HRESULT GetStoredView (
    [out] aafUInt32 *  pStoredHeight,
    [out] aafUInt32 *  pStoredWidth);


  //***********************************************************
  //
  // SetSampledView()
  //
  /// Sets the dimensions of sampled view.  Typically this includes
  /// any VITC lines as well as the active picture area, but excludes
  /// leading blank video lines.  The offset is specified relative to
  /// the rectangle specified by Set/GetStoredView().
  ///
  /// The following properties are optional:
  ///
  ///     SampledXOffset - The default value is 0.  Use a value of 0 to
  ///                      select the default.
  ///     SampledYOffset - The default value is 0.  Use a value of 0 to
  ///                      select the default.
  ///
  /// Succeeds if all of the following are true:
  /// - The given dimensions exist within the StoredView.
  /// 
  /// If this method fails, the SampledXOffset and SampledYOffset
  /// properties will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - The area specified by SampledHeight and SampledXOffset is
  ///     outside the StoredView, or the area specified by SampledWidth
  ///     and SampledYOffset is outside the StoredView.
  /// 
  /// @param SampledHeight [in] Number of pixels in vertical dimension of sampled view.
  /// @param SampledWidth [in] Number of pixels in horizontal dimension of sampled view.
  /// @param SampledXOffset [in] Number of pixels from top left corner of sampled view. Optional.
  /// @param SampledYOffset [in] Number of pixels from top left corner of sampled view. Optional.
  ///
  HRESULT SetSampledView (
    [in] aafUInt32  SampledHeight,
    [in] aafUInt32  SampledWidth,
    [in] aafInt32  SampledXOffset,
    [in] aafInt32  SampledYOffset);


  //***********************************************************
  //
  // GetSampledView()
  //
  /// Gets the dimensions of sampled view.  Typically this includes
  /// any VITC lines as well as the active picture area, but excludes
  /// leading blank video lines.  The offset is specified relative to
  /// the rectangle specified by Set/GetStoredView().
  ///
  /// Succeeds if all of the following are true:
  /// - pSampledHeight, pSampledWidth, pSampledXOffset and
  ///   pSampledYOffset are valid pointers
  /// 
  /// If any of the input parameters are NULL, the property will not
  /// be returned.
  ///
  /// If this method fails, *pSampledHeight, *pSampledWidth,
  /// *pSampledXOffset, and *pSampledYOffset will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - any of pSampledHeight, pSampledWidth, pSampledXOffset, or
  ///     pSampledYOffset are NULL.
  /// 
  /// @param pSampledHeight [out] Number of pixels in vertical dimension of sampled view.
  /// @param pSampledWidth [out] Number of pixels in horizontal dimension of sampled view.
  /// @param pSampledXOffset [out] Number of pixels from top left corner of sampled view. Optional.
  /// @param pSampledYOffset [out] Number of pixels from top left corner of sampled view. Optional.
  ///
  HRESULT GetSampledView (
    [out] aafUInt32 *  pSampledHeight,
    [out] aafUInt32 *  pSampledWidth,
    [out] aafInt32 *  pSampledXOffset,
    [out] aafInt32 *  pSampledYOffset);


  //***********************************************************
  //
  // SetDisplayView()
  //
  /// Sets the dimension of display view.  Typically this includes
  /// the active picture area, but excludes leading blank video lines
  /// and any VITC lines.  The offset is specified relative to the
  /// rectangle specified by Set/GetStoredView().
  /// 
  /// The following properties are optional:
  ///
  ///     DisplayHeight  - The default value is the storedHeight. Use
  ///                      storedHeight to select the default.
  ///     DisplayWidth   - The default value is the storedWidth. Use
  ///                      storedWidth to select the default.
  ///     DisplayXOffset - The default value is 0.  Use a value of 0 to
  ///                      select the default.
  ///     DisplayYOffset - The default value is 0.  Use a value of 0 to
  ///                      select the default.
  ///
  /// Note that The specified display rectangle may exist outside the
  /// SampledView or even the StoredView.
  ///
  /// If this method fails the DisplayHeight, DisplayWidth, DisplayXOffset and
  /// DisplayYOffset properties will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - The area specified by DisplayHeight and DisplayXOffset is
  ///     outside the StoredView, or the area specified by DisplayWidth
  ///     and DisplayYOffset is outside the StoredView.
  /// 
  /// @param DisplayHeight [in] Number of pixels in vertical dimension of display view. Optional.
  /// @param DisplayWidth [in] Number of pixels in horizontal dimension of display view. Optional.
  /// @param DisplayXOffset [in] Number of pixels from the top-left corner of the display view. Optional.
  /// @param DisplayYOffset [in] Number pixels from the top-left corner of the display view. Optional.
  ///
  HRESULT SetDisplayView (
    [in] aafUInt32  DisplayHeight,
    [in] aafUInt32  DisplayWidth,
    [in] aafInt32  DisplayXOffset,
    [in] aafInt32  DisplayYOffset);


  //***********************************************************
  //
  // GetDisplayView()
  //
  /// Gets the dimension of display view.  Typically this includes
  /// the active picture area, but excludes leading blank video lines
  /// and any VITC lines.  The offset is specified relative to the
  /// rectangle specified by Set/GetStoredView().
  /// 
  /// Note that The specified display rectangle may exist outside the
  /// SampledView or even the StoredView.
  ///
  /// Succeeds if all of the following are true:
  /// - pDisplayHeight, pDisplayWidth, pDisplayXOffset and
  ///   pDisplayYOffset are valid pointers.
  /// 
  /// If this method fails, *pDisplayHeight, *pDisplayWidth,
  /// *pDisplayXOffset, and *pDisplayYOffset will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - any of pDisplayHeight, pDisplayWidth, pDisplayXOffset, or
  ///     pDisplayYOffset are NULL.
  /// 
  /// @param pDisplayHeight [out] Number of pixels in vertical dimension of display view. Optional.
  /// @param pDisplayWidth [out] Number of pixels in horizontal dimension of display view. Optional.
  /// @param pDisplayXOffset [out] Number of pixels from the top-left corner of the display view. Optional.
  /// @param pDisplayYOffset [out] Number pixels from the top-left corner of the display view. Optional.
  ///
  HRESULT GetDisplayView (
    [out] aafUInt32 *  pDisplayHeight,
    [out] aafUInt32 *  pDisplayWidth,
    [out] aafInt32 *  pDisplayXOffset,
    [out] aafInt32 *  pDisplayYOffset);


  //***********************************************************
  //
  // SetFrameLayout()
  //
  /// Sets the frame layout.  The frame layout describes whether all
  /// data for a complete sample is in one frame or is split into more
  /// than/ one field.
  ///
  /// Values are:
  ///
  ///    kNoLayout       - Default; not a valid value.
  ///    kFullFrame      - Each frame contains a full sample in
  ///                      progressive scan lines.
  ///    kSeparateFields - Each sample consists of two fields, which
  ///                      when interlaced produce a full sample.
  ///    kOneField       - Each sample consists of two interlaced
  ///                      fields, but only one field is stored in the
  ///                      data stream.
  ///    kMixedFields    - Similar to FullFrame, except the two fields
  ///                      may have been sampled at different times.
  /// 
  /// Succeeds if all of the following are true:
  /// - frameLayout is a valid value
  /// 
  /// If this method fails, the Frame Layout property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - FrameLayout is not a valid value.
  /// 
  /// @param FrameLayout [in] layout of the frame
  ///
  HRESULT SetFrameLayout (
    [in] aafFrameLayout_t  FrameLayout);


  //***********************************************************
  //
  // GetFrameLayout()
  //
  /// Gets the frame layout.  The frame layout describes whether all
  /// data for a complete sample is in one frame or is split into more
  /// than one field.
  /// 
  /// Values are:
  ///
  ///    kNoLayout       - Default; not a valid value.
  ///    kFullFrame      - Each frame contains a full sample in
  ///                      progressive scan lines.
  ///    kSeparateFields - Each sample consists of two fields, which
  ///                      when interlaced produce a full sample.
  ///    kOneField       - Each sample consists of two interlaced
  ///                      fields, but only one field is stored in the
  ///                      data stream.
  ///    kMixedFields    - Similar to FullFrame, except the two fields
  ///                      may have been sampled at different times.
  /// 
  /// Succeeds if all of the following are true:
  /// - pFrameLayout is a valid pointer
  /// 
  /// If this method fails, *pFrameLayout will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFrameLayout is NULL.
  /// 
  /// @param pFrameLayout [out] layout of the frame
  ///
  HRESULT GetFrameLayout (
    [out] aafFrameLayout_t *  pFrameLayout);


  //***********************************************************
  //
  // SetVideoLineMap()
  //
  /// Sets the VideoLineMap property.  The video line map specifies the
  /// scan line in the analog source that corresponds to the beginning
  /// of each digitized field.  For single-field video, there is 1
  /// value in the array.  For interleaved video, there are 2 values
  /// in the array.
  /// 
  /// Succeeds if all of the following are true:
  /// - pVideoLineMap is a valid pointer
  /// 
  /// If this method fails, the Video Line Map property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pVideoLineMap is NULL.
  /// 
  /// @param numberElements [in] The number of elements in the array
  /// @param pVideoLineMap [in, size_is(numberElements)] Array to hold the Video Line Map information
  ///
  HRESULT SetVideoLineMap (
    [in] aafUInt32  numberElements,
    [in, size_is(numberElements)] aafInt32 *  pVideoLineMap);


  //***********************************************************
  //
  // GetVideoLineMap()
  //
  /// Gets the VideoLineMap property.  The video line map specifies the
  /// scan line in the analog source that corresponds to the beginning of each
  /// digitized field.  For single-field video, there is 1 value in the array.
  /// For interleaved video, there are 2 values in the array.
  ///
  /// The values are written to the array specified by pVideoLineMap,
  /// which is of size numberElements.  The required size may be found
  /// by calling GetVideoLineMapSize().
  /// 
  /// Succeeds if all of the following are true:
  /// - pVideoLineMap is a valid pointer.
  /// - numberElements indicates the array is large enough to hold the
  ///   data.
  /// 
  /// If this method fails, videoLineMap will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumberElements is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - numberElements indicates that the array is too small to hold
  ///     the data.
  /// 
  /// @param numberElements [in] The number of elements in the array
  /// @param pVideoLineMap [out, size_is(numberElements)] Array to hold the Video Line Map information
  ///
  HRESULT GetVideoLineMap (
    [in] aafUInt32  numberElements,
    [out, size_is(numberElements)] aafInt32 *  pVideoLineMap);


  //***********************************************************
  //
  // GetVideoLineMapSize()
  //
  /// Get the number of elements in the VideoLineMap property array.
  /// 
  /// Succeeds if all of the following are true:
  /// - pNumberElements is a valid pointer
  /// 
  /// If this method fails, *pNumberElements will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumberElements is NULL.
  /// 
  /// @param pNumberElements [out] The number of elements in the array
  ///
  HRESULT GetVideoLineMapSize (
    [out] aafUInt32 *  pNumberElements);


  //***********************************************************
  //
  // SetImageAspectRatio()
  //
  /// Sets the Image Aspect Ratio property.  This ratio describes the
  /// ratio between the horizontal size and the vertical size in the
  /// intended final image.
  ///
  /// Succeeds if all of the following are true:
  /// - 
  /// 
  /// If this method fails, the Image Access Ratio property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param ImageAspectRatio [in] Ratio between horizontal and vertical size
  ///
  HRESULT SetImageAspectRatio (
    [in] aafRational_t  ImageAspectRatio);


  //***********************************************************
  //
  // GetImageAspectRatio()
  //
  /// Gets the Image Aspect Ratio property.  This ratio describes the
  /// ratio between the horizontal size and the vertical size in the
  /// intended final image.
  ///
  /// Succeeds if all of the following are true:
  /// - pImageAspectRatio is a valid pointer
  /// 
  /// If this method fails, *pImageAspectRatio will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pImageAspectRatio is NULL.
  /// 
  /// @param pImageAspectRatio [out] Ratio between horizontal and vertical size
  ///
  HRESULT GetImageAspectRatio (
    [out] aafRational_t *  pImageAspectRatio);


  //***********************************************************
  //
  // SetAlphaTransparency()
  //
  /// Sets the AlphaTransparency property.  This property is optional.
  ///
  /// Valid values:
  ///	kMaxValueTransparent - means the maximum Alpha value is
  ///                           transparent
  ///    kMinValueTransparent - means the minimum Alpha value is
  ///                           transparent
  ///
  /// Succeeds if all of the following are true:
  /// - AlphaTransparency is a valid value.
  /// 
  /// If this method fails, the AlphaTransparency property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - AlphaTransparency is not a valid value.
  /// 
  /// @param AlphaTransparency [in] Alpha Transparency value.
  ///
  HRESULT SetAlphaTransparency (
    [in] aafAlphaTransparency_t  AlphaTransparency);


  //***********************************************************
  //
  // GetAlphaTransparency()
  //
  /// Gets the AlphaTransparency property.  This property is optional.
  ///
  /// Valid values:
  ///	kMaxValueTransparent - means the maximum Alpha value is transparent
  ///    kMinValueTransparent - means the minimum Alpha value is transparent
  ///
  /// Succeeds if all of the following are true:
  /// - pAlphaTransparency is a valid pointer
  /// 
  /// If this method fails, pAlphaTransparency not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pAlphaTransparency is NULL.
  /// 
  /// @param pAlphaTransparency [out] Alpha Transparency value.
  ///
  HRESULT GetAlphaTransparency (
    [out] aafAlphaTransparency_t *  pAlphaTransparency);


  //***********************************************************
  //
  // SetGamma()
  //
  /// Sets the TransferCharacteristic property.
  ///
  /// Succeeds if all of the following are true:
  /// - 
  /// 
  /// If this method fails, the Gamma property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param Gamma [in] Optional
  ///
  HRESULT SetGamma (
    [in] aafUID_t  Gamma);


  //***********************************************************
  //
  // GetGamma()
  //
  /// Gets the TransferCharacteristic property.
  ///
  /// Succeeds if all of the following are true:
  /// - pGamma is a valid pointer
  /// 
  /// If this method fails, pGamma will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pGamma is NULL.
  /// 
  /// @param pGamma [out] Optional.
  ///
  HRESULT GetGamma (
    [out] aafUID_t *  pGamma);


  //***********************************************************
  //
  // SetImageAlignmentFactor()
  //
  /// Sets the ImageAlignmentFactor property.  Specifies the alignment
  /// when storing the digital essence.  For example, a value of 16
  /// means that the image is stored on 16-byte boundaries.  The
  /// starting point for a field will always be a multiple of 16 bytes.
  /// If the field does not end on a 16-byte boundary, it is padded
  /// out to the next 16-byte boundary.
  ///
  /// Succeeds if all of the following are true:
  /// 
  /// If this method fails, the ImageAlignmentFactor property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param ImageAlignmentFactor [in] Optional.
  ///
  HRESULT SetImageAlignmentFactor (
    [in] aafUInt32  ImageAlignmentFactor);


  //***********************************************************
  //
  // GetImageAlignmentFactor()
  //
  /// Gets the ImageAlignmentFactor property.  Specifies the alignment when
  /// storing the digital essence.  For example, a value of 16 means that the image
  /// is stored on 16-byte boundaries.  The starting point for a field will always
  /// be a multiple of 16 bytes.  If the field does not end on a 16-byte boundary,
  /// it is padded out to the next 16-byte boundary.
  ///
  ///
  /// Succeeds if all of the following are true:
  /// - pImageAlignmentFactor is a valid pointer
  /// 
  /// If this method fails, pImageAlignmentFactor will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pImageAlignmentFactor is NULL.
  /// 
  /// @param pImageAlignmentFactor [out] Optional.
  ///
  HRESULT GetImageAlignmentFactor (
    [out] aafUInt32 *  pImageAlignmentFactor);






















}


// ************************
//
// Interface IAAFEdgecode
//
// ************************
 
///
/// Objects that implement IAAFEdgecode also implement the following interfaces:
///  - IAAFSegment
///  - IAAFComponent
///  - IAAFComponent2
///  - IAAFObject
[
    object,
    uuid(38e6f8a4-2a2c-11d2-8411-00600832acb8),
    helpstring("IAAFEdgecode Interface"),
    pointer_default(unique)
]
interface IAAFEdgecode : IUnknown
{


  //***********************************************************
  //
  // Initialize()
  //
  /// This function creates a new edgecode clip with the
  /// given property values.  The edgecode value is represented with an
  /// aafEdgecode_t struct consisting of startFrame, filmKind, and
  /// codeFormat.
  /// 
  /// @param length   [in] Length Property Value
  /// @param edgecode [in] Edgecode Value
  ///
  HRESULT Initialize (
    [in] aafLength_t    length  ,
    [in] aafEdgecode_t  edgecode);

  //***********************************************************
  //
  // GetEdgecode()
  //
  /// This set of functions returns the required property values
  /// for the object identified by XXX.
  /// 
  /// @param edgecode [out] Edgecode
  ///
  HRESULT GetEdgecode (
    [out] aafEdgecode_t *  edgecode);

}



// ************************
//
// Interface IAAFEssenceAccess
//
// ************************

///
/// AAFEssenceAccess is an interace which provides streaming access
/// over multiple channels of essence data.  This interface deals with
/// essence data which is in an uncompressed form, and handles
/// compression or decompression of the data if required.  You may need
/// to QueryInterface for an AAFEssenceAccess interface in order to do
/// non-read write operations such as seek.
///
/// You should call the CreateMultiEssence or OpenMultiEssence calls on
/// AAFMasterMob in order to get an interface pointer to
/// AAFEssenceAccess, as there is no public create or open method in
/// the interface.
///
/// A number of errors can be returned from most method calls,  These
/// are:
///    AAFRESULT_NOMEMORY   -- The system ran out of memory processing
///                              the method.
///    AAFRESULT_NULL_PARAM -- A NULL parameter was passed in which
///                              was required.
///
/// Objects that implement IAAFEssenceAccess also implement the following interfaces:
///  - IAAFEssenceMultiAccess
[
    object,
    uuid(aed97eb0-2bc8-11D2-bfaa-006097116212),
    helpstring("IAAFEssenceAccess Interface"),
    pointer_default(unique)
]
interface IAAFEssenceAccess : IUnknown
{


  //***********************************************************
  //
  // SetEssenceCodecFlavour()
  //
  /// Sets which flavour of the codec ID is to be used.
  ///
  /// An example of a flavour would be a number of standard starting
  /// JPEG tables.
  /// 
  /// @param flavour [in, ref] The particular flavour
  ///
  HRESULT SetEssenceCodecFlavour (
    [in, ref] aafUID_constref  flavour);


  //***********************************************************
  //
  // WriteSamples()
  //
  /// Writes data to the given essence stream.
  ///
  /// A single video frame is ONE sample.
  ///
  /// Buflen must be large enough to hold the total sample size.
  ///
  /// Possible Errors:
  ///   AAFRESULT_SINGLE_CHANNEL_OP -- Tried to write to an interleaved
  ///                                  stream.
  ///   AAFRESULT_BADDATAADDRESS    -- The buffer must not be a NULL
  ///                                  pointer.
  /// 
  /// @param nSamples [in] write this many samples
  /// @param buflen [in] from a buffer of this size
  /// @param buffer [in,size_is(buflen)] from a buffer
  /// @param samplesWritten [out, ref] The number of samples actually written
  /// @param bytesWritten [out, ref] The number of bytes actually written
  ///
  HRESULT WriteSamples (
    [in] aafUInt32  nSamples,
    [in] aafUInt32  buflen,
    [in,size_is(buflen)] aafDataBuffer_t  buffer,
    [out, ref] aafUInt32 *  samplesWritten,
    [out, ref] aafUInt32 *  bytesWritten);


  //***********************************************************
  //
  // GetLargestSampleSize()
  //
  /// Returns the size in bytes of the largest sample for a given
  /// essence type.
  ///
  /// For uncompressed data, or the output of the software codec, the
  /// sample size will propably be a constant.
  ///
  /// The essence type parameter exists to support codecs with multiple
  /// interleaved essence types.
  /// 
  /// @param pDataDef [in] for this essence type
  /// @param maxSize [out] the largest sample size
  ///
  HRESULT GetLargestSampleSize (
    [in] IAAFDataDef * pDataDef,
    [out] aafLength_t*  maxSize);


  //***********************************************************
  //
  // GetIndexedSampleSize()
  //
  /// Returns the size in bytes of the given sample for a given essence
  /// type.
  ///
  /// For uncompressed data, or the output of the software codec, the
  /// sample size will propably be a constant.
  ///
  /// The essence type parameter exists to support codecs with multiple
  /// interleaved essence types.
  /// 
  /// Possible Errors:
  ///   AAFRESULT_NULL_PARAM      -- A return parameter was NULL.
  ///   AAFRESULT_BADSAMPLEOFFSET -- The supplied sample offset is out
  ///                                of range.
  /// 
  /// @param pDataDef [in] and this essence type
  /// @param frameNum [in] for this [0-based] sample frame number
  /// @param frameSize [out] How big is the sample frame?
  ///
  HRESULT GetIndexedSampleSize (
    [in] IAAFDataDef * pDataDef,
    [in] aafPosition_t  frameNum,
    [out] aafLength_t*  frameSize);


  //***********************************************************
  //
  // SetTransformParameters()
  //
  /// Sets a series of format objects which will be used to describe
  /// the in-memory format.
  ///
  /// This is the format expected on writes and produced on reads.
  ///
  /// On writes, the data will be written in this format, except
  /// where a software codec may be used.  On reads, the data will be
  /// translated to this format.
  ///
  /// The order of the parameters does matter, as transformations will
  /// be applied in that order to get from the on-disk format to the
  /// in-memory format.
  /// 
  /// @param op [in] A set of transforms to apply to the essence if required
  ///
  HRESULT SetTransformParameters (
    [in] IAAFEssenceFormat * op);
	 

  //***********************************************************
  //
  // CountSamples()
  //
  /// Returns the number of samples of the given essence type on the
  /// given essence stream.
  /// 
  /// A video sample is one frame.
  /// 
  /// @param pDataDef [in] For this essence dataDef
  /// @param result [out] find out how many samples are present
  ///
  HRESULT CountSamples (
    [in] IAAFDataDef * pDataDef,
    [out] aafLength_t *  result);


  //***********************************************************
  //
  // ReadSamples()
  //
  /// Read a given number of samples from an opened essence stream.
  ///
  /// This call will only return a single channel of essence from an
  /// interleaved stream.
  ///
  /// A video sample is a frame.
  ///
  /// Buflen is in bytes, and should be large enough to hold the
  /// samples after the requested transforms have been applied.
  ///
  /// Possible Errors:
  ///   AAFRESULT_END_OF_DATA -- Hit the end of the essence (like
  ///                            EOF) while reading.
  ///   AAFRESULT_SMALLBUF    -- Buffer too small for samples.
  /// 
  /// @param nSamples [in] Read this many samples
  /// @param buflen [in] into a buffer of this size
  /// @param buffer [out, size_is(buflen),length_is(*bytesRead)] The transfer buffer
  /// @param samplesRead [out, ref] The number of samples actually read
  /// @param bytesRead [out, ref] The number of bytes actually read
  ///
  HRESULT ReadSamples (
    [in] aafUInt32  nSamples,
    [in] aafUInt32  buflen,
    [out, size_is(buflen),length_is(*bytesRead)] aafDataBuffer_t  buffer,
    [out, ref] aafUInt32 *  samplesRead,
    [out, ref] aafUInt32 *  bytesRead);


  //***********************************************************
  //
  // Seek()
  //
  /// The seek function for essence.
  ///
  /// Useful only on reading, you can't seek aound while writing
  /// essence.
  ///
  /// An audio frame is one sample across all channels.
  ///
  /// Possible Errors:
  ///   AAFRESULT_BADSAMPLEOFFSET -- Hit the end of the essence
  ///                                (like EOF) while reading.
  /// 
  /// @param sampleFrameNum [in] A 0-based offset in units of the sample rate to seek to.
  ///
  HRESULT Seek (
    [in] aafPosition_t  sampleFrameNum);


  //***********************************************************
  //
  // GetFileFormat()
  //
  /// Given an AAFEssenceFormat, read the essence parameters inside
  /// and set the values from the file format.
  /// 
  /// @param opsTemplate [in] An AAFEssenceFormat with parameter codes set but no values
  /// @param opsResult [out] Another AAFEssenceFormat with values set
  ///
  HRESULT GetFileFormat (
    [in] IAAFEssenceFormat * opsTemplate,
    [out] IAAFEssenceFormat ** opsResult);


  //***********************************************************
  //
  // GetFileFormatParameterList()
  //
  /// Returns an AAFEssenceFormat containing a list of all parameters
  /// supported by the current codec.
  /// 
  /// @param ops [out] An ampty AAFEssenceFormat object
  ///
  HRESULT GetFileFormatParameterList (
    [out] IAAFEssenceFormat ** ops);


  //***********************************************************
  //
  // GetEmptyFileFormat()
  //
  /// Returns an empty AAFEssenceFormat object.  This is the factory
  /// method for AAFEssenceFormat.
  /// 
  /// @param ops [out] An ampty AAFEssenceFormat object
  ///
  HRESULT GetEmptyFileFormat (
    [out] IAAFEssenceFormat ** ops);


  //***********************************************************
  //
  // PutFileFormat()
  //
  /// Given an AAFEssenceFormat, read the essence parameters inside
  /// and change the file format.
  /// 
  /// @param ops [in] An AAFEssenceFormat with one or more parameter/value pairs
  ///
  HRESULT PutFileFormat (
    [in] IAAFEssenceFormat * ops);


  //***********************************************************
  //
  // GetCodecName()
  //
  /// Returns the full name of the given codec expanded for human
  /// consumption.
  ///
  /// No other call uses this name, so it may be fully
  /// descriptive, esp. of limitations.
  ///
  /// The name will be truncated to fit within "buflen" bytes.
  ///
  /// Possible Errors:
  ///   AAFRESULT_CODEC_INVALID - The given codec ID is not loaded.
  ///   AAFRESULT_SMALLBUF      - The buffer is not large enough to
  ///                             hold the data.
  /// 
  /// @param namelen [in] The size of the name buffer to be filled
  /// @param name [out,size_is(namelen)] The buffer to fill
  ///
  HRESULT GetCodecName (
    [in] aafUInt32  namelen,
    [out,size_is(namelen)] aafCharacter *  name);


  //***********************************************************
  //
  // GetCodecID()
  //
  /// Returns the codec ID being used to handle the specified essence.
  ///
  /// This will be required in order to send private data to the
  /// codec.
  ///
  /// The name will be truncated to fit within "buflen" bytes.
  /// 
  /// @param codecID [out] Returns the current codec ID
  ///
  HRESULT GetCodecID (
    [out] aafCodecID_t *  codecID);


  //***********************************************************
  //
  // CompleteWrite()
  //
  /// Handle any format related writing at the end and adjust mob
  /// lengths.  Must be called before releasing a write essence
  /// access.
  ///
  /// Possible Errors:
  ///   AAFRESULT_STREAM_FULL
  ///   - The essence can not be written because of a fault such as a
  ///     disk full error in the underlying operating system.
  /// 
  HRESULT CompleteWrite ();





}


// ************************
//
// Interface IAAFEssenceData
//
// ************************

///
///
/// This interface is DEPRECATED, please use IAAFEssenceData2.
///
/// The IAAFEssenceData interface is used to modify AAFEssenceData
/// objects, which contain the actual essence data (ex. WAVE) when
/// it is contained within an AAF file.  Normally the client
/// application would access the essence through the IAAFEssenceAccess
/// interface, which handles the work of finding and (de)compressing
/// the data.  However, in rare cases direct access to the data is
/// required, so this interface is exposed.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
///
/// AAFRESULT_NULL_PARAM
///   - One of the passed in pointers is NULL.
///
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
///
/// Objects that implement IAAFEssenceData also implement the following interfaces:
///  - IAAFObject
[
    object,
    uuid(6a33f4e2-8ed6-11d2-bf9d-00104bc9156d),
    helpstring("IAAFEssenceData Interface"),
    pointer_default(unique)
]
interface IAAFEssenceData : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Associates a weak reference to the given file mob with the
  /// essence data.
  ///
  /// Succeeds if all of the following are true:
  /// - the pFileMob pointer is valid and points to 
  /// a file mob (contains a file descriptor).
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFileMob is null.
  /// 
  /// @param pFileMob [in] reference to a file mob
  ///
  HRESULT Initialize (
    [in] IAAFSourceMob * pFileMob);

  //***********************************************************
  //
  // Write()
  //
  /// Write pre-interleaved data to a essence stream.
  /// 
  /// @param bytes [in] write this many bytes
  /// @param buffer [out, size_is(bytes)] here is the buffer
  /// @param bytesWritten [out,ref] 
  ///
  HRESULT Write (
    [in] aafUInt32  bytes,
    [out, size_is(bytes)] aafDataBuffer_t  buffer,
    [out,ref] aafUInt32 *  bytesWritten);


  //***********************************************************
  //
  // Read()
  //
  /// Read pre-interleaved data from a essence stream.
  /// 
  /// @param bytes [in] read this many bytes
  /// @param buffer [out, size_is(bytes), length_is(*bytesRead)] here is the buffer
  /// @param bytesRead [out,ref] 
  ///
  HRESULT Read (
    [in] aafUInt32  bytes,
    [out, size_is(bytes), length_is(*bytesRead)] aafDataBuffer_t  buffer,
    [out,ref] aafUInt32 *  bytesRead);


  //***********************************************************
  //
  // SetPosition()
  //
  /// Seek to absolute position within the essence data.
  /// 
  /// @param offset [in] offset from beginning of essence
  ///
  HRESULT SetPosition (
    [in] aafPosition_t  offset);


  //***********************************************************
  //
  // GetPosition()
  //
  /// Get the absolute position within the essence data.
  /// 
  /// @param pOffset [out] offset from beginning of essence
  ///
  HRESULT GetPosition (
    [out] aafPosition_t*  pOffset);


  //***********************************************************
  //
  // GetSize()
  //
  /// Return the total size of the essence data.
  /// 
  /// @param pSize  [out] size of essence data
  ///
  HRESULT GetSize (
    [out] aafLength_t *  pSize );


  //***********************************************************
  //
  // SetFileMob()
  //
  /// Associates a weak reference to the given file mob with the
  /// essence data.
  ///
  /// Succeeds if all of the following are true:
  /// - the pFileMob pointer is valid and points to 
  /// a file mob (contains a file descriptor).
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFileMob is null.
  /// 
  /// @param pFileMob [in] reference to a file mob
  ///
  HRESULT SetFileMob (
    [in] IAAFSourceMob * pFileMob);


  //***********************************************************
  //
  // GetFileMob()
  //
  /// Associates a weak reference to the given file mob with the
  /// essence data.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppFileMob pointer is valid and a weak
  /// reference to the associated file mob can be
  /// resolved.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppFileMob is null.
  /// 
  /// @param ppFileMob [in] reference to a file mob
  ///
  HRESULT GetFileMob (
    [in] IAAFSourceMob ** ppFileMob);


  //***********************************************************
  //
  // GetFileMobID()
  //
  /// Return the mob id used to find the file mob associated with this
  /// essence.  The file mob must exist in the same file as this
  /// essence data.
  /// 
  /// @param pFileMobID [out] the file mob id associated with essence
  ///
  HRESULT GetFileMobID (
    [out] aafMobID_t *  pFileMobID);







}


// ************************
//
// Interface IAAFEssenceDescriptor
//
// ************************
///
/// The IAAFEssenceDescriptor interface is implemented by objects which
/// describe the format of the content data associated with a File
/// Source mob or of the media associated with a Physical Source mob.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it through
///     this object's primary interface.  Note that
///     IAAFEssenceDescriptor is a primary interface for an abstract
///     class, so it is not appropriate for the Initialize() method
///     to exist in this interface.  The Initialize() method is
///     available through the concrete object's primary interface.
///
///
/// Objects that implement IAAFEssenceDescriptor also implement the following interfaces:
///  - IAAFObject
[
    object,
    uuid(94659783-2a3c-11D2-bfA4-006097116212),
    helpstring("IAAFEssenceDescriptor Interface"),
    pointer_default(unique)
]
interface IAAFEssenceDescriptor : IUnknown
{

  //***********************************************************
  //
  // CountLocators()
  //
  /// Return the number of locators attached to this essence
  /// descriptor.  The number of locators may be zero if the essence is
  /// in the current file.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pCount pointer is valid.
  /// 
  /// If this method fails nothing is written to *pCount.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCount is null.
  /// 
  /// @param pResult [out] Returns the number of locators
  ///
  HRESULT CountLocators (
    [out] aafUInt32 *  pResult);


  //***********************************************************
  //
  // AppendLocator()
  //
  /// Append another locator to this essence descriptor.  Use this
  /// function to add a locator to be scanned last when searching for
  /// the essence (a secondary location for the essence).
  /// 
  /// Succeeds if all of the following are true:
  /// - the pLocator pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLocator is null.
  /// 
  /// @param pLocator [in] Locator to append
  ///
  HRESULT AppendLocator (
    [in] IAAFLocator * pLocator);


  //***********************************************************
  //
  // PrependLocator()
  //
  /// Prepend another locator to this essence descriptor.  Use this
  /// function to add a locator to be scanned first when searching for
  /// the essence (a new primary location for the essence).
  /// 
  /// Succeeds if all of the following are true:
  /// - the pLocator pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLocator is null.
  /// 
  /// @param pLocator [in] Locator to append
  ///
  HRESULT PrependLocator (
    [in] IAAFLocator * pLocator);


  //***********************************************************
  //
  // InsertLocatorAt()
  //
  /// Inserts the given locator at the given index.  Locators already
  /// existing at the given and higher indices will be moved to the
  /// next higher index to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pLocator pointer is valid.
  /// - index is less than or equal to the value returned by
  ///   CountLocators().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLocator is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than the value returned by
  ///     CountLocators().
  /// 
  /// @param index [in] index at which locator is to be inserted
  /// @param pLocator [in] Locator to append
  ///
  HRESULT InsertLocatorAt (
    [in] aafUInt32  index,
    [in] IAAFLocator * pLocator);


  //***********************************************************
  //
  // GetLocatorAt()
  //
  /// Retrieves the locator at the given index.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pLocator pointer is valid.
  /// - index is less than the value returned by CountLocators().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLocator is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than or equal to the value returned by
  ///     CountLocators().
  /// 
  /// @param index [in] index of locator to retrieve
  /// @param ppLocator [out, retval] returned locator
  ///
  HRESULT GetLocatorAt (
    [in] aafUInt32  index,
    [out, retval] IAAFLocator ** ppLocator);


  //***********************************************************
  //
  // RemoveLocatorAt()
  //
  /// Removes the locator at the given index.  Locators already
  /// existing at indices higher than the given index will be moved to
  /// the next lower index to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - index is less than the value returned by CountLocators().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than or equal to the value returned by
  ///     CountLocators().
  /// 
  /// @param index [in] index of locator to remove
  ///
  HRESULT RemoveLocatorAt (
    [in] aafUInt32  index);


  //***********************************************************
  //
  // GetLocators()
  //
  /// Returns an enumerator to the locators.  The number of locators
  /// may be zero if the essence is in the current file.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  /// 
  /// @param ppEnum [out] An enumerator to the locators on this essence descriptor
  ///
  HRESULT GetLocators (
    [out] IEnumAAFLocators ** ppEnum);
}



// ************************
//
// Interface IAAFEssenceFormat
//
// ************************
///
/// The AAFEssenceFormat class represents a collection of parameters
/// (such as image height/width, audio sample width) which describes
/// a piece of essence.  Each parameter is specified by an AUID, and
/// contains a variable length piece of data.
///
/// When creating a piece of essence, you should call
/// AddFormatSpecifier() for each required or known parameter, and
/// the codec will supply defaults for other optional parameters.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it through
///     this object's primary interface.
///


[
    object,
    uuid(34C2DC82-904C-11d2-8088-006008143E6F),
    helpstring("IAAFEssenceFormat Interface"),
    pointer_default(unique)
]
interface IAAFEssenceFormat : IUnknown
{

  //***********************************************************
  //
  // AddFormatSpecifier()
  //
  /// Appends a format specifier to the AAFEssenceFormat.  If an
  /// essenceFormatCode has already been added, then this call
  /// replaces the value, otherwise the value is appended.
  ///
  /// The value data is passed in as a void * through the "value"
  /// argument.  The size of the value must be passed through the
  /// valueSize argument.
  /// 
  /// @param essenceFormatCode [in] From aaddefuids.h
  /// @param valueSize [in] Size of preallocated buffer
  /// @param value [in, size_is(valueSize)] Value data
  ///
  HRESULT AddFormatSpecifier (
    [in] aafUID_constref  essenceFormatCode,
    [in] aafInt32  valueSize,
    [in, size_is(valueSize)] aafDataBuffer_t  value);


  //***********************************************************
  //
  // GetFormatSpecifier()
  //
  /// The data value is returned in a preallocated buffer of size
  /// valueSize.
  ///
  /// The actual number of bytes read is returned in bytesRead.  If the
  /// buffer is not big enough to return the entire  value, an error
  /// is returned.
  /// 
  /// @param essenceFormatCode [in] From aaddefuids.h
  /// @param valueSize [in] Size of preallocated buffer
  /// @param value [out, size_is(valueSize),length_is(*bytesRead)] Preallocated buffer to hold value
  /// @param bytesRead [out] Number of actual bytes read
  ///
  HRESULT GetFormatSpecifier (
    [in] aafUID_constref  essenceFormatCode,
    [in] aafInt32  valueSize,
    [out, size_is(valueSize),length_is(*bytesRead)] aafDataBuffer_t  value,
    [out] aafInt32*  bytesRead);


  //***********************************************************
  //
  // NumFormatSpecifiers()
  //
  /// The data value is returned in a preallocated buffer of size
  /// valueSize.
  /// 
  /// @param numSpecifiers [out] The number of specifiers present.
  ///
  HRESULT NumFormatSpecifiers (
    [out] aafInt32*  numSpecifiers);


  //***********************************************************
  //
  // GetIndexedFormatSpecifier()
  //
  /// The data value is returned in a preallocated buffer of size
  /// valueSize.
  /// 
  /// @param index [in] 0-based index
  /// @param essenceFormatCode [out] From aaddefuids.h
  /// @param valueSize [in] Size of preallocated buffer
  /// @param value [out, size_is(valueSize),length_is(*bytesRead)] Preallocated buffer to hold value
  /// @param bytesRead [out] Number of actual bytes read
  ///
  HRESULT GetIndexedFormatSpecifier (
    [in] aafInt32  index,
    [out] aafUID_t*  essenceFormatCode,
    [in] aafInt32  valueSize,
    [out, size_is(valueSize),length_is(*bytesRead)] aafDataBuffer_t  value,
    [out] aafInt32*  bytesRead);
}



// ************************
//
// Interface IAAFEssenceGroup
//
// ************************
///
/// This interface provides access to the IAAFEssenceGroup interface,
/// which contains multiple representations of the same media within a
/// MasterMob.  The IAAFEssenceAccess methods allow specifying
/// parameters such as "best quality", or "lowest frame rate" for and
/// follow the correct path through the EssenceGroup in order to find
/// the media which matches the criteria.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
///
/// Objects that implement IAAFEssenceGroup also implement the following interfaces:
///  - IAAFSegment
///  - IAAFComponent
///  - IAAFComponent2
///  - IAAFObject
[
    object,
    uuid(e58a8567-2a3e-11D2-bfa4-006097116212),
    helpstring("IAAFEssenceGroup Interface"),
    pointer_default(unique)
]
interface IAAFEssenceGroup : IUnknown
{

  //***********************************************************
  //
  // SetStillFrame()
  //
  /// This method sets the still frame property on a essence group to
  /// be the source clip passed as the stillFrame argument.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pStillFrame is null.
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param pStillFrame [in] Still Frame source clip 
  ///
  HRESULT SetStillFrame (
    [in] IAAFSourceClip * pStillFrame);
    

  //***********************************************************
  //
  // GetStillFrame()
  //
  /// Gets the still frame property on a essence group.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppStillFrame is null.
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param ppStillFrame [out] Still Frame source clip 
  ///
  HRESULT GetStillFrame (
    [out] IAAFSourceClip ** ppStillFrame);


  //***********************************************************
  //
  // AppendChoice()
  //
  /// Append another choice to this AAFEssenceGroup.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pChoice pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pChoice is null.
  /// 
  /// @param pChoice [in] Source clip to add as a choice 
  ///
  HRESULT AppendChoice (
    [in] IAAFSegment * pChoice);


  //***********************************************************
  //
  // PrependChoice()
  //
  /// Prepend another choice to this AAFEssenceGroup.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pChoice pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pChoice is null.
  /// 
  /// @param pChoice [in] Source clip to add as a choice
  ///
  HRESULT PrependChoice (
    [in] IAAFSegment * pChoice);


  //***********************************************************
  //
  // InsertChoiceAt()
  //
  /// Insert another choice to this AAFEssenceGroup at the given
  /// index.  Choices already existing at the given and higher indices
  /// will be moved up by one index to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pChoice pointer is valid.
  /// - index is less than or equal to the value returned by
  ///   CountChoices().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pChoice is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than the value returned by
  ///     CountChoices().
  /// 
  /// @param index [in] place to insert new choice
  /// @param pChoice [in] Source clip to add as a choice
  ///
  HRESULT InsertChoiceAt (
    [in] aafUInt32  index,
    [in] IAAFSegment * pChoice);


  //***********************************************************
  //
  // CountChoices()
  //
  /// Returns the number of choices attached to this AAFEssenceGroup.,
  /// excepting the still frame.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pCount pointer is valid.
  /// 
  /// If this method fails nothing is written to *pCount.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCount is null.
  /// 
  /// @param pCount [out] The number of representations contained within.
  ///
  HRESULT CountChoices (
    [out] aafUInt32*   pCount);


  //***********************************************************
  //
  // GetChoiceAt()
  //
  /// Given an index, returns the corresponding source clip choice.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppChoice pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppChoice.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_MISSING_INDEX
  ///   - The given index value is not present.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppChoice arg is NULL.
  /// 
  /// @param index [in] The 0-based index into the array
  /// @param ppChoice [out] The representation at that index
  ///
  HRESULT GetChoiceAt (
    [in] aafUInt32  index,
    [out] IAAFSegment  ** ppChoice);


  //***********************************************************
  //
  // RemoveChoiceAt()
  //
  /// Removes the choice at the given index.  Items already existing at
  /// higher indices will be moved down by one index to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppChoice pointer is valid.
  /// - index is less than the value returned by CountChoices().
  /// 
  /// If this method fails no state will be changed.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppChoice arg is NULL.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than or equal to the value returned by
  ///     CountChoices().
  /// 
  /// @param index [in] The 0-based index into the array
  ///
  HRESULT RemoveChoiceAt (
    [in] aafUInt32  index);
}



// ************************
//
// Interface IAAFEvent
//
// ************************

///
/// The IAAFEvent interface is implemented by objects which represent
/// a text comment, a trigger, or an area in the image that has an
/// associated interactive action.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it through
///     this object's primary interface.  Note that IAAFMobSlot is a
///     primary interface for an abstract class, so it is not
///     appropriate for the Initialize() method to exist in this
///     interface.  The Initialize() method is available through the
///     concrete object's primary interface.
/// 
///
///
/// Objects that implement IAAFEvent also implement the following interfaces:
///  - IAAFSegment
///  - IAAFComponent
///  - IAAFComponent2
///  - IAAFObject
[
    object,
    uuid(e684d790-b935-11d2-bf9d-00104bc9156d),
    helpstring("IAAFEvent Interface"),
    pointer_default(unique)
]
interface IAAFEvent : IUnknown
{


  //***********************************************************
  //
  // GetPosition()
  //
  /// This method will return the Position of this event.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pPosition pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPosition arg is NULL.
  /// 
  /// @param pPosition [out,retval] Position property value
  ///
  HRESULT GetPosition (
    [out,retval] aafPosition_t *  pPosition);

  //***********************************************************
  //
  // SetPosition()
  //
  /// This method will set the Position of this event.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.).
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param Position [in] Position property value
  ///
  HRESULT SetPosition (
    [in] aafPosition_t  Position);


  //***********************************************************
  //
  // SetComment()
  //
  /// Sets specifies the purpose of the event.
  ///
  /// Set the Comment property to the value specified in
  /// pComment.  A copy is made of the data so the caller
  /// retains ownership of the *pComment buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pComment pointer is valid.
  /// 
  /// If this method fails the Comment property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pComment arg is NULL.
  /// 
  /// @param pComment [in, string] buffer from which Comment is to be read
  ///
  HRESULT SetComment (
    [in, string] aafCharacter_constptr  pComment);


  //***********************************************************
  //
  // GetComment()
  //
  /// Gets specifies the purpose of the event.
  /// 
  /// Writes the Comment property, with a trailing null
  /// character, into the pComment buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the Comment property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetCommentBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pComment.
  /// 
  /// Succeeds if:
  /// - The pComment pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   Comment.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pComment arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold Comment.
  /// 
  /// @param pComment [out, string, size_is(bufSize)] buffer into which Comment is to be written
  /// @param bufSize [in] size of *pComment buffer in bytes
  ///
  HRESULT GetComment (
    [out, string, size_is(bufSize)] aafCharacter *  pComment,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetCommentBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetComment().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetCommentBufLen (
    [out] aafUInt32 *  pBufSize);

}



// ************************
//
// Interface IAAFEventMobSlot
//
// ************************

///
/// IAAFEventMobSlot is DEPRECATED, please use IAAFEventMobSlot2.
///
/// An EventMobSlot, as all MobSlots, has a concrete segment, which
/// is a concrete Event or a Sequence of ordered Events. If it has a
/// sequence of events, all events shall have the same concrete
/// Event.
///


///
/// Objects that implement IAAFEventMobSlot also implement the following interfaces:
///  - IAAFEventMobSlot2
///  - IAAFMobSlot
///  - IAAFObject
[
    object,
    uuid(e684d766-b935-11d2-bf9d-00104bc9156d),
    helpstring("IAAFEventMobSlot Interface"),
    pointer_default(unique)
]
interface IAAFEventMobSlot : IUnknown
{
  //***********************************************************
  //
  // GetEditRate()
  //
  /// This method will get the edit rate for this mob slot.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pEditRate pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEditRate arg is NULL.
  /// 
  /// @param pEditRate [out,retval] Edit rate property value
  ///
  HRESULT GetEditRate (
    [out,retval] aafRational_t *  pEditRate);


  //***********************************************************
  //
  // SetEditRate()
  //
  /// This method will get set edit rate for this mob slot.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pEditRate pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEditRate arg is NULL.
  /// 
  /// @param pEditRate [in] Edit rate property value
  ///
  HRESULT SetEditRate (
    [in] aafRational_t *  pEditRate);








}


// ************************
//
// Interface IAAFFile
//
// ************************
///
/// This interface is used with an object representing an AAF file.
///
/// Any filesystem file can be opened for reading by multiple
/// IAAFFile-supporting objects.
///
/// It is not recommended to Close an IAAFFile-implementing object
/// which contains objects to which outstanding references are held in
/// client code.  Nevertheless, even if that is done, the Close()
/// method will succeed and all referenced objects will be put into a
/// Detached state in which may cause any methods on such objects to
/// fail with the error status of AAFRESULT_NOT_IN_FILE.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
[
    object,
    uuid(9346ACD3-2713-11d2-8035-006008143E6F),
    helpstring("IAAFFile Interface"),
    pointer_default(unique)
]
interface IAAFFile : IUnknown
{

  //***********************************************************
  //
  // Open()
  //
  /// Associates this IAAFFile-supporting object with the storage to
  /// which it is to be associated.  It will then be possible to access
  /// objects within this file.
  ///
  /// This method will succeed only if all of the following are true:
  /// - This object has not already been opened.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_OPEN
  ///   - This object has already been Open()ed.
  /// 
  HRESULT Open ();


  //***********************************************************
  //
  // SaveCopyAs()
  //
  /// Copies the contents of this file to *pDestFile.  Requires that
  /// *pDestFile be open, writeable or modifiable, and not yet
  /// contain any objects.
  ///
  /// NOTE! Stub only.   Implementation not yet added.
  ///
  /// Succeeds if:
  /// - This object is currently open.
  /// - The named filesystem file is writable.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_OPEN
  ///   - This object is not open.
  ///
  /// AAFRESULT_NOT_WRITEABLE
  ///   - The named file cannot be written.
  /// 
  /// @param pDestFile [in] File to recieve contents
  ///
  HRESULT SaveCopyAs (
    [in] IAAFFile * pDestFile);


  //***********************************************************
  //
  // GetHeader()
  //
  /// Returns the IAAFHeader-supporting object associated with this
  /// file.  If this object has never been associated with a file, a
  /// new empty IAAFHeader-supporting object will be created and
  /// returned.  The returned header is AddRef()ed before it is
  /// returned.  Note that the header is automatically created when the
  /// file object is created.
  ///
  /// Succeeds if:
  /// - This object has already been Initialize()d.
  /// - This file object is open.
  /// - the given header pointer is valid.
  /// - this object contains a header.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NOT_OPEN
  ///   - This object is not open.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - the header pointer arg is NULL.
  ///
  /// AAFRESULT_NO_HEADER
  ///   - this object contains no header.
  /// 
  /// @param ppHeader [out, retval] Set to header of the current file
  ///
  HRESULT GetHeader (
    [out, retval] IAAFHeader ** ppHeader);


  //***********************************************************
  //
  // GetRevision()
  //
  /// Get the revision of the current AAF file, and returns it in pRev.
  ///
  /// Succeeds if:
  /// - This object has already been Initialize()d.
  /// - the given revision pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - the revision pointer arg is NULL.
  ///
  /// AAFRESULT_NOT_OPEN
  ///   - This object is not open.
  /// 
  /// @param pRev [out, retval] Revision of the current file
  ///
  HRESULT GetRevision (
    [out, retval] aafFileRev_t *  pRev);


  //***********************************************************
  //
  // Save()
  //
  /// If this IAAFFile-supporting object is open, all unsaved changes
  /// made to the contents of this object are saved.
  ///
  /// This method will succeed only if all of the following are true:
  /// - This object is currently open.
  /// - Sufficient space remains in the storage for the data to be
  ///   written.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_OPEN
  ///   - This object is not open.
  ///
  /// AAFRESULT_WRONG_OPENMODE
  ///   - This object is not open for writing or modification.
  ///
  /// AAFRESULT_INSUFFICIENT_SPACE
  ///   - There is insufficient space in the storage to save the
  ///     contents of this object.
  /// 
  HRESULT Save ();


  //***********************************************************
  //
  // Close()
  //
  /// Dissociates this IAAFFile-supporting object from its
  /// currently-associated storage.  Any AAF objects which were
  /// contained within this object will then no longer be available to
  /// the client.
  ///
  /// If the client is maintaining any references to any objects which
  /// are contained in this object, those objects will be marked as
  /// dissociated, and methods on them will fail.
  ///
  /// Any unsaved changes will be written to the file before the Close
  /// operation is complete.
  ///
  /// This method will succeed only if all of the following are true:
  /// - This object is currently open.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_OPEN
  ///   - This object is not already open.
  /// 
  HRESULT Close ();

  //***********************************************************
  //
  // GetDictionary()
  //
  /// Places the dictionary that contains all types of aaf definition
  /// objects into the *ppDictionary argument.  The returned dictionary
  /// is AddRef()ed before it is returned.  Note that the dictionary
  /// is automatically created when the header object is created.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppDictionary pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDictionary is null.
  /// 
  /// @param ppDictionary [out, retval] The AAF Dictionary
  ///
  HRESULT GetDictionary (
    [out, retval] IAAFDictionary ** ppDictionary);

}



// ************************
//
// Interface IAAFFileDescriptor
//
// ************************
///
/// IAAFFileDescriptor is DEPRECATED, please use IAAFFileDescriptor2
///
/// The IAAFFileDescriptor interface is implemented by objects which
/// describe the format of the content data associated with a File
/// Source mob or the media associated with a Physical Source mob.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it through
///     this object's primary interface.  Note that IAAFFileDescriptor
///     is a primary interface for an abstract class, so it is not
///     appropriate for the Initialize() method to exist in this
///     interface.  The Initialize() method is available through the
///     concrete object's primary interface.
///


///
/// Objects that implement IAAFFileDescriptor also implement the following interfaces:
///  - IAAFFileDescriptor2
///  - IAAFEssenceDescriptor
///  - IAAFObject
[
    object,
    uuid(e58a8561-2a3e-11D2-bfa4-006097116212),
    helpstring("IAAFFileDescriptor Interface"),
    pointer_default(unique)
]
interface IAAFFileDescriptor : IUnknown
{
  //***********************************************************
  //
  // SetLength()
  //
  /// Sets the length of the essence in samples [not edit units].
  /// 
  /// Always succeeds.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param length [in] length of the essence in samples
  ///
  HRESULT SetLength (
    [in] aafLength_t  length);


  //***********************************************************
  //
  // GetLength()
  //
  /// Gets the length of the essence in samples [not edit units].
  ///
  /// Succeeds if all of the following are true:
  /// - the pLength pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pLength.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLength arg is NULL.
  /// 
  /// @param pLength [out] returns length of the essence in samples
  ///
  HRESULT GetLength (
    [out] aafLength_t *  pLength);


  //***********************************************************
  //
  // SetCodecDef()
  //
  /// Set to the exact codec which was used as a hint.
  /// 
  /// Always succeeds.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param codecDef [in] Which codec was used
  ///
  HRESULT SetCodecDef (
    [in] IAAFCodecDef * codecDef);


  //***********************************************************
  //
  // GetCodecDef()
  //
  /// Get to the exact codec which was used as a hint.
  ///
  /// Succeeds if all of the following are true:
  /// - the pCodecDef pointer is valid.
  /// - the CodecDefinition identifying the codec is
  ///   present in the dictionary.
  /// 
  /// If this method fails nothing will be written to *pCodecDef.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCodecDef arg is NULL.
  ///
  /// AAFRESULT_OBJECT_NOT_FOUND
  ///   - the CodecDefinition identifying the codec is not
  ///     in the dictionary.
  /// 
  /// @param pCodecDef [out] Which codec was used
  ///
  HRESULT GetCodecDef (
    [out] IAAFCodecDef ** pCodecDef);


  //***********************************************************
  //
  // SetSampleRate()
  //
  /// Sets sample rate of the essence as opposed to the edit rate.
  /// 
  /// If this method fails the sample rate property will not be
  /// changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param rate [in] sample rate of the essence
  ///
  HRESULT SetSampleRate (
    [in] aafRational_constref  rate);


  //***********************************************************
  //
  // GetSampleRate()
  //
  /// Gets sample rate of the essence as opposed to the edit rate. and
  /// writes it into the *pRate argument.
  ///
  /// Succeeds if all of the following are true:
  /// - the pRate pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pRate.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pRate arg is NULL.
  /// 
  /// @param pRate [out] sample rate of the essence
  ///
  HRESULT GetSampleRate (
    [out] aafRational_t*  pRate);


  //***********************************************************
  //
  // SetContainerFormat()
  //
  /// Identifies the file format.  The container format is an optional
  /// property.
  /// 
  /// If this method fails the container format property will not be
  /// changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param format [in] file format
  ///
  HRESULT SetContainerFormat (
    [in] IAAFContainerDef * format);


  //***********************************************************
  //
  // GetContainerFormat()
  //
  /// Identifies the file format.
  ///
  /// Succeeds if all of the following are true:
  /// - the pFormat pointer is valid.
  /// - the ContainerDefinition identifying the file format is
  ///   present in the dictionary.
  /// 
  /// If this method fails nothing will be written to *pFormat.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFormat arg is NULL.
  ///
  /// AAFRESULT_OBJECT_NOT_FOUND
  ///   - the ContainerDefinition identifying the file format is not
  ///     in the dictionary.
  /// 
  /// @param pFormat [out] Optional
  ///
  HRESULT GetContainerFormat (
    [out] IAAFContainerDef ** pFormat);





}


// ************************
//
// Interface IAAFFileEncoding
//
// ************************
///
/// Start of the comment
///
/// End of the comment
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///


[
    object,
    uuid(56904725-a95c-40f4-a746-8754e7d16f6d),
    helpstring("IAAFFileEncoding Interface"),
    pointer_default(unique)
]
interface IAAFFileEncoding : IUnknown
{

  //***********************************************************
  //
  // GetName()
  //
  /// Gets the name of this file encoding.
  /// 
  /// Writes the Name property, with a trailing null
  /// character, into the pName buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the Name property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetNameBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pName.
  /// 
  /// Succeeds if:
  /// - The pName pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   Name.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold Name.
  /// 
  /// @param pName [out, string, size_is(bufSize)] buffer into which Name is to be written
  /// @param bufSize [in] size of *pName buffer in bytes
  ///
  HRESULT GetName (
    [out, string, size_is(bufSize)] aafCharacter *  pName,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetNameBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetName().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetNameBufLen (
    [out] aafUInt32 *  pBufSize);


  //***********************************************************
  //
  // GetDescription()
  //
  /// Gets the description of this file encoding.
  /// 
  /// Writes the Description property, with a trailing null
  /// character, into the pDescription buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the Description property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetDescriptionBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pDescription.
  /// 
  /// Succeeds if:
  /// - The pDescription pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   Description.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDescription arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold Description.
  /// 
  /// @param pDescription [out, string, size_is(bufSize)] buffer into which Description is to be written
  /// @param bufSize [in] size of *pDescription buffer in bytes
  ///
  HRESULT GetDescription (
    [out, string, size_is(bufSize)] aafCharacter *  pDescription,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetDescriptionBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetDescription().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetDescriptionBufLen (
    [out] aafUInt32 *  pBufSize);



  //***********************************************************
  //
  // GetFileKind()
  //
  /// This method returns the unique ID associated with this file encoding.
  ///
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pFileKind pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pFileKind.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFileKind argument is NULL.
  /// 
  /// @param pFileKind [out] The unique file encoding ID
  ///
  HRESULT GetFileKind (
    [out] aafUID_t *  pFileKind);

}



// ************************
//
// Interface IAAFFiller
//
// ************************
///
/// The IAAFFiller interface is supported by objects which serve as
/// placeholders for an unknown values for the component duration.
/// Typically, a Filler object is used in a Sequence to allow
/// positioning of a Segment whem not all of the preceding material has
/// been specified.  If a Filler object is played, applications can
/// choose any appropiate blank media to play.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
///
/// Objects that implement IAAFFiller also implement the following interfaces:
///  - IAAFSegment
///  - IAAFComponent
///  - IAAFComponent2
///  - IAAFObject
[
    object,
    uuid(38e6f8a9-2a2c-11d2-8411-00600832acb8),
    helpstring("IAAFFiller Interface"),
    pointer_default(unique)
]

interface IAAFFiller : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// This function will create a new filler object with the given
  /// property values.  Length is specified in units of the edit rate
  /// of the containing timeline mob slot.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has not yet been initialized.
  /// - the length is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDataDef is null.
  ///
  /// AAFRESULT_BAD_LENGTH
  ///   - length is negative.
  /// 
  /// @param pDataDef [in] Data Definition Object
  /// @param length [in] Length Property Value
  ///
  HRESULT Initialize (
    [in] IAAFDataDef * pDataDef,
    [in] aafLength_t  length);
}



// ************************
//
// Interface IAAFFilmDescriptor
//
// ************************
///
/// The IAAFFilmDescriptor interface is implemented by objects which
/// describe film essence.  A FilmDescriptor object shall be the
/// EssenceDescription of a  physical Source Mob.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
///
/// Objects that implement IAAFFilmDescriptor also implement the following interfaces:
///  - IAAFEssenceDescriptor
///  - IAAFObject
[
    object,
    uuid(e58a8563-2a3e-11D2-bfa4-006097116212),
    helpstring("IAAFFilmDescriptor Interface"),
    pointer_default(unique)
]
interface IAAFFilmDescriptor : IUnknown
{

  //***********************************************************
  //
  // SetFilmManufacturer()
  //
  /// Sets the Film Manufacturer string property.
  ///
  /// Set the FilmManufacturer property to the value specified in
  /// pFilmManufacturer.  A copy is made of the data so the caller
  /// retains ownership of the *pFilmManufacturer buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pFilmManufacturer pointer is valid.
  /// 
  /// If this method fails the FilmManufacturer property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFilmManufacturer arg is NULL.
  /// 
  /// @param pFilmManufacturer [in, string] buffer from which FilmManufacturer is to be read
  ///
  HRESULT SetFilmManufacturer (
    [in, string] aafCharacter_constptr  pFilmManufacturer);


  //***********************************************************
  //
  // GetFilmManufacturer()
  //
  /// Gets the Film Manufacturer string property.
  /// 
  /// Writes the FilmManufacturer property, with a trailing null
  /// character, into the pFilmManufacturer buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the FilmManufacturer property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetFilmManufacturerBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pFilmManufacturer.
  /// 
  /// Succeeds if:
  /// - The pFilmManufacturer pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   FilmManufacturer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFilmManufacturer arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold FilmManufacturer.
  /// 
  /// @param pFilmManufacturer [out, string, size_is(bufSize)] buffer into which FilmManufacturer is to be written
  /// @param bufSize [in] size of *pFilmManufacturer buffer in bytes
  ///
  HRESULT GetFilmManufacturer (
    [out, string, size_is(bufSize)] aafCharacter *  pFilmManufacturer,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetFilmManufacturerBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetFilmManufacturer().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetFilmManufacturerBufLen (
    [out] aafUInt32 *  pBufSize);


  //***********************************************************
  //
  // SetFilmModel()
  //
  /// Sets the Film Model string property.
  ///
  /// Set the FilmModel property to the value specified in
  /// pFilmModel.  A copy is made of the data so the caller
  /// retains ownership of the *pFilmModel buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pFilmModel pointer is valid.
  /// 
  /// If this method fails the FilmModel property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFilmModel arg is NULL.
  /// 
  /// @param pFilmModel [in, string] buffer from which FilmModel is to be read
  ///
  HRESULT SetFilmModel (
    [in, string] aafCharacter_constptr  pFilmModel);


  //***********************************************************
  //
  // GetFilmModel()
  //
  /// Gets the Film Model string property.
  /// 
  /// Writes the FilmModel property, with a trailing null
  /// character, into the pFilmModel buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the FilmModel property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetFilmModelBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pFilmModel.
  /// 
  /// Succeeds if:
  /// - The pFilmModel pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   FilmModel.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFilmModel arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold FilmModel.
  /// 
  /// @param pFilmModel [out, string, size_is(bufSize)] buffer into which FilmModel is to be written
  /// @param bufSize [in] size of *pFilmModel buffer in bytes
  ///
  HRESULT GetFilmModel (
    [out, string, size_is(bufSize)] aafCharacter *  pFilmModel,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetFilmModelBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetFilmModel().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetFilmModelBufLen (
    [out] aafUInt32 *  pBufSize);


  //***********************************************************
  //
  // GetFilmFormat()
  //
  /// Gets the film format.
  ///
  /// Valid values include:
  ///  - kFt35MM
  ///  - kFt16MM
  ///  - kFt8MM
  ///  - kFt65MM
  /// 
  /// This method succeeds if all of the following are true:
  /// - the pFilmFormat pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFilmFormat arg is NULL.
  /// 
  /// @param pFilmFormat [out] pointer to the filmFormat
  ///
  HRESULT GetFilmFormat (
    [out] aafFilmType_t*  pFilmFormat);


  //***********************************************************
  //
  // GetFrameRate()
  //
  /// Get the frame rate of the film.
  /// 
  /// This method succeeds if all of the following are true:
  /// - the pRate pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pRate parameter is NULL.
  /// 
  /// @param pRate [out] Frame Rate
  ///
  HRESULT GetFrameRate (
    [out] aafUInt32*  pRate);


  //***********************************************************
  //
  // GetPerfPerFrame()
  //
  /// Get the number of perforations per frame.
  /// 
  /// This method succeeds if all of the following are true:
  /// - the pPerfPerFrame pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPerfPerFrame parameter is NULL.
  /// 
  /// @param pPerfPerFrame [out] Perforations per frame
  ///
  HRESULT GetPerfPerFrame (
    [out] aafUInt8*  pPerfPerFrame);


  //***********************************************************
  //
  // GetFilmAspectRatio()
  //
  /// Get the image aspect ratio.
  /// 
  /// This method succeeds if all of the following are true:
  /// - the pAspectRatio pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pAspectRatio arg is NULL.
  /// 
  /// @param pAspectRatio [out] Film Aspect Ratio
  ///
  HRESULT GetFilmAspectRatio (
    [out] aafRational_t*  pAspectRatio);


  //***********************************************************
  //
  // SetFilmFormat()
  //
  /// Sets the film format of the film.
  /// Valid values include:
  ///  - kFt35MM
  ///  - kFt16MM
  ///  - kFt8MM
  ///  - kFt65MM
  /// 
  /// This method succeeds if all of the following are true:
  /// - formFactor represents a valid format.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_BAD_TYPE
  ///	- filmFormat is invalid.
  /// 
  /// @param filmFormat [in] Film Format
  ///
  HRESULT SetFilmFormat (
    [in] aafFilmType_t  filmFormat);


  //***********************************************************
  //
  // SetFrameRate()
  //
  /// Set the frame rate of the film.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param rate [in] Frame Rate
  ///
  HRESULT SetFrameRate (
    [in] aafUInt32  rate);


  //***********************************************************
  //
  // SetPerfPerFrame()
  //
  /// Set the number of perforations per frame.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param perfPerFrame [in] Perforations per frame
  ///
  HRESULT SetPerfPerFrame (
    [in] aafUInt8  perfPerFrame);


  //***********************************************************
  //
  // SetFilmAspectRatio()
  //
  /// Set the image aspect ratio.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param aspectRatio [in] Film Aspect Ratio
  ///
  HRESULT SetFilmAspectRatio (
    [in] aafRational_t  aspectRatio);
}



// ************************
//
// Interface IAAFFindSourceInfo
//
// ************************
[
    object,
    uuid(9346ACD1-2713-11d2-8035-006008143E6F),
    helpstring("IAAFFindSourceInfo Interface"),
    pointer_default(unique)
]
interface IAAFFindSourceInfo : IUnknown
{


  //***********************************************************
  //
  // GetMob()
  //
  /// This function returns the mob found by the function
  /// which generated this IAAFFindSourceInfo as a result.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppMob pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppMob.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULLOBJECT
  ///   - There is no valid mob referenced
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppMob arg is NULL.
  /// 
  /// @param ppMob [out] The final media object referenced
  ///
  HRESULT GetMob (
    [out] IAAFMob ** ppMob);

  //***********************************************************
  //
  // GetSourceReference()
  //
  /// This function returns the source reference found by the function
  /// which generated this IAAFFindSourceInfo as a result.
  ///
  /// Note: the 3 properties that make up the "source
  /// reference" are sourceID, sourceTrackID, and startTime.
  ///
  /// Succeeds if all of the following are true:
  /// - This object has already been Initialize()d.
  /// - the pSourceRef pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pSourceRef.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSourceRef arg is NULL.
  /// 
  /// @param pSourceRef [out] Source Reference
  ///
  HRESULT GetSourceReference (
    [out] aafSourceRef_t *  pSourceRef);

  //***********************************************************
  //
  // GetLength()
  //
  /// Gets the length of this component.
  /// This function returns the duration in edit units of the result.
  ///	
  /// Succeeds if all of the following are true:
  /// - the pLength pointer is valid.
  /// - the optional length property is present for this object.
  ///
  /// This method deals with an optional property, which will only be
  /// present for time-varying media.
  /// 
  /// If this method fails nothing will be written to *pLength.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLength arg is NULL.
  ///
  /// AAFRESULT_BAD_PROP
  ///   - the optional length property is not present for this object.
  /// 
  /// @param pLength [retval][out] Length of this component
  ///
  HRESULT GetLength (
    [retval][out] aafLength_t *  pLength);

  //***********************************************************
  //
  // GetEditRate()
  //
  /// This method will get the edit rate for this result.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pEditRate pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEditRate arg is NULL.
  /// 
  /// @param pEditRate [out,retval] Edit rate property value
  ///
  HRESULT GetEditRate (
    [out,retval] aafRational_t *  pEditRate);

}



// ************************
//
// Interface IAAFGPITrigger
//
// ************************

///
/// The IAAFGPITrigger interface is implemented by objects which represent
/// an trigger action that should be taken when its position in time is
/// reached.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it through
///     this object's primary interface.  Note that IAAFMobSlot is a
///     primary interface for an abstract class, so it is not
///     appropriate for the Initialize() method to exist in this
///     interface.  The Initialize() method is available through the
///     concrete object's primary interface.
/// 
///
///
/// Objects that implement IAAFGPITrigger also implement the following interfaces:
///  - IAAFEvent
///  - IAAFSegment
///  - IAAFComponent
///  - IAAFComponent2
///  - IAAFObject
[
    object,
    uuid(e684d78c-b935-11d2-bf9d-00104bc9156d),
    helpstring("IAAFGPITrigger Interface"),
    pointer_default(unique)
]
interface IAAFGPITrigger : IUnknown
{


  //***********************************************************
  //
  // GetActiveState()
  //
  /// Sets *pActiveState to AAFTrue it the event is on otherwise
  /// sets it to AAFFalse.
  ///
  /// Succeeds if:
  /// - The pActiveState pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - The pActiveState pointer is NULL.
  /// 
  /// @param pActiveState [out, retval] pointer to the result
  ///
  HRESULT GetActiveState (
    [out, retval] aafBoolean_t *  pActiveState);


  //***********************************************************
  //
  // SetActiveState()
  //
  /// Set to AAFTrue to turn the trigger on or AAFFalse
  /// to turn the trigger off.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param ActiveState [in] the active state of the trigger
  ///
  HRESULT SetActiveState (
    [in] aafBoolean_t  ActiveState);

}



// ************************
//
// Interface IAAFGetFileBits
//
// ************************
///
/// This interface is implemented by the toolkit, and is provided to
/// clients of IAAFFile to allow them to obtain the raw bits of a file
/// after close.
///
/// Note that this and the IAAFSetFileBits interfaces are different
/// than the IAAFRawStorage interfaces in that those are implemented by
/// clients to provide access to the desired media; these are provided
/// by the toolkit to provide read OR write (but not both
/// simultaneously) access to the raw bits.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.


[
    object,
    uuid(3CC80282-72A8-11D4-B80D-0000863F2C27),
    helpstring("IAAFGetFileBits Interface"),
    pointer_default(unique)
]
interface IAAFGetFileBits : IUnknown
{

  //***********************************************************
  //
  // ReadAt()
  //
  /// Attempts to read bufsize bytes from this stream at the given byte
  /// offset.  Places the data into buf.  Any attempt to read beyond
  /// the size of this file, as reported by GetSize(), will be
  /// considered an error.
  ///
  /// A value of zero for position indicates the beginning of the
  /// stream.
  ///
  /// Succeeds if:
  /// - The pNumBytes pointer is valid.
  /// - position + buSize is not larger than the size of this file, as
  ///   reported by GetSize().
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - buf arg is NULL.
  ///
  /// AAFRESULT_OFFSET_SIZE
  ///   - position + size is larger than the size of this file.
  /// 
  /// @param buf [out, size_is(bufSize)] Buffer into which data is read
  /// @param bufSize [in] Size of buf in bytes
  /// @param position [in] The position in bytes at which to read
  ///
  HRESULT ReadAt (
    [out, size_is(bufSize)] aafMemPtr_t  buf,
    [in] aafUInt32  bufSize,
    [in] aafUInt64  position);


  //***********************************************************
  //
  // GetSize()
  //
  /// Returns the size of this file, in bytes, in *pSize.
  ///
  /// Succeeds if:
  /// - The pSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSize arg is NULL.
  /// 
  /// @param pSize [out] The size of this file in bytes
  ///
  HRESULT GetSize (
    [out] aafUInt64 *  pSize);
}



// ************************
//
// Interface IAAFHeader
//
// ************************
///
/// The IAAFHeader interface provides file-wide information and
/// indexes.  Each AAF file has one and only one instance of an object
/// which supports IAAFHeader.
///
/// When an IAAFHeader-supporting object is created, the contained
/// dictionary object is automatically created.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
///
/// Objects that implement IAAFHeader also implement the following interfaces:
///  - IAAFObject
[
    object,
    uuid(B1A21382-1A7D-11D2-BF78-00104BC9156D),
    helpstring("IAAFHeader Interface"),
    pointer_default(unique)
]
interface IAAFHeader : IUnknown
{
  //***********************************************************
  //
  // LookupMob()
  //
  /// Looks up the Mob that matches the given mob id and puts it into
  /// the ppMob argument.  The returned mob interface is AddRef()ed
  /// before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppMob pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppMob.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppMob is null
  ///
  /// AAFRESULT_MOB_NOT_FOUND
  ///   - the requested mob wasn't found.
  /// 
  /// @param mobID [in, ref] The Mob ID
  /// @param ppMob [out,retval] Matching Mob
  ///
  HRESULT LookupMob (
    [in, ref] aafMobID_constref  mobID,
    [out,retval] IAAFMob ** ppMob);


  //***********************************************************
  //
  // CountMobs()
  //
  /// Writes the number of matches for the given mob kind into the
  /// *pNumMobs argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pNumMobs pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pNumMobs.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumMobs is null.
  /// 
  /// @param mobKind [in] The mob kind to count
  /// @param pResult [out, retval] Total number of mobs of kind mobKind
  ///
  HRESULT CountMobs (
    [in] aafMobKind_t  mobKind,
    [out, retval] aafNumSlots_t *  pResult);


  //***********************************************************
  //
  // GetMobs()
  //
  /// Places an enumerator for mobs that apply to the criteria into the
  /// *ppEnum argument.  If pSearchCriteria is null, all mobs are
  /// returned.   The searchTag field of pSearchCriteria, and exactly
  /// ONE of the fields in the union (tags.mobID, tags.name, etc. )
  /// must be set.  Only one search criterion may be specified.  The
  /// returned enumerator is AddRef()ed before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  /// 
  /// @param pSearchCriteria [in] Search Criteria for enumeration
  /// @param ppEnum [out, retval] Mob Enumeration
  ///
  HRESULT GetMobs (
    [in] aafSearchCrit_t *  pSearchCriteria,
    [out, retval] IEnumAAFMobs ** ppEnum);


  //***********************************************************
  //
  // AddMob()
  //
  /// Appends the given mob to the header.  If the given mob is already
  /// contained this method will do nothing and will return success.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pMob pointer is valid.
  /// - the given mob is not already part of this collection.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMob is null.
  ///
  /// AAFRESULT_DUPLICATE_MOBID
  ///   - the given mob is already contained.
  /// 
  /// @param pMob [in] Mob to add
  ///
  HRESULT AddMob (
    [in] IAAFMob * pMob);


  //***********************************************************
  //
  // RemoveMob()
  //
  /// Removes the given mob from the header.
  ///
  /// Succeeds if all of the following are true:
  /// - the pMob pointer is valid.
  /// - the given mob is currently in the collection.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMob is null.
  ///
  /// AAFRESULT_MOB_NOT_FOUND
  ///   - the given mob is not already contained.
  /// 
  /// @param pMob [in] Mob to remove
  ///
  HRESULT RemoveMob (
    [in] IAAFMob * pMob);


  //***********************************************************
  //
  // CountEssenceData()
  //
  /// Writes the total number of essence data into the *pNumEssenceData
  /// argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pNumEssenceData pointer is valid.
  /// 
  /// If this method fails nothing will be written to
  /// *pNumEssenceData.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumEssenceData is null.
  /// 
  /// @param pResult [out, retval] Total number of essence data
  ///
  HRESULT CountEssenceData (
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // IsEssenceDataPresent()
  //
  /// Returns true if the essence is found.
  ///
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  /// 
  /// @param fileMobID [in, ref] A Unique File Mob ID
  /// @param fmt [in] The Essence File Format
  /// @param pResult [out,retval] True if the essence is found
  ///
  HRESULT IsEssenceDataPresent (
    [in, ref] aafMobID_constref  fileMobID,
    [in] aafFileFormat_t  fmt,
    [out,retval] aafBoolean_t *  pResult);


  //***********************************************************
  //
  // EnumEssenceData()
  //
  /// Places an enumerator for essence that applies to the criteria
  /// into the *ppEnum argument.  The returned enumerator is
  /// AddRef()ed before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pMediaCriteria pointer is valid.
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pMediaCriteria or ppEnum is null.
  /// 
  /// @param ppEnum [out,retval] Essence Enumeration
  ///
  HRESULT EnumEssenceData (
    [out,retval] IEnumAAFEssenceData ** ppEnum);


  //***********************************************************
  //
  // AddEssenceData()
  //
  /// Appends the given essence data object to the header.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pEssenceData pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_DUPLICATE_MOBID
  ///   - The given mob has already been added.  The validation is done by comparing
  ///     mobIDs, which should be unique.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEssenceData is null.
  /// 
  /// @param pEssenceData [in] Essence data object to append
  ///
  HRESULT AddEssenceData (
    [in] IAAFEssenceData * pEssenceData);

  //***********************************************************
  //
  // RemoveEssenceData()
  //
  /// Removes the given EssenceData from the header.
  ///
  /// Succeeds if all of the following are true:
  /// - the pEssenceData pointer is valid.
  /// - the given EssenceData is currently in the collection.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEssenceData is null.
  ///
  /// AAFRESULT_ESSENCE_NOT_FOUND
  ///   - the given EssenceData is not already contained.
  /// 
  /// @param pEssenceData [in] EssenceData to remove
  ///
  HRESULT RemoveEssenceData (
    [in] IAAFEssenceData * pEssenceData);

  //***********************************************************
  //
  // LookupEssenceData()
  //
  /// Looks up the EssenceData that matches the given mob id and puts it into
  /// the ppEssenceData argument.  The returned EssenceData interface is AddRef()ed
  /// before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEssenceData pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEssenceData.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEssenceData is null
  ///
  /// AAFRESULT_MOB_NOT_FOUND
  ///   - the requested EssenceData wasn't found.
  /// 
  /// @param mobID [in, ref] The Mob ID
  /// @param ppEssenceData [out,retval] Matching EssenceData
  ///
  HRESULT LookupEssenceData (
    [in, ref] aafMobID_constref  mobID,
    [out,retval] IAAFEssenceData ** ppEssenceData);

  //***********************************************************
  //
  // GetDictionary()
  //
  /// Places the dictionary that contains all types of aaf definition
  /// objects into the *ppDictionary argument.  The returned dictionary
  /// is AddRef()ed before it is returned.  Note that the dictionary
  /// is automatically created when the header object is created.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppDictionary pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDictionary is null.
  /// 
  /// @param ppDictionary [out, retval] The AAF Dictionary
  ///
  HRESULT GetDictionary (
    [out, retval] IAAFDictionary ** ppDictionary);


  //***********************************************************
  //
  // GetLastIdentification()
  //
  /// Places the identification of the last entity that modified the
  /// file into the *ppIdentification argument.  The returned
  /// identification is AddRef()ed before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppIdentification pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppIdentification is null.
  /// 
  /// @param ppIdentification [out,retval] Indentification Object
  ///
  HRESULT GetLastIdentification (
    [out,retval] IAAFIdentification ** ppIdentification);


  //***********************************************************
  //
  // LookupIdentification()
  //
  /// Places the Identification that matches the given generation into
  /// the *ppIdentification argument.  The returned identification is
  /// AddRef()ed before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppIdentification pointer is valid.
  /// - the given generation was found.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppIdentification is null.
  ///
  /// AAFRESULT_OBJECT_NOT_FOUND
  ///   - the given generation was not found..
  /// 
  /// @param generation [in, ref] Unique Generation ID
  /// @param ppIdentification [out,retval] Indentification Object
  ///
  HRESULT LookupIdentification (
    [in, ref] aafUID_constref  generation,
    [out,retval] IAAFIdentification ** ppIdentification);


  //***********************************************************
  //
  // CountIdentifications()
  //
  /// Writes the number of identification objects into the *pResult
  /// argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  /// 
  /// @param pResult [out, retval] Total number of identification objects
  ///
  HRESULT CountIdentifications (
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // GetIdentifications()
  //
  /// Places an enumerator for all Identifications criteria into the
  /// *ppEnum argument.  The returned enumerator is AddRef()ed before
  /// it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  /// 
  /// @param ppEnum [out,retval] Indentification Enumeration
  ///
  HRESULT GetIdentifications (
    [out,retval] IEnumAAFIdentifications ** ppEnum);


  //***********************************************************
  //
  // AppendIdentification()
  //
  /// Appends the given Identification class to the header.  This
  /// method does not attempt to identify duplicate identifications, so
  /// it will succeed even if an identical identification has already
  /// been appended.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pIdent pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pIdent is null.
  /// 
  /// @param pIdent [in] Identification to append
  ///
  HRESULT AppendIdentification (
    [in] IAAFIdentification * pIdent);


  //***********************************************************
  //
  // GetIdentificationAt()
  //
  /// Retrieves the indexed identification from the header.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppIdentification pointer is valid.
  /// - index is less than the value returned by CountIdentifications().
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppIdent is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than or equal to result of
  ///     CountIdentifications().
  /// 
  /// @param index [in] Index of identification to retrieve
  /// @param ppIdentification [out, retval] Retrieved identification
  ///
  HRESULT GetIdentificationAt (
    [in] aafUInt32  index,
    [out, retval] IAAFIdentification ** ppIdentification);


  //***********************************************************
  //
  // GetRefImplVersion()
  //
  /// Return the version of the Reference Implementation currently
  /// running on this machine, which implements these interfaces.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pVersion pointer is valid.
  /// 
  /// If this method fails nothing is written to *pVersion.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pVersion is null.
  /// 
  /// @param pVersion [out, retval] The Reference Implementation Version
  ///
  HRESULT GetRefImplVersion (
    [out, retval] aafProductVersion_t *  pVersion);


  //***********************************************************
  //
  // GetFileRevision()
  //
  /// Return the File Revision property.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pRevision pointer is valid.
  /// 
  /// If this method fails nothing is written to *pRevision.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pRevision is null.
  /// 
  /// @param pRevision [out, retval] The File Version
  ///
  HRESULT GetFileRevision (
    [out, retval] aafVersionType_t *  pRevision);


  //***********************************************************
  //
  // GetLastModified()
  //
  /// Return the Last Modified property.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pTimeStamp pointer is valid.
  /// 
  /// If this method fails nothing is written to *pTimeStamp.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTimeStamp is null.
  /// 
  /// @param pTimeStamp [out, retval] The modification date-time stamp
  ///
  HRESULT GetLastModified (
    [out, retval] aafTimeStamp_t *  pTimeStamp);


  //***********************************************************
  //
  // GetContentStorage()
  //
  /// Places the Content Storage object attached to the header into the
  /// *ppStorage argument.
  ///
  /// The returned content storage object is
  /// AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppStorage pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppStorage is null.
  /// 
  /// @param ppStorage [out] Returned Content Storage object
  ///
  HRESULT GetContentStorage (
    [out] IAAFContentStorage ** ppStorage);



















}


// ************************
//
// Interface IAAFIdentification
//
// ************************
///
/// The IAAFIdentification interface provides information about an
/// application that either created or modified the AAF file.
///
/// If a file was opened for modification by many applications in its
/// lifetime, then there will be multiple Identification objects.
/// These are kept in an ordered array, with the first entry being the
/// file creator, and the last entry being the last application to
/// modify the file.
///
/// The identification object is useful for technical support when
/// diagnosing problem AAF files, as it tells which applications (and
/// versions) have touched the file.   If a file has been modified by
/// multiple applications, then the date and productID fields can be
/// used to tell which changes to the file were made by a particular
/// application.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///


///
/// Objects that implement IAAFIdentification also implement the following interfaces:
///  - IAAFObject
[
    object,
    uuid(B1A2137E-1A7D-11D2-BF78-00104BC9156D),
    helpstring("IAAFIdentification Interface"),
    pointer_default(unique)
]
interface IAAFIdentification : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated IAAFIdentification-supporting
  /// object.  This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// This method fills in the mandatory properties of the object.  The
  /// values of the following required properties are set based on the
  /// information given in arguments to this method:
  /// - companyName
  /// - productname
  /// - productVersionString
  /// - productID
  /// 
  /// The following mandatory properties will be filled in
  /// automatically by the reference implementation:
  /// - date
  /// - generationAUID
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  /// - companyName is a valid pointer
  /// - productName is a valid pointer
  /// - productVersionString is a valid pointer
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - companyName, productName, or productVersionString is NULL.
  /// 
  /// @param companyName [in] company name string
  /// @param productName [in] product name string
  /// @param productVersionString [in] product version string
  /// @param productID [in] product identification
  ///
  HRESULT Initialize (
    [in] aafCharacter_constptr  companyName,
    [in] aafCharacter_constptr  productName,
    [in] aafCharacter_constptr  productVersionString,
    [in] aafUID_constref  productID);


  //***********************************************************
  //
  // GetCompanyName()
  //
  /// Gets the Company Name string property.
  /// 
  /// Writes the CompanyName property, with a trailing null
  /// character, into the pCompanyName buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the CompanyName property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetCompanyNameBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pCompanyName.
  /// 
  /// Succeeds if:
  /// - The pCompanyName pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   CompanyName.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCompanyName arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold CompanyName.
  /// 
  /// @param pCompanyName [out, string, size_is(bufSize)] buffer into which CompanyName is to be written
  /// @param bufSize [in] size of *pCompanyName buffer in bytes
  ///
  HRESULT GetCompanyName (
    [out, string, size_is(bufSize)] aafCharacter *  pCompanyName,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetCompanyNameBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetCompanyName().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetCompanyNameBufLen (
    [out] aafUInt32 *  pBufSize);


  //***********************************************************
  //
  // GetProductName()
  //
  /// Gets the Product Name string property.
  /// 
  /// Writes the ProductName property, with a trailing null
  /// character, into the pProductName buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the ProductName property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetProductNameBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pProductName.
  /// 
  /// Succeeds if:
  /// - The pProductName pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   ProductName.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pProductName arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold ProductName.
  /// 
  /// @param pProductName [out, string, size_is(bufSize)] buffer into which ProductName is to be written
  /// @param bufSize [in] size of *pProductName buffer in bytes
  ///
  HRESULT GetProductName (
    [out, string, size_is(bufSize)] aafCharacter *  pProductName,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetProductNameBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetProductName().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetProductNameBufLen (
    [out] aafUInt32 *  pBufSize);


  //***********************************************************
  //
  // GetProductVersionString()
  //
  /// Gets the Product Version string property.
  /// 
  /// Writes the ProductVersionString property, with a trailing null
  /// character, into the pProductVersionString buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the ProductVersionString property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetProductVersionStringBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pProductVersionString.
  /// 
  /// Succeeds if:
  /// - The pProductVersionString pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   ProductVersionString.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pProductVersionString arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold ProductVersionString.
  /// 
  /// @param pProductVersionString [out, string, size_is(bufSize)] buffer into which ProductVersionString is to be written
  /// @param bufSize [in] size of *pProductVersionString buffer in bytes
  ///
  HRESULT GetProductVersionString (
    [out, string, size_is(bufSize)] aafCharacter *  pProductVersionString,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetProductVersionStringBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetProductVersionString().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetProductVersionStringBufLen (
    [out] aafUInt32 *  pBufSize);


  //***********************************************************
  //
  // GetProductVersion()
  //
  /// Gets the Product Version property associated with this
  /// identification object and places it into *pVersion.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pVersion pointer is valid.
  /// 
  /// If this method fails, nothing will be written to *pVersion.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pVersion arg is NULL.
  /// 
  /// @param pVersion [out] The Product Version
  ///
  HRESULT GetProductVersion (
    [out] aafProductVersion_t *  pVersion);


  //***********************************************************
  //
  // SetProductVersion()
  //
  /// Set the Product Version property to the value specified in
  /// pVersion.  A copy is made of the data so the caller retains
  /// ownership of the *pVersion struct and is responsible for
  /// de-allocating it.
  /// 
  /// If this method fails the Product Version property will not be
  /// changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param version [in] The Product Version
  ///
  HRESULT SetProductVersion (
    [in] aafProductVersion_constref  version);


  //***********************************************************
  //
  // GetProductID()
  //
  /// Obtains the Product ID, which is the identification number
  /// assigned to the application and vendor of the application which
  /// attached this object to the AAF file.  This ID is written into
  /// the caller-allocated aafUID_t specified by the pProductID
  /// argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pProductID pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pProductID.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pProductID arg is NULL.
  /// 
  /// @param pProductID [out] The Product ID
  ///
  HRESULT GetProductID (
    [out] aafUID_t *  pProductID);


  //***********************************************************
  //
  // GetDate()
  //
  /// Writes the Date-time Stamp property into the caller-allocated
  /// aafTimeStamp_t specified by the pTimeStamp argument.  The
  /// date-time stamp recorded in this object corresponds to the time
  /// that this file was created or modified upon the occasion that
  /// this object was added to the file.
  ///
  /// Note: This is a read-only property.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pTimeStamp pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pTimeStamp.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTimeStamp arg is NULL.
  /// 
  /// @param pTimestamp [out] The date-time stamp
  ///
  HRESULT GetDate (
    [out] aafTimeStamp_t *  pTimestamp);


  //***********************************************************
  //
  // GetRefImplVersion()
  //
  /// Obtains the version of the Reference Implementation which
  /// created this identification object and writes it into the
  /// caller-allocated aafProductVersion_t specified by the pVersion
  /// argument.
  ///
  /// Note: This is a read-only property.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pVersion pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pVersion.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pVersion arg is NULL.
  /// 
  /// @param pVersion [out] The Reference Implementation Version
  ///
  HRESULT GetRefImplVersion (
    [out] aafProductVersion_t *  pVersion);


  //***********************************************************
  //
  // GetPlatform()
  //
  /// Gets the Platform string property.
  ///
  /// This information is provided only to allow diagnostic printing of
  /// platform information to be read by humans.  The format of the
  /// strings is not guaranteed to remain the same for a given
  /// platform.  Having said that, the possible values currently
  /// returned are:
  /// - "Win32" for Intel/Win32 platforms
  /// - "MacOS" for MacOS platforms
  /// - "Unknown" for unknown platforms
  /// 
  /// Writes the Platform property, with a trailing null
  /// character, into the pPlatform buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the Platform property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetPlatformBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pPlatform.
  /// 
  /// Succeeds if:
  /// - The pPlatform pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   Platform.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPlatform arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold Platform.
  /// 
  /// @param pPlatform [out, string, size_is(bufSize)] buffer into which Platform is to be written
  /// @param bufSize [in] size of *pPlatform buffer in bytes
  ///
  HRESULT GetPlatform (
    [out, string, size_is(bufSize)] aafCharacter *  pPlatform,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetPlatformBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetPlatform().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetPlatformBufLen (
    [out] aafUInt32 *  pBufSize);


  //***********************************************************
  //
  // GetGenerationID()
  //
  /// Obtains the generation of this AAF file, which was generated at
  /// the time this identification object was created.  If a file was
  /// opened for modification by many applications in its lifetime,
  /// then there will be multiple Identification objects.  This is
  /// written into the caller-allocated aafUID_t specified by the
  /// pGeneration argument.
  /// 
  /// Note: This is a read-only property.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pGeneration pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pGeneration.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pGeneration arg is NULL.
  /// 
  /// @param pGeneration [out] The unique generation
  ///
  HRESULT GetGenerationID (
    [out] aafUID_t *  pGeneration);
}



// ************************
//
// Interface IAAFImportDescriptor
//
// ************************

///
/// The IAAFImportDescriptor interface is implemented by objects which
/// describe a file which was imported into AAF.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///


///
/// Objects that implement IAAFImportDescriptor also implement the following interfaces:
///  - IAAFPhysicalDescriptor
///  - IAAFEssenceDescriptor
///  - IAAFObject
[
    object,
    uuid(2CAA17DF-DDBC-4ac5-A87E-166fcd06cc9c ),
    helpstring("IAAFImportDescriptor Interface"),
    pointer_default(unique)
]
interface IAAFImportDescriptor : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty
  /// IAAFImportDescriptor-supporting object.  This method must be called
  /// after allocation, and before any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  /// 
  HRESULT Initialize ();

}



// ************************
//
// Interface IAAFInterpolationDef
//
// ************************
///
/// This interface is used with an object representing a particular
/// kind of interpolator, which may be implemented by one or more
/// AAFPluginDescriptors.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
///
/// Objects that implement IAAFInterpolationDef also implement the following interfaces:
///  - IAAFDefObject
///  - IAAFObject
[
    object,
    uuid(293600A3-0D37-11d3-80A9-006008143E6F),
    helpstring("IAAFInterpolationDef Interface"),
    pointer_default(unique)
]
interface IAAFInterpolationDef : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Init all fields of a definition object.
  /// 
  /// @param id [in, ref] AUID for new DefObject
  /// @param pName [in, string] Name for new DefObject
  /// @param pDescription [in, string] Description for new DefObject
  ///
  HRESULT Initialize (
    [in, ref] aafUID_constref  id,
    [in, string] aafCharacter_constptr  pName,
    [in, string] aafCharacter_constptr  pDescription);


}



// ************************
//
// Interface IAAFKLVData
//
// ************************
///
/// The IAAFKLVData interface is implemented by objects that
/// specify an User defined tag and value.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
///
/// Objects that implement IAAFKLVData also implement the following interfaces:
///  - IAAFObject
[
    object,
    uuid(46114414-0676-11d4-A356-009027DFCA6A),
    helpstring("IAAFKLVData Interface"),
    pointer_default(unique)
]
interface IAAFKLVData : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a new KLVData object to be interpreted using the
  /// given given key.  The key must have been registered using dictionary->RegisterKLVDataKey()
  /// in order to use the byte swapping functionality of the type model.
  ///
  /// This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  /// - pName is a valid pointer.
  /// - pTypeDef is a valid pointer and registered
  /// - pValue is a valid pointer
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - This object has already had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTypeDef or pValue arg is NULL.
  ///
  /// AAFRESULT_NOT_VALID_KEY
  ///   - The  given key must not resolve to a builtin type.  For most purposes, use
  ///     IAAFTypeDefRename to rename an existing type.
  ///
  /// 
  /// 
  /// @param key [in] Key of the following value data
  /// @param length [in] Length of preallocated buffer
  /// @param pValue [in, size_is(length)] buffer containing value
  ///
  HRESULT Initialize (
    [in] aafUID_t  key,
    [in] aafUInt32  length,
    [in, size_is(length)] aafDataBuffer_t  pValue);

  //***********************************************************
  //
  // GetKey()
  //
  /// Returns the type definition for this invocation.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pKey pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pKey.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - This property does not exist in the file.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pKey arg is NULL.
  /// 
  /// @param pKey [out] The key of this object
  ///
  HRESULT GetKey (
    [out] aafUID_t*  pKey);


  //***********************************************************
  //
  // GetValue()
  //
  /// Writes the value into the pValue buffer.  The buffer is allocated
  /// by the caller, and the size of the buffer is given by
  /// valueSize.
  /// 
  /// Caller may call GetValueBufLen() to determine the
  /// required buffer size.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pValue pointer is valid.
  /// - valueSize indicates the buffer is large enough to hold the name.
  /// 
  /// If this method fails nothing will be written to *pValue.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pValue arg is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - valueSize indicates the buffer is too small to hold the value.
  /// 
  /// @param valueSize [in] Size of preallocated buffer
  /// @param pValue [out, size_is(valueSize), length_is(*bytesRead)] Preallocated buffer to hold value
  /// @param bytesRead [out] Number of actual bytes read
  ///
  HRESULT GetValue (
    [in] aafUInt32  valueSize,
    [out, size_is(valueSize), length_is(*bytesRead)] aafDataBuffer_t  pValue,
    [out] aafUInt32 *  bytesRead);


  //***********************************************************
  //
  // GetValueBufLen()
  //
  /// Returns the length of buffer required for the GetValue() method.
  /// The value is placed into the location specified by pLen.
  ///
  /// Succeeds if all of the following are true:
  /// - the pLen pointer is valid.
  ///
  /// If this method fails nothing will be written to *pLen.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLen arg is NULL.
  /// 
  /// @param pLen [out] Pointer to an variable used to return the length
  ///
  HRESULT GetValueBufLen (
    [out] aafUInt32 *  pLen);

  //***********************************************************
  //
  // SetValue()
  //
  /// The data value is set from a buffer of size valueSize and type.
  ///
  /// Succeeds if all of the following are true:
  /// - the pValue pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pValue is null.
  /// 
  /// @param valueSize [in] Size of preallocated buffer
  /// @param pValue [in, size_is(valueSize)] buffer containing value
  ///
  HRESULT SetValue (
    [in] aafUInt32  valueSize,
    [in, size_is(valueSize)] aafDataBuffer_t  pValue);

}



// ************************
//
// Interface IAAFKLVDataDefinition
//
// ************************
///
/// This interface is used to describe the data type of a value stored
/// in an AAFKLVData object.
///
///
/// Objects that implement IAAFKLVDataDefinition also implement the following interfaces:
///  - IAAFDefObject
///  - IAAFObject
[
    object,
    uuid(f6af8700-949c-4304-9706-c0576b53f4aa),
    helpstring("IAAFKLVDataDefinition Interface"),
    pointer_default(unique)
]
interface IAAFKLVDataDefinition : IUnknown
{


  //***********************************************************
  //
  // Initialize()
  //
  /// Init all fields of a definition object.
  /// 
  /// @param id [in, ref] AUID for new DefObject
  /// @param pName [in, string] Name for new DefObject
  /// @param pDescription [in, string] Description for new DefObject
  ///
  HRESULT Initialize (
    [in, ref] aafUID_constref  id,
    [in, string] aafCharacter_constptr  pName,
    [in, string] aafCharacter_constptr  pDescription);

  //***********************************************************
  //
  // AddParentProperty()
  //
  /// Add a property definition to the KLV data definition.
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pParentProperty is null.
  /// 
  /// @param pParentProperty [in] Property definition to add.
  ///
  HRESULT AddParentProperty (
    [in] IAAFPropertyDef * pParentProperty);

  //***********************************************************
  //
  // GetParentProperties()
  //
  /// Writes an enumerator for the property definitions into *ppEnum.
  /// A reference is added to the new enumerator before it is returned.
  ///
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  /// 
  /// @param ppEnum [out] Property definition enumerator.
  ///
  HRESULT GetParentProperties (
    [out] IEnumAAFPropertyDefs ** ppEnum);

  //***********************************************************
  //
  // CountParentProperties()
  //
  /// Writes the total number of property definitions into *pNumProperties if,
  /// and only if, the method succeeds.
  ///
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  /// 
  /// @param pNumProperties [out] Number of property definitions.
  ///
  HRESULT CountParentProperties (
    [out] aafUInt32*  pNumProperties);

  //***********************************************************
  //
  // RemoveParentProperty()
  //
  /// Removes the given property definition.
  ///
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - The property definition is not in this tagged value definition.
  /// 
  /// @param pParentProperty [in] Property to remove.
  ///
  HRESULT RemoveParentProperty (
    [in] IAAFPropertyDef * pParentProperty);

  //***********************************************************
  //
  // GetKLVDataType()
  //
  /// Writes the data definition object attached to this KLV data
  /// definition into the *ppTypeDef argument if, and only if, the call succeeds.
  /// If none exists, NULL is written to the *ppTypeDef argument.
  ///
  /// The returned data definition object, if it exists, is
  /// AddRef()ed before it is returned.
  ///
  /// Return codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTypeDef is null.
  /// 
  /// @param ppTypeDef [out] Returned data definition object
  ///
  HRESULT GetKLVDataType (
    [out] IAAFTypeDef ** ppTypeDef);


  //***********************************************************
  //
  // SetKLVDataType()
  //
  /// Sets the date type of this KLV data definition to be the given one.
  ///
  /// Return codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTypeDef is null.
  /// 
  /// @param pTypeDef [in] Data definition object
  ///
  HRESULT SetKLVDataType (
    [in] IAAFTypeDef * pTypeDef);

}



// ************************
//
// Interface IAAFLocator
//
// ************************
///
/// The IAAFLocator interface is implemented by objects that provide
/// information to help find a file that contains the essence.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it through
///     this object's primary interface.  Note that IAAFLocator is a
///     primary interface for an abstract class, so it is not
///     appropriate for the Initialize() method to exist in this
///     interface.  The Initialize() method is available through the
///     concrete object's primary interface.
///


///
/// Objects that implement IAAFLocator also implement the following interfaces:
///  - IAAFObject
[
    object,
    uuid(d4f89061-69d6-11d2-841b-00600832acb8),
    helpstring("IAAFLocator Interface"),
    pointer_default(unique)
]
interface IAAFLocator : IUnknown
{

  //***********************************************************
  //
  // SetPath()
  //
  /// Sets the Path string property.
  ///
  /// Set the Path property to the value specified in
  /// pPath.  A copy is made of the data so the caller
  /// retains ownership of the *pPath buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pPath pointer is valid.
  /// 
  /// If this method fails the Path property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPath arg is NULL.
  /// 
  /// @param pPath [in, string] buffer from which Path is to be read
  ///
  HRESULT SetPath (
    [in, string] aafCharacter_constptr  pPath);


  //***********************************************************
  //
  // GetPath()
  //
  /// Gets the Path string property.
  /// 
  /// Writes the Path property, with a trailing null
  /// character, into the pPath buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the Path property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetPathBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pPath.
  /// 
  /// Succeeds if:
  /// - The pPath pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   Path.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPath arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold Path.
  /// 
  /// @param pPath [out, string, size_is(bufSize)] buffer into which Path is to be written
  /// @param bufSize [in] size of *pPath buffer in bytes
  ///
  HRESULT GetPath (
    [out, string, size_is(bufSize)] aafCharacter *  pPath,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetPathBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetPath().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetPathBufLen (
    [out] aafUInt32 *  pBufSize);
}



// ************************
//
// Interface IAAFMasterMob
//
// ************************
///
/// The IAAFMasterMob interface is implemented by objects which provide
/// access to the File Source Mobs and EssenceData objects.  The Master
/// Mob object is used to provide a level of indirection for accessing
/// Source Mobs from Composition Mobs.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
///
/// Objects that implement IAAFMasterMob also implement the following interfaces:
///  - IAAFMob
///  - IAAFMob2
///  - IAAFObject
[
    object,
    uuid(b1a21372-1a7d-11d2-bf78-00104bc9156d),
    helpstring("IAAFMasterMob Interface"),
    pointer_default(unique)
]
interface IAAFMasterMob : IUnknown
{
  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty IAAFMasterMob-supporting
  /// object.  This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  /// 
  HRESULT Initialize ();


  //***********************************************************
  //
  // AddMasterSlot()
  //
  /// This function adds a slot to the specified Master Mob that
  /// references the specified a slot in the specified Source Mob. The
  /// new slot in the Master Mob contains a Source Clip that specifies
  /// the Source Mob in its source reference properties.  Typically this
  /// is done automatically by passing the Master Mob handle to
  /// AAFMedia::Create, but this function allows you to add it later.
  ///
  /// Note: If pSlotName is passed in with zero length, then the
  /// slot is not assigned a name.  Slot names are not used by the
  /// SDK, and exist only so the user can name slots.
  /// 
  /// Succeeds if all of the following are true:
  /// (more conditions here)
  /// 
  /// If this method fails no state is changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - One or more of the following parameters are NULL pSourceMob,
  ///     pSlotName, and pDataDef.
  ///
  /// AAFRESULT_INVALID_DATADEF
  ///   - The data kind of the source MOB slot to be added to the Master
  ///     Mob does not match what is specfied in pDataDef.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The specified Source Mob slot was not found.
  ///
  /// AAFRESULT_SLOT_EXISTS
  ///   - The specified Master slot ID already exists.
  /// 
  /// @param pDataDef [in] Data kind of new slot.  Requires a data kind valid for a media
  /// stream. Valid data kinds are:
  /// - Picture
  /// - Sound
  /// @param sourceSlotID [in] Slot ID of the Source Mob slot to be added to the Master Mob
  /// @param pSourceMob [in] Source Mob containing the slot to be added to the Master Mob
  /// @param masterSlotID [in] SlotID assigned to the new Master Mob slot
  /// @param pSlotName [in, string] Name to assign to new slot in Master Mob
  ///
  HRESULT AddMasterSlot (
    [in] IAAFDataDef * pDataDef,
    [in] aafSlotID_t  sourceSlotID,
    [in] IAAFSourceMob * pSourceMob,
    [in] aafSlotID_t  masterSlotID,
    [in, string] aafCharacter_constptr  pSlotName);


  //***********************************************************
  //
  // GetTapeName()
  //
  /// Finds the tape Source Mob associated with a Master Mob slot
  /// and writes the name of the tape, which is stored in the
  /// Mobs Name property, into the pTapeName buffer.  The buffer is
  /// allocated by the caller.  The size of the buffer is given by
  /// bufSize.  If the property name has not yet been set, a
  /// zero-length string will be written (that is, only the trailing
  /// null character).
  /// 
  /// Caller may call GetTapeNameBufLen() to determine the required
  /// buffer size.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pTapeName pointer is valid.
  /// - the specified master slot was found.
  /// - the specified master slot contains a tape mob.
  /// - bufSize indicates the buffer is large enough to hold the name.
  /// 
  /// If this method fails nothing will be written to *pTapeName.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTapeName arg is NULL.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The specified Master Slot was not found.
  ///
  /// AAFRESULT_NOT_TAPEMOB
  ///   - The specified Master Slot does not contain a Tape MOB.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - bufSize indicates the buffer is too small to hold the string.
  /// 
  /// @param masterSlotID [in] SlotID of the Master Mob slot
  /// @param pTapeName [out, size_is(bufSize), string] The returned name
  /// @param bufSize [in] the size of the pTapeName buffer
  ///
  HRESULT GetTapeName (
    [in] aafUInt32  masterSlotID,
    [out, size_is(bufSize), string] aafCharacter *  pTapeName,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetTapeNameBufLen()
  //
  /// Returns the length of buffer required for the GetTapeName()
  /// method.  The value is placed into the location specified by
  /// pLen.  The value will include space required for the trailing
  /// null character.
  ///
  /// Succeeds if all of the following are true:
  /// - the pLen pointer is valid.
  ///
  /// If this method fails nothing will be written to *pLen.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLen arg is NULL.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The specified Master Slot was not found.
  ///
  /// AAFRESULT_NOT_TAPEMOB
  ///   - The specified Master Slot does not contain a Tape MOB.
  /// 
  /// @param masterSlotID [in] SlotID of the Master Mob slot
  /// @param pLen [out] required buffer length
  ///
  HRESULT GetTapeNameBufLen (
    [in] aafUInt32  masterSlotID,
    [out] aafUInt32 *  pLen);


  //***********************************************************
  //
  // GetNumRepresentations()
  //
  /// This function returns the number of media representations
  /// available for the specified SlotID on a specified Master
  /// Mob. This function is meant to work with
  /// GetRepresentationSourceClip, so that you can iterate through
  /// all of the choices yourself.  In most cases, you can use
  /// GetCriteriaSourceClip to handle multiple
  /// representations.  This function and
  /// GetRepresentationSourceClip are lower-level functions.
  ///
  /// Succeeds if all of the following are true:
  /// - the pNumReps pointer is valid.
  ///
  /// If this method fails nothing will be written to *pNumReps.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumReps arg is NULL.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The Master Slot specified by slotID was not found.
  /// 
  /// @param slotID [in] SlotID
  /// @param pNumReps [out, retval] number of representations
  ///
  HRESULT GetNumRepresentations (
    [in] aafSlotID_t  slotID,
    [out, retval] aafNumSlots_t *  pNumReps);


  //***********************************************************
  //
  // GetRepresentation()
  //
  /// This method returns the indexed media representation for the
  /// specified Master Mob, SlotID, and index.  This call is meant to
  /// work with GetNumRepresentations, so that you can iterate through
  /// all of the choices yourself.  This method uses an integer index,
  /// not an iterator.  The function GetRepresentationSourceClip takes
  /// an index between 1 and the number of representations
  /// [inclusive], and returns the indexed Source Mob. You can make
  /// calls to functions such as AAFMedia::GetVideoInfo and
  /// AAFMedia::IsMediaContiguous to determine which media is the best
  /// fit.
  ///
  /// The returned source clip is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppSourceClip pointer is valid.
  ///
  /// If this method fails nothing will be written to *ppSourceClip.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppSourceClip arg is NULL.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The specified Master Slot was not found.
  ///
  /// AAFRESULT_BADINDEX
  ///   - No Source Mob at specified index.
  /// 
  /// @param slotID [in] Slot ID
  /// @param index [in] Index of requested representation
  /// @param ppSourceClip [out] Requested Source Clip
  ///
  HRESULT GetRepresentation (
    [in] aafSlotID_t  slotID,
    [in] aafUInt32  index,
    [out] IAAFSegment ** ppSourceClip);


  //***********************************************************
  //
  // GetCriteriaSegment()
  //
  /// Returns the Segment on the specified slot of a Master Mob
  /// that references the Source Mob that best meets the specified
  /// criteria.  This function will work whether multiple media
  /// representations exist or not.
  ///
  /// The returned segment is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppSegment pointer is valid.
  ///
  /// If this method fails nothing will be written to *ppSegment.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppSegment arg is NULL.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The specified Master Slot was not found.
  /// 
  /// @param slotID [in] Slot ID
  /// @param pCriteria [in] Index of requested representation.  Note: the
  /// aafMediaCriteria_t is defined as the following structure:
  /// typedef struct
  /// {
  ///	aafCriteriaType_t type;
  ///	aafCriteriaProc_t proc;
  /// } aafMediaCriteria_t;
  ///
  /// The type field can have one of the following values:
  /// typedef enum
  /// {
  ///	kAAFAnyRepresentation = 0,
  ///	kAAFFastestRepresentation,
  ///	kAAFBestFidelityRepresentation,
  ///	kAAFSmallestRepresentation,
  ///	kAAFUseRepresentationProc
  /// } aafCriteriaType_t;
  /// @param ppSegment [out] Requested Segment
  ///
  HRESULT GetCriteriaSegment (
    [in] aafSlotID_t  slotID,
    [in] aafMediaCriteria_t *  pCriteria,
    [out] IAAFSegment ** ppSegment);


  //***********************************************************
  //
  // AppendPhysSourceRef()
  //
  /// Connects this Source Mob with the physical Source Mob that
  /// describes the previous generation of essence, appending it to
  /// existing Mob data.  If a physical Source Mob, such as a File
  /// Source Mob or tape Source Mob, references another physical
  /// Source Mob as its ancestor, with no pulldown, then this
  /// function makes the connection between the two.
  ///
  /// Functionally, this is a helper function to create a slot with an
  /// AAFSourceClip referencing a particular piece of media.  This
  /// function takes many parameters because the components of an
  /// aafSourceRef_t have been broken out as separate parameters.
  ///
  /// The ancestor of an AAFSourceMob with an AAFFileDescriptor is often an
  /// AAFTapeDescriptor or NIL.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSourceRefObj pointer is valid.
  /// - the pEssenceKind pointer is valid.
  /// (other conditions here)
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSourceRefObj or pEssenceKind is null.
  ///
  /// (other codes here.)
  /// 
  /// @param editrate [in] Edit rate of slot to contain reference
  /// @param aMobSlot [in] SlotID of slot to contain reference
  /// @param pEssenceKind [in] Data kind of slot to contain reference.  Requires a data kind
  /// valid for a essence stream.  Valid data kinds are:
  /// - Picture
  /// - Sound
  /// @param ref [in] Reference to a Physical Source Mob
  /// @param srcRefLength [in] Length of the Source Clip
  ///
  HRESULT AppendPhysSourceRef (
    [in] aafRational_t  editrate,
    [in] aafSlotID_t  aMobSlot,
    [in] IAAFDataDef * pEssenceKind,
    [in] aafSourceRef_t  ref,
    [in] aafLength_t  srcRefLength);


  //***********************************************************
  //
  // NewPhysSourceRef()
  //
  /// Connects this Source Mob with the physical Source Mob that
  /// describes the previous generation of essence, replacing any
  /// existing Mob data.  If a physical Source Mob, such as a File
  /// Source Mob or tape Source Mob, references another physical
  /// Source Mob as its ancestor, with no pulldown, then this
  /// function makes the connection between the two.
  ///
  /// Functionally, this is a helper function to create a slot with an
  /// AAFSourceClip referencing a particular piece of media.  This
  /// function takes many parameters because the components of an
  /// aafSourceRef_t have been broken out as separate parameters.
  ///
  /// The ancestor of an AAFSourceMob with an AAFFileDescriptor is often an
  /// AAFTapeDescriptor or NIL.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSourceRefObj pointer is valid.
  /// - the pEssenceKind pointer is valid.
  /// (other conditions here)
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSourceRefObj or pEssenceKind is null.
  ///
  /// (other codes here.)
  /// 
  /// @param editrate [in] Edit rate of slot to contain reference
  /// @param aMobSlot [in] SlotID of slot to contain reference
  /// @param pEssenceKind [in] Data kind of slot to contain reference.  Requires a data kind
  /// valid for a essence stream.  Valid data kinds are:
  /// - Picture
  /// - Sound
  /// @param ref [in] Reference to a Physical Source Mob
  /// @param srcRefLength [in] Length of the Source Clip
  ///
  HRESULT NewPhysSourceRef (
    [in] aafRational_t  editrate,
    [in] aafSlotID_t  aMobSlot,
    [in] IAAFDataDef * pEssenceKind,
    [in] aafSourceRef_t  ref,
    [in] aafLength_t  srcRefLength);


  //***********************************************************
  //
  // CreateEssence()
  //
  /// Creates a single channel stream of essence.  Convenience
  /// functions exist to create audio or video essence, and a separate
  /// call (MultiCreate) exists to create interleaved audio and video
  /// data.
  ///
  /// The essence handle from this call can be used with
  /// WriteDataSamples  and possibly WriteDataLines, but NOT with
  /// WriteMultiSamples.
  /// 
  /// If you are creating the essence, and then attaching it to a
  /// master mob, then the "masterMob" field may be left NULL.  For
  /// video, the sampleRate should be the edit rate of the file mob.
  /// For audio, the sample rate should be the actual samples per
  /// second.
  /// 
  /// @param masterSlotID [in] 
  /// @param pMediaKind [in] create essence of this type
  /// @param codecID [in, ref] using this codec
  /// @param editRate [in] with this edit rate
  /// @param samplerate [in] with this sample rate
  /// @param Enable [in] optionally compressing it
  /// @param destination [in] Optionally create the file HERE.
  /// @param fileFormat [in, ref] with this format
  /// @param access [out] Return an essence access on the essence.
  ///
  HRESULT CreateEssence (
    [in] aafSlotID_t  masterSlotID,
    [in] IAAFDataDef * pMediaKind,
    [in, ref] aafUID_constref  codecID,
    [in] aafRational_t  editRate,
    [in] aafRational_t  samplerate,
    [in] aafCompressEnable_t  Enable,
    [in] IAAFLocator * destination,
    [in, ref] aafUID_constref  fileFormat,
    [out] IAAFEssenceAccess ** access);


  //***********************************************************
  //
  // CreateMultiEssence()
  //
  /// Creates a multi-channel interleaved stream of essence.  The
  /// essence handle from this call can be used with WriteDataSamples
  /// or WriteMultiSamples but NOT with or WriteDataLines.
  /// 
  /// If you are creating the essence, and then attaching it to a
  /// master mob, then the "masterMob" field may be left NULL.
  /// 
  /// @param codecID [in, ref] using this codec
  /// @param arrayElemCount [in] this many channels
  /// @param mediaArray [in,ref,size_is(arrayElemCount)] using these definitions
  /// @param Enable [in] optionally compressing it
  /// @param destination [in] Optionally create the file HERE.
  /// @param fileFormat [in, ref] with this format
  /// @param access [out] Return an essence access on the essence.
  ///
  HRESULT CreateMultiEssence (
    [in, ref] aafUID_constref  codecID,
    [in] aafUInt16  arrayElemCount,
    [in,ref,size_is(arrayElemCount)] aafmMultiCreate_t *  mediaArray,
    [in] aafCompressEnable_t  Enable,
    [in] IAAFLocator * destination,
    [in, ref] aafUID_constref  fileFormat,
    [out] IAAFEssenceMultiAccess**  access);


  //***********************************************************
  //
  // OpenEssence()
  //
  /// Opens a single channel of a file mob.  If the essence is
  /// interleaved, then it will be di-interleaved when samples are
  /// read.  This routine follows the locator, and may call the locator
  /// failure callback if the essence can not be found.  If the failure
  /// callback finds the essence, then this routine will return
  /// normally.
  /// 
  /// The essence handle from this call can be used with
  /// ReadDataSamples  and possibly ReadDataLines, but NOT with
  /// ReadMultiSamples.
  /// 
  /// NOTE: If a locator is followed, then essencePtr may reference
  /// ANOTHER file object, which must be closed on file close.
  /// 
  /// @param slotID [in] On this slot
  /// @param mediaCrit [in] using this essence criteria
  /// @param openMode [in] ReadOnly or Append
  /// @param compEnable [in] optionally decompressing
  /// @param access [out] Return an essence access on the essence.
  ///
  HRESULT OpenEssence (
    [in] aafSlotID_t  slotID,
    [in] aafMediaCriteria_t*  mediaCrit,
    [in] aafMediaOpenMode_t  openMode,
    [in] aafCompressEnable_t  compEnable,
    [out] IAAFEssenceAccess ** access);
	

  //***********************************************************
  //
  // OpenMultiEssence()
  //
  /// Opens a all channels associated with a file mob.  This routine
  /// follows the locator, and may call the locator failure callback if
  /// the essence can not be found.  If the failure callback finds the
  /// essence, then this routine will return normally.
  ///
  /// The essence handle from this call can be used with
  /// WriteMultiSamples but NOT with WriteDataSamples.
  /// 
  /// @param slotID [in] On this slot
  /// @param mediaCrit [in] using this essence criteria
  /// @param openMode [in] ReadOnly or Append
  /// @param compEnable [in] optionally decompressing
  /// @param access [out] Return an essence access on the essence.
  ///
  HRESULT OpenMultiEssence (
    [in] aafSlotID_t  slotID,
    [in] aafMediaCriteria_t*  mediaCrit,
    [in] aafMediaOpenMode_t  openMode,
    [in] aafCompressEnable_t  compEnable,
    [out] IAAFEssenceMultiAccess**  access);


  //***********************************************************
  //
  // CountChannels()
  //
  /// Takes an opaque handle, a master mob reference, and a slot ID
  /// so that it may be called before the essence is opened.
  ///
  /// Returns the number of interleaved essence channels of a given
  /// type in the essence stream referenced by the given file mob.
  ///
  /// If the data format is not interleaved, then the answer will
  /// always be zero or one.  This function correctly returns zero for
  /// essence types not handled by a given codec, and handles codecs
  /// which work with multiple essence types.
  /// 
  /// @param slotID [in] On this slot
  /// @param mediaCrit [in] using this essence criteria
  /// @param pMediaKind [in] for this essence type
  /// @param numCh [out] How many channels?
  ///
  HRESULT CountChannels (
    [in] aafSlotID_t  slotID,
    [in] aafMediaCriteria_t*  mediaCrit,
    [in] IAAFDataDef * pMediaKind,
    [out] aafUInt16*  numCh);












}


// ************************
//
// Interface IAAFMetaDefinition
//
// ************************
///
/// This interface is defines an item to be referenced in the AAF file.
/// It specifies the AUID unique identifier used to define types used
/// in AAF persistent objects.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it through
///     this object's primary interface.  Note that IAAFObject is a
///     primary interface for an abstract class, so it is not
///     appropriate for the Initialize() method to exist in this
///     interface.  The Initialize() method is available through the
///     concrete object's primary interface.
[
    object,
    uuid(cee32174-0c10-11d4-8014-00104bc9156d),
    helpstring("IAAFMetaDefinition Interface"),
    pointer_default(unique)
]
interface IAAFMetaDefinition : IUnknown
{


  //***********************************************************
  //
  // Initialize()
  //
  /// Init all fields of a meta definition object.
  /// 
  /// @param id [in, ref] AUID for new DefObject
  /// @param pName [in, string] Name for new Meta Definition
  /// @param pDescription [in, string] the Description of this meta definition
  ///
  HRESULT Initialize (
    [in, ref] aafUID_constref  id,
    [in, string] aafCharacter_constptr  pName,
    [in, string] aafCharacter_constptr  pDescription);


  //***********************************************************
  //
  // GetAUID()
  //
  /// Gets the AUID for this object.
  /// 
  /// @param pAuid [retval,out] Pointer to an AUID reference
  ///
  HRESULT GetAUID (
    [retval,out] aafUID_t *  pAuid);

  //***********************************************************
  //
  // SetName()
  //
  /// Sets the Name of this definition.
  ///
  /// Set the Name property to the value specified in
  /// pName.  A copy is made of the data so the caller
  /// retains ownership of the *pName buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pName pointer is valid.
  /// 
  /// If this method fails the Name property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  /// 
  /// @param pName [in, string] buffer from which Name is to be read
  ///
  HRESULT SetName (
    [in, string] aafCharacter_constptr  pName);


  //***********************************************************
  //
  // GetName()
  //
  /// Gets the Name of this definition.
  /// 
  /// Writes the Name property, with a trailing null
  /// character, into the pName buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the Name property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetNameBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pName.
  /// 
  /// Succeeds if:
  /// - The pName pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   Name.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold Name.
  /// 
  /// @param pName [out, string, size_is(bufSize)] buffer into which Name is to be written
  /// @param bufSize [in] size of *pName buffer in bytes
  ///
  HRESULT GetName (
    [out, string, size_is(bufSize)] aafCharacter *  pName,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetNameBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetName().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetNameBufLen (
    [out] aafUInt32 *  pBufSize);

  //***********************************************************
  //
  // SetDescription()
  //
  /// Sets the Description of this definition.
  ///
  /// Set the Description property to the value specified in
  /// pDescription.  A copy is made of the data so the caller
  /// retains ownership of the *pDescription buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pDescription pointer is valid.
  /// 
  /// If this method fails the Description property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDescription arg is NULL.
  /// 
  /// @param pDescription [in, string] buffer from which Description is to be read
  ///
  HRESULT SetDescription (
    [in, string] aafCharacter_constptr  pDescription);


  //***********************************************************
  //
  // GetDescription()
  //
  /// Gets the Description of this definition.
  /// 
  /// Writes the Description property, with a trailing null
  /// character, into the pDescription buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the Description property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetDescriptionBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pDescription.
  /// 
  /// Succeeds if:
  /// - The pDescription pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   Description.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDescription arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold Description.
  /// 
  /// @param pDescription [out, string, size_is(bufSize)] buffer into which Description is to be written
  /// @param bufSize [in] size of *pDescription buffer in bytes
  ///
  HRESULT GetDescription (
    [out, string, size_is(bufSize)] aafCharacter *  pDescription,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetDescriptionBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetDescription().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetDescriptionBufLen (
    [out] aafUInt32 *  pBufSize);

}



// ************************
//
// Interface IAAFMob
//
// ************************
///
/// IAAFMob is DEPRECATED,  Please use IAAFMob2.
///
/// The IAAFMob interface is implemented by objects that specify a
/// Metadata Object, which can describe a composition, essence, or
/// physical media.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it through
///     this object's primary interface.  Note that IAAFMob is a
///     primary interface for an abstract class, so it is not
///     appropriate for the Initialize() method to exist in this
///     interface.  The Initialize() method is available through the
///     concrete object's primary interface.
///
///
/// Objects that implement IAAFMob also implement the following interfaces:
///  - IAAFMob2
///  - IAAFObject
[
    object,
    uuid(B1A21374-1A7D-11d2-BF78-00104BC9156D),
    helpstring("IAAFMob Interface"),
    pointer_default(unique)
]

interface IAAFMob : IUnknown
{

  //***********************************************************
  //
  // GetMobID()
  //
  /// This method returns the unique Mob ID associated with this mob.
  ///
  /// Succeeds if all of the following are true:
  /// - the pMobID pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pMobID.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMobID arg is NULL.
  /// 
  /// @param pMobID [out] The unique media object id
  ///
  HRESULT GetMobID (
    [out] aafMobID_t *  pMobID);


  //***********************************************************
  //
  // SetMobID()
  //
  /// When a mob is initially created, the Reference Implementation
  /// internally creates a mobID for the new mob.  This method should
  /// be used to change the mob's identity to an explicit mobID.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param mobID [in, ref] New Mob ID
  ///
  HRESULT SetMobID (
    [in, ref] aafMobID_constref  mobID);


  //***********************************************************
  //
  // SetName()
  //
  /// Sets the Mob Name string property.
  ///
  /// Set the Name property to the value specified in
  /// pName.  A copy is made of the data so the caller
  /// retains ownership of the *pName buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pName pointer is valid.
  /// 
  /// If this method fails the Name property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  /// 
  /// @param pName [in, string] buffer from which Name is to be read
  ///
  HRESULT SetName (
    [in, string] aafCharacter_constptr  pName);


  //***********************************************************
  //
  // GetName()
  //
  /// Gets the Mob Name string property.
  /// 
  /// Writes the Name property, with a trailing null
  /// character, into the pName buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the Name property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetNameBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pName.
  /// 
  /// Succeeds if:
  /// - The pName pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   Name.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold Name.
  /// 
  /// @param pName [out, string, size_is(bufSize)] buffer into which Name is to be written
  /// @param bufSize [in] size of *pName buffer in bytes
  ///
  HRESULT GetName (
    [out, string, size_is(bufSize)] aafCharacter *  pName,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetNameBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetName().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetNameBufLen (
    [out] aafUInt32 *  pBufSize);


  //***********************************************************
  //
  // CountSlots()
  //
  /// This method returns the number of slots contained by this mob.
  ///
  /// Succeeds if all of the following are true:
  /// - the pNumSlots pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pNumSlots.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumSlots arg is NULL.
  /// 
  /// @param pNumSlots [out] Number of slots
  ///
  HRESULT CountSlots (
    [out] aafNumSlots_t *  pNumSlots);


  //***********************************************************
  //
  // AppendSlot()
  //
  /// Appends the given mob slot to the mob.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pSlot pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSlot is null.
  /// 
  /// @param pSlot [in] slot to append
  ///
  HRESULT AppendSlot (
    [in] IAAFMobSlot * pSlot);


  //***********************************************************
  //
  // PrependSlot()
  //
  /// Prepends the given mob slot to the mob.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pSlot pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSlot is null.
  /// 
  /// @param pSlot [in] slot to prepend
  ///
  HRESULT PrependSlot (
    [in] IAAFMobSlot * pSlot);


  //***********************************************************
  //
  // InsertSlotAt()
  //
  /// Inserts the given slot into this mob at the given index.  All
  /// existing slots at the given and higher index will be moved up one
  /// index to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pSlot pointer is valid.
  /// - index is less than or equal to the result obtained by
  ///   CountSlots().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSlot is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than the result obtained from CountSlots().
  /// 
  /// @param index [in] index where slot is to be inserted
  /// @param pSlot [in] slot to insert
  ///
  HRESULT InsertSlotAt (
    [in] aafUInt32  index,
    [in] IAAFMobSlot * pSlot);


  //***********************************************************
  //
  // RemoveSlotAt()
  //
  /// Removes the slot at the given index.  All existing slots at
  /// indices higher than the given index will be moved down one index
  /// to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - index is less than the result obtained by CountSlots().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is not less than the result obtained from
  ///     CountSlots().
  /// 
  /// @param index [in] index of slot to be removed
  ///
  HRESULT RemoveSlotAt (
    [in] aafUInt32  index);


  //***********************************************************
  //
  // GetSlotAt()
  //
  /// Returns the indexed slot in *ppSlot.
  /// 
  /// Succeeds if all of the following are true:
  /// - ppSlot is a valid pointer.
  /// - index is less than the result obtained by CountSlots().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppSlot is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is not less than the result obtained from
  ///     CountSlots().
  /// 
  /// @param index [in] index of slot to be obtained
  /// @param ppSlot [out, retval] the returned slot
  ///
  HRESULT GetSlotAt (
    [in] aafUInt32  index,
    [out, retval] IAAFMobSlot ** ppSlot);


  //***********************************************************
  //
  // GetSlots()
  //
  /// Return an enumeration for all mob slots.  The returned
  /// enumerator is AddRef()ed before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  /// 
  /// @param ppEnum [out] Mob Slot Enumeration
  ///
  HRESULT GetSlots (
    [out] IEnumAAFMobSlots ** ppEnum);


  //***********************************************************
  //
  // GetModTime()
  //
  /// This method will return the modification time for this mob.
  ///
  /// Succeeds if all of the following are true:
  /// - the pLastModified pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pLastModified.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLastModified arg is NULL.
  /// 
  /// @param pLastModified [out] Modified Time
  ///
  HRESULT GetModTime (
    [out] aafTimeStamp_t *  pLastModified);


  //***********************************************************
  //
  // SetModTime()
  //
  /// This method sets the modification time on a mob.  The
  /// modification time is initially set to the time that the mob
  /// was created.  The Reference Implementation does not maintain the
  /// modification time every time that a mob has been updated.
  /// Therefore, this method should be called explicitly to change the
  /// modification time.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param modTime [in, ref] New Modification Time
  ///
  HRESULT SetModTime (
    [in, ref] aafTimeStamp_constref  modTime);


  //***********************************************************
  //
  // GetCreateTime()
  //
  /// This method will return the creation time for this mob.
  ///
  /// Succeeds if all of the following are true:
  /// - the pCreationTime pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pCreationTime.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCreationTime arg is NULL.
  /// 
  /// @param pCreationTime [out] Creation Time
  ///
  HRESULT GetCreateTime (
    [out] aafTimeStamp_t *  pCreationTime);


  //***********************************************************
  //
  // SetCreateTime()
  //
  /// This method sets the creation time on a mob.  The
  /// creation time is initially set to the time that the mob
  /// was created.
  /// Therefore, this method should be called explicitly to change the
  /// creation time.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param createTime [in, ref] New Creation Time
  ///
  HRESULT SetCreateTime (
    [in, ref] aafTimeStamp_constref  createTime);


  //***********************************************************
  //
  // AppendComment()
  //
  /// Creates a user-defined comment and appends it to the specified
  /// Mob.  A Mob comment is implemented as a AAFTaggedValue object of type 
  /// WCharString.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pCategory pointer is valid.
  /// - the pComment pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pCategory or pComment args is NULL.
  /// 
  /// @param pCategory [in,string] Comment heading
  /// @param pComment [in, string] Comment value
  ///
  HRESULT AppendComment (
    [in,string] aafCharacter *  pCategory,
    [in, string] aafCharacter_constptr  pComment);


  //***********************************************************
  //
  // CountComments()
  //
  /// Return total number of comments attached to this mob.
  ///
  /// Succeeds if all of the following are true:
  /// - the pNumComments pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pNumComments.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumComments arg is NULL.
  /// 
  /// @param pNumComments [out] Number  of Mob Comments
  ///
  HRESULT CountComments (
    [out] aafUInt32 *  pNumComments);


  //***********************************************************
  //
  // GetComments()
  //
  /// Return the enumeration for all mob comments.  The returned
  /// enumerator is AddRef()ed before it is returned.  Mob comments are 
  /// implemented as AAFTaggedValue of type WCharString.   The enumerator
  /// is implemented as a EnumAAAFTaggedValues.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  /// 
  /// @param ppEnum [out] Mob Comments
  ///
  HRESULT GetComments (
    [out] IEnumAAFTaggedValues ** ppEnum);


  //***********************************************************
  //
  // RemoveComment()
  //
  /// Removes the given comment from this mob.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pComment pointer is valid.
  /// - the given comment is present in the mob.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pComment is null.
  ///
  /// AAFRESULT_OBJECT_NOT_FOUND
  ///   - the given comment is not in this mob.
  /// 
  /// @param pComment [in] Comment to remove
  ///
  HRESULT RemoveComment (
    [in] IAAFTaggedValue * pComment);


  //***********************************************************
  //
  // AppendNewTimelineSlot()
  //
  /// This method creates a new timeline mob slot with the given
  /// property values and appends it to the input mob.
  /// 
  /// The returned mob slot is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSegment pointer is valid.
  /// - the pSlotName pointer is valid.
  /// - the ppNewSlot pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - any of pSegment, pSlotName, or ppNewSlot arguments is null.
  /// 
  /// @param editRate [in] Edit rate property value
  /// @param pSegment [in] Segment to append as slot component
  /// @param slotID [in] new slot ID
  /// @param pSlotName [in, string] new slot name
  /// @param origin [in] The slot origin
  /// @param ppNewSlot [out] Newly created slot
  ///
  HRESULT AppendNewTimelineSlot (
    [in] aafRational_t  editRate,
    [in] IAAFSegment * pSegment,
    [in] aafSlotID_t  slotID,
    [in, string] aafCharacter_constptr  pSlotName,
    [in] aafPosition_t  origin,
    [out] IAAFTimelineMobSlot ** ppNewSlot);


  //***********************************************************
  //
  // GetMobInfo()
  //
  /// This method will get all mob property information is a single call.
  ///
  /// Caller may call GetNameBufLen() to determine the required pName
  /// buffer size.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pLastModified pointer is valid.
  /// - the pCreationTime pointer is valid.
  /// - the pName pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pLastModified,
  /// *pCreationTime, or *pName.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - any of pLastModified, pCreationTime, or pName arguments is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - bufSize indicates the buffer is too small to hold the string.
  /// 
  /// @param pLastModified [out] Modified Time
  /// @param pCreationTime [out] Creation Time
  /// @param pName [out, size_is(bufSize), string] Mob Name
  /// @param bufSize [in] size of the supplied buffer.
  ///
  HRESULT GetMobInfo (
    [out] aafTimeStamp_t *  pLastModified,
    [out] aafTimeStamp_t *  pCreationTime,
    [out, size_is(bufSize), string] aafCharacter *  pName,
    [in] aafInt32  bufSize);


  //***********************************************************
  //
  // OffsetToMobTimecode()
  //
  /// This method will determine the timecode at the given offset into
  /// the given timecode segment, and will return it in *pResult.  If
  /// pTcSeg is NULL, will search for the slot containing a timecode
  /// segment and will use that instead.
  ///
  /// Succeeds if all of the following are true:
  /// - the pTcSeg pointer is valid.
  /// - the pOffset pointer is valid.
  /// - the pResult pointer is valid.
  /// - Timecode track exists.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pOffset or pResult argument is NULL.
  ///
  /// AAFRESULT_TIMECODE_NOT_FOUND
  ///   - timecode track wasn't found.
  /// 
  /// @param pTcSeg [in] Timecode Segment
  /// @param pOffset [in] Offset into segment in edit units for that segment's mob slot
  /// @param pResult [out] The resulting timecode
  ///
  HRESULT OffsetToMobTimecode (
    [in] IAAFSegment * pTcSeg,
    [in] aafPosition_t *  pOffset,
    [out] aafTimecode_t *  pResult);


  //***********************************************************
  //
  // LookupSlot()
  //
  /// The method will find the mob slot for the given slot id.
  ///
  /// The returned mob slot is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppDestSlot pointer is valid.
  /// - the given slot ID is found.
  /// 
  /// If this method fails nothing will be written to *ppDestSlot.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDestSlot arg is NULL.
  /// 
  /// @param slotId [in] The requested slot id
  /// @param ppDestSlot [out] The requested slot
  ///
  HRESULT LookupSlot (
    [in] aafSlotID_t  slotId,
    [out] IAAFMobSlot ** ppDestSlot);


  //***********************************************************
  //
  // ChangeRef()
  //
  /// Finds all Source Clips in the specified Mob that refer to the
  /// specified old Mob, and changes the references to point to the
  /// new Mob.
  ///
  /// This function traverses through the entire structure of the input
  /// Mob looking for Source Clips, and changes the sourceID property
  /// on all Source Clips with oldMobID to newMobID.
  ///
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param oldMobID [in, ref] Old Mob ID reference in source clip
  /// @param newMobID [in, ref] New Mob ID reference in source clip
  ///
  HRESULT ChangeRef (
    [in, ref] aafMobID_constref  oldMobID,
    [in, ref] aafMobID_constref  newMobID);


  //***********************************************************
  //
  // CloneExternal()
  //
  /// Clones the specified Source Mob, and optionally all dependent
  /// Mobs, to an external file, keeping the same MobID.  A pointer
  /// to the newly created destination mob is returned in *ppDestMob.
  /// 
  /// This function clones the specified Source Mob in the source file
  /// into a destination Mob, with the same MobID, in the destination
  /// file.  If resolveDependencies is kFollowDepend, the function
  /// also clones all Mobs referenced by the specified Source Mob.  If
  /// includeMedia is kIncludeMedia, the function also copies the
  /// media data associated with the Source Mob, returns the
  /// destination Mob, and clones all private data.
  ///
  /// If the media data is not in the file, the function does not
  /// attempt to find it in another file and clone it.  Both AAF files
  /// must be open before you call this function and both must have the
  /// same AAF Version number.
  ///
  /// The returned mob is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the pDestFile pointer is valid.
  /// - the ppDestMob pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pDestFile or ppDestMob arguments is NULL.
  /// 
  /// @param resolveDependencies [in] Whether to clone dependent mobs
  /// @param includeMedia [in] Whether to include media data
  /// @param pDestFile [in] Destination AAF File
  /// @param ppDestMob [out] Destination Mob
  ///
  HRESULT CloneExternal (
    [in] aafDepend_t  resolveDependencies,
    [in] aafIncMedia_t  includeMedia,
    [in] IAAFFile * pDestFile,
    [out] IAAFMob ** ppDestMob);


  //***********************************************************
  //
  // Copy()
  //
  /// This function copies the specified Mob into a destination Mob in
  /// the same AAF file. The new Mob is returned through the destMob
  /// parameter. The function gives the destination Mob a new MobID and
  /// the name specified in the destMobName parameter. The function
  /// also copies all private data.
  /// 
  /// The returned mob is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the pDestMobName pointer is valid.
  /// - the ppDestMob pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pDestMobName or pDestMob arguments is NULL.
  /// 
  /// @param pDestMobName [in, string] Optional Input. The name to be assigned to the new copy of the
  /// Mob.  The destMobName argument is optional. Specify a NULL
  /// value if no destination Mob name is desired.
  /// @param ppDestMob [out] Destination Mob
  ///
  HRESULT Copy (
    [in, string] aafCharacter_constptr  pDestMobName,
    [out] IAAFMob ** ppDestMob);
  ///

  //***********************************************************
  //
  // AppendKLVData()
  //
  /// Appends a pre-existing KLV Data object to the specified
  /// Mob.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pKLV pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - the pData arg is NULL.
  /// 
  /// @param pData [in] KLV object
  ///
  HRESULT AppendKLVData (
    [in] IAAFKLVData * pData);


  //***********************************************************
  //
  // CountKLVData()
  //
  /// Return total number of KLV data objects attached to this mob.
  ///
  /// Succeeds if all of the following are true:
  /// - the pNumData pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pNumComments.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumData arg is NULL.
  /// 
  /// @param pNumData [out] Number  of KLV data objects
  ///
  HRESULT CountKLVData (
    [out] aafUInt32 *  pNumData);


  //***********************************************************
  //
  // GetKLVData()
  //
  /// Return the enumeration for all KLV data objects on this mob.  The returned
  /// enumerator is AddRef()ed before it is returned.  The enumerator
  /// is implemented as a EnumAAFKLVData.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  /// 
  /// @param ppEnum [out] KLV data objects
  ///
  HRESULT GetKLVData (
    [out] IEnumAAFKLVData ** ppEnum);


  //***********************************************************
  //
  // RemoveKLVData()
  //
  /// Removes the given KLV data object from this mob.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pData pointer is valid.
  /// - the given KLV data object is present in the mob.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pData is null.
  ///
  /// AAFRESULT_OBJECT_NOT_FOUND
  ///   - the given KLV data object is not in this mob.
  /// 
  /// @param pData [in] KLV data object to remove
  ///
  HRESULT RemoveKLVData (
    [in] IAAFKLVData * pData);













}


// ************************
//
// Interface IAAFMobSlot
//
// ************************
///
/// The IAAFMobSlot interface is implemented by objects which represent
/// a Segment of essence in a Mob.  IAAFMobSlot-implementing objects
/// contan a Segment, which can be a timeline, static, or event Segment.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it through
///     this object's primary interface.  Note that IAAFMobSlot is a
///     primary interface for an abstract class, so it is not
///     appropriate for the Initialize() method to exist in this
///     interface.  The Initialize() method is available through the
///     concrete object's primary interface.
///
/// Types required by this module:
///
/// aafBool
/// aafRational_t
/// AAFSegment
/// aafPosition_t
/// aafSlotID_t
/// aafUInt32
/// AAFDataDef
///
///
/// Objects that implement IAAFMobSlot also implement the following interfaces:
///  - IAAFObject
[
    object,
    uuid(B1A21376-1A7D-11D2-BF78-00104BC9156D),
    helpstring("IAAFMobSlot Interface"),
    pointer_default(unique)
]
interface IAAFMobSlot : IUnknown
{

  //***********************************************************
  //
  // GetSegment()
  //
  /// This method will get the segment for this mob slot and place an
  /// interface for it into the **ppResult argument.  If a segment
  /// exists, the result will be AddRef()ed.  If not, the result will
  /// be NULL.
  ///
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult arg is NULL.
  /// 
  /// @param ppResult [out,retval] Segment property value
  ///
  HRESULT GetSegment (
    [out,retval] IAAFSegment ** ppResult);


  //***********************************************************
  //
  // SetName()
  //
  /// Sets the Mob Slot Name string property.
  ///
  /// Set the Name property to the value specified in
  /// pName.  A copy is made of the data so the caller
  /// retains ownership of the *pName buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pName pointer is valid.
  /// 
  /// If this method fails the Name property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  /// 
  /// @param pName [in, string] buffer from which Name is to be read
  ///
  HRESULT SetName (
    [in, string] aafCharacter_constptr  pName);


  //***********************************************************
  //
  // GetName()
  //
  /// Gets the Mob Slot Name string property.
  /// 
  /// Writes the Name property, with a trailing null
  /// character, into the pName buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the Name property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetNameBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pName.
  /// 
  /// Succeeds if:
  /// - The pName pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   Name.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold Name.
  /// 
  /// @param pName [out, string, size_is(bufSize)] buffer into which Name is to be written
  /// @param bufSize [in] size of *pName buffer in bytes
  ///
  HRESULT GetName (
    [out, string, size_is(bufSize)] aafCharacter *  pName,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetNameBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetName().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetNameBufLen (
    [out] aafUInt32 *  pBufSize);


  //***********************************************************
  //
  // GetPhysicalNum()
  //
  /// Returns information about the physical output channel associated
  /// with the  Slot.
  ///
  /// This function returns the physical slot number of the specified
  /// slot. The physical slot number identifies the physical slot
  /// associated with the media.  For File Source Mobs that describe
  /// stereo audio media, the left channel should have a PhysicalSlot
  /// of 1 and the right channel should have a Physical-Slot of 2.
  ///
  /// The function returns an error if the object specified in the slot
  /// parameter is not a slot.
  ///
  /// Succeeds if all of the following are true:
  /// - the pDatadef pointer is valid.
  /// - the object in the slot parameter is a slot.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDatadef arg is NULL.
  ///
  /// AAFRESULT_SLOT_NOT_FOUND
  ///   - object specified is not a slot.
  /// 
  /// @param pResult [out,retval] The physical slot number property value
  ///
  HRESULT GetPhysicalNum (
    [out,retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // GetDataDef()
  //
  /// This method will return the Data Definition object
  /// associated with the segment in this Mob Slot.  Common
  /// DataDefinitions are kAAFDataDef_Picture, kAAFDataDef_Sound, kAAFDataDef_Timecode,
  /// and kAAFDataDef_Edgecode.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppResult arg is NULL.
  /// 
  /// @param ppResult [out,retval] Data Definition AUID
  ///
  HRESULT GetDataDef (
    [out,retval] IAAFDataDef ** ppResult);


  //***********************************************************
  //
  // GetSlotID()
  //
  /// This method will return the slot id of this mob slot.
  ///
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult arg is NULL.
  /// 
  /// @param pResult [out,retval] Slot id of the Mob Slot
  ///
  HRESULT GetSlotID (
    [out,retval] aafSlotID_t *  pResult);


  //***********************************************************
  //
  // SetSegment()
  //
  /// This method will set the segment for this mob slot.  If a segment
  /// already exists for this mob slot, it will be discarded.
  /// 
  /// Always succeeds.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param pSegment [in] Segment property value
  ///
  HRESULT SetSegment (
    [in] IAAFSegment * pSegment);


  //***********************************************************
  //
  // SetPhysicalNum()
  //
  /// This function sets the physical slot number of the specified
  /// slot.  The physical slot number identifies the physical slot
  /// associated with the media.  For File Source Mobs that describe
  /// stereo audio media, the left channel should have a PhysicalSlot
  /// of 1 and the right channel should have a Physical-Slot of 2.
  ///
  /// The function returns an error if the Mob Slot passed in is not a
  /// slot.
  /// 
  /// Succeeds if all of the following are true:
  /// - the Mob Slot passed in is a slot.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.
  ///
  /// AAFRESULT_SLOT_NOT_FOUND
  ///   - object specified is not a slot.
  /// 
  /// @param number [in] The physical slot number property value
  ///
  HRESULT SetPhysicalNum (
    [in] aafUInt32  number);


  //***********************************************************
  //
  // SetSlotID()
  //
  /// This method will set the slot id of this mob slot.
  /// 
  /// Always succeeds.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param value [in] Slot id of the Mob Slot
  ///
  HRESULT SetSlotID (
    [in] aafSlotID_t  value);
}



// ************************
//
// Interface IAAFMPEGVideoDescriptor
//
// ************************
///
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
///
/// Objects that implement IAAFMPEGVideoDescriptor also implement the following interfaces:
///  - IAAFCDCIDescriptor
///  - IAAFCDCIDescriptor2
///  - IAAFDigitalImageDescriptor
///  - IAAFDigitalImageDescriptor2
///  - IAAFFileDescriptor
///  - IAAFFileDescriptor2
///  - IAAFEssenceDescriptor
///  - IAAFObject
[
    object,
    uuid(f2768aac-ed68-4ace-a8a3-3304e94c799f),
    helpstring("IAAFMPEGVideoDescriptor Interface"),
    pointer_default(unique)
]
interface IAAFMPEGVideoDescriptor : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty
  /// IAAFMPEGVideoDescriptor-supporting object.  This method must be
  /// called after allocation, and before any other method can be
  /// called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  /// 
  HRESULT Initialize ();


  //***********************************************************
  //
  // SetSingleSequence()
  //
  /// Sets the SingleSequence property. This property is optional.
  /// 
  /// If this method fails, the SingleSequence property will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// 
  /// @param singleSequence [in] value to assign to the SingleSequence property
  ///
  HRESULT SetSingleSequence (
    [in] aafBoolean_t  singleSequence);


  //***********************************************************
  //
  // GetSingleSequence()
  //
  /// Gets the SingleSequence property.
  ///
  /// Succeeds if all of the following are true:
  /// - pSingleSequence is a valid pointer
  /// - the property is present.
  ///
  /// If this method fails, pSingleSequence will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSingleSequence is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pSingleSequence [out] The value of the SingleSequence property
  ///
  HRESULT GetSingleSequence (
    [out] aafBoolean_t *  pSingleSequence);


  //***********************************************************
  //
  // SetConstantBPictureCount()
  //
  /// Sets the ConstantBPictureCount property. This property is optional.
  /// 
  /// If this method fails, the ConstantBPictureCount property will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// 
  /// @param constantBPictureCount [in] value to assign to the ConstantBPictureCount property
  ///
  HRESULT SetConstantBPictureCount (
    [in] aafBoolean_t  constantBPictureCount);


  //***********************************************************
  //
  // GetConstantBPictureCount()
  //
  /// Gets the ConstantBPictureCount property.
  ///
  /// Succeeds if all of the following are true:
  /// - pConstantBPictureCount is a valid pointer
  /// - the property is present.
  ///
  /// If this method fails, pConstantBPictureCount will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSingleSequence is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pConstantBPictureCount [out] value of the ConstantBPictureCount property
  ///
  HRESULT GetConstantBPictureCount (
    [out] aafBoolean_t *  pConstantBPictureCount);


  //***********************************************************
  //
  // SetCodedContentScanning()
  //
  /// Sets the CodedContentScanning property.  This property is optional.
  ///
  /// Succeeds if all of the following are true:
  /// - codedContentDirection is a valid value.
  /// 
  /// If this method fails, the CodedContentScanning property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_AAFRESULT_INVALID_ENUM_VALUE
  ///   - codedContentDirection is not a valid value.
  /// 
  /// @param codedContentScanning [in] Coded Content Scanning value.
  ///
  HRESULT SetCodedContentScanning (
    [in] aafContentScanningType_t  codedContentScanning);


  //***********************************************************
  //
  // GetCodedContentScanning()
  //
  /// Gets the CodedContentScanning property.  This property is optional.
  ///
  /// Succeeds if all of the following are true:
  /// - pContentScanning is a valid pointer
  /// - the property is present.
  /// 
  /// If this method fails, pSContentScanning not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pContentScanning is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pContentScanning [out] Coded content scanning value.
  ///
  HRESULT GetCodedContentScanning (
    [out] aafContentScanningType_t *  pContentScanning);


  //***********************************************************
  //
  // SetLowDelay()
  //
  /// Sets the LowDelay property.  This property is optional.
  ///
  /// If this method fails, the LowDelay property will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// 
  /// @param lowDelay [in] value to assign to the LowDelay property
  ///
  HRESULT SetLowDelay (
    [in] aafBoolean_t  lowDelay);


  //***********************************************************
  //
  // GetLowDelay()
  //
  /// Gets the LowDelay property.
  ///
  /// Succeeds if all of the following are true:
  /// - pLowDelay is a valid pointer
  /// - the property is present.
  ///
  /// If this method fails, pLowDelay will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLowDelay is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pLowDelay [out] value of the LowDelay property
  ///
  HRESULT GetLowDelay (
    [out] aafBoolean_t *  pLowDelay);


  //***********************************************************
  //
  // SetClosedGOP()
  //
  /// Sets the ClosedGOP property. This property is optional.
  /// 
  /// If this method fails, the ClosedGOP property will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// 
  /// @param closedGOP [in] value to assign to the ClosedGOP property
  ///
  HRESULT SetClosedGOP (
    [in] aafBoolean_t  closedGOP);


  //***********************************************************
  //
  // GetClosedGOP()
  //
  /// Gets the ClosedGOP property.
  ///
  /// Succeeds if all of the following are true:
  /// - pClosedGOP is a valid pointer
  /// - the property is present.
  ///
  /// If this method fails, pClosedGOP will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pClosedGOP is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pClosedGOP [out] value of the ClosedGOP property
  ///
  HRESULT GetClosedGOP (
    [out] aafBoolean_t *  pClosedGOP);


  //***********************************************************
  //
  // SetIdenticalGOP()
  //
  /// Sets the IdenticalGOP property. This is an optional property.
  /// 
  /// If this method fails, the IdenticalGOP property will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// 
  /// @param identicalGOP [in] value to assign to the IdenticalGOP property
  ///
  HRESULT SetIdenticalGOP (
    [in] aafBoolean_t  identicalGOP);


  //***********************************************************
  //
  // GetIdenticalGOP()
  //
  /// Gets the IdenticalGOP property.
  ///
  /// Succeeds if all of the following are true:
  /// - pIdenticalGOP is a valid pointer
  /// - the property is present.
  ///
  /// If this method fails, pIdenticalGOP will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pIdenticalGOP is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pIdenticalGOP [out] value of the IdenticalGOP property
  ///
  HRESULT GetIdenticalGOP (
    [out] aafBoolean_t *  pIdenticalGOP);


  //***********************************************************
  //
  // SetMaxGOP()
  //
  /// Sets the MaxGOP property. This is an optional property.
  ///
  /// If this method fails, the MaxGOP property will not be
  /// changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param maxGOP [in] value to assign to the MaxGOP property
  ///
  HRESULT SetMaxGOP (
    [in] aafUInt16  maxGOP);

  //***********************************************************
  //
  // GetMaxGOP()
  //
  /// Gets the MaxGOP property.
  ///
  /// Succeeds if all of the following are true:
  /// - pMaxGOP is a valid pointer
  /// - the property is present.
  ///
  /// If this method fails, pMaxGOP will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMaxGOP is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pMaxGOP [out] value of the MaxGOP property
  ///
  HRESULT GetMaxGOP (
    [out] aafUInt16 *  pMaxGOP);


  //***********************************************************
  //
  // SetMaxBPictureCount()
  //
  /// Sets the MaxBPictureCount property. This is an optional property.
  ///
  /// If this method fails, the MaxBPictureCount property will not be
  /// changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param maxBPictureCount [in] value to assign to the MaxBPictureCount property
  ///
  HRESULT SetMaxBPictureCount (
    [in] aafUInt16  maxBPictureCount);

  //***********************************************************
  //
  // GetMaxBPictureCount()
  //
  /// Gets the MaxBPictureCount property.
  ///
  /// Succeeds if all of the following are true:
  /// - pMaxBPictureCount is a valid pointer
  /// - the property is present.
  ///
  /// If this method fails, pMaxBPictureCount will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMaxBPictureCount is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pMaxBPictureCount [out] valud of the MaxBPictureCount property
  ///
  HRESULT GetMaxBPictureCount (
    [out] aafUInt16 *  pMaxBPictureCount);


  //***********************************************************
  //
  // SetBitRate()
  //
  /// Sets the BitRate property. This is an optional property.
  ///
  /// If this method fails, the BitRate property will not be
  /// changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param bitRate [in] value to assign to the BitRate property
  ///
  HRESULT SetBitRate (
    [in] aafUInt32  bitRate);

  //***********************************************************
  //
  // GetBitRate()
  //
  /// Gets the BitRate property.
  ///
  /// Succeeds if all of the following are true:
  /// - pBitRate is a valid pointer
  /// - the property is present.
  ///
  /// If this method fails, pBitRate will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBitRate is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pBitRate [out] value of the BitRate property
  ///
  HRESULT GetBitRate (
    [out] aafUInt32 *  pBitRate);


  //***********************************************************
  //
  // SetProfileAndLevel()
  //
  /// Sets the ProfileAndLevel property. This is an optional property.
  ///
  /// If this method fails, the ProfileAndLevel property will not be
  /// changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param profileAndLevel [in] value to assign to the ProfileAndLevel property
  ///
  HRESULT SetProfileAndLevel (
    [in] aafUInt8  profileAndLevel);

  //***********************************************************
  //
  // GetProfileAndLevel()
  //
  /// Gets the ProfileAndLevele property.
  ///
  /// Succeeds if all of the following are true:
  /// - pProfileAndLevel is a valid pointer
  /// - the property is present.
  ///
  /// If this method fails, pProfileAndLevel will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pProfileAndLevel is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pProfileAndLevel [out] value of the ProfileAndLevel property
  ///
  HRESULT GetProfileAndLevel (
    [out] aafUInt8 *  pProfileAndLevel);

}



// ************************
//
// Interface IAAFMultipleDescriptor
//
// ************************
///
/// The IAAFMultipleDescriptor interface is implemented by objects which
/// describe the format of the content data associated with a File
/// Source mob containing multiple tracks of essence.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it through
///     this object's primary interface.
///
///
/// Objects that implement IAAFMultipleDescriptor also implement the following interfaces:
///  - IAAFFileDescriptor
///  - IAAFFileDescriptor2
///  - IAAFEssenceDescriptor
///  - IAAFObject
[
    object,
    uuid(dabf53cf-1ec3-43a2-9418-f22fb87c38f4),
    helpstring("IAAFMultipleDescriptor Interface"),
    pointer_default(unique)
]

interface IAAFMultipleDescriptor : IUnknown
{


  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty
  /// IAAFMultipleDescriptor-supporting object.  This method must be
  /// called after allocation, and before any other method can be
  /// called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  /// 
  HRESULT Initialize ();

  //***********************************************************
  //
  // CountFileDescriptors()
  //
  /// Return the number of FileDescriptors attached to this essence
  /// descriptor.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pCount pointer is valid.
  /// 
  /// If this method fails nothing is written to *pCount.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCount is null.
  /// 
  /// @param pResult [out] Returns the number of FileDescriptors
  ///
  HRESULT CountFileDescriptors (
    [out] aafUInt32 *  pResult);


  //***********************************************************
  //
  // AppendFileDescriptor()
  //
  /// Append another FileDescriptor to this essence descriptor.  Use this
  /// function to add a FileDescriptor to the end of the interleave pattern.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pFileDescriptor pointer is valid.
  /// - the pFileDescriptor pointer indicates an object which is not already
  ///   owned by any object
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFileDescriptor is null.
  ///
  /// AAFRESULT_OBJECT_ALREADY_ATTACHED
  ///   - the object pointed to by pFileDescriptor is already owned by this
  ///     or another object.
  /// 
  /// @param pFileDescriptor [in] FileDescriptor to append
  ///
  HRESULT AppendFileDescriptor (
    [in] IAAFFileDescriptor * pFileDescriptor);


  //***********************************************************
  //
  // PrependFileDescriptor()
  //
  /// Prepend another FileDescriptor to this essence descriptor.  Use this
  /// function to add a FileDescriptor to to the beginning of the interleave pattern.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pFileDescriptor pointer is valid.
  /// - the pFileDescriptor pointer indicates an object which is not already
  ///   owned by any object
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFileDescriptor is null.
  ///
  /// AAFRESULT_OBJECT_ALREADY_ATTACHED
  ///   - the object pointed to by pFileDescriptor is already owned by this
  ///     or another object.
  /// 
  /// @param pFileDescriptor [in] FileDescriptor to append
  ///
  HRESULT PrependFileDescriptor (
    [in] IAAFFileDescriptor * pFileDescriptor);


  //***********************************************************
  //
  // InsertFileDescriptorAt()
  //
  /// Inserts the given FileDescriptor at the given index.  FileDescriptors already
  /// existing at the given and higher indices will be moved to the
  /// next higher index to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pFileDescriptor pointer is valid.
  /// - index is less than or equal to the value returned by
  ///   CountFileDescriptors().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFileDescriptor is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than the value returned by
  ///     CountFileDescriptors().
  /// 
  /// @param index [in] index at which FileDescriptor is to be inserted
  /// @param pFileDescriptor [in] FileDescriptor to append
  ///
  HRESULT InsertFileDescriptorAt (
    [in] aafUInt32  index,
    [in] IAAFFileDescriptor * pFileDescriptor);


  //***********************************************************
  //
  // GetFileDescriptorAt()
  //
  /// Retrieves the FileDescriptor at the given index.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pFileDescriptor pointer is valid.
  /// - index is less than the value returned by CountFileDescriptors().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFileDescriptor is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than or equal to the value returned by
  ///     CountFileDescriptors().
  /// 
  /// @param index [in] index of FileDescriptor to retrieve
  /// @param ppFileDescriptor [out, retval] returned FileDescriptor
  ///
  HRESULT GetFileDescriptorAt (
    [in] aafUInt32  index,
    [out, retval] IAAFFileDescriptor ** ppFileDescriptor);


  //***********************************************************
  //
  // RemoveFileDescriptorAt()
  //
  /// Removes the FileDescriptor at the given index.  FileDescriptors already
  /// existing at indices higher than the given index will be moved to
  /// the next lower index to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - index is less than the value returned by CountFileDescriptors().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than or equal to the value returned by
  ///     CountFileDescriptors().
  /// 
  /// @param index [in] index of FileDescriptor to remove
  ///
  HRESULT RemoveFileDescriptorAt (
    [in] aafUInt32  index);


  //***********************************************************
  //
  // GetFileDescriptors()
  //
  /// Returns an enumerator of all the FileDescriptors in 
  /// this MultipleDescriptor.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  /// 
  /// @param ppEnum [out] An enumerator of the FileDescriptors in this MultipleDescriptor
  ///
  HRESULT GetFileDescriptors (
    [out] IEnumAAFFileDescriptors ** ppEnum);

}



// ************************
//
// Interface IAAFNestedScope
//
// ************************
///
/// This interface is used with an object which contains an ordered set
/// of AAFSegments and produces the value specified by the last
/// AAFSegement in the ordered seta reference to a segment.
/// AAFNestedScopes are used to encapsulate intermediate results which
/// may be referenced from more than one place, in a manner much like
/// common subexpressions in mathmatical expressions.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
///
/// Objects that implement IAAFNestedScope also implement the following interfaces:
///  - IAAFSegment
///  - IAAFComponent
///  - IAAFComponent2
///  - IAAFObject
[
    object,
    uuid(e44be451-2099-11d2-bf98-006097116212),
    helpstring("IAAFNestedScope Interface"),
    pointer_default(unique)
]
interface IAAFNestedScope : IUnknown
{

  //***********************************************************
  //
  // AppendSegment()
  //
  /// Append another input segment to the list of source segments.  The
  /// last segment added will be used as the output of the nested
  /// scope, and usually contains operations whose inputs are scope
  /// references.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pSegment pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSegment is null.
  /// 
  /// @param pSegment [in] Pointer to segment to be added
  ///
  HRESULT AppendSegment (
    [in] IAAFSegment * pSegment);


  //***********************************************************
  //
  // PrependSegment()
  //
  /// Prepend another input segment to the list of source segments.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pSegment pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSegment is null.
  /// 
  /// @param pSegment [in] Pointer to segment to be added
  ///
  HRESULT PrependSegment (
    [in] IAAFSegment * pSegment);


  //***********************************************************
  //
  // InsertSegmentAt()
  //
  /// Insert an input segment to the list of source segments at the
  /// given index.  Segments already existing at the given and higher
  /// indices will be moved up one index to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pSegment pointer is valid.
  /// - index is less than or equal to the value returned by
  ///   CountSegments().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSegment is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than the value returned by
  ///     CountSegments().
  /// 
  /// @param index [in] index where segment is to be inserted
  /// @param pSegment [in] Pointer to segment to be added
  ///
  HRESULT InsertSegmentAt (
    [in] aafUInt32  index,
    [in] IAAFSegment * pSegment);


  //***********************************************************
  //
  // RemoveSegmentAt()
  //
  /// Removes the indexed segment.  Segments already existing at
  /// indices greater than the given index will be moved down by one
  /// index to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pSegment pointer is valid.
  /// - index is less than the value returned by CountSegments().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSegment is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than or equal to the value returned by
  ///     CountSegments().
  /// 
  /// @param index [in] index of segment to be removed
  ///
  HRESULT RemoveSegmentAt (
    [in] aafUInt32  index);


  //***********************************************************
  //
  // CountSegments()
  //
  /// Returns the number of source segments currently contained.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails no value will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  /// 
  /// @param pResult [out, retval] number of segments contained
  ///
  HRESULT CountSegments (
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // GetSegmentAt()
  //
  /// Retrieves the indexed segment.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// - index is less than the value returned by CountSegments().
  /// 
  /// If this method fails nothing will be written to *ppSegment.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than or equal to the value returned by
  ///     CountSegments().
  /// 
  /// @param index [in] index of segment to retrieve
  /// @param ppSegment [out, retval] retrieved segment
  ///
  HRESULT GetSegmentAt (
    [in] aafUInt32  index,
    [out, retval] IAAFSegment ** ppSegment);


  //***********************************************************
  //
  // GetSegments()
  //
  /// Return an enumerator for the ordered list of AAFSegments which
  /// make up the nested scope.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  /// 
  /// @param ppEnum [out, retval] Slots - segment list  enumeration
  ///
  HRESULT GetSegments (
    [out, retval] IEnumAAFSegments ** ppEnum);
}



// ************************
//
// Interface IAAFNetworkLocator
//
// ************************
///
/// The IAAFNetworkLocator interface is implemented by objects which
/// provide information to help find a file containing essence data.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it through
///     this object's primary interface.
///


///
/// Objects that implement IAAFNetworkLocator also implement the following interfaces:
///  - IAAFLocator
///  - IAAFObject
[
    object,
    uuid(2c1097b2-69d6-11d2-841b-00600832acb8),
    helpstring("IAAFNetworkLocator Interface"),
    pointer_default(unique)
]
interface IAAFNetworkLocator : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty
  /// IAAFNetworkLocator-supporting object.  This method must be called
  /// after allocation, and before any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  /// 
  HRESULT Initialize ();









}



// ************************
//
// Interface IAAFObject
//
// ************************
///
/// This interface is implemented for all AAF persistent classes.  In
/// addition to methods which all clients can use, it provides methods
/// for direct property access which should not be used unless the
/// client programmer is aware of the liabilities.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it through
///     this object's primary interface.  Note that IAAFObject is a
///     primary interface for an abstract class, so it is not
///     appropriate for the Initialize() method to exist in this
///     interface.  The Initialize() method is available through the
///     concrete object's primary interface.
[
    object,
    uuid(B1A213AB-1A7D-11D2-BF78-00104BC9156D),
    helpstring("IAAFObject Interface"),
    pointer_default(unique)
]
interface IAAFObject : IUnknown
{

  //***********************************************************
  //
  // GetGeneration()
  //
  /// Gets the generation of this object, which is represented by an
  /// AAFIdentification object.  This is used to detect when an object
  /// has been modified.
  ///
  /// This method will succeed if generation tracking is enabled for
  /// this object.  Call EnableGenerationTrackint() and
  /// DisableGenerationTrackint() to control generation tracking for
  /// this object.  Call IsGenerationTracked() to determine if
  /// generation tracking is currently enabled for this object.
  ///
  /// Succeeds if all of the following are true:
  /// - the given pGeneration pointer is valid.
  /// - generation tracking is enabled for this object.
  /// - this object is attached to a file.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppGeneration arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - Generation tracking is not enabled for this object.
  ///
  /// AAFRESULT_OBJECT_NOT_ATTACHED
  ///   - This object is not attached to a file from which generation
  ///     information can be obtained..
  /// 
  /// @param ppGeneration [out] AAFIdentification object corresponding to this object's
  /// Generation ID
  ///
  HRESULT GetGeneration (
    [out] IAAFIdentification ** ppGeneration);


  //***********************************************************
  //
  // GetGenerationAUID()
  //
  /// Shortcut to get the AUID representing the Identification
  /// representing this object's generation.  (Can also be obtained by
  /// calling this->GetGeneration(&pIdent), and using its result to
  /// call pIdent->GetAuid()).
  ///
  /// This method will succeed if generation tracking is enabled for
  /// this object.  Call EnableGenerationTrackint() and
  /// DisableGenerationTrackint() to control generation tracking for
  /// this object.  Call IsGenerationTracked() to determine if
  /// generation tracking is currently enabled for this object.
  ///
  /// Succeeds if all of the following are true:
  /// - the given pResult pointer is valid.
  /// - generation tracking is enabled for this object.
  /// - this object is attached to a file.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - Generation tracking is not enabled for this object.
  ///
  /// AAFRESULT_OBJECT_NOT_ATTACHED
  ///   - This object is not attached to a file from which generation
  ///     information can be obtained..
  /// 
  /// @param pResult [out] AUID corresponding to this object's Generation ID
  ///
  HRESULT GetGenerationAUID (
    [out] aafUID_t *  pResult);


  //***********************************************************
  //
  // GetDefinition()
  //
  /// Returns the class definition which describes this object
  /// instance.
  ///
  /// Succeeds if all of the following are true:
  /// - the given ppClassDef pointer is valid.
  ///
  /// Note! Use care when dealing with the object class.  Among the
  /// pitfalls to be avoided is that tests for equality will not
  /// reflect inheritance.  This becomes important if an unknown
  /// non-builtin (that is, user defined) object class ID is obtained.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppClassDef arg is NULL.
  /// 
  /// @param ppClassDef [out] class definition of which this object is an instance.
  ///
  HRESULT GetDefinition (
    [out] IAAFClassDef ** ppClassDef);


  //***********************************************************
  //
  // GetProperties()
  //
  /// Returns an enumerator across all properties actually contained in
  /// this object.  Each property is represented by an IAAFProperty
  /// interface.
  /// 
  ///
  /// *ppEnum is AddRef()ed before it is returned.
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// Note! This is a low-level method which allows direct access to
  /// properties.  If such access is done, any semantic checking (such
  /// as that which is performed in all other named property Get/Set
  /// methods) is not done here.  Users must use this method at their
  /// own risk.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  /// 
  /// @param ppEnum [out, retval] Property Enumeration
  ///
  HRESULT GetProperties (
    [out, retval] IEnumAAFProperties ** ppEnum);


  //***********************************************************
  //
  // CountProperties()
  //
  /// Returns the number of properties currently present in this
  /// object.  This is the same number as will be accessed through
  /// GetProperties().
  /// 
  /// Note! This is a low-level method which allows direct access to
  /// properties.  If such access is done, any semantic checking (such
  /// as that which is performed in all other named property Get/Set
  /// methods) is not done here.  Users must use this method at their
  /// own risk.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCount arg is NULL.
  /// 
  /// @param pCount [out] count of properties present in this object
  ///
  HRESULT CountProperties (
    [out] aafUInt32 *  pCount);


  //***********************************************************
  //
  // GetPropertyValue()
  //
  /// Returns the requested Property Value.  The desired property data
  /// is identified by the given property definition.
  /// 
  /// Note! This is a low-level method which allows direct access to
  /// properties.  If such access is done, any semantic checking (such
  /// as that which is performed in all other named property Get/Set
  /// methods) is not done here.  Users must use this method at their
  /// own risk.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPropDef or ppPropVal arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_PROPERTY
  ///   - named property illegal for this object's class.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - named property is optional, but not present in this class.
  /// 
  /// @param pPropDef [in] property definition indentifying desired property
  /// @param ppPropVal [out] returned AAFPropertyValue
  ///
  HRESULT GetPropertyValue (
    [in] IAAFPropertyDef * pPropDef,
    [out] IAAFPropertyValue ** ppPropVal);


  //***********************************************************
  //
  // SetPropertyValue()
  //
  /// Sets the value of the given property to the given value.  If the
  /// selected property is optional but not yet present, will make the
  /// property present before setting its value.
  ///
  /// Note! This is a low-level method which allows direct access to
  /// properties.  If such access is done, any semantic checking (such
  /// as that which is performed in all other named property Get/Set
  /// methods) is not done here.  Users must use this method at their
  /// own risk.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPropDef or ppPropVal arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_PROPERTY
  ///   - named property illegal for this object's class.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - named property is optional, but not present in this class.
  /// 
  /// @param pPropDef [in] property definition indentifying desired property
  /// @param pPropVal [in] value to set.
  ///
  HRESULT SetPropertyValue (
    [in] IAAFPropertyDef * pPropDef,
    [in] IAAFPropertyValue * pPropVal);


  //***********************************************************
  //
  // IsPropertyPresent()
  //
  /// Sets *pResultReturns true in if named property is legal and is
  /// present; sets it to false if it is legal and is absent.
  /// 
  /// Note! This is a low-level method which allows direct access to
  /// properties.  If such access is done, any semantic checking (such
  /// as that which is performed in all other named property Get/Set
  /// methods) is not done here.  Users must use this method at their
  /// own risk.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_PROPERTY
  ///   - named property illegal for this object's class.
  /// 
  /// @param pPropDef [in] property definition indentifying desired property
  /// @param pResult [out] true if present; false if not present
  ///
  HRESULT IsPropertyPresent (
    [in] IAAFPropertyDef * pPropDef,
    [out] aafBoolean_t*  pResult);


  //***********************************************************
  //
  // RemoveOptionalProperty()
  //
  /// Removes the property if named property is legal and is
  /// optional and present.
  /// 
  /// Note! This is a low-level method which allows direct access to
  /// properties.  If such access is done, any semantic checking (such
  /// as that which is performed in all other named property Get/Set
  /// methods) is not done here.  Users must use this method at their
  /// own risk.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_PROPERTY
  ///   - named property illegal for this object's class.
  /// 
  /// @param pPropDef [in] property definition indentifying desired property
  ///
  HRESULT RemoveOptionalProperty (
    [in] IAAFPropertyDef * pPropDef);


  //***********************************************************
  //
  // CreateOptionalPropertyValue()
  //
  /// Returns the requested Property Value.  The desired property data
  /// is identified by the given optional property definition.
  /// 
  /// Note! This is a low-level method which allows direct access to
  /// properties.  If such access is done, any semantic checking (such
  /// as that which is performed in all other named property Get/Set
  /// methods) is not done here.  Users must use this method at their
  /// own risk.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPropDef or ppPropVal arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_PROPERTY
  ///   - named property illegal for this object's class.
  ///
  /// AAFRESULT_PROP_ALREADY_PRESENT
  ///   - named property is optional, but already present in this class.
  /// 
  /// @param pPropDef [in] property definition indentifying desired property
  /// @param ppPropVal [out] returned AAFPropertyValue
  ///
  HRESULT CreateOptionalPropertyValue (
    [in] IAAFPropertyDef * pPropDef,
    [out] IAAFPropertyValue ** ppPropVal);


  //***********************************************************
  //
  // GetDictionary()
  //
  /// Returns the dictionary for this object instance.
  ///
  /// Succeeds if all of the following are true:
  /// - the given ppDictionary pointer is valid.
  ///
  /// Note! Use care when dealing with the object class.  Among the
  /// pitfalls to be avoided is that tests for equality will not
  /// reflect inheritance.  This becomes important if an unknown
  /// non-builtin (that is, user defined) object class ID is obtained.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppClassDef arg is NULL.
  /// 
  /// @param ppDictionary [out, retval] A pointer to an Dictionary pointer
  ///
  HRESULT GetDictionary (
    [out, retval] IAAFDictionary ** ppDictionary);


  //***********************************************************
  //
  // EnableGenerationTracking()
  //
  /// Calling this method will cause generation tracking to be enabled
  /// for this object.  Generation information will then be available
  /// through the GetGeneration() and GetGenerationAUID() methods.
  /// 
  /// Calling the DisableGenerationTracking() method will disable
  /// generation tracking for this object.
  /// 
  /// Generation tracking is disabled by default.
  ///
  /// This method always succeeds, even if generation tracking is
  /// already enabled.
  /// 
  /// This method will return the following result:
  ///  - AAFRESULT_SUCCESS
  /// 
  HRESULT EnableGenerationTracking ();


  //***********************************************************
  //
  // DisableGenerationTracking()
  //
  /// Calling this method will cause generation tracking to be disabled
  /// for this object.  Generation information will then not be
  /// available through the GetGeneration() and GetGenerationAUID()
  /// methods.
  /// 
  /// Calling the EnableGenerationTracking() method will enable
  /// generation tracking for this object.
  /// 
  /// Generation tracking is disabled by default.
  ///
  /// This method always succeeds, even if generation tracking is
  /// already disbled.
  /// 
  /// This method will return the following result:
  ///  - AAFRESULT_SUCCESS
  /// 
  HRESULT DisableGenerationTracking ();


  //***********************************************************
  //
  // IsGenerationTracked()
  //
  /// This method will set *pResult to AAFTrue if generations are
  /// being tracked for this object.  A result of AAFTrue indicates
  /// that generation information will be available through the
  /// GetGeneration() and GetGenerationAUID() methods.
  /// 
  /// Calling the EnableGenerationTracking() method will enable
  /// generation tracking for this object; calling the
  /// DisableGenerationTracking() method will disable generation
  /// tracking for this object.
  /// 
  /// Generation tracking is disabled by default.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult arg is NULL.
  /// 
  /// @param pResult [out] set to true if generations are tracked; false otherwise
  ///
  HRESULT IsGenerationTracked (
    [out] aafBoolean_t *  pResult);
}



// ************************
//
// Interface IAAFOperationDef
//
// ************************
///
/// The IAAFOperationDef interface is implemented by objects that
/// specify an operation definition.  Operation definitions specify
/// which parameters are possible on an operation, while an
/// AAFOperationGroup specifies specific parameters and input segments
/// for a particular operation invocation.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///






 

///
/// Objects that implement IAAFOperationDef also implement the following interfaces:
///  - IAAFDefObject
///  - IAAFObject
[
    object,
    uuid(14035d91-1ff5-11d2-bf97-006097116212),
    helpstring("IAAFOperationDef Interface"),
    pointer_default(unique)
]
interface IAAFOperationDef : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Init all fields of a definition object.
  /// 
  /// @param id [in, ref] AUID for new DefObject
  /// @param pName [in, string] Name for new DefObject
  /// @param pDescription [in, string] Description for new DefObject
  ///
  HRESULT Initialize (
    [in, ref] aafUID_constref  id,
    [in, string] aafCharacter_constptr  pName,
    [in, string] aafCharacter_constptr  pDescription);


  //***********************************************************
  //
  // GetDataDef()
  //
  /// Places the DataDefinition object attached to this
  /// IAAFOperationDef into the *ppDataDef argument.  The data
  /// definition will match one of the AUIDs in the file
  /// AAFDataDefs.h, (which includes kAAFDataDef_Picture, and
  /// kAAFDataDef_Sound), and indicates what type of data the operation will
  /// be performed upon.  For example, a video dissolve will have the
  /// data def kAAFDataDef_Picture.  If a data definition is used which is not
  /// from AAFDataDefs.h, then the client is responsible for making
  /// sure that a data definition object with that ID exists in the
  /// dictionary.  The SDK will take care of creating the standard data
  /// definitions.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppDataDefID pointer is valid.
  /// - A valid DataDefinition exists.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDataDef is null.
  ///
  /// AAFRESULT_INVALID_DATA_DEF
  ///   - There is no IAAFDataDefinition.  There has to be one of some
  ///     kind for this to be a valid operation definition.
  /// 
  /// @param ppDataDef [out] Returned DataDefinition object
  ///
  HRESULT GetDataDef (
    [out] IAAFDataDef ** ppDataDef);


  //***********************************************************
  //
  // SetDataDef()
  //
  /// Sets the IAAFDataDefinition of this IAAFOperationDef to be the
  /// given one.  The
  /// data definition will match one of the AUIDs in the file
  /// AAFDataDefs.h, (which includes kAAFDataDef_Picture, and
  /// kAAFDataDef_Sound), and indicates what type of data the operation will
  /// be performed upon.  For example, a video dissolve will have the
  /// data def kAAFDataDef_Picture.  If a data definition is used which is not
  /// from AAFDataDefs.h, then the client is responsible for making
  /// sure that a data definition object with that ID exists in the
  /// dictionary.  The SDK will take care of creating the standard data
  /// definitions.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDataDef is null.
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param pDataDef [in] Essence Descriptor object
  ///
  HRESULT SetDataDef (
    [in] IAAFDataDef * pDataDef);


  //***********************************************************
  //
  // IsTimeWarp()
  //
  /// Returns the value of isTimeWarp.  IsTimeWarp is true if the
  /// length of an IAAFOperationGroup is different from the lengths of
  /// the input segments.  For example, a slow motion effect.
  ///
  /// Succeeds if all of the following are true:
  /// - the bIsTimeWarp pointer is valid.
  /// 
  /// If this method fails nothing will be written to *bIsTimeWarp.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - bIsTimeWarp arg is NULL.
  /// 
  /// @param bIsTimeWarp [out, retval] pointer to the return value
  ///
  HRESULT IsTimeWarp (
    [out, retval] aafBoolean_t *  bIsTimeWarp);


  //***********************************************************
  //
  // SetIsTimeWarp()
  //
  /// Sets the IsTimeWarp boolean.  IsTimeWarp is true if the length of
  /// an IAAFOperationGroup is different from the lengths of the input
  /// segments.  For example, a slow motion effect.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param IsTimeWarp [in] is timewarp value
  ///
  HRESULT SetIsTimeWarp (
    [in] aafBoolean_t  IsTimeWarp);


  //***********************************************************
  //
  // PrependDegradeToOperation()
  //
  /// Prepend another operation definition to the DegradeTo list of
  /// definitions.  Use this function to add an operation definition to
  /// be scanned first when searching for the a replacement (a more
  /// desirable alternate operation).
  /// 
  /// Succeeds if all of the following are true:
  /// - the pOperationDef pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pOperationDef is null.
  /// 
  /// @param pOperationDef [in] Degrade To Operation Definition Object
  ///
  HRESULT PrependDegradeToOperation (
    [in] IAAFOperationDef * pOperationDef);


  //***********************************************************
  //
  // AppendDegradeToOperation()
  //
  /// Append another operation definition to the DegradeTo list of
  /// definitions.  Use this function to add an operation definition to
  /// be scanned last when searching for the a replacement (a less
  /// desirable alternate operation).
  /// 
  /// Succeeds if all of the following are true:
  /// - the pOperationDef pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pOperationDef is null.
  /// 
  /// @param pOperationDef [in] Degrade To operation Definition Object
  ///
  HRESULT AppendDegradeToOperation (
    [in] IAAFOperationDef * pOperationDef);


  //***********************************************************
  //
  // InsertDegradeToOperationAt()
  //
  /// Insert an operation definition into the DegradeTo list of
  /// definitions at the given index.  Operation definitions already
  /// existing at the given and higher indices will be moved up to the
  /// next higher index to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pOperationDef pointer is valid.
  /// - index is less than or equal to the value returned by
  ///   CountDegradeToOperations().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pOperationDef is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than the value returned by
  ///     CountDegradeToOperations().
  /// 
  /// @param index [in] index where operation def is to be inserted
  /// @param pOperationDef [in] Degrade To operation Definition Object
  ///
  HRESULT InsertDegradeToOperationAt (
    [in] aafUInt32  index,
    [in] IAAFOperationDef * pOperationDef);


  //***********************************************************
  //
  // RemoveDegradeToOperationAt()
  //
  /// Removes the indexed operation definition from the DegradeTo list
  /// of definitions.  Operation definitions already existing at
  /// indices higher than the given index will be moved down to the
  /// next lower index to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - index is less than the value returned by
  ///   CountDegradeToOperations().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater or equal to than the value returned by
  ///     CountDegradeToOperations().
  /// 
  /// @param index [in] index where operation def is to be inserted
  ///
  HRESULT RemoveDegradeToOperationAt (
    [in] aafUInt32  index);


  //***********************************************************
  //
  // GetDegradeToOperations()
  //
  /// Return an enumerator for aaf operation definitions, ordered from
  /// the most desirable to the least desirable alternative.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  /// 
  /// @param ppEnum [out, retval] Operation Definition Enumeration
  ///
  HRESULT GetDegradeToOperations (
    [out, retval] IEnumAAFOperationDefs ** ppEnum);


  //***********************************************************
  //
  // CountDegradeToOperations()
  //
  /// Retrieves the number of Degrade To operations currently present
  /// and places that number in *pResult.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  /// 
  /// @param pResult [out, retval] resulting count of Degrade To operations
  ///
  HRESULT CountDegradeToOperations (
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // GetCategory()
  //
  /// This method returns an AUID indicating the category of the given operation.
  ///
  /// Succeeds if all of the following are true:
  /// - the pValue pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pValue.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pValue arg is NULL.
  /// 
  /// @param pValue [out] The enumeration describing the current category
  ///
  HRESULT GetCategory (
    [out] aafUID_t*  pValue);


  //***********************************************************
  //
  // SetCategory()
  //
  /// This method sets an AUID indicating the category of the given operation.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param value [in, ref] The enumeration describing the current categor
  ///
  HRESULT SetCategory (
    [in, ref] aafUID_constref  value);


  //***********************************************************
  //
  // GetNumberInputs()
  //
  /// Gets the Number of input media segments.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pNumberInputs pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pNumberInputs.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumberInputs arg is NULL.
  /// 
  /// @param pNumberInputs [out, retval] Pointer to Number of Inputs
  ///
  HRESULT GetNumberInputs (
    [out, retval] aafInt32 *  pNumberInputs);


  //***********************************************************
  //
  // SetNumberInputs()
  //
  /// Sets the Number of input media segments.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param NumberInputs [in] Number of Inputs
  ///
  HRESULT SetNumberInputs (
    [in] aafInt32  NumberInputs);


  //***********************************************************
  //
  // GetBypass()
  //
  /// Gets the Bypass media segment index, which is a value from 0
  /// to one less than that returned by GetNumberInputs().  This
  /// value allows the client application to pick one of the inputs
  /// (foreground, background, etc.) to stand in for the
  /// effect if it is not available, and none of the degrade to
  /// effects are available.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pBypass pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pBypass.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBypass arg is NULL.
  /// 
  /// @param pBypass [out,retval] Pointer to a Bypass media segment index 
  ///
  HRESULT GetBypass (
    [out,retval] aafUInt32 *  pBypass);


  //***********************************************************
  //
  // SetBypass()
  //
  /// Sets the media segment index, which is a value from 0 to one
  /// less than that returned by GetNumberInputs().  This value
  /// allows the client application to pick one of the inputs
  /// (foreground, background, etc.) to stand in for the
  /// effect if it is not available, and none of the degrade to
  /// effects are available.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param bypass [in] Bypass media segment index
  ///
  HRESULT SetBypass (
    [in] aafUInt32  bypass);


  //***********************************************************
  //
  // AddParameterDef()
  //
  /// Add the Parameter Definition object to the unordered list of
  /// parameter definitions. 
  /// 
  /// Succeeds if all of the following are true:
  /// - the pAAFParameterDef pointer is valid. 
  /// - the given Parameter Definition does not exists in this Operation
  ///   Definition already
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pAAFParameterDef is null.
  ///
  /// AAFRESULT_OBJECT_ALREADY_ATTACHED
  ///	- pAAFParameterDef is already in this OperationDef
  /// 
  /// @param pParameterDef [in] Parameter definition Object
  ///
  HRESULT AddParameterDef (
    [in] IAAFParameterDef * pParameterDef);


  //***********************************************************
  //
  // GetParameterDefs()
  //
  /// Return an enumerator for the unordered list of AAF Parameter
  /// definitions.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  /// 
  /// @param ppEnum [out,retval] Parameter definition enumeration
  ///
  HRESULT GetParameterDefs (
    [out,retval] IEnumAAFParameterDefs ** ppEnum);


  //***********************************************************
  //
  // CountParameterDefs()
  //
  /// This method returns the number of parameter defs.
  ///
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult arg is NULL.
  /// 
  /// @param pResult [out] Number of parameter defs
  ///
  HRESULT CountParameterDefs (
    [out] aafUInt32 *  pResult);


  //***********************************************************
  //
  // LookupParameterDef()
  //
  /// This method looks up the parameter def corresponding to the given
  /// ID.
  ///
  /// Succeeds if all of the following are true:
  /// - the given ID corresponds to a known parameter def
  /// - the ppParameterDef pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppParameterDef.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pParameterDef arg is NULL.
  ///
  /// AAFRESULT_OBJECT_NOT_FOUND
  ///   - given ID does not correspond to a known parameter def.
  /// 
  /// @param parameterDefId [in] ID of parameter def to look up
  /// @param ppParameterDef [out] resulting parameter def
  ///
  HRESULT LookupParameterDef (
    [in] aafUID_constref  parameterDefId,
    [out] IAAFParameterDef ** ppParameterDef);
}



// ************************
//
// Interface IAAFOperationGroup
//
// ************************
///
/// The IAAFOperationGroup interface is implemented by objects describe
/// an operation (such as an effect) affecting the interpretation of
/// zero or more input segments.  OperationGroup objects may include
/// any object implementing the IAAFSegment interface as source
/// material, including another nested OperationGroup object.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it through
///     this object's primary interface.  Note that IAAFMob is a
///     primary interface for an abstract class, so it is not
///     appropriate for the Initialize() method to exist in this
///     interface.  The Initialize() method is available through the
///     concrete object's primary interface.
///
///
/// Objects that implement IAAFOperationGroup also implement the following interfaces:
///  - IAAFSegment
///  - IAAFComponent
///  - IAAFComponent2
///  - IAAFObject
[
    object,
    uuid(3AE3BA82-2C98-11d2-8042-006008143E6F),
    helpstring("IAAFOperationGroup Interface"),
    pointer_default(unique)
]
interface IAAFOperationGroup : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes an operation group object with the given property
  /// values.
  ///
  /// This function takes an already created operation definition
  /// object as an argument.  To add slots to the operation group, call
  /// AddNewSlot.  To add renderings, call SetRender.
  /// 
  /// @param pDataDef [in] Data Definition Object
  /// @param length [in] Length property value
  /// @param operationDef [in] Operation Definition object
  ///
  HRESULT Initialize (
    [in] IAAFDataDef * pDataDef,
    [in] aafLength_t  length,
    [in] IAAFOperationDef * operationDef);


  //***********************************************************
  //
  // GetOperationDefinition()
  //
  /// Returns the operation definition for this invocation.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppOperationDef pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppOperationDef.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - This property does not exist in the file.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppOperationDef arg is NULL.
  /// 
  /// @param ppOperationDef [out] Operation definition object
  ///
  HRESULT GetOperationDefinition (
    [out] IAAFOperationDef ** ppOperationDef);

  //***********************************************************
  //
  // SetOperationDefinition()
  //
  /// This function sets the operation definition for the given operation
  /// group.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pOperationDef pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pOperationDef arg is NULL.
  /// 
  /// @param pOperationDef [in] Operation definition object
  ///
  HRESULT SetOperationDefinition (
    [in] IAAFOperationDef * pOperationDef);

  //***********************************************************
  //
  // GetRender()
  //
  /// Returns the segment that represents the optional rendering on an
  /// operation group object.  Working and final renderings are handled
  /// by using an IAAFEssenceGroup as the segment. 
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppSourceRef pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppSourceRef.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - This property does not exist in the file.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppSourceRef arg is NULL.
  /// 
  /// @param ppSourceRef [out] Final rendering segment
  ///
  HRESULT GetRender (
    [out] IAAFSourceReference ** ppSourceRef);


  //***********************************************************
  //
  // IsATimeWarp()
  //
  /// This boolean function returns whether or not an operation group
  /// is a timewarp effect.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pIsTimeWarp pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pIsTimeWarp.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pIsTimeWarp arg is NULL.
  /// 
  /// @param pIsTimeWarp [out, retval] Returned boolean value
  ///
  HRESULT IsATimeWarp (
    [out, retval] aafBoolean_t *  pIsTimeWarp);


  //***********************************************************
  //
  // GetBypassOverride()
  //
  /// Returns the optional bypass override propertyvalue from the input
  /// operation def object.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pBypassOverride pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pBypassOverride.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - This property does not exist in the file.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBypassOverride arg is NULL.
  /// 
  /// @param pBypassOverride [out] Bypass override property value
  ///
  HRESULT GetBypassOverride (
    [out] aafUInt32 *  pBypassOverride);


  //***********************************************************
  //
  // CountSourceSegments()
  //
  /// Returns the number of media sources to the operation group.
  ///
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult arg is NULL.
  /// 
  /// @param pResult [out] Number of source media segments in the operation group
  ///
  HRESULT CountSourceSegments (
    [out] aafUInt32 *  pResult);


  //***********************************************************
  //
  // IsValidTranOperation()
  //
  /// Verifies that the input operation group object can be used in a
  /// transition.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pValidTransition pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pValidTransition.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pValidTransition arg is NULL.
  /// 
  /// @param pValidTransition [out] TRUE if the operation group is valid in a transition
  ///
  HRESULT IsValidTranOperation (
    [out] aafBoolean_t *  pValidTransition);


  //***********************************************************
  //
  // CountParameters()
  //
  /// Returns the number of parameters in the operation group.
  ///
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult arg is NULL.
  /// 
  /// @param pResult [out] Number of parameter slots in the operation group
  ///
  HRESULT CountParameters (
    [out] aafUInt32 *  pResult);


  //***********************************************************
  //
  // AddParameter()
  //
  /// Adds a new parameter object.
  ///
  /// Succeeds if all of the following are true:
  /// - the pValue pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_DUPLICATE_PARAMETER
  ///   - The given argID is already present.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pValue arg is NULL.
  /// 
  /// @param pParameter [in] Parameter to place in operation group slot
  ///
  HRESULT AddParameter (
    [in] IAAFParameter * pParameter);


  //***********************************************************
  //
  // AppendInputSegment()
  //
  /// Appends another input segment to an operation group.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pSegment pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_DUPLICATE_INDEX
  ///   - The given index value is already present.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSegment arg is NULL.
  /// 
  /// @param pSegment [in] Segment to place in operation group
  ///
  HRESULT AppendInputSegment (
    [in] IAAFSegment * pSegment);


  //***********************************************************
  //
  // PrependInputSegment()
  //
  /// Prepends another input segment to an operation group.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pSegment pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_DUPLICATE_INDEX
  ///   - The given index value is already present.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSegment arg is NULL.
  /// 
  /// @param pSegment [in] Segment to place in operation group
  ///
  HRESULT PrependInputSegment (
    [in] IAAFSegment * pSegment);


  //***********************************************************
  //
  // InsertInputSegmentAt()
  //
  /// Inserts an input segment to an operation group at the given
  /// index.  The existing segments at the given and higher indices are
  /// moved up by one to make room.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pSegment pointer is valid.
  /// - the index is not greater than the value returned by
  ///   CountInputSegments().
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_DUPLICATE_INDEX
  ///   - The given index value is already present.
  ///
  /// AAFRESULT_BAD_INDEX
  ///   - index is greater than the value returned by
  ///     CountInputSegments().
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSegment arg is NULL.
  /// 
  /// @param index [in] index to place this segment
  /// @param pSegment [in] Segment to place in operation group
  ///
  HRESULT InsertInputSegmentAt (
    [in] aafUInt32  index,
    [in] IAAFSegment * pSegment);


  //***********************************************************
  //
  // SetRender()
  //
  /// This function sets the final rendering for the given operation
  /// group to the input source clip.  (Multiple renderings may exist if
  /// the source clip refers to a master mob that contains a Essence
  /// group.)
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppSourceRef pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppSourceRef arg is NULL.
  /// 
  /// @param ppSourceRef [in] A segment containing a representation of the rendering
  ///
  HRESULT SetRender (
    [in] IAAFSourceReference * ppSourceRef);


  //***********************************************************
  //
  // SetBypassOverride()
  //
  /// This function sets the optional bypass override property on the
  /// given operation group object.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param bypassOverride [in] Bypass override
  ///
  HRESULT SetBypassOverride (
    [in] aafUInt32  bypassOverride);


  //***********************************************************
  //
  // GetParameters()
  //
  /// returns an enumerator across all parameters.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  /// 
  /// @param ppEnum [out] Parameter enumerator
  ///
  HRESULT GetParameters (
    [out] IEnumAAFParameters ** ppEnum);


  //***********************************************************
  //
  // LookupParameter()
  //
  /// Given an argID, returns the corresponding parameter slot and
  /// parameter slot value.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppParameter pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppParameter.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_MISSING_PARAMETER
  ///   - The given argID is not present.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppParameter arg is NULL.
  /// 
  /// @param argID [in] Arg ID
  /// @param ppParameter [out] Parameter object
  ///
  HRESULT LookupParameter (
    [in] aafArgIDType_constref  argID,
    [out] IAAFParameter ** ppParameter);


  //***********************************************************
  //
  // GetInputSegmentAt()
  //
  /// Given an index, returns the corresponding input segment.
  /// Working and final renderings are handled by using an
  /// IAAFEssenceGroup as the segment.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppInputSegment pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppInputSegment.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_MISSING_INDEX
  ///   - The given index value is not present.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppInputSegment arg is NULL.
  /// 
  /// @param index [in] 0-based index into the effet inputs
  /// @param ppInputSegment [out] Input segment
  ///
  HRESULT GetInputSegmentAt (
    [in] aafUInt32  index,
    [out] IAAFSegment ** ppInputSegment);


  //***********************************************************
  //
  // RemoveInputSegmentAt()
  //
  /// Removes the segment at the given index.  Existing segments at
  /// higher indices are moved down by one to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - index is less than the result of CountInputSegments().
  /// 
  /// If this method fails no state will be changed.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_MISSING_INDEX
  ///   - The given index value is not present.
  /// 
  /// @param index [in] 0-based index into the effect inputs
  ///
  HRESULT RemoveInputSegmentAt (
    [in] aafUInt32  index);
}



// ************************
//
// Interface IAAFPCMDescriptor
//
// ************************
///
/// The IAAFPCMDescriptor interface is implemented by objects which
/// describe audio essence.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///


///
/// Objects that implement IAAFPCMDescriptor also implement the following interfaces:
///  - IAAFSoundDescriptor
///  - IAAFFileDescriptor
///  - IAAFFileDescriptor2
///  - IAAFEssenceDescriptor
///  - IAAFObject
[
    object,
    uuid(F17D58D8-5107-47e4-9ABA-8329FC1B2C84),
    helpstring("IAAFPCMDescriptor Interface"),
    pointer_default(unique)
]
interface IAAFPCMDescriptor : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, IAAFPCMDescriptor-supporting
  /// object. This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  /// 
  HRESULT Initialize ();


  //***********************************************************
  //
  // SetBlockAlign()
  //
  /// Sets the number of bytes used to store one sample of all channels.
  /// This property is required.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the BlockAlign property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  /// 
  /// @param blockAlign [in] The number of bytes used to store one sample of all channels.
  ///
  HRESULT SetBlockAlign (
    [in] aafUInt16  blockAlign);


  //***********************************************************
  //
  // GetBlockAlign()
  //
  /// Gets the number of bytes used to store one sample of all channels.
  /// This property is required.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pBlockAlign pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pBlockAlign.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBlockAlign arg is NULL.
  /// 
  /// @param pBlockAlign [out] The number of bytes used to store one sample of all channels.
  ///
  HRESULT GetBlockAlign (
    [out] aafUInt16 *  pBlockAlign);


  //***********************************************************
  //
  // SetSequenceOffset()
  //
  /// Sets the frame number of the beginning of the essence data
  /// within a five-frame sequence. This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the SequenceOffset property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  /// 
  /// @param offset [in] Zero-based ordinal frame number of the beginning of
	/// the essence data within a five-frame sequence.
  ///
  HRESULT SetSequenceOffset (
    [in] aafUInt8  offset);


  //***********************************************************
  //
  // GetSequenceOffset()
  //
  /// Gets the frame number of the beginning of the essence data
  /// within a five-frame sequence. This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pOffset pointer is valid.
  /// - the property is present.
  /// 
  /// If this method fails nothing will be written to *pOffset.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pOffset arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pOffset [out] Zero-based ordinal frame number of the beginning of
	/// the essence data within a five-frame sequence.
  ///
  HRESULT GetSequenceOffset (
    [out] aafUInt8 *  pOffset);


  //***********************************************************
  //
  // SetAverageBPS()
  //
  /// Sets the average bytes per second of the essence stream.
  /// This property is required.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the AverageBPS property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  /// 
  /// @param bps [in] Average bytes per second of the essence stream.
  ///
  HRESULT SetAverageBPS (
    [in] aafUInt32  bps);


  //***********************************************************
  //
  // GetAverageBPS()
  //
  /// Gets the average bytes per second of the essence stream.
  /// This property is required.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pBps pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pBps.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBps arg is NULL.
  /// 
  /// @param pBps [out] Average bytes per second of the essence stream.
  ///
  HRESULT GetAverageBPS (
    [out] aafUInt32 *  pBps);


  //***********************************************************
  //
  // SetChannelAssignment()
  //
  /// Sets the channel assignment scheme. This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the ChannelAssignment property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  /// 
  /// @param channelAssignment [in, ref] The channel assignment to use.
  ///
  HRESULT SetChannelAssignment (
    [in, ref] aafUID_constref  channelAssignment);


  //***********************************************************
  //
  // GetChannelAssignment()
  //
  /// Gets the channel assignment scheme. This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pChannelAssignment pointer is valid.
  /// - the property is present.
  /// 
  /// If this method fails nothing will be written to *pChannelAssignment.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pChannelAssignment arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pChannelAssignment [out] The channel assignment in use.
  ///
  HRESULT GetChannelAssignment (
    [out] aafUID_t *  pChannelAssignment);


  //***********************************************************
  //
  // AreAllPeakEnvelopePropertiesPresent()
  //
  /// Places TRUE into *pArePresent if the following optional
  /// properties are set on the descriptor:
  ///   PeakEnvelopeVersion
  ///   PeakEnvelopeFormat
  ///   PointsPerPeakValue
  ///   PeakEnvelopeBlockSize
  ///   PeakChannels
  ///   PeakFrames
  ///   PeakOfPeaksPosition
  ///   PeakEnvelopeTimestamp
  ///   PeakEnvelopeData
  ///
  /// Succeeds if all of the following are true:
  /// - the pArePresent pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pIsPresent.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pArePresent arg is NULL.
  /// 
  /// @param pArePresent [out] The flag indicating presence of the optional properties
	/// that form peak envelope.
  ///
  HRESULT AreAllPeakEnvelopePropertiesPresent (
    [out] aafBoolean_t *  pArePresent);


  //***********************************************************
  //
  // SetPeakEnvelopeVersion()
  //
  /// Sets the version of the peak envelope data.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the version will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  /// 
  /// @param version [in] Version of the peak envelope data.
  ///
  HRESULT SetPeakEnvelopeVersion (
    [in] aafUInt32  version);


  //***********************************************************
  //
  // GetPeakEnvelopeVersion()
  //
  /// Gets the version of the peak envelope data.
  /// This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pVersion pointer is valid.
  /// - the property is present.
  /// 
  /// If this method fails nothing will be written to *pVersion.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pVersion arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pVersion [out] Version of the peak envelope data.
  ///
  HRESULT GetPeakEnvelopeVersion (
    [out] aafUInt32 *  pVersion);


  //***********************************************************
  //
  // SetPeakEnvelopeFormat()
  //
  /// Sets the format of the peak point.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the format will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  /// 
  /// @param format [in] Format of the peak point.
  ///
  HRESULT SetPeakEnvelopeFormat (
    [in] aafUInt32  format);


  //***********************************************************
  //
  // GetPeakEnvelopeFormat()
  //
  /// Gets the format of the peak point.
  /// This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pFormat pointer is valid.
  /// - the property is present.
  /// 
  /// If this method fails nothing will be written to *pFormat.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFormat arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pFormat [out] Format of the peak point.
  ///
  HRESULT GetPeakEnvelopeFormat (
    [out] aafUInt32 *  pFormat);


  //***********************************************************
  //
  // SetPointsPerPeakValue()
  //
  /// Sets the number of peak points per peak value.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the PointsPerPeakValue property will
  /// not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  /// 
  /// @param pointCount [in] The number of peak points per peak value.
  ///
  HRESULT SetPointsPerPeakValue (
    [in] aafUInt32  pointCount);


  //***********************************************************
  //
  // GetPointsPerPeakValue()
  //
  /// Gets the number of peak points per peak value.
  /// This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pPointCount pointer is valid.
  /// - the property is present.
  /// 
  /// If this method fails nothing will be written to *pPointCount.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPointCount arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pPointCount [out] The number of peak points per peak value.
  ///
  HRESULT GetPointsPerPeakValue (
    [out] aafUInt32 *  pPointCount);


  //***********************************************************
  //
  // SetPeakEnvelopeBlockSize()
  //
  /// Sets the number of audio samples used to generate each peak frame.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the PeakEnvelopeBlockSize property will
  /// not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  /// 
  /// @param blockSize [in] The number of audio samples used to generate each peak frame.
  ///
  HRESULT SetPeakEnvelopeBlockSize (
    [in] aafUInt32  blockSize);


  //***********************************************************
  //
  // GetPeakEnvelopeBlockSize()
  //
  /// Gets the number of audio samples used to generate each peak frame.
  /// This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pBlockSize pointer is valid.
  /// - the property is present.
  /// 
  /// If this method fails nothing will be written to *pBlockSize.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBlockSize arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pBlockSize [out] The number of audio samples used to generate each peak frame.
  ///
  HRESULT GetPeakEnvelopeBlockSize (
    [out] aafUInt32 *  pBlockSize);


  //***********************************************************
  //
  // SetPeakChannelCount()
  //
  /// Sets the number of peak channels.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the channel count will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  /// 
  /// @param channelCount [in] The number of peak channels.
  ///
  HRESULT SetPeakChannelCount (
    [in] aafUInt32  channelCount);


  //***********************************************************
  //
  // GetPeakChannelCount()
  //
  /// Gets the number of peak channels.
  /// This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pChannelCount pointer is valid.
  /// - the property is present.
  /// 
  /// If this method fails nothing will be written to *pChannelCount.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pChannelCount arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pChannelCount [out] The number of peak channels.
  ///
  HRESULT GetPeakChannelCount (
    [out] aafUInt32 *  pChannelCount);


  //***********************************************************
  //
  // SetPeakFrameCount()
  //
  /// Sets the number of peak frames.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the frame count will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  /// 
  /// @param frameCount [in] The number of peak frames.
  ///
  HRESULT SetPeakFrameCount (
    [in] aafUInt32  frameCount);


  //***********************************************************
  //
  // GetPeakFrameCount()
  //
  /// Gets the number of peak frames.
  /// This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pFrameCount pointer is valid.
  /// - the property is present.
  /// 
  /// If this method fails nothing will be written to *pFrameCount.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFrameCount arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pFrameCount [out] The number of peak frames.
  ///
  HRESULT GetPeakFrameCount (
    [out] aafUInt32 *  pFrameCount);


  //***********************************************************
  //
  // SetPeakOfPeaksPosition()
  //
  /// Sets the offset to the first audio sample whose absolute
  /// value is the maximum value of the entire audio file.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the PeakOfPeaksPosition property will
  /// not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  /// 
  /// @param position [in] The offset to peak of peaks
  ///
  HRESULT SetPeakOfPeaksPosition (
    [in] aafPosition_t  position);


  //***********************************************************
  //
  // GetPeakOfPeaksPosition()
  //
  /// Gets the offset to the first audio sample whose absolute
  /// value is the maximum value of the entire audio file.
  /// This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pPosition pointer is valid.
  /// - the property is present.
  /// 
  /// If this method fails nothing will be written to *pPosition.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPosition arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pPosition [out] The offset to peak of peaks.
  ///
  HRESULT GetPeakOfPeaksPosition (
    [out] aafPosition_t *  pPosition);


  //***********************************************************
  //
  // SetPeakEnvelopeTimestamp()
  //
  /// Sets the time stamp of the creation of the peak data.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the time stamp will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  /// 
  /// @param timeStamp [in] The time stamp of the creation of the peak data.
  ///
  HRESULT SetPeakEnvelopeTimestamp (
    [in] aafTimeStamp_constref  timeStamp);


  //***********************************************************
  //
  // GetPeakEnvelopeTimestamp()
  //
  /// Gets the time stamp of the creation of the peak data.
  /// This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pTimeStamp pointer is valid.
  /// - the property is present.
  /// 
  /// If this method fails nothing will be written to *pTimeStamp.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTimeStamp arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pTimeStamp [out] The time stamp of the creation of the peak data.
  ///
  HRESULT GetPeakEnvelopeTimestamp (
    [out] aafTimeStamp_t *  pTimeStamp);


  //***********************************************************
  //
  // SetPeakEnvelopeDataPosition()
  //
  /// Sets the offset from the beginning of peak envelope data.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the object is persistent (attached to a file).
  /// 
  /// If this method fails the position will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_OBJECT_NOT_PERSISTENT
  ///   - the object is not persistent.
  /// 
  /// @param position [in] Offset from the beginning of peak envelope data.
  ///
  HRESULT SetPeakEnvelopeDataPosition (
    [in] aafPosition_t  position);


  //***********************************************************
  //
  // GetPeakEnvelopeDataPosition()
  //
  /// Gets the offset from the beginning of peak envelope data.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pPosition pointer is valid.
  /// - the object is persistent (attached to a file).
  /// 
  /// If this method fails nothing will be written to *pPosition.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPosition arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the PeakEnvelopeData property is not present.
  ///
  /// AAFRESULT_OBJECT_NOT_PERSISTENT
  ///   - the object is not persistent.
  /// 
  /// @param pPosition [out] Offset from the beginning of peak envelope data.
  ///
  HRESULT GetPeakEnvelopeDataPosition (
    [out] aafPosition_t *  pPosition);


  //***********************************************************
  //
  // GetPeakEnvelopeDataSize()
  //
  /// Gets the size of peak envelope data.
  /// PeakEnvelopeData is optional property.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pSize pointer is valid.
  /// - the PeakEnvelopeData property is present.
  /// - the object is persistent (attached to a file).
  /// 
  /// If this method fails nothing will be written to *pSize.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSize arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the PeakEnvelopeData property is not present.
  ///
  /// AAFRESULT_OBJECT_NOT_PERSISTENT
  ///   - the object is not persistent.
  /// 
  /// @param pSize [out] The size of peak envelope data.
  ///
  HRESULT GetPeakEnvelopeDataSize (
    [out] aafLength_t *  pSize);


  //***********************************************************
  //
  // WritePeakEnvelopeData()
  //
  /// Write the specified bytes to the peak envelope data stream.
  /// 
  /// Succeeds if all of the following are true:
  /// - the number of bytes to write is non-zero.
  /// - the buffer pointer is valid.
  /// - the pBytesWritten pointer is valid.
  /// - the object is initialized.
  /// - the object is persistent (attached to a file).
  /// 
  /// If this method fails the PeakEnvelopeData property will
  /// not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - bytes arg is larger than zero.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - buffer arg is NULL.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBytesWritten arg is NULL.
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_OBJECT_NOT_PERSISTENT
  ///   - the object is not persistent.
  ///
  /// AAFRESULT_CONTAINERWRITE
  ///   - writing failed.
  /// 
  /// @param bytes [in] Write this many bytes
  /// @param buffer [out, size_is(bytes)] Data to write
  /// @param pBytesWritten [out,ref] Number of bytes actually written.
  ///
  HRESULT WritePeakEnvelopeData (
    [in] aafUInt32  bytes,
    [out, size_is(bytes)] aafDataBuffer_t  buffer,
    [out,ref] aafUInt32 *  pBytesWritten);


  //***********************************************************
  //
  // ReadPeakEnvelopeData()
  //
  /// Read the specified number of bytes from the peak envelope data
  /// stream into buffer.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the number of bytes to read is non-zero.
  /// - the buffer pointer is valid.
  /// - the pBytesRead pointer is valid.
  /// - the PeakEnvelopeData property is present.
  /// - the object is persistent (attached to a file).
  /// - not yet reached the end of the data stream.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// AAFRESULT_END_OF_DATA
  ///   - trying to read beyond the end of the data stream.
  /// 
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  /// 
  /// AAFRESULT_INVALID_PARAM
  ///   - bytes arg is larger than zero.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - buffer arg is NULL.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBytesRead arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the PeakEnvelopeData property is not present.
  ///
  /// AAFRESULT_OBJECT_NOT_PERSISTENT
  ///   - the object is not persistent.
  /// 
  /// @param bytes [in] Read this many bytes
  /// @param buffer [out, size_is(bytes)] Buffer to read the data to
  /// @param pBytesRead [out,ref] Number of bytes actually read.
  ///
  HRESULT ReadPeakEnvelopeData (
    [in] aafUInt32  bytes,
    [out, size_is(bytes)] aafDataBuffer_t  buffer,
    [out,ref] aafUInt32 *  pBytesRead);
}



// ************************
//
// Interface IAAFParameter
//
// ************************
///
/// The IAAFParameter interface is implemented by objects that specify
/// an Instantiation of an operation parameter.  It is an abstract
/// class, so you should use AAFConstantValue or AAFVaryingValue.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///



 

///
/// Objects that implement IAAFParameter also implement the following interfaces:
///  - IAAFObject
[
    object,
    uuid(9c568a81-2096-11d2-bf98-006097116212),
    helpstring("IAAFParameter Interface"),
    pointer_default(unique)
]
interface IAAFParameter : IUnknown
{


  //***********************************************************
  //
  // GetParameterDefinition()
  //
  /// Places the parameter definition of the operation parameter into
  /// the *ppParmDef argument.  The length of an operation parameter is
  /// in the same edit units and has the same value as the
  /// IAAFOperationGroup enclosing this parameter.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppParmDef pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppParmDef is null.
  /// 
  /// @param ppParmDef [out,retval] New parameter definition
  ///
  HRESULT GetParameterDefinition (
    [out,retval] IAAFParameterDef ** ppParmDef);

  //***********************************************************
  //
  // GetTypeDefinition()
  //
  /// Places the IAAFTypeDefinition of the data value inside this
  /// parameter into the *ppTypeDef argument.  The data value is the
  /// value of the parameter.  It is often an integer or rational, and
  /// may change over time.  An example of a value would be the
  /// "level" parameter of a video dissolve, which has control
  /// points with a value of zero (0 percent B material) at the
  /// start, to one (100 percent B material) at the end.  The data
  /// value will actually be stored in either AAFConstantValue or one
  /// of the AAFControlPoints inside of an AAFVaryingValue.
  ///
  /// The definition is stored in the base class because it should be
  /// constant for all control points inside of a varying value.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTypeDef is null.
  /// 
  /// @param ppTypeDef [out,retval] Type Definition of the data value inside of this object
  ///
  HRESULT GetTypeDefinition (
    [out,retval] IAAFTypeDef ** ppTypeDef);
}



// ************************
//
// Interface IAAFParameterDef
//
// ************************
///
/// The IAAFParameterDef interface is implemented by objects that
/// specify a definition of an operation group parameter.  The
/// parameterDef object is separate from the operation definition to
/// allow some parameters, for example level, to be specified once
/// for multiple operation definitions. Parmeter definitions define the
/// possible values and display units of a single operation parameter.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///

 

///
/// Objects that implement IAAFParameterDef also implement the following interfaces:
///  - IAAFDefObject
///  - IAAFObject
[
    object,
    uuid(20045fa1-1d87-11d2-bf96-006097116212),
    helpstring("IAAFParameterDef Interface"),
    pointer_default(unique)
]
interface IAAFParameterDef : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Init all fields of a definition object.
  /// 
  /// @param id [in, ref] AUID for new DefObject
  /// @param pName [in, string] Name for new DefObject
  /// @param pDescription [in, string] Description for new DefObject
  /// @param pType [in] The type definition for all parameters that use this definition
  ///
  HRESULT Initialize (
    [in, ref] aafUID_constref  id,
    [in, string] aafCharacter_constptr  pName,
    [in, string] aafCharacter_constptr  pDescription,
    [in] IAAFTypeDef * pType);


  //***********************************************************
  //
  // GetTypeDefinition()
  //
  /// Places the AAFTypeDef object attached to this IAAFParameterDef
  /// into the *ppTypeDef argument.  If none exists yet, NULL is
  /// placed into the *ppTypeDef argument.
  ///
  /// The returned AAFTypeDef object, if it exists, is AddRef()ed
  /// before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppTypeDef pointer is valid.
  /// - A valid AAFTypeDef exists.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTypeDef is null.
  ///
  /// AAFRESULT_NO_ESSENCE_DESC
  ///   - There is no AAFTypeDef.  There has to be one of some
  ///     kind for this to be a valid operation definition.
  /// 
  /// @param ppTypeDef [retval,out] Pointer to a type definition
  ///
  HRESULT GetTypeDefinition (
    [retval,out] IAAFTypeDef ** ppTypeDef);


  //***********************************************************
  //
  // SetDisplayUnits()
  //
  /// Sets the Display Units string property.
  ///
  /// Set the DisplayUnits property to the value specified in
  /// pDisplayUnits.  A copy is made of the data so the caller
  /// retains ownership of the *pDisplayUnits buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pDisplayUnits pointer is valid.
  /// 
  /// If this method fails the DisplayUnits property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDisplayUnits arg is NULL.
  /// 
  /// @param pDisplayUnits [in, string] buffer from which DisplayUnits is to be read
  ///
  HRESULT SetDisplayUnits (
    [in, string] aafCharacter_constptr  pDisplayUnits);


  //***********************************************************
  //
  // GetDisplayUnits()
  //
  /// Gets the Display Units string property.
  /// 
  /// Writes the DisplayUnits property, with a trailing null
  /// character, into the pDisplayUnits buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the DisplayUnits property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetDisplayUnitsBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pDisplayUnits.
  /// 
  /// Succeeds if:
  /// - The pDisplayUnits pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   DisplayUnits.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDisplayUnits arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold DisplayUnits.
  /// 
  /// @param pDisplayUnits [out, string, size_is(bufSize)] buffer into which DisplayUnits is to be written
  /// @param bufSize [in] size of *pDisplayUnits buffer in bytes
  ///
  HRESULT GetDisplayUnits (
    [out, string, size_is(bufSize)] aafCharacter *  pDisplayUnits,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetDisplayUnitsBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetDisplayUnits().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetDisplayUnitsBufLen (
    [out] aafUInt32 *  pBufSize);
}



// ************************
//
// Interface IAAFPhysicalDescriptor
//
// ************************

///
/// The AAFPhysicalDescriptor interface is implemented by objects which
/// describe physical sources.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///


///
/// Objects that implement IAAFPhysicalDescriptor also implement the following interfaces:
///  - IAAFEssenceDescriptor
///  - IAAFObject
[
    object,
    uuid(e3a1234e-a544-448e-95f0-ed4944edafc8),
    helpstring("IAAFPhysicalDescriptor Interface"),
    pointer_default(unique)
]
interface IAAFPhysicalDescriptor : IUnknown
{


}



// ************************
//
// Interface IAAFPlainEssenceData
//
// ************************
///
/// This is a default inerface for a class used to provide
/// access to file encoding-independent stream data.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// Objects that implement IAAFPlainEssenceData also implement the following interfaces:
///  - IAAFKLVEssenceDataParameters
[
    object,
    uuid(3bde74ff-7305-4a19-b3b1-b13501404dff),
    helpstring("IAAFPlainEssenceData Interface"),
    pointer_default(unique)
]
interface IAAFPlainEssenceData : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Associates a weak reference to the given file mob with the
  /// essence data.
  ///
  /// Succeeds if all of the following are true:
  /// - the pFileMob pointer is valid and points to 
  /// a file mob (contains a file descriptor).
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFileMob is null.
  /// 
  /// @param pFileMob [in] reference to a file mob
  ///
  HRESULT Initialize (
    [in] IAAFSourceMob * pFileMob);


  //***********************************************************
  //
  // Write()
  //
  /// Write pre-interleaved data to a essence stream.
  /// 
  /// @param bytes [in] write this many bytes
  /// @param buffer [out, size_is(bytes)] here is the buffer
  /// @param bytesWritten [out,ref] 
  ///
  HRESULT Write (
    [in] aafUInt32  bytes,
    [out, size_is(bytes)] aafDataBuffer_t  buffer,
    [out,ref] aafUInt32 *  bytesWritten);


  //***********************************************************
  //
  // Read()
  //
  /// Read pre-interleaved data from a essence stream.
  /// 
  /// @param bytes [in] read this many bytes
  /// @param buffer [out, size_is(bytes), length_is(*bytesRead)] here is the buffer
  /// @param bytesRead [out,ref] 
  ///
  HRESULT Read (
    [in] aafUInt32  bytes,
    [out, size_is(bytes), length_is(*bytesRead)] aafDataBuffer_t  buffer,
    [out,ref] aafUInt32 *  bytesRead);


  //***********************************************************
  //
  // SetPosition()
  //
  /// Seek to absolute position within the essence data.
  /// 
  /// @param offset [in] offset from beginning of essence
  ///
  HRESULT SetPosition (
    [in] aafPosition_t  offset);


  //***********************************************************
  //
  // GetPosition()
  //
  /// Get the absolute position within the essence data.
  /// 
  /// @param pOffset [out] offset from beginning of essence
  ///
  HRESULT GetPosition (
    [out] aafPosition_t*  pOffset);


  //***********************************************************
  //
  // GetSize()
  //
  /// Return the total size of the essence data.
  /// 
  /// @param pSize  [out] size of essence data
  ///
  HRESULT GetSize (
    [out] aafLength_t *  pSize );


  //***********************************************************
  //
  // WriteSampleIndex()
  //
  /// Write pre-interleaved data to a sample index stream.
  /// 
  /// @param bytes [in] write this many bytes to the sample index stream
  /// @param buffer [out, size_is(bytes)] here is the buffer
  /// @param bytesWritten [out,ref] 
  ///
  HRESULT WriteSampleIndex (
    [in] aafUInt32  bytes,
    [out, size_is(bytes)] aafDataBuffer_t  buffer,
    [out,ref] aafUInt32 *  bytesWritten);


  //***********************************************************
  //
  // ReadSampleIndex()
  //
  /// Read pre-interleaved data from a sample index stream.
  /// 
  /// @param bytes [in] read this many bytes from the sample index stream
  /// @param buffer [out, size_is(bytes), length_is(*bytesRead)] here is the buffer
  /// @param bytesRead [out,ref] 
  ///
  HRESULT ReadSampleIndex (
    [in] aafUInt32  bytes,
    [out, size_is(bytes), length_is(*bytesRead)] aafDataBuffer_t  buffer,
    [out,ref] aafUInt32 *  bytesRead);


  //***********************************************************
  //
  // SetSampleIndexPosition()
  //
  /// Seek to absolute position within the sample index data.
  /// 
  /// @param offset [in] offset from beginning of sample index
  ///
  HRESULT SetSampleIndexPosition (
    [in] aafPosition_t  offset);


  //***********************************************************
  //
  // GetSampleIndexPosition()
  //
  /// Get the absolute position within the sample index data.
  /// 
  /// @param pOffset [out] offset from beginning of sample index
  ///
  HRESULT GetSampleIndexPosition (
    [out] aafPosition_t*  pOffset);


  //***********************************************************
  //
  // GetSampleIndexSize()
  //
  /// Return the total size of the sample index data.
  /// 
  /// @param pSize  [out] size of sample index data
  ///
  HRESULT GetSampleIndexSize (
    [out] aafLength_t *  pSize );


  //***********************************************************
  //
  // SetFileMob()
  //
  /// Associates a weak reference to the given file mob with the
  /// essence data.
  ///
  /// Succeeds if all of the following are true:
  /// - the pFileMob pointer is valid and points to 
  /// a file mob (contains a file descriptor).
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFileMob is null.
  /// 
  /// @param pFileMob [in] reference to a file mob
  ///
  HRESULT SetFileMob (
    [in] IAAFSourceMob * pFileMob);


  //***********************************************************
  //
  // GetFileMob()
  //
  /// Associates a weak reference to the given file mob with the
  /// essence data.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppFileMob pointer is valid and a weak
  /// reference to the associated file mob can be
  /// resolved.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppFileMob is null.
  /// 
  /// @param ppFileMob [in] reference to a file mob
  ///
  HRESULT GetFileMob (
    [in] IAAFSourceMob ** ppFileMob);


  //***********************************************************
  //
  // GetFileMobID()
  //
  /// Return the mob id used to find the file mob associated with this
  /// essence.  The file mob must exist in the same file as this
  /// essence data.
  /// 
  /// @param pFileMobID [out] the file mob id associated with essence
  ///
  HRESULT GetFileMobID (
    [out] aafMobID_t *  pFileMobID);




}


// ************************
//
// Interface IAAFPlainStreamData
//
// ************************
///
/// This interface is used to define Stream types used in AAF
/// persistent objects.  Streams are conceptually similar to
/// variably-sized arrays except that they are intended to be used for
/// very large pieces of data (such as essence).
/// Note: All reads/and writes advance the current position.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// Objects that implement IAAFPlainStreamData also implement the following interfaces:
///  - IAAFKLVStreamParameters
[
    object,
    uuid(86f9aaff-b6ad-4f3e-a71c-f69f1b4c48a5),
    helpstring("IAAFPlainStreamData Interface"),
    pointer_default(unique)
]
interface IAAFPlainStreamData : IUnknown
{


  //***********************************************************
  //
  // GetSize()
  //
  /// Returns number of bytes contained in the referenced property
  /// value.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  /// - pSize is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pStreamPropertyValue or pSize arg is NULL.
  /// 
  /// @param pStreamPropertyValue [in] stream property value
  /// @param pSize [out] count of bytes in the specified stream property value
  ///
  HRESULT GetSize (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [out] aafInt64 *  pSize);

  //***********************************************************
  //
  // SetSize()
  //
  /// Set the number of bytes contained in the give stream property value
  /// to newElementCount
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - If pStreamPropertyValue arg is NULL.
  /// 
  /// @param pStreamPropertyValue [in] stream property value
  /// @param newSize [in] new count of bytes in the specified stream property value
  ///
  HRESULT SetSize (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [in] aafInt64  newSize);

  //***********************************************************
  //
  // GetPosition()
  //
  /// Returns the byte position of the current element in the stream. 
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  /// - pPosition is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pStreamPropertyValue or pPosition arg is NULL.
  /// 
  /// @param pStreamPropertyValue [in] stream property value
  /// @param pPosition [out] current byte position in the specified stream property value
  ///
  HRESULT GetPosition (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [out] aafInt64 *  pPosition);

  //***********************************************************
  //
  // SetPosition()
  //
  /// Make the current byte position to the one at newPosition in the stream 
  /// property value. 
  ///
  /// Succeeds if:
  /// - pStreamPropertyValue is a valid pointer.
  /// - the new position is valid
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - If pStreamPropertyValue arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - newPosition is outside the bounds of the stream.
  /// 
  /// @param pStreamPropertyValue [in] stream property value
  /// @param newPosition [in] the new position in the specified stream property value
  ///
  HRESULT SetPosition (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [in] aafInt64  newPosition);


  //***********************************************************
  //
  // Read()
  //
  /// Sequential access.
  /// Copies the data at the position of the stream to the given
  /// buffer.
  ///
  /// Succeeds if all of the following are true:
  /// - the pStreamPropertyValue pointer is valid.
  /// - the pData pointer is valid.
  /// - the indicated bytes exist in the stream.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pStreamPropertyValue or pData arg is NULL.
  /// 
  /// @param pStreamPropertyValue [in] stream property value to read
  /// @param dataSize [in] number of bytes to read
  /// @param pData [out, size_is(dataSize), length_is(*bytesRead)] buffer into which one element from the stream should be written
  /// @param bytesRead [out,ref] number of bytes actually read (will be either dataSize or 0 if there 
  /// is in error)
  ///
  HRESULT Read (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [in] aafUInt32  dataSize,
    [out, size_is(dataSize), length_is(*bytesRead)] aafMemPtr_t  pData,
    [out,ref] aafUInt32 *  bytesRead);

  //***********************************************************
  //
  // Write()
  //
  /// Sequential access.
  /// Copies the data in the given buffer into the stream at the 
  /// current position of the stream..
  ///
  /// Succeeds if all of the following are true:
  /// - the pStreamPropertyValue pointer is valid.
  /// - the pData pointer is valid.
  /// - the indicated bytes could be written to the stream.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pStreamPropertyValue or pData arg is NULL.
  /// 
  /// @param pStreamPropertyValue [in] stream property value to modify
  /// @param dataSize [in] number of bytes to write
  /// @param pData [in, ref, size_is(dataSize)] buffer into which should contain one element to be written to the stream
  ///
  HRESULT Write (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [in] aafUInt32  dataSize,
    [in, ref, size_is(dataSize)] aafMemPtr_t  pData);

  //***********************************************************
  //
  // Append()
  //
  /// Extending the stream.
  /// Copies the data in the given buffer into the stream at the 
  /// end of the stream.
  ///
  /// Succeeds if all of the following are true:
  /// - the pStreamPropertyValue pointer is valid.
  /// - the pData pointer is valid.
  /// - the indicated bytes could be appended to the stream.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pStreamPropertyValue or pData arg is NULL.
  /// 
  /// @param pStreamPropertyValue [in] stream property value to modify
  /// @param dataSize [in] number of bytes to write (must be equal to the element type length)
  /// @param pData [in, ref, size_is(dataSize)] buffer into which should contain one element to be written to the stream
  ///
  HRESULT Append (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [in] aafUInt32  dataSize,
    [in, ref, size_is(dataSize)] aafMemPtr_t  pData);


  //***********************************************************
  //
  // HasStoredByteOrder()
  //
  /// Returns kAAFTrue if the stream has a stored byte order or 
  /// kAAFFalse otherwise.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  /// - pHasByteOrder is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pStreamPropertyValue or pHasByteOrder arg is NULL.
  /// 
  /// @param pStreamPropertyValue [in] stream property value
  /// @param pHasByteOrder [out] kAAFTrue if this stream has a stored byte order
  ///
  HRESULT HasStoredByteOrder (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [out] aafBoolean_t *  pHasByteOrder);

  //***********************************************************
  //
  // GetStoredByteOrder()
  //
  /// Access byte order of the stream.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  /// - pByteOrder is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pStreamPropertyValue or pByteOrder arg is NULL.
  /// 
  /// @param pStreamPropertyValue [in] stream property value
  /// @param pByteOrder [out] Pointer to variable where byte order is to be copied
  ///
  HRESULT GetStoredByteOrder (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [out] eAAFByteOrder_t *  pByteOrder);

  //***********************************************************
  //
  // SetStoredByteOrder()
  //
  /// Sets the byte order to be associated with this stream. Note: the stream
  /// must be empty.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  /// - stream is empty.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - If pStreamPropertyValue arg is NULL.
  /// 
  /// @param pStreamPropertyValue [in] stream property value
  /// @param byteOrder [in] byte order is to be stored with the stream
  ///
  HRESULT SetStoredByteOrder (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [in] eAAFByteOrder_t  byteOrder);

  //***********************************************************
  //
  // ClearStoredByteOrder()
  //
  /// Clears the byte order to be associated with this stream. Note: the stream
  /// must be empty.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  /// - stream is empty.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - If pStreamPropertyValue arg is NULL.
  /// 
  /// @param pStreamPropertyValue [in] stream property value
  ///
  HRESULT ClearStoredByteOrder (
    [in] IAAFPropertyValue * pStreamPropertyValue);


  //***********************************************************
  //
  // ReadElements()
  //
  /// Access in typed chunks of Elements.
  /// Copies the data at the current position of the stream to the given
  /// buffer. Requires that any structures declared within element 
  /// typedef have had their offsets registered with that type.
  ///
  /// Succeeds if all of the following are true:
  /// - the pStreamPropertyValue pointer is valid.
  /// - the pElementType pointer is valid.
  /// - the pData pointer is valid.
  /// - dataSize indicates pData is large enough to hold the data.
  /// - compile-time struct has had its member offests registered.
  /// - the indicated elements exist in this stream type def.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pStreamPropertyValue or pElementType or pBytesRead or pData arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - dataSize indicates pData is too small.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for element typedef.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - there are not dataSize bytes left in the stream.
  /// 
  /// @param pStreamPropertyValue [in] stream property value to read
  /// @param pElementType [in] the type definition of the elements to read
  /// @param dataSize [in] number of bytes to read (must be evenly divisible by the element 
  /// type length)
  /// @param pData [out, size_is(dataSize), length_is(*pBytesRead)] buffer into which elements from the stream should be written
  /// @param pBytesRead [out,ref] number of bytes actually read (will be either dataSize or 0 if 
  /// there is in error)
  ///
  HRESULT ReadElements (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [in] IAAFTypeDef * pElementType,
    [in] aafUInt32  dataSize,
    [out, size_is(dataSize), length_is(*pBytesRead)] aafMemPtr_t  pData,
    [out,ref] aafUInt32 *  pBytesRead);

  //***********************************************************
  //
  // WriteElements()
  //
  /// Access in typed chunks of Elements.
  /// Copies the data in the given buffer into the stream at the  
  /// current position of the stream. Requires that any structures 
  /// declared within element 
  /// typedef have had their offsets registered with that type..
  ///
  /// Succeeds if all of the following are true:
  /// - the pStreamPropertyValue pointer is valid.
  /// - the pElementType pointer is valid.
  /// - the pData pointer is valid.
  /// - dataSize indicates pData is large enough to hold the data.
  /// - compile-time struct has had its member offests registered.
  /// - the indicated elements exist in this stream type def.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pStreamPropertyValue or pElementType or pData arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - dataSize indicates pData is an even multiple of the given 
  ///     element type size.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for the element typedef.
  /// 
  /// @param pStreamPropertyValue [in] stream property value to modify
  /// @param pElementType [in] the type definition of the elements to read
  /// @param dataSize [in] number of bytes to write (must be evenly divisible by the element type 
  /// length)
  /// @param pData [in, ref, size_is(dataSize)] buffer into which elements from the stream should be written
  ///
  HRESULT WriteElements (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [in] IAAFTypeDef * pElementType,
    [in] aafUInt32  dataSize,
    [in, ref, size_is(dataSize)] aafMemPtr_t  pData);


cpp_quote("  /// Extend in chunks of typed Elements") 

  //***********************************************************
  //
  // AppendElements()
  //
  /// Access in typed chunks of Elements.
  /// Copies the data in the given buffer onto the end of the stream. 
  /// Requires that any structures declared within element 
  /// typedef have had their offsets registered with that type..
  ///
  /// Succeeds if all of the following are true:
  /// - the pStreamPropertyValue pointer is valid.
  /// - the pElementType pointer is valid.
  /// - the pData pointer is valid.
  /// - dataSize indicates pData is large enough to hold the data.
  /// - compile-time struct has had its member offests registered.
  /// - the indicated elements exist in this stream type def.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pStreamPropertyValue or pElementType or pData arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - dataSize indicates pData is an even multiple of the given 
  ///     element type size.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for the element typedef.
  /// 
  /// @param pStreamPropertyValue [in] stream property value to modify
  /// @param pElementType [in] the type definition of the elements to read
  /// @param dataSize [in] number of bytes to write (must be evenly divisible by the element type 
  /// length)
  /// @param pData [in, ref, size_is(dataSize)] buffer into which elements from the stream should be written
  ///
  HRESULT AppendElements (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [in] IAAFTypeDef * pElementType,
    [in] aafUInt32  dataSize,
    [in, ref, size_is(dataSize)] aafMemPtr_t  pData);




}


// ************************
//
// Interface IAAFPluginDef
//
// ************************
///
/// An object which describes a particular implementation of a plug-in
/// interface.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
///
/// Objects that implement IAAFPluginDef also implement the following interfaces:
///  - IAAFDefObject
///  - IAAFObject
[
    object,
    uuid(AD1BB854-DBB2-11d2-809C-006008143E6F),
    helpstring("IAAFPluginDef Interface"),
    pointer_default(unique)
]
interface IAAFPluginDef : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Init all fields of a definition object.
  /// 
  /// @param id [in, ref] AUID for new DefObject
  /// @param pName [in] Name for new DefObject
  /// @param pDescription [in] Description for new DefObject
  ///
  HRESULT Initialize (
    [in, ref] aafUID_constref  id,
    [in] aafCharacter_constptr  pName,
    [in] aafCharacter_constptr  pDescription);

  //***********************************************************
  //
  // GetCategoryClass()
  //
  /// Obtains the Category Class, which is identifies the stored
  /// classID of the subclass of AAFPluggableDefinition which
  /// references this plugin descriptor.  This ID is written into the
  /// caller-allocated aafUID_t specified by the pCategoryClass
  /// argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pCategoryClass pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pCategoryClass.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCategoryClass arg is NULL.
  /// 
  /// @param pCategoryClass [out] The CategoryClass
  ///
  HRESULT GetCategoryClass (
    [out] aafUID_t *  pCategoryClass);


  //***********************************************************
  //
  // SetCategoryClass()
  //
  /// Sets the Category Class, which is identifies the stored classID
  /// of the subclass of AAFPluggableDefinition which references this
  /// plugin descriptor.
  /// 
  /// If this method fails the Category Class property will not be
  /// changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param categoryClass [in, ref] The Category Class
  ///
  HRESULT SetCategoryClass (
    [in, ref] aafUID_constref  categoryClass);


  //***********************************************************
  //
  // GetPluginVersion()
  //
  /// Gets the Plugin Version property associated with this plugin
  /// descriptor and places it into *pVersion. 
  ///
  /// Succeeds if all of the following are true:
  /// - the pVersion pointer is valid.
  /// 
  /// If this method fails, nothing will be written to *pVersion.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pVersion arg is NULL.
  /// 
  /// @param pVersion [out] The Plugin Version
  ///
  HRESULT GetPluginVersion (
    [out] aafVersionType_t *  pVersion);


  //***********************************************************
  //
  // SetPluginVersion()
  //
  /// Sets the plugin version property of this plugin descriptor.
  ///
  /// Succeeds if all of the following are true:
  /// - pVersion pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pVersion arg is NULL.
  /// 
  /// @param pVersion [in] The plugin Version
  ///
  HRESULT SetPluginVersion (
    [in] aafVersionType_t *  pVersion);


  //***********************************************************
  //
  // SetPluginVersionString()
  //
  /// Sets the Plugin Version String property.
  ///
  /// Set the PluginVersionString property to the value specified in
  /// pPluginVersionString.  A copy is made of the data so the caller
  /// retains ownership of the *pPluginVersionString buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pPluginVersionString pointer is valid.
  /// 
  /// If this method fails the PluginVersionString property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPluginVersionString arg is NULL.
  /// 
  /// @param pPluginVersionString [in, string] buffer from which PluginVersionString is to be read
  ///
  HRESULT SetPluginVersionString (
    [in, string] aafCharacter_constptr  pPluginVersionString);


  //***********************************************************
  //
  // GetPluginVersionString()
  //
  /// Gets the Plugin Version String property.
  /// 
  /// Writes the PluginVersionString property, with a trailing null
  /// character, into the pPluginVersionString buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the PluginVersionString property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetPluginVersionStringBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pPluginVersionString.
  /// 
  /// Succeeds if:
  /// - The pPluginVersionString pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   PluginVersionString.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPluginVersionString arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold PluginVersionString.
  /// 
  /// @param pPluginVersionString [out, string, size_is(bufSize)] buffer into which PluginVersionString is to be written
  /// @param bufSize [in] size of *pPluginVersionString buffer in bytes
  ///
  HRESULT GetPluginVersionString (
    [out, string, size_is(bufSize)] aafCharacter *  pPluginVersionString,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetPluginVersionStringBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetPluginVersionString().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetPluginVersionStringBufLen (
    [out] aafUInt32 *  pBufSize);


  //***********************************************************
  //
  // SetPluginManufacturerName()
  //
  /// Sets the Plugin Manufacturer Name string property.
  ///
  /// Set the PluginManufacturerName property to the value specified in
  /// pPluginManufacturerName.  A copy is made of the data so the caller
  /// retains ownership of the *pPluginManufacturerName buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pPluginManufacturerName pointer is valid.
  /// 
  /// If this method fails the PluginManufacturerName property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPluginManufacturerName arg is NULL.
  /// 
  /// @param pPluginManufacturerName [in, string] buffer from which PluginManufacturerName is to be read
  ///
  HRESULT SetPluginManufacturerName (
    [in, string] aafCharacter_constptr  pPluginManufacturerName);


  //***********************************************************
  //
  // GetPluginManufacturerName()
  //
  /// Gets the Plugin Manufacturer Name string property.
  /// 
  /// Writes the PluginManufacturerName property, with a trailing null
  /// character, into the pPluginManufacturerName buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the PluginManufacturerName property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetPluginManufacturerNameBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pPluginManufacturerName.
  /// 
  /// Succeeds if:
  /// - The pPluginManufacturerName pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   PluginManufacturerName.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPluginManufacturerName arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold PluginManufacturerName.
  /// 
  /// @param pPluginManufacturerName [out, string, size_is(bufSize)] buffer into which PluginManufacturerName is to be written
  /// @param bufSize [in] size of *pPluginManufacturerName buffer in bytes
  ///
  HRESULT GetPluginManufacturerName (
    [out, string, size_is(bufSize)] aafCharacter *  pPluginManufacturerName,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetPluginManufacturerNameBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetPluginManufacturerName().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetPluginManufacturerNameBufLen (
    [out] aafUInt32 *  pBufSize);


  //***********************************************************
  //
  // GetManufacturerInfo()
  //
  /// This method will get an AAFNetworkLocator pointing to
  /// ManufacturerInfo for this plugin and place an interface for the
  /// locator into the **ppResult argument.  If a ManufacturerInfo
  /// locator exists, the result will be AddRef()ed. If not, the
  /// result will be NULL.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppResult arg is NULL.
  /// 
  /// @param ppResult [out, retval] ManufacturerInfo property value
  ///
  HRESULT GetManufacturerInfo (
    [out, retval] IAAFNetworkLocator ** ppResult);


  //***********************************************************
  //
  // SetManufacturerInfo()
  //
  /// This method will set a locator pointing to the location of
  /// ManufacturerInfo for this plugin.  If a ManufacturerInfo
  /// already exists for this mob slot, it will be discarded.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param pManufacturerInfo [in] ManufacturerInfo property value
  ///
  HRESULT SetManufacturerInfo (
    [in] IAAFNetworkLocator * pManufacturerInfo);


  //***********************************************************
  //
  // GetManufacturerID()
  //
  /// Obtains the manufacturer ID, which is identifies the manfacturer
  /// of this plugin.  This ID is written into the caller-allocated
  /// aafUID_t specified by the pManufacturerID argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pManufacturerID pointer is valid.
  /// 
  /// If this method fails nothing will be written to
  /// *pManufacturerID.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pManufacturerID arg is NULL.
  /// 
  /// @param pManufacturerID [out] The ManufacturerID
  ///
  HRESULT GetManufacturerID (
    [out] aafUID_t *  pManufacturerID);


  //***********************************************************
  //
  // SetManufacturerID()
  //
  /// Sets the manufacturer ID, which is identifies the manufacturer
  /// of this plugin.
  /// 
  /// If this method fails the ManufacturerID property will not be
  /// changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param manufacturerID [in, ref] The Category Class
  ///
  HRESULT SetManufacturerID (
    [in, ref] aafUID_constref  manufacturerID);


  //***********************************************************
  //
  // GetHardwarePlatform()
  //
  /// Obtains the hardware platform ID, which identifies the hardware
  /// platform which is required to use this plugin.  This ID is
  /// written into the caller-allocated variable specified by the
  /// pHardwarePlatform argument. The type aafHardwarePlatform_t is an
  /// extensible enumerated type, and the value given must be either
  /// standard or in the type dictionary.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pHardwarePlatform pointer is valid.
  /// 
  /// If this method fails nothing will be written to
  /// *pHardwarePlatform.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pHardwarePlatform arg is NULL.
  /// 
  /// @param pHardwarePlatform [out] The HardwarePlatform
  ///
  HRESULT GetHardwarePlatform (
    [out] aafHardwarePlatform_t *  pHardwarePlatform);


  //***********************************************************
  //
  // SetHardwarePlatform()
  //
  /// Sets the hardware platform ID, which identifies the hardware
  /// platform which is required to use this plugin.  The type
  /// aafHardwarePlatform_t is an extensible enumerated type, and the
  /// value given must be either standard or in the type dictionary.
  /// 
  /// If this method fails the HardwarePlatform property will not be
  /// changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param hardwarePlatform [in] The Category Class
  ///
  HRESULT SetHardwarePlatform (
    [in] aafHardwarePlatform_constref  hardwarePlatform);


  //***********************************************************
  //
  // GetPlatformVersionRange()
  //
  /// Gets the minimum and maximum platform Version properties
  /// associated with this plugin descriptor and places it into
  /// *pMinVersion, and *pMaxVersion.  These are the minimum and
  /// maximum versions of the platform for which this plugin will
  /// function.
  ///
  /// Succeeds if all of the following are true:
  /// - both pMinVersion and pMaxVersion pointers are valid.
  /// 
  /// If this method fails, nothing will be written to *pMinVersion or
  /// *pMaxVersion.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMinVersion or pMaxVersion arg is NULL.
  /// 
  /// @param pMinVersion [out] The Minimum Platform Version
  /// @param pMaxVersion [out] The Maximum Platform Version
  ///
  HRESULT GetPlatformVersionRange (
    [out] aafVersionType_t *  pMinVersion,
    [out] aafVersionType_t *  pMaxVersion);


  //***********************************************************
  //
  // SetPlatformMinimumVersion()
  //
  /// Sets the maximum platform Version property of this plugin
  /// descriptor.  This is the minimum version of the platform for
  /// which this plugin will function.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param minVersion [in] The Minimum Platform Version
  ///
  HRESULT SetPlatformMinimumVersion (
    [in] aafVersionType_constref  minVersion);


  //***********************************************************
  //
  // SetPlatformMaximumVersion()
  //
  /// Sets the maximum platform Version properties associated with this
  /// plugin descriptor.  This is the maximum version of the platform
  /// for which this plugin will function.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param maxVersion [in] The Maximum Platform Version
  ///
  HRESULT SetPlatformMaximumVersion (
    [in] aafVersionType_constref  maxVersion);


  //***********************************************************
  //
  // GetEngine()
  //
  /// Obtains the software engine ID, which identifies the software
  /// subsystem used for essence management and playback used by the
  /// plugin.  This ID is written into the caller-allocated variable
  /// specified by the pHardwarePlatform argument.  The type
  /// aafEngine_t is an extensible, enumerated type, and the value
  /// given must be either standard or in the type dictionary.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pHardwarePlatform pointer is valid.
  /// 
  /// If this method fails nothing will be written to
  /// *pHardwarePlatform.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEngine arg is NULL.
  /// 
  /// @param pEngine [out] The software engine
  ///
  HRESULT GetEngine (
    [out] aafEngine_t *  pEngine);


  //***********************************************************
  //
  // SetEngine()
  //
  /// Sets the software engine ID, which identifies the software
  /// subsystem used for essence management and playback used by the
  /// plugin.  The type aafEngine_t is an extensible enumerated type,
  /// and the value given must be either standard or in the type
  /// dictionary.
  /// 
  /// If this method fails the engine property will not be
  /// changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param engine [in] The software engine
  ///
  HRESULT SetEngine (
    [in] aafEngine_constref  engine);


  //***********************************************************
  //
  // GetEngineVersionRange()
  //
  /// Gets the minimum and maximum engine Version properties of the
  /// engine which is associated with this plugin and places it into
  /// *pMinVersion, and *pMaxVersion.  These are the minimum and
  /// maximum versions of the engine for which this plugin will
  /// function.
  ///
  /// Succeeds if all of the following are true:
  /// - both pMinVersion and pMaxVersion pointers are valid.
  /// 
  /// If this method fails, nothing will be written to *pMinVersion or
  /// *pMaxVersion.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMinVersion or pMaxVersion arg is NULL.
  /// 
  /// @param pMinVersion [out] The Minimum Engine Version
  /// @param pMaxVersion [out] The Maximum Engine Version
  ///
  HRESULT GetEngineVersionRange (
    [out] aafVersionType_t *  pMinVersion,
    [out] aafVersionType_t *  pMaxVersion);


  //***********************************************************
  //
  // SetEngineMinimumVersion()
  //
  /// Sets the minimum engine Version property to the minimum useful
  /// version of the engine which is associated with this plugin.  This
  /// is the minimum version of the engine for which this plugin will
  /// function.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param minVersion [in] The Minimum Engine Version
  ///
  HRESULT SetEngineMinimumVersion (
    [in] aafVersionType_constref  minVersion);


  //***********************************************************
  //
  // SetEngineMaximumVersion()
  //
  /// Sets the minimum engine Version property to the maximum useful
  /// version of the engine which is associated with this plugin.  This
  /// is the maximum version of the engine for which this plugin will
  /// function.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param pMaxVersion [in] The Minimum Engine Version
  ///
  HRESULT SetEngineMaximumVersion (
    [in] aafVersionType_constref  pMaxVersion);


  //***********************************************************
  //
  // GetPluginAPI()
  //
  /// Obtains the manufacturer ID Class, which identifies the plugin
  /// interface supported by the plugin.  This ID is written into the
  /// caller-allocated variable specified by the pPluginAPI argument.
  /// The type aafPluginAPI_t is an extensible enumerated type, and
  /// the value given must be either standard or in the type
  /// dictionary.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pPluginAPI pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pPluginAPI.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPluginAPI arg is NULL.
  /// 
  /// @param pPluginAPI [out] The PluginAPI
  ///
  HRESULT GetPluginAPI (
    [out] aafPluginAPI_t *  pPluginAPI);


  //***********************************************************
  //
  // SetPluginAPI()
  //
  /// Obtains the manufacturer ID, which identifies the plugin
  /// interface supported by the plugin.
  /// 
  /// The type aafPluginAPI_t is an extensible enumerated type, and
  /// the value given must be either standard or in the type dictionary.
  /// 
  /// If this method fails the PluginAPI property will not be
  /// changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param pluginAPI [in] The Category Class
  ///
  HRESULT SetPluginAPI (
    [in] aafPluginAPI_constref  pluginAPI);


  //***********************************************************
  //
  // GetPluginAPIVersionRange()
  //
  /// Gets the minimum and maximum plugin API Version properties of the
  /// plugin API which is associated with this plugin descriptor and
  /// places it into *pMinVersion, and *pMaxVersion.  These are the
  /// minimum and maximum versions of the PluginAPI for which this
  /// plugin will function.
  ///
  /// Succeeds if all of the following are true:
  /// - both pMinVersion and pMaxVersion pointers are valid.
  /// 
  /// If this method fails, nothing will be written to *pMinVersion or
  /// *pMaxVersion.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMinVersion or pMaxVersion arg is NULL.
  /// 
  /// @param pMinVersion [out] The Minimum Plugin API Version
  /// @param pMaxVersion [out] The Maximum Plugin API Version
  ///
  HRESULT GetPluginAPIVersionRange (
    [out] aafVersionType_t *  pMinVersion,
    [out] aafVersionType_t *  pMaxVersion);


  //***********************************************************
  //
  // SetPluginAPIMinimumVersion()
  //
  /// Sets the minimum plugin API Version property to the minimum
  /// useful version of the plugin API which is associated with this
  /// plugin.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param minVersion [out] The Minimum Plugin API Version
  ///
  HRESULT SetPluginAPIMinimumVersion (
    [out] aafVersionType_constref  minVersion);


  //***********************************************************
  //
  // SetPluginAPIMaximumVersion()
  //
  /// Sets the maximum engine Version property to the maximum useful
  /// version of the plugin API which is associated with this plugin.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param maxVersion [in] The Maximum Plugin API Version
  ///
  HRESULT SetPluginAPIMaximumVersion (
    [in] aafVersionType_constref  maxVersion);


  //***********************************************************
  //
  // IsSoftwareOnly()
  //
  /// Tells whether the given plugin is capable of running in a
  /// software-only environment.  A value of AAFTrue indicates that no
  /// additional hardware is required.  If the result is AAFTrue, then
  /// this plugin may also support hardware acceleration, as long as
  /// it also contains a software method of processing the data.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pIsSoftwareOnly pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pIsSoftwareOnly.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pIsSoftwareOnly arg is NULL.
  /// 
  /// @param pIsSoftwareOnly [out] The IsSoftwareOnly
  ///
  HRESULT IsSoftwareOnly (
    [out] aafBoolean_t *  pIsSoftwareOnly);


  //***********************************************************
  //
  // SetIsSoftwareOnly()
  //
  /// Sets whether the given plugin is capable of running in a
  /// software-only environment, and returns AAFFalse if any hardware
  /// is required.  If isSoftwareOnly is AAFTrue, then this plugin may
  /// also support hardware acceleration, as long as it also contains
  /// a software method of processing the data.  If this method fails
  /// the isSoftwareOnly property will not be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param isSoftwareOnly [in] The isSoftwareOnly flag
  ///
  HRESULT SetIsSoftwareOnly (
    [in] aafBoolean_t  isSoftwareOnly);


  //***********************************************************
  //
  // IsAccelerated()
  //
  /// Tells whether the given plugin is capable of running with a
  /// hardware accelerator.  If the result is AAFTrue, then this
  /// plugin may also support software decompression.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pIsAccelerated pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pIsAccelerated.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pIsAccelerated arg is NULL.
  /// 
  /// @param pIsAccelerated [out] The IsAccelerated
  ///
  HRESULT IsAccelerated (
    [out] aafBoolean_t *  pIsAccelerated);


  //***********************************************************
  //
  // SetIsAccelerated()
  //
  /// Tells whether the given plugin is capable of running with a
  /// hardware accelerator.  If the result is AAFTrue, then this
  /// plugin may also support software decompression.
  ///
  /// If this method fails the IsAccelerated property will not be
  /// changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param isAccelerated [in] The isAccelerated flag
  ///
  HRESULT SetIsAccelerated (
    [in] aafBoolean_t  isAccelerated);


  //***********************************************************
  //
  // SupportsAuthentication()
  //
  /// Tells whether the given plugin is capable of supporting
  /// authentication.  The methods for authenticating a plugin are
  /// still <tbd>.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pSupportsAuthentication pointer is valid.
  /// 
  /// If this method fails nothing will be written to
  /// *pSupportsAuthentication.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSupportsAuthentication arg is NULL.
  /// 
  /// @param pSupportsAuthentication [out] The SupportsAuthentication
  ///
  HRESULT SupportsAuthentication (
    [out] aafBoolean_t *  pSupportsAuthentication);


  //***********************************************************
  //
  // SetSupportsAuthentication()
  //
  /// Tells whether the given plugin is capable of supporting
  /// authentication.  The methods for authenticating a plugin are
  /// still <tbd>.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param SupportsAuthentication [in] The SupportsAuthentication flag
  ///
  HRESULT SetSupportsAuthentication (
    [in] aafBoolean_t  SupportsAuthentication);



  //***********************************************************
  //
  // CountLocators()
  //
  /// Return the number of locators attached to this plugin descriptor.
  /// The number of locators may be zero if the plugin is in the
  /// current file.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pCount pointer is valid.
  /// 
  /// If this method fails nothing is written to *pCount.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCount is null.
  /// 
  /// @param pResult [out] Returns the number of locators
  ///
  HRESULT CountLocators (
    [out] aafUInt32 *  pResult);


  //***********************************************************
  //
  // AppendLocator()
  //
  /// Append another locator to this plugin descriptor.  Use this
  /// function to add a locator to be scanned last when searching for
  /// the plugin (a secondary location for the plugin).
  /// 
  /// Succeeds if all of the following are true:
  /// - the pLocator pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLocator is null.
  /// 
  /// @param pLocator [in] Locator to append
  ///
  HRESULT AppendLocator (
    [in] IAAFLocator * pLocator);


  //***********************************************************
  //
  // PrependLocator()
  //
  /// Append another locator to this plugin descriptor.  Use this
  /// function to add a locator to be scanned first when searching for
  /// the plugin (a new primary location for the plugin).
  /// 
  /// Succeeds if all of the following are true:
  /// - the pLocator pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLocator is null.
  /// 
  /// @param pLocator [in] Locator to append
  ///
  HRESULT PrependLocator (
    [in] IAAFLocator * pLocator);


  //***********************************************************
  //
  // InsertLocatorAt()
  //
  /// Insert another locator to this plugin descriptor at the given
  /// index.  Locators already existing at the named and higher indices
  /// will be moved up to the next higher index to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - index is less than or equal to the value returned by
  ///   CountLocators().
  /// - the pLocator pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLocator is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than the value returned by
  ///     CountLocators().
  /// 
  /// @param index [in] index to insert locator
  /// @param pLocator [in] Locator to insert
  ///
  HRESULT InsertLocatorAt (
    [in] aafUInt32  index,
    [in] IAAFLocator * pLocator);


  //***********************************************************
  //
  // GetLocatorAt()
  //
  /// Gets the locator which exists in this plugin descriptor at the
  /// given index.
  /// 
  /// Succeeds if all of the following are true:
  /// - index is less than the value returned by CountLocators().
  /// - the ppLocator pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppLocator is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than or equal to the value returned by
  ///     CountLocators().
  /// 
  /// @param index [in] index to insert locator
  /// @param ppLocator [out] returned Locator
  ///
  HRESULT GetLocatorAt (
    [in] aafUInt32  index,
    [out] IAAFLocator ** ppLocator);


  //***********************************************************
  //
  // RemoveLocatorAt()
  //
  /// Removes the locator which exists in this plugin descriptor at the
  /// given index.  Locators already existing at indices higher than
  /// the named index will be moved down to the next higher index to
  /// accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - index is less than the value returned by CountLocators().
  /// - the ppLocator pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppLocator is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than or equal to the value returned by
  ///     CountLocators().
  /// 
  /// @param index [in] index to insert locator
  ///
  HRESULT RemoveLocatorAt (
    [in] aafUInt32  index);



  //***********************************************************
  //
  // GetLocators()
  //
  /// Places an IEnumAAFPluginLocators enumerator for the plugin
  /// locators contained in the AAFPluginDescriptor into the *ppEnum
  /// argument.
  /// 
  /// The returned enumerator is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// E_FAIL
  ///   - Failed to create the enumerator.
  /// 
  /// @param ppEnum [out, retval] Plugin Locator Enumeration
  ///
  HRESULT GetLocators (
    [out, retval] IEnumAAFPluginLocators ** ppEnum);

    //***********************************************************
  //
  // SetDefinitionObjectID()
  //
  /// Sets the definition object handled by this plugin.
  /// 
  /// @param pDef [in] AUID of an AAFDefinitionObject
  ///
  HRESULT SetDefinitionObjectID (
    [in] aafUID_t  pDef);

    //***********************************************************
  //
  // GetDefinitionObjectID()
  //
  /// Gets the definition object handled by this plugin.
  /// 
  /// @param ppDef [retval,out] AUID of an AAFDefinitionObject
  ///
  HRESULT GetDefinitionObjectID (
    [retval,out] aafUID_t*  ppDef);

}




// ************************
//
// Interface IAAFPluginManager
//
// ************************
///
/// This interface is used with an object representing an AAF class
/// definition.  The operations on a class definition include managing
/// the position of the class within the class heirarchy, and
/// accessing property definitions associated with the class.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
[
    object,
    uuid(AD1BB85C-DBB2-11d2-809C-006008143E6F),
    helpstring("IAAFPluginManager Interface"),
    pointer_default(unique)
]
interface IAAFPluginManager : IUnknown
{

  //***********************************************************
  //
  // RegisterSharedPlugins()
  //
  /// Attempts to load and register all of the AAF plugin files found
  /// in shared installation directory.
  /// 
  HRESULT RegisterSharedPlugins ();


  //***********************************************************
  //
  // RegisterPluginDirectory()
  //
  /// Attempts to load and register all of the AAF plugin files found
  /// in the given directory.
  /// 
  /// @param directoryName [in] Pointer to the name of directory to look for plugins.
  ///
  HRESULT RegisterPluginDirectory (
    [in] aafCharacter_constptr  directoryName);


  //***********************************************************
  //
  // RegisterPluginFile()
  //
  /// Attempts to load and register all of the AAF plugins found
  /// in the given file.
  /// 
  /// @param fileName [in] Pointer to the name of plugin file to register.
  ///
  HRESULT RegisterPluginFile (
    [in] aafCharacter_constptr  fileName);


  //***********************************************************
  //
  // EnumLoadedPlugins()
  //
  /// Returns an enumerator which enumerates over all of the loaded
  /// plugin choices through the *ppEnum argument.  The returned
  /// enumerator is AddRef()ed before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - if ppEnum is null.
  /// 
  /// @param categoryID [in, ref] Which category ID do we want to enumerate
  /// @param ppEnum [out,retval] Loaded Plugin Enumeration
  ///
  HRESULT EnumLoadedPlugins (
    [in, ref] aafUID_constref  categoryID,
    [out,retval] IEnumAAFLoadedPlugins ** ppEnum);


  //***********************************************************
  //
  // CreatePluginDefinition()
  //
  /// Given a plugin definition ID, find a plugin and manufactures a
  /// plugin descriptor of the correct class for this plugin, filling
  /// in the values, and returning the definition through the
  /// *pPluginDesc argument.  The returned definition is AddRef()ed
  /// before it is returned.  You must call QueryInterface on the
  /// result in order to find the correct interface, and are
  /// responsible for adding the definition to the correct place in the
  /// dictionary, as well as preventing duplicates. The resulting
  /// definiton has the plugin descriptor already attached.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pPluginDesc pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - if pPluginDesc is null.
  /// 
  /// @param pluginDefID [in, ref] Which plugin definition do you want to create
  /// @param pDictionary [in] The dictionary of the file where the descriptor is to be created
  /// @param ppPluginDef [out] The interface of the returned definition
  ///
  HRESULT CreatePluginDefinition (
    [in, ref] aafUID_constref  pluginDefID,
    [in] IAAFDictionary * pDictionary,
    [out] IAAFDefObject**  ppPluginDef);


  //***********************************************************
  //
  // CreateInstance()
  //
  /// Create an object contained within one of the loaded plugin
  /// files.
  /// 
  /// Succeeds if all of the following are true:
  /// - the rclsid was found by the plugin manager
  /// - the interface corresponding to riid is supported by the plugin
  /// - if pUnkOuter is not NULL and given plugin supports aggregation
  ///   and riid must be a reference to IID_IUnknown.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// E_INVALIDARG
  ///   - if ppPlugin is null.
  ///   - pUnkOuter is not NULL and riid is not IID_IUnknown.
  ///
  /// AAFRESULT_EXTENSION_NOT_FOUND
  ///   - The given rclsid could not be found by the Plugin Manager.
  ///
  /// E_NOINTERFACE
  ///   - if initial interface given by riid is not supported by the
  ///     plugin.
  /// 
  /// @param rclsid [in] The class id of the plugin object do you want to create
  /// @param pUnkOuter [in] The controlling unknown of the new instance
  /// @param riid [in] The IID of the initialial interface for the new plugin instance
  /// @param ppPlugin [out,iid_is(riid)] The IID of the initialial interface for the new plugin instance
  ///
  HRESULT CreateInstance (
    [in] REFCLSID  rclsid,
    [in] IUnknown *  pUnkOuter,
    [in] REFIID  riid,
    [out,iid_is(riid)] void **  ppPlugin);
}



// ************************
//
// Interface IAAFProperty
//
// ************************
///
/// This interface is used to access instances of properties contained
/// in AAF persistent objects.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
[
    object,
    uuid(83057d74-9691-11d2-aa7f-80e6aa000000),
    helpstring("IAAFProperty Interface"),
    pointer_default(unique)
]
interface IAAFProperty : IUnknown
{

  //***********************************************************
  //
  // GetDefinition()
  //
  /// Returns the definition of this property.
  ///
  /// Succeeds if:
  /// - This object has already been Initialize()d.
  /// - The ppPropDef pointer is valid.
  /// - The associated property definition can be found in the
  ///   dictionary.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppPropDef arg is NULL.
  ///
  /// AAFRESULT_BAD_PROP
  ///   - The definition for this property could not be found in the
  ///     dictionary.
  /// 
  /// @param ppPropDef [out] This property's definition
  ///
  HRESULT GetDefinition (
    [out] IAAFPropertyDef ** ppPropDef);


  //***********************************************************
  //
  // GetValue()
  //
  /// Returns the Property Value object associated with this property.
  ///
  /// Succeeds if:
  /// - This object has already been Initialize()d.
  /// - The ppPval pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppValue arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - The given property is optional and not present.
  /// 
  /// @param ppValue [out] The Property Value object associated with this property.
  ///
  HRESULT GetValue (
    [out] IAAFPropertyValue ** ppValue);
}



// ************************
//
// Interface IAAFPropertyDef
//
// ************************
///
/// This interface is used to access the definitions of types for
/// properties contained in AAF persistent objects.
///
/// A property definition is used to indicate a particular property
/// within a class.  It defines the name and type of a property to be
/// contained in objects.  Clients cannot create these directly; they
/// must be created through IAAFClassDef::RegisterNewPropertyDef().
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///



 

///
/// Objects that implement IAAFPropertyDef also implement the following interfaces:
///  - IAAFMetaDefinition
[
    object,
    uuid(dfbd6521-1d81-11d2-bf96-006097116212),
    helpstring("IAAFPropertyDef Interface"),
    pointer_default(unique)
]
interface IAAFPropertyDef : IUnknown
{

  //***********************************************************
  //
  // GetTypeDef()
  //
  /// Returns a reference to this property's type definition.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  /// 
  /// @param ppTypeDef [out] definition of type contained by this property
  ///
  HRESULT GetTypeDef (
    [out] IAAFTypeDef ** ppTypeDef);


  //***********************************************************
  //
  // GetName()
  //
  /// Gets the human-legible name.
  /// 
  /// Writes the Name property, with a trailing null
  /// character, into the pName buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the Name property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetNameBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pName.
  /// 
  /// Succeeds if:
  /// - The pName pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   Name.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold Name.
  /// 
  /// @param pName [out, string, size_is(bufSize)] buffer into which Name is to be written
  /// @param bufSize [in] size of *pName buffer in bytes
  ///
  HRESULT GetName (
    [out, string, size_is(bufSize)] aafCharacter *  pName,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetNameBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetName().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetNameBufLen (
    [out] aafUInt32 *  pBufSize);


  //***********************************************************
  //
  // GetIsOptional()
  //
  /// Sets *pIsOptional to AAFTrue for properties that are optional.
  /// Sets it to AAFFalse for properties that are mandatory.
  ///
  /// Succeeds if:
  /// - The pIsOptional pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - The pIsOptional pointer is NULL.
  /// 
  /// @param pIsOptional [out, retval] pointer to the result
  ///
  HRESULT GetIsOptional (
    [out, retval] aafBoolean_t *  pIsOptional);

  //***********************************************************
  //
  // GetIsUniqueIdentifier()
  //
  /// Sets *pIsUniqueIdentifier to AAFTrue for properties that are optional.
  /// Sets it to AAFFalse for properties that are mandatory.
  ///
  /// Succeeds if:
  /// - The pIsUniqueIdentifier pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - The pIsUniqueIdentifier pointer is NULL.
  /// 
  /// @param pIsUniqueIdentifier [out, retval] pointer to the result
  ///
  HRESULT GetIsUniqueIdentifier (
    [out, retval] aafBoolean_t *  pIsUniqueIdentifier);




  //***********************************************************
  //
  // SetDescription()
  //
  /// Sets the description of the property definition.
  ///
  /// Set the Description property to the value specified in
  /// pDescription.  A copy is made of the data so the caller
  /// retains ownership of the *pDescription buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pDescription pointer is valid.
  /// 
  /// If this method fails the Description property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDescription arg is NULL.
  /// 
  /// @param pDescription [in, string] buffer from which Description is to be read
  ///
  HRESULT SetDescription (
    [in, string] aafCharacter_constptr  pDescription);


  //***********************************************************
  //
  // GetDescription()
  //
  /// Gets the description of the property definition.
  /// 
  /// Writes the Description property, with a trailing null
  /// character, into the pDescription buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the Description property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetDescriptionBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pDescription.
  /// 
  /// Succeeds if:
  /// - The pDescription pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   Description.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDescription arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold Description.
  /// 
  /// @param pDescription [out, string, size_is(bufSize)] buffer into which Description is to be written
  /// @param bufSize [in] size of *pDescription buffer in bytes
  ///
  HRESULT GetDescription (
    [out, string, size_is(bufSize)] aafCharacter *  pDescription,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetDescriptionBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetDescription().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetDescriptionBufLen (
    [out] aafUInt32 *  pBufSize);

}



// ************************
//
// Interface IAAFPropertyValue
//
// ************************
///
/// This interface is used to access the values of properties contained
/// in AAF persistent objects.  Values may be simple (e.g. integer),
/// structured (e.g. aafTimecode_t), other AAF persistent objects,
/// media, or arrays of other types.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
[
    object,
    uuid(83057d72-9691-11d2-aa7f-80e6aa000000),
    helpstring("IAAFPropertyValue Interface"),
    pointer_default(unique)
]
interface IAAFPropertyValue : IUnknown
{

  //***********************************************************
  //
  // GetType()
  //
  /// Returns the type definition associated with this property value.
  /// If this Property Value is not of a recognized type (such as from
  /// a damaged or incorrectly construct file) this method will return
  /// a raw access type which can be used to access the property data
  /// in a raw manner.
  ///
  /// Succeeds if:
  /// - The ppTypeDef pointer is valid.
  /// - The associated type definition can be found in the dictionary.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTypeDef arg is NULL.
  /// 
  /// @param ppTypeDef [out] The type definition associated with this property value
  ///
  HRESULT GetType (
    [out] IAAFTypeDef ** ppTypeDef);


  //***********************************************************
  //
  // IsDefinedType()
  //
  /// Returns false if this property value's type is not (necessarily)
  /// the one which was defined for it.  That may be the case if this
  /// property value was read from a damaged file where type
  /// information was not available; in that case GetType() will return
  /// the raw access type for this value.
  ///
  /// If this property value's type is the one which was defined for
  /// it, this method will return true and GetType() will return that
  /// defined type for this value.
  ///
  /// Succeeds if:
  /// - The pIsDefined pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pIsDefined arg is NULL.
  /// 
  /// @param pIsDefined [out] result
  ///
  HRESULT IsDefinedType (
    [out] aafBoolean_t *  pIsDefined);
}



// ************************
//
// Interface IAAFPulldown
//
// ************************
///
/// This interface is used with an object which converts between film
/// frame rates and videotape frame rates by describing the mapping
/// between them.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///


///
/// Objects that implement IAAFPulldown also implement the following interfaces:
///  - IAAFSegment
///  - IAAFComponent
///  - IAAFComponent2
///  - IAAFObject
[
    object,
    uuid(92B88031-2B2B-11d2-BF7E-00104BC9156D),
    helpstring("IAAFPulldown Interface"),
    pointer_default(unique)
]
interface IAAFPulldown : IUnknown
{

  //***********************************************************
  //
  // GetInputSegment()
  //
  /// Places the input Segment object in this pulldown into the
  /// *ppInputSegment argument.  If none exists yet, NULL is placed
  /// into the *ppInputSegment argument.
  ///
  /// The returned segment object, if it exists, is AddRef()ed
  /// before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppInputSegment pointer is valid.
  /// - A valid segment exists.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppInputSegment is null.
  /// 
  /// @param ppInputSegment [out] Returns the input Segment object
  ///
  HRESULT GetInputSegment (
    [out] IAAFSegment ** ppInputSegment);


  //***********************************************************
  //
  // SetInputSegment()
  //
  /// Sets the input segment .
  ///
  /// Succeeds if all of the following are true:
  /// - the pInputSegment pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pInputSegment is null.
  /// 
  /// @param pInputSegment [in] A Segment object
  ///
  HRESULT SetInputSegment (
    [in] IAAFSegment * pInputSegment);


  //***********************************************************
  //
  // GetPulldownKind()
  //
  /// Returns the pulldownKind property of this pulldown through the
  /// *pPulldownKind argument.  The pulldown kinds include
  /// kThreeTwoPD, kPalPD, kOneToOneNTSC, kOneToOnePAL, and
  /// kVideoTapNTSC.
  ///
  /// Succeeds if all of the following are true:
  /// - the pPulldownKind pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPulldownKind is null.
  /// 
  /// @param pPulldownKind [out] Returns the pulldownKind property
  ///
  HRESULT GetPulldownKind (
    [out] aafPulldownKind_t *  pPulldownKind);


  //***********************************************************
  //
  // SetPulldownKind()
  //
  /// Sets the pulldown kind field of this pulldown object.  The
  /// pulldown kinds include kThreeTwoPD, kPalPD, kOneToOneNTSC,
  /// kOneToOnePAL, and kVideoTapNTSC.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pInputSegment is null.
  /// 
  /// @param pulldownKind [in] A Segment object
  ///
  HRESULT SetPulldownKind (
    [in] aafPulldownKind_t  pulldownKind);


  //***********************************************************
  //
  // GetPulldownDirection()
  //
  /// Returns the pulldownDirection field of this pulldown through the
  /// *pPulldownDirection argument.  The valid
  /// pulldown directions are:
  ///    kVideoToFilmSpeed -- The input segment is at videoSpeed, and
  ///                         the pulldown object is on a mob slot at
  ///                         film edit rate.
  ///    kFilmToVideoSpeed -- The input segment is at film edit rate.
  ///
  /// The value kVideoToFilmSpeed is used when connecting 24fps file
  /// mobs to tape mobs. 
  ///
  /// The value kFilmToVideoSpeed is used when connecting tape mobs to
  /// film mobs.
  ///
  /// Succeeds if all of the following are true:
  /// - the pPulldownDirection pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPulldownDirection is null.
  /// 
  /// @param pPulldownDirection [out] Returns the input Segment object
  ///
  HRESULT GetPulldownDirection (
    [out] aafPulldownDir_t *  pPulldownDirection);


  //***********************************************************
  //
  // SetPulldownDirection()
  //
  /// Sets the pulldown direction field of this pulldown object.  The
  /// valid pulldown directions are:
  ///    kVideoToFilmSpeed -- The input segment is at videoSpeed, and
  ///                         the pulldown object is on a mob slot at
  ///                         film edit rate.
  ///    kFilmToVideoSpeed -- The input segment is at film edit rate.
  ///
  /// The value kVideoToFilmSpeed is used when connecting 24fps file
  /// mobs to tape mobs.
  ///
  /// The value kFilmToVideoSpeed is used when connecting tape mobs to
  /// film mobs.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pInputSegment is null.
  /// 
  /// @param pulldownDirection [in] A Segment object
  ///
  HRESULT SetPulldownDirection (
    [in] aafPulldownDir_t  pulldownDirection);


  //***********************************************************
  //
  // GetPhaseFrame()
  //
  /// Returns the phaseFrame field of this pulldown through the
  /// *pPhaseFrame argument.  The phase frame field specifies the phase
  /// within the repeating pattern used to map between the two edit
  /// rates. A value of zero specifies that the pulldown object starts
  /// at the begining of the pattern.
  ///
  /// Succeeds if all of the following are true:
  /// - the pPhaseFrame pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPhaseFrame is null.
  /// 
  /// @param pPhaseFrame [out] Returns the input Segment object
  ///
  HRESULT GetPhaseFrame (
    [out] aafPhaseFrame_t *  pPhaseFrame);


  //***********************************************************
  //
  // SetPhaseFrame()
  //
  /// Sets the phase frame field of this pulldown object.  The phase
  /// frame field specifies the phase within the repeating pattern used
  /// to map between the two edit rates. A value of zero specifies that
  /// the pulldown object starts at the begining of the pattern.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pInputSegment is null.
  /// 
  /// @param phaseFrame [in] A Segment object
  ///
  HRESULT SetPhaseFrame (
    [in] aafPhaseFrame_t  phaseFrame);






}



// ************************
//
// Interface IAAFRGBADescriptor
//
// ************************


///
/// IAAFRGBADescriptor is DEPRECATED.
/// Please use IAAFRGBADescriptor2.
///
/// The IAAFRGBADescriptor interface is implemented by objects
/// which describe video content data formatted using RGBA formatting.
///
/// In addition to the parameters inherited from AAFDigitalImageDescriptor,
/// this interface adds Pixel layout (order of R, B, G, alpha)
/// PixelStructure (sizes of the various components), Palette, Palette Layout,
/// and Palette Structure.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it through
///     this object's primary interface.  Note that
///     IAAFDigitalImageDescriptor is a primary interface for an
///     abstract class, so it is not appropriate for the
///     Initialize() method to exist in this interface.  The
///     Initialize() method is available through the concrete
///     object's primary interface.
///
///
/// Objects that implement IAAFRGBADescriptor also implement the following interfaces:
///  - IAAFRGBADescriptor2
///  - IAAFDigitalImageDescriptor
///  - IAAFDigitalImageDescriptor2
///  - IAAFFileDescriptor
///  - IAAFFileDescriptor2
///  - IAAFEssenceDescriptor
///  - IAAFObject
[
    object,
    uuid(e684d772-b935-11d2-bf9d-00104bc9156d),
    helpstring("IAAFRGBADescriptor Interface"),
    pointer_default(unique)
]

interface IAAFRGBADescriptor : IUnknown
{

  //***********************************************************
  //
  // SetPixelLayout()
  //
  /// Sets the layout and structure of the components in a single pixel.
  /// The layout array is an Array of 8 aafRGBAComponent_t.  The 'Code' field of the struct is
  /// from the set:
  ///   	- kAAFCompNone
  /// 	- kAAFCompAlpha
  /// 	- kAAFCompBlue
  /// 	- kAAFCompFill
  /// 	- kAAFCompGreen
  /// 	- kAAFCompPalette
  /// 	- kAAFCompRed
  ///
  /// The 'Size' field of the struct is the component size in bits.
  /// 
  /// If you set less than 8 entries, the remaining entries will be padded with kAAFCompNone and a size of zero.
  /// If this method fails the PixelLayout property will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param numberElements [in] The number of elements in each array
  /// @param PixelLayoutArray [in] Array of up to 8 aafRGBAComponent_t indicating component order and size.
  ///
  HRESULT SetPixelLayout (
    [in] aafUInt32  numberElements,
    [in] aafRGBAComponent_t*  PixelLayoutArray);

  //***********************************************************
  //
  // CountPixelLayoutElements()
  //
  /// This function returns the number of components in a pixel.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails no state is changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  /// 
  /// @param pResult [out] Number of components
  ///
  HRESULT CountPixelLayoutElements (
    [out] aafUInt32 *  pResult);

  //***********************************************************
  //
  // GetPixelLayout()
  //
  /// Gets the layout and structure of the components in a single pixel.
  /// The layout array is an Array of 8 aafRGBAComponent_t.  The 'Code' field of the struct is
  /// from the set:
  ///   	- kAAFCompNone
  /// 	- kAAFCompAlpha
  /// 	- kAAFCompBlue
  /// 	- kAAFCompFill
  /// 	- kAAFCompGreen
  /// 	- kAAFCompPalette
  /// 	- kAAFCompRed
  ///
  /// The 'Size' field of the struct is the component size in bits.
  /// 
  /// If you Get more entries than were set, the extra entries will be padded with kAAFCompNone and a size of zero.
  ///
  /// If this method fails, PixelLayoutArray will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumberElements or PixelLayoutArray or PixelStructureArray is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - numberElements indicates that the array is too small to hold
  ///     the data.
  /// 
  /// @param numberElements [in] The number of elements in the array
  /// @param PixelLayoutArray [out, size_is(numberElements)] Array to hold up to 8 aafRGBAComponent_t indicating component order and size.
  ///
  HRESULT GetPixelLayout (
    [in] aafUInt32  numberElements,
    [out, size_is(numberElements)] aafRGBAComponent_t*  PixelLayoutArray);

  //***********************************************************
  //
  // SetPalette()
  //
  /// Sets the palette property.  The palette must be in the form specified
  /// by the palette layout and palette structure parameters.
  /// 
  /// Succeeds if all of the following are true:
  /// - pPalette is a valid pointer
  /// 
  /// If this method fails, the palette property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPalette is NULL.
  /// 
  /// @param numberElements [in] The number of bytes in the array
  /// @param pPalette [in, size_is(numberElements)] Array to hold the palette information
  ///
  HRESULT SetPalette (
    [in] aafUInt32  numberElements,
    [in, size_is(numberElements)] aafUInt8*  pPalette);


  //***********************************************************
  //
  // GetPalette()
  //
  /// Sets the palette property.  The palette must be in the form specified
  /// by the palette layout and palette structure parameters.
  /// The values are written to the array specified by pPalette,
  /// which is of size numberElements.  The required size may be found
  /// by calling GetPaletteSize().
  /// 
  /// Succeeds if all of the following are true:
  /// - pPalette is a valid pointer.
  /// - numberElements indicates the array is large enough to hold the
  ///   data.
  /// 
  /// If this method fails, pPalette will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumberElements is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - numberElements indicates that the array is too small to hold
  ///     the data.
  /// 
  /// @param numberRecords [in] The number of bytes in the array
  /// @param pPalette [out, size_is(numberRecords)] Array to hold the palette information
  ///
  HRESULT GetPalette (
    [in] aafUInt32  numberRecords,
    [out, size_is(numberRecords)] aafUInt8*  pPalette);


  //***********************************************************
  //
  // GetPaletteSize()
  //
  /// Get the number of bytes in the VideoLineMap property array.
  /// 
  /// Succeeds if all of the following are true:
  /// - pNumberBytes is a valid pointer
  /// 
  /// If this method fails, *pNumberBytes will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumberBytes is NULL.
  /// 
  /// @param pNumberBytes [out] The number of bytes in the array
  ///
  HRESULT GetPaletteSize (
    [out] aafUInt32 *  pNumberBytes);

  //***********************************************************
  //
  // CountPaletteLayoutElements()
  //
  /// This function returns the number of components in a pixel.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails no state is changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  /// 
  /// @param pResult [out] Number of components
  ///
  HRESULT CountPaletteLayoutElements (
    [out] aafUInt32 *  pResult);

  //***********************************************************
  //
  // SetPaletteLayout()
  //
  /// Sets the layout and structure of the components in a single pixel.
  /// The layout array is an Array of 8 aafRGBAComponent_t.  The 'Code' field of the struct is
  /// from the set:
  ///   	- kAAFCompNone
  /// 	- kAAFCompAlpha
  /// 	- kAAFCompBlue
  /// 	- kAAFCompFill
  /// 	- kAAFCompGreen
  /// 	- kAAFCompPalette
  /// 	- kAAFCompRed
  ///
  /// The 'Size' field of the struct is the component size in bits.
  /// 
  /// If you set less than 8 entries, the remaining entries will be padded with kAAFCompNone and a size of zero.
  /// If this method fails the PaletteLayout property will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param numberElements [in] The number of elements in the array
  /// @param PaletteLayoutArray [in] Array of up to 8 bytes indicating component size, matching layout, and terminated by a zero byte.
  ///
  HRESULT SetPaletteLayout (
    [in] aafUInt32  numberElements,
    [in] aafRGBAComponent_t*  PaletteLayoutArray);

  //***********************************************************
  //
  // GetPaletteLayout()
  //
  /// The layout array is an Array of 8 aafRGBAComponent_t.  The 'Code' field of the struct is
  /// from the set:
  ///   	- kAAFCompNone
  /// 	- kAAFCompAlpha
  /// 	- kAAFCompBlue
  /// 	- kAAFCompFill
  /// 	- kAAFCompGreen
  /// 	- kAAFCompPalette
  /// 	- kAAFCompRed
  ///
  /// The 'Size' field of the struct is the component size in bits.
  /// 
  /// If you Get more entries than were set, the extra entries will be padded with kAAFCompNone and a size of zero.
  ///
  /// If this method fails, PaletteLayoutArray will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumberElements or PaletteLayoutArray is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - numberElements indicates that the array is too small to hold
  ///     the data.
  /// 
  /// @param numberElements [in] The number of elements in each array
  /// @param PaletteLayoutArray [out, size_is(numberElements)] Array to hold 8 aafRGBAComponent_t indicating component order and size.
  ///
  HRESULT GetPaletteLayout (
    [in] aafUInt32  numberElements,
    [out, size_is(numberElements)] aafRGBAComponent_t*  PaletteLayoutArray);












}


// ************************
//
// Interface IAAFRandomFile
//
// ************************
///
/// Specialized file interface for use with files which exist on
/// storage media which has random access capability.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
///
/// Objects that implement IAAFRandomFile also implement the following interfaces:
///  - IAAFFile
[
    object,
    uuid(3CC80284-72A8-11D4-B80D-0000863F2C27),
    helpstring("IAAFRandomFile Interface"),
    pointer_default(unique)
]
interface IAAFRandomFile : IUnknown
{

  //***********************************************************
  //
  // GetFileBits()
  //
  /// Since the purpose of this method is to obtain file data after a
  /// file has been created, it will only succeed if this file has
  /// already been Open()ed and then Close()d, or if it was never
  /// opened with write access.
  /// 
  /// Succeeds if:
  /// - The ppGetFileBits argument is valid
  /// - This file has been opened for write or modify, and has been
  ///   subsequently closed.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppGetFileBits arg is NULL.
  ///
  /// AAFRESULT_BADOPEN
  /// - This file has never been opened
  ///
  /// AAFRESULT_NOT_WRITEABLE
  /// - This file has never been opened for write or modify
  ///
  /// AAFRESULT_BADCLOSE
  /// - This file has not been closed after being opened.
  /// 
  /// @param ppGetFileBits [out] The interface to the GetFileBits object
  ///
  HRESULT GetFileBits (
    [out] IAAFGetFileBits ** ppGetFileBits);


  //***********************************************************
  //
  // Revert()
  //
  /// Reverts this file to the previously-saved state.
  ///
  /// NOTE! Stub only.   Implementation not yet added.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  HRESULT Revert ();


  //***********************************************************
  //
  // SaveAsFile()
  //
  /// Associates this file with the storage specified in pDestFile.
  /// Any objects contained in pDestFile will be lost.
  /// 
  /// Behaves in a manner similar to SaveCopyAs(), except that
  /// SaveAs() will change this object to be associated with the new
  /// file.
  /// 
  /// Special case: if f->SaveAs(f) is called, passing this as the
  /// save-to argument, the operation will save everything including
  /// things which have not changed.
  ///
  /// NOTE! Stub only.   Implementation not yet added.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param pDestFile [in] The destination file into which the contents of this file are to
  /// be written.
  ///
  HRESULT SaveAsFile (
    [in] IAAFFile * pDestFile);


  //***********************************************************
  //
  // SetFileBits()
  //
  /// Since the purpose of this method is to specify file data with
  /// which a file is to be created, it will only succeed if this file
  /// has not yet been Open()ed.
  ///
  /// Succeeds if:
  /// - The ppSetFileBits argument is valid
  /// - This file has not yet been opened.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppSetFileBits arg is NULL.
  ///
  /// AAFRESULT_BADOPEN
  /// - This file has has already been opened
  ///
  /// AAFRESULT_NOT_READABLE
  /// - This read or modify has not been specified for this file
  /// 
  /// @param ppSetFileBits [out] The interface to the SetFileBits object
  ///
  HRESULT SetFileBits (
    [out] IAAFSetFileBits ** ppSetFileBits);
}



// ************************
//
// Interface IAAFRandomRawStorage
//
// ************************
///
/// This interface is used by the toolkit to access storage in which
/// AAF files are to be read and written.  It is typically implemented
/// by clients of IAAFFileXXX.  Note that some implementations are
/// provided as a convenience to IAAFFileXXX clients.
///
/// Assumes that the storage has at least random access capability.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.


///
/// Objects that implement IAAFRandomRawStorage also implement the following interfaces:
///  - IAAFRawStorage
[
    object,
    uuid(B1341782-71FE-11d4-B80D-0000863F2C27),
    helpstring("IAAFRandomRawStorage Interface"),
    pointer_default(unique)
]
interface IAAFRandomRawStorage : IUnknown
{

  //***********************************************************
  //
  // ReadAt()
  //
  /// Attempts to read bufsize bytes from this storage.  Places the
  /// data into buf, and puts the actual number of bytes read into
  /// *pNumRead.  If the end of the storage is encountered before
  /// bufSize bytes can be read, the value written into *pNumRead may
  /// be smaller than bufSize.
  ///
  /// This call will advance the current position by *pNumRead bytes.
  ///
  /// Succeeds if:
  /// - The pNumRead pointer is valid.
  /// - This storage is open for read or read/write.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - buf or pNumRead arg is NULL.
  ///
  /// AAFRESULT_NOT_READABLE
  ///   - This storage is not open for read or read/write.
  /// 
  /// @param position [in] position in this storage from which data is read
  /// @param buf [out, size_is(bufSize), length_is(*pNumRead)] Buffer into which data is read
  /// @param bufSize [in] Size of buf in bytes
  /// @param pNumRead [out] Number of bytes read
  ///
  HRESULT ReadAt (
    [in] aafUInt64  position,
    [out, size_is(bufSize), length_is(*pNumRead)] aafMemPtr_t  buf,
    [in] aafUInt32  bufSize,
    [out] aafUInt32 *  pNumRead);


  //***********************************************************
  //
  // WriteAt()
  //
  /// Writes bufsize bytes into this storage.  Obtains the data
  /// from buf.
  ///
  /// This call may fail if the capacity of this storage cannot be
  /// extended sufficiently to complete the request.  The client can
  /// call SetSize() to attempt to reserve capacity for the storage;
  /// if the SetSize() call succeeds, subsequent Write() calls
  /// within requested that capacty are guaranteed to succeed.
  ///
  /// This call will advance the current position by bufSize bytes.
  ///
  /// Succeeds if:
  /// - The pNumWritten pointer is valid.
  /// - This storage is open for write or read/write.
  /// - Sufficient capacity exists in this storage to perform the
  ///   write.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumWritten arg is NULL.
  ///
  /// AAFRESULT_NOT_WRITEABLE
  ///   - This storage is not open for write or read/write.
  ///
  /// AAFRESULT_OFFSET_SIZE
  ///   - It is not possible to extend the allocated size of this
  ///     storage.
  /// 
  /// @param position [in] position in this storage into which data is written
  /// @param buf [in, size_is(bufSize)] Buffer from which data is written
  /// @param bufSize [in] Number of bytes
  /// @param pNumWritten [out] Number of bytes written
  ///
  HRESULT WriteAt (
    [in] aafUInt64  position,
    [in, size_is(bufSize)] aafMemConstPtr_t  buf,
    [in] aafUInt32  bufSize,
    [out] aafUInt32 *  pNumWritten);


  //***********************************************************
  //
  // GetSize()
  //
  /// Returns the highest byte position in this storage which has been
  /// written so far.
  ///
  /// Succeeds if:
  /// - The pSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSize arg is NULL.
  /// 
  /// @param pSize [out] Number of bytes currently in this storage
  ///
  HRESULT GetSize (
    [out] aafUInt64 *  pSize);


  //***********************************************************
  //
  // IsExtendable()
  //
  /// Sets *pResult to true if the memory allocated to this storage can
  /// be dynamically extened; sets it to false otherwise.
  ///
  /// Succeeds if:
  /// - The pResult pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult arg is NULL.
  /// 
  /// @param pResult [out] set to true if extendable
  ///
  HRESULT IsExtendable (
    [out] aafBoolean_t *  pResult);


  //***********************************************************
  //
  // GetExtent()
  //
  /// Returns the number of bytes currently allocated storage.
  ///
  /// Succeeds if:
  /// - The pSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pExtent arg is NULL.
  /// 
  /// @param pExtent [out] Number of bytes currently allocated for this storage
  ///
  HRESULT GetExtent (
    [out] aafUInt64 *  pExtent);


  //***********************************************************
  //
  // SetExtent()
  //
  /// Requests the given capacity for this storage.  If successful,
  /// subsequent calls to WriteAt() and IAAFRawStorage::Write()
  /// within that capacity are guaranteed to succeed.
  ///
  /// Succeeds if:
  /// - It is permissible to set the extent of this storage.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_OFFSET_SIZE
  ///   - This storage has insufficient capacity to perform the write.
  /// 
  /// @param extent [in] Number of bytes capacity requested for this storage
  ///
  HRESULT SetExtent (
    [in] aafUInt64  extent);
}



// ************************
//
// Interface IAAFRawStorage
//
// ************************
///
/// This interface is used by the toolkit to access storage in which
/// AAF files are to be read and written.  It is typically implemented
/// by clients of IAAFFileXXX.  Note that some implementations are
/// provided as a convenience to IAAFFileXXX clients.
///
/// When writing to a stream, clients should be aware that the
/// stream's capacity may be limited.  To insure that writes will not
/// fail due to insufficient stream capacity, clients can call
/// SetSize() to pre-allocate capacity in the stream.  Writes done
/// within the size specified to the most recent successful SetSize()
/// call are guaranteed to succeed.
///
/// Assumes that the storage has at least sequential access
/// capability.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.


[
    object,
    uuid(F45FA9E1-7166-11D4-B80D-0000863F2C27),
    helpstring("IAAFRawStorage Interface"),
    pointer_default(unique)
]
interface IAAFRawStorage : IUnknown
{

  //***********************************************************
  //
  // IsReadable()
  //
  /// Sets *pResult to true if this storage is readable; sets it to
  /// false otherwise.
  ///
  /// Succeeds if:
  /// - The pResult pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult arg is NULL.
  /// 
  /// @param pResult [out] set to true if readable
  ///
  HRESULT IsReadable (
    [out] aafBoolean_t *  pResult);


  //***********************************************************
  //
  // Read()
  //
  /// Attempts to read bufsize bytes from this stream.  Places the data
  /// into buf, and puts the actual number of bytes read into
  /// *pNumRead.  If the end of the stream is encountered before
  /// bufSize bytes can be read, the value written into *pNumRead may
  /// be smaller than bufSize.
  ///
  /// This call will advance the current position by *pNumRead bytes.
  ///
  /// Succeeds if:
  /// - The pNumBytes pointer is valid.
  /// - This stream is open for read or read/write.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - buf or pNumRead arg is NULL.
  ///
  /// AAFRESULT_NOT_READABLE
  ///   - This stream is not open for read or read/write.
  /// 
  /// @param buf [out, size_is(bufSize), length_is(*pNumRead)] Buffer into which data is read
  /// @param bufSize [in] Size of buf in bytes
  /// @param pNumRead [out] Number of bytes read
  ///
  HRESULT Read (
    [out, size_is(bufSize), length_is(*pNumRead)] aafMemPtr_t  buf,
    [in] aafUInt32  bufSize,
    [out] aafUInt32 *  pNumRead);


  //***********************************************************
  //
  // IsWriteable()
  //
  /// Sets *pResult to true if this storage is writeable; sets it to
  /// false otherwise.
  ///
  /// Succeeds if:
  /// - The pResult pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult arg is NULL.
  /// 
  /// @param pResult [out] set to true if writeable
  ///
  HRESULT IsWriteable (
    [out] aafBoolean_t *  pResult);


  //***********************************************************
  //
  // Write()
  //
  /// Writes bufsize bytes into this stream.  Obtains the data
  /// from buf.
  ///
  /// This call may fail if the stream has insufficient capacity to
  /// complete the request.  If this storage supports the
  /// IAAFRandomRawStorage interface, the client can call
  /// IAAFRandomRawStorage::SetSize() to attempt to reserve capacity
  /// in the stream; if the SetSize() call succeeds, subsequent
  /// Write() calls within that capacity are guaranteed to succeed.
  ///
  /// This call will advance the current position by bufSize bytes.
  ///
  /// Succeeds if:
  /// - This stream is open for write or read/write.
  /// - Sufficient capacity exists in this stream to perform the
  ///   write.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_WRITEABLE
  ///   - This stream is not open for write or read/write.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - This stream has insufficient capacity to perform the write.
  /// 
  /// @param buf [in, size_is(bufSize)] Buffer from which data is written
  /// @param bufSize [in] Number of bytes to write
  /// @param pNumWritten [out] Number of bytes written
  ///
  HRESULT Write (
    [in, size_is(bufSize)] aafMemConstPtr_t  buf,
    [in] aafUInt32  bufSize,
    [out] aafUInt32 *  pNumWritten);


  //***********************************************************
  //
  // Synchronize()
  //
  /// Synchronizes any cached data with the underlying storage.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  HRESULT Synchronize ();
}



// ************************
//
// Interface IAAFRIFFChunk
//
// ************************
///
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - Insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it.
///
///
/// Objects that implement IAAFRIFFChunk also implement the following interfaces:
///  - IAAFObject
[
    object,
    uuid(49b6de18-f562-434e-bfab-a46d144ef22a),
    helpstring("IAAFRIFFChunk Interface"),
    pointer_default(unique)
]

interface IAAFRIFFChunk : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty
  /// IAAFRIFFChunk-supporting object. The data content is initially
  /// empty.
  ///
  /// This method must be called after allocation, and before any other
  /// method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  /// 
  /// @param chunkID [in] ChunkID value
  ///
  HRESULT Initialize (
    [in] aafUInt32  chunkID);


  //***********************************************************
  //
  // SetChunkID()
  //
  /// Sets the ChunkID property.
                        
  ///
  /// Succeeds if all of the following are true:
  /// - This object has already been had Initialize() called on it.
  ///
  /// If this method fails, the ChunkID property will not be
  /// changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param chunkID [in] ChunkID to set
  ///
  HRESULT SetChunkID (
    [in] aafUInt32  chunkID);

  //***********************************************************
  //
  // GetChunkID()
  //
  /// Gets the ChunkID property.
  ///
  ///
  /// Succeeds if all of the following are true:
  /// - pChunkID is a valid pointer
  ///
  /// If this method fails, pChunkID will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pChunkID is NULL.
  /// 
  /// @param pChunkID [out] Retrieved ChunkID
  ///
  HRESULT GetChunkID (
    [out] aafUInt32 *  pChunkID);


  //***********************************************************
  //
  // Read()
  //
  /// Reads data from this RIFFChunk at the current position. Advances the position by the number of bytes read.
  /// 
  /// @param bytes [in] read this many bytes
  /// @param buffer [out, size_is(bytes), length_is(*pBytesRead)] buffer to receive chunk data
  /// @param pBytesRead [out,ref] 
  ///
  HRESULT Read (
    [in] aafUInt32  bytes,
    [out, size_is(bytes), length_is(*pBytesRead)] aafDataBuffer_t  buffer,
    [out,ref] aafUInt32 *  pBytesRead);


  //***********************************************************
  //
  // Write()
  //
  /// Write data to this RIFFChunk at the current position. Advances the position
/// by the number of bytes written. Any data beyond the new position is lost; 
///that is, the buffer is truncated.
  /// 
  /// @param bytes [in] write this many bytes
  /// @param buffer [out, size_is(bytes)] chunk data to write
  /// @param pBytesWritten [out,ref] actual number of bytes written
  ///
  HRESULT Write (
    [in] aafUInt32  bytes,
    [out, size_is(bytes)] aafDataBuffer_t  buffer,
    [out,ref] aafUInt32 *  pBytesWritten);


  //***********************************************************
  //
  // SetPosition()
  //
  /// Seeks to absolute position within the RIFFChunk data. The next Read or Write
/// call will operate from the given position.
  /// 
  /// @param offset [in] offset from beginning of the RIFFChunk data
  ///
  HRESULT SetPosition (
    [in] aafPosition_t  offset);


  //***********************************************************
  //
  // GetPosition()
  //
  /// Gets the current position within the RIFFChunk data. This is the position at
///which the next Read or Write call will operate.
  /// 
  /// @param pOffset [out] current offset from beginning of the RIFFChunk data
  ///
  HRESULT GetPosition (
    [out] aafPosition_t*  pOffset);


  //***********************************************************
  //
  // GetLength()
  //
  /// Returns the total size of the RIFFChunk data, in bytes.
  /// 
  /// @param pLength [out] length of the RIFFChunk data
  ///
  HRESULT GetLength (
    [out] aafLength_t *  pLength);


}



// ************************
//
// Interface IAAFRecordingDescriptor
//
// ************************

///
/// The IAAFRecordingDescriptor interface is implemented by objects that
/// describe a file source which has no physical source.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
///
/// Objects that implement IAAFRecordingDescriptor also implement the following interfaces:
///  - IAAFPhysicalDescriptor
///  - IAAFEssenceDescriptor
///  - IAAFObject
[
    object,
    uuid(a6542226-19a7-40ee-9650-a3b9c66ccfe7),
    helpstring("IAAFRecordingDescriptor Interface"),
    pointer_default(unique)
]

interface IAAFRecordingDescriptor : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty
  /// IAAFRecordingDescriptor object.  This method must be called
  /// after allocation, and before any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  /// 
  HRESULT Initialize ();

}



// ************************
//
// Interface IAAFScopeReference
//
// ************************
///
/// This interface is used with an object representing a reference to a
/// segment on another slot of this scope (AAFNestedScope or AAFMob)
/// or an enclosing scope.  Scope references are specified in terms of
/// a relative slot offset, and the number of scopes to skip outward.
/// For example a slot offset of 1 and a scope of 0 means to look 1
/// track back in the current scope.  A slot offset of 1 and a scope of
/// 1 means to look one slot lower in the enslosing scope.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
///
/// Objects that implement IAAFScopeReference also implement the following interfaces:
///  - IAAFSegment
///  - IAAFComponent
///  - IAAFComponent2
///  - IAAFObject
[
    object,
    uuid(e44be453-2099-11d2-bf98-006097116212),
    helpstring("IAAFScopeReference Interface"),
    pointer_default(unique)
]
interface IAAFScopeReference : IUnknown
{

  //***********************************************************
  //
  // Create()
  //
  /// Constructs a Scope Reference object.
  /// 
  /// If this method fails the length property will not be
  /// changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param RelativeScope [in] Number of nested scopes to pass to find the Nested Scope slot
  /// @param RelativeSlot [in] Number of slots to look backwards from the slot containing the
  /// Scope Reference
  ///
  HRESULT Create (
    [in] aafUInt32  RelativeScope,
    [in] aafUInt32  RelativeSlot);

  //***********************************************************
  //
  // Initialize()
  //
  /// Constructs a Scope Reference object.
  /// 
  /// If this method fails the length property will not be
  /// changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param pDataDef [in] Data definition for referenced slot
  /// @param RelativeScope [in] Number of nested scopes to pass to find the Nested Scope slot
  /// @param RelativeSlot [in] Number of slots to look backwards from the slot containing the
  /// Scope Reference
  ///
  HRESULT Initialize (
    [in] IAAFDataDef * pDataDef,
    [in] aafUInt32  RelativeScope,
    [in] aafUInt32  RelativeSlot);

  //***********************************************************
  //
  // GetRelativeScope()
  //
  /// Gets the number of nested scopes to pass to find the Nested Scope
  /// slot.
  ///	
  /// Succeeds if all of the following are true:
  /// - the pnRelativeScope pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pnRelativeScope.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pnRelativeScope arg is NULL.
  /// 
  /// @param pnRelativeScope [retval][out] Pointer to a Relative Scope
  ///
  HRESULT GetRelativeScope (
    [retval][out] aafUInt32 *  pnRelativeScope);


  //***********************************************************
  //
  // GetRelativeSlot()
  //
  /// Gets the number of slots that preced the slot containing the
  /// Scope Reference. 
  ///	
  /// Succeeds if all of the following are true:
  /// - the pnRelativeScope pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pnRelativeSlot.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pnRelativeSlot arg is NULL.
  /// 
  /// @param pnRelativeSlot [retval][out] Pointer to a Relative Slot
  ///
  HRESULT GetRelativeSlot (
    [retval][out] aafUInt32 *  pnRelativeSlot);
}



// ************************
//
// Interface IAAFSegment
//
// ************************
///
/// The IAAFSegment interface is implemented by objects which represent
/// a component that is independent of any other components which may
/// surround it in a sequence.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it through
///     this object's primary interface.  Note that IAAFSegment is a
///     primary interface for an abstract class, so it is not
///     appropriate for the Initialize() method to exist in this
///     interface.  The Initialize() method is available through the
///     concrete object's primary interface.
///


///
/// Objects that implement IAAFSegment also implement the following interfaces:
///  - IAAFComponent
///  - IAAFComponent2
///  - IAAFObject
[
    object,
    uuid(7a2f0570-1ba3-11D2-bfaa-006097116212),
    helpstring("IAAFSegment Interface"),
    pointer_default(unique)
]
interface IAAFSegment : IUnknown
{

  //***********************************************************
  //
  // SegmentOffsetToTC()
  //
  /// Converts the given Segment offset to timecode.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pOffset pointer is valid.
  /// - the pTimeCode pointer is valid.
  /// 
  /// If this method fails the value of pTimecode is left unchanged.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - any arg is NULL.
  ///
  /// AAFRESULT_TIMECODE_NOT_FOUND
  ///   - the given offset is not available in this segment.
  /// 
  /// @param pOffset [in] Pointer to a Segment Offset to be convert to Timecode
  /// @param pTimecode [out] The converted timecode to be returned
  ///
  HRESULT SegmentOffsetToTC (
    [in] aafPosition_t *  pOffset,
    [out] aafTimecode_t *  pTimecode);


  //***********************************************************
  //
  // SegmentTCToOffset()
  //
  /// Converts the given Timecode to an Offset.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pTimeCode pointer is valid.
  /// - the pEditRate pointer is valid
  /// - the pFrameOffset pointer is valid.
  /// 
  /// If this method fails the value of pOffset is left unchanged.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - any arg is NULL.
  ///
  /// AAFRESULT_TIMECODE_NOT_FOUND
  ///   - the given timecode is not available in this segment.
  /// 
  /// @param pTimecode [in] Pointer to a timecode to be converted to Offset
  /// @param pEditRate [in] The edit rate for the given timecode 
  /// @param pOffset [out] Frame Offset to be returned if found
  ///
  HRESULT SegmentTCToOffset (
    [in] aafTimecode_t *  pTimecode,
    [in] aafRational_t *  pEditRate,
    [out] aafFrameOffset_t *  pOffset);
}



// ************************
//
// Interface IAAFSelector
//
// ************************
///
/// The IAAFSelector interface is implemented by objects that specify a
/// single segment while preserving references to unused alternatives.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it through
///     this object's primary interface. 
///
///
/// Objects that implement IAAFSelector also implement the following interfaces:
///  - IAAFSegment
///  - IAAFComponent
///  - IAAFComponent2
///  - IAAFObject
[
    object,
    uuid(e684d788-b935-11d2-bf9d-00104bc9156d),
    helpstring("IAAFSelector Interface"),
    pointer_default(unique)
]
interface IAAFSelector : IUnknown
{

  //***********************************************************
  //
  // GetSelectedSegment()
  //
  /// Places the Selected Segment object in this Selector into the
  /// *ppSelSegment argument.  If none exists yet, NULL is placed into
  /// the *ppSelSegment argument.
  ///
  /// The returned essence descriptor object, if it exists, is
  /// AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppSelSegment pointer is valid.
  /// - A valid segment exists.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppSelSegment is null.
  /// 
  /// @param ppSelSegment [out] Returned the selected Segment object
  ///
  HRESULT GetSelectedSegment (
    [out] IAAFSegment ** ppSelSegment);


  //***********************************************************
  //
  // SetSelectedSegment()
  //
  /// Sets the Selected segment.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSelSegment pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSelSegment is null.
  /// 
  /// @param pSelSegment [in] A Segment object
  ///
  HRESULT SetSelectedSegment (
    [in] IAAFSegment * pSelSegment);


  //***********************************************************
  //
  // AppendAlternateSegment()
  //
  /// This function appends the input segment to the alternate segment
  /// list, the alternate list of segments represents unused
  /// alternative segments. 
  ///
  /// This method will AddRef() the segment if it succeeds.
  ///
  /// If the segment is successfully appended to the set of
  /// alternates, the reference count of the segment is incremented.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the pSegment pointer is valid.
  /// 
  /// If this method fails no state is changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSegment is null.
  /// 
  /// @param pSegment [in] Segment to append to the Alternate list of segments
  ///
  HRESULT AppendAlternateSegment (
    [in] IAAFSegment * pSegment);


  //***********************************************************
  //
  // GetNumAlternateSegments()
  //
  /// This function returns the number of segments in the set.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the pNumSegments pointer is valid.
  /// 
  /// If this method fails no state is changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumSegments is null.
  /// 
  /// @param pNumSegments [out] Number of Alternate Segments
  ///
  HRESULT GetNumAlternateSegments (
    [out] aafInt32 *  pNumSegments);


  //***********************************************************
  //
  // EnumAlternateSegments()
  //
  /// Places an IEnumAAFSegments enumerator for the alterante segments
  /// contained in the selector into the *ppEnum argument.
  /// 
  /// The returned enumerator is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// E_FAIL
  ///   - Failed to create the enumerator.
  /// 
  /// @param ppEnum [out, retval] Segment Enumeration
  ///
  HRESULT EnumAlternateSegments (
    [out, retval] IEnumAAFSegments ** ppEnum);

  //***********************************************************
  //
  // RemoveAlternateSegment()
  //
  /// Removes the given Segment from the selector.
  ///
  /// Succeeds if all of the following are true:
  /// - the v pointer is valid.
  /// - the given segment is currently in the collection.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEssenceData is null.
  ///
  /// AAFRESULT_SEGMENT_NOT_FOUND
  ///   - the given segment is not already contained.
  /// 
  /// @param pSegment [in] Segment to remove
  ///
  HRESULT RemoveAlternateSegment (
    [in] IAAFSegment * pSegment);

}



// ************************
//
// Interface IAAFSequence
//
// ************************
///
/// This interface provides access to the list of Segment and
/// Transition objects maintained by a Sequence object.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
///
/// Objects that implement IAAFSequence also implement the following interfaces:
///  - IAAFSegment
///  - IAAFComponent
///  - IAAFComponent2
///  - IAAFObject
[
    object,
    uuid(66e855f0-2bc2-11d2-bfaa-006097116212),
    helpstring("IAAFSequence Interface"),
    pointer_default(unique)
]
interface IAAFSequence : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// This function sets the properties on a newly created sequence
  /// object with the given property values. The length of the sequence
  /// is initially set to 0.  When components are appended to the
  /// sequence with the AppendComponent() call, the length of the
  /// appended component is added to the length of the sequence.  The
  /// given DataDef specifies the kind of data which all components to
  /// be contained in this sequence must share.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has not yet been initialized.
  /// 
  /// If this method fails no state is changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDataDef is null.
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  /// 
  /// @param pDataDef [in] DataDef of this object
  ///
  HRESULT Initialize (
    [in] IAAFDataDef * pDataDef);


  //***********************************************************
  //
  // AppendComponent()
  //
  /// This function appends the input component to the given sequence,
  /// enforcing bottom up creation of mobs.  The length of the sequence
  /// is incremented by the size of the component, unless the
  /// component is a transition.  If the component is a transition, it
  /// verifies that it is not the first object in a transition, and
  /// that it is not neighboring another transition.  It also verifies
  /// that there is enough source material on either side of the
  /// transition.  The function also verifies that the datadefs are
  /// compatible.
  ///
  /// This method will AddRef() the component if it succeeds.
  ///
  /// If the component is successfully appended to the sequence, the
  /// reference count of the component is incremented.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the pComponent pointer is valid.
  /// 
  /// If this method fails no state is changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pComponent is null.
  ///
  /// AAFRESULT_INVALID_DATADEF
  ///   - The data kind of the component is not compatible with the 
  ///     data def of the sequence.
  ///
  /// AAFRESULT_LEADING_TRAN
  ///   - Attempted to append a transition as the first component of
  ///     a sequence.  A sequence can not start with a transition. 
  ///
  /// AAFRESULT_ADJACENT_TRAN
  ///   - Attempted to append a transition next to a transition.  A
  ///     sequence can not contain back to back transitions.
  ///
  /// AAFRESULT_INSUFF_TRAN_MATERIAL
  ///   - There is not enough source material to add this component.
  /// 
  /// @param pComponent [in] Component to append to the sequence
  ///
  HRESULT AppendComponent (
    [in] IAAFComponent * pComponent);


  //***********************************************************
  //
  // PrependComponent()
  //
  /// This function prepends the input component to the given
  /// sequence, enforcing bottom up creation of mobs.  The length of
  /// the sequence is incremented by the size of the component, unless
  /// the component is a transition.  If the component is a
  /// transition, it verifies that it is not the first object in a
  /// transition, and that it is not neighboring another transition.
  /// It also verifies that there is enough source material on either
  /// side of the transition.  The function also verifies that the
  /// datadefs are compatible.
  ///
  /// This method will AddRef() the component if it succeeds.
  ///
  /// If the component is successfully appended to the sequence, the
  /// reference count of the component is incremented.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the pComponent pointer is valid.
  /// 
  /// If this method fails no state is changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pComponent is null.
  ///
  /// AAFRESULT_INVALID_DATADEF
  ///   - The data kind of the component is not compatible with the 
  ///     data def of the sequence.
  ///
  /// AAFRESULT_LEADING_TRAN
  ///   - Attempted to append a transition as the first component of
  ///     a sequence.  A sequence can not start with a transition. 
  ///
  /// AAFRESULT_ADJACENT_TRAN
  ///   - Attempted to append a transition next to a transition.  A
  ///     sequence can not contain back to back transitions.
  ///
  /// AAFRESULT_INSUFF_TRAN_MATERIAL
  ///   - There is not enough source material to add this component.
  /// 
  /// @param pComponent [in] Component to prepend to the sequence
  ///
  HRESULT PrependComponent (
    [in] IAAFComponent * pComponent);


  //***********************************************************
  //
  // InsertComponentAt()
  //
  /// This function inserts the input component into the given sequence
  /// at the given index, enforcing bottom up creation of mobs.  The
  /// length of the sequence is incremented by the size of the
  /// component, unless the component is a transition.  If the
  /// component is a transition, it verifies that it is not the first
  /// object in a transition, and that it is not neighboring another
  /// transition.  It also verifies that there is enough source
  /// material on either side of the transition.  The function also
  /// verifies that the datadefs are compatible.
  ///
  /// This method will AddRef() the component if it succeeds.
  ///
  /// If the component is successfully appended to the sequence, the
  /// reference count of the component is incremented.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the pComponent pointer is valid.
  /// - index is less than or equal to the value returned by
  ///   CountComponents().
  /// 
  /// If this method fails no state is changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pComponent is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than the value returned by
  ///     CountComponents().
  ///
  /// AAFRESULT_INVALID_DATADEF
  ///   - The data kind of the component is not compatible with the 
  ///     data def of the sequence.
  ///
  /// AAFRESULT_LEADING_TRAN
  ///   - Attempted to append a transition as the first component of
  ///     a sequence.  A sequence can not start with a transition. 
  ///
  /// AAFRESULT_ADJACENT_TRAN
  ///   - Attempted to append a transition next to a transition.  A
  ///     sequence can not contain back to back transitions.
  ///
  /// AAFRESULT_INSUFF_TRAN_MATERIAL
  ///   - There is not enough source material to add this component.
  /// 
  /// @param index [in] index to insert component
  /// @param pComponent [in] Component to insert into the sequence
  ///
  HRESULT InsertComponentAt (
    [in] aafUInt32  index,
    [in] IAAFComponent * pComponent);


  //***********************************************************
  //
  // GetComponentAt()
  //
  /// This function retrieves the input component at the given index in
  /// the given sequence.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the ppComponent pointer is valid.
  /// - index is less than the value returned by
  ///   CountComponents().
  /// 
  /// If this method fails nothing will be written to *ppComponent.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pComponent is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than or equal to the value returned by
  ///     CountComponents().
  /// 
  /// @param index [in] index of component to retrieve
  /// @param ppComponent [out, retval] Retrieved component
  ///
  HRESULT GetComponentAt (
    [in] aafUInt32  index,
    [out, retval] IAAFComponent ** ppComponent);


  //***********************************************************
  //
  // RemoveComponentAt()
  //
  /// This function removes the input component at the given index in
  /// the given sequence.  Components already existing at indices
  /// higher than the given index will be moved to the next lower index
  /// to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - index is less than the value returned by
  ///   CountComponents().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than or equal to the value returned by
  ///     CountComponents().
  /// 
  /// @param index [in] index of component to remove
  ///
  HRESULT RemoveComponentAt (
    [in] aafUInt32  index);


  //***********************************************************
  //
  // CountComponents()
  //
  /// This function returns the number of components in the sequence.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails no state is changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  /// 
  /// @param pResult [out] Number of components
  ///
  HRESULT CountComponents (
    [out] aafUInt32 *  pResult);


  //***********************************************************
  //
  // GetComponents()
  //
  /// Places an IEnumAAFComponents enumerator for the components
  /// contained in the sequence into the *ppEnum argument.
  /// 
  /// The returned enumerator is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// E_FAIL
  ///   - Failed to create the enumerator.
  /// 
  /// @param ppEnum [out, retval] Component Enumeration
  ///
  HRESULT GetComponents (
    [out, retval] IEnumAAFComponents ** ppEnum);






}



// ************************
//
// Interface IAAFSetFileBits
//
// ************************
///
/// This interface is implemented by the toolkit, and is provided to
/// clients of IAAFFile to allow them to supply the raw bits of a file
/// before open.
///
/// Note that this and the IAAFGetFileBits interfaces are different
/// than the IAAFRawStorage interfaces in that those are implemented by
/// clients to provide access to the desired media; these are provided
/// by the toolkit to provide read OR write (but not both
/// simultaneously) access to the raw bits.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.


[
    object,
    uuid(6D950762-8DB4-11D4-B80D-0000863F2C27),
    helpstring("IAAFSetFileBits Interface"),
    pointer_default(unique)
]
interface IAAFSetFileBits : IUnknown
{

  //***********************************************************
  //
  // WriteAt()
  //
  /// Writes bufsize bytes into this file at the given byte offset.
  /// Obtains the data from buf.  A value of zero for position
  /// indicates the beginning of the stream.
  ///
  /// Succeeds if sufficient space is available in the file to write
  /// the given number of bytes at the given position.  It's possible
  /// to guarantee that this method will succeed if SetSize() is first
  /// called to reserve the required space.  If SetSize() is not first
  /// called to reserve the space, this method will attempt to request
  /// it, but this attempt may fail.
  ///
  /// Succeeds if:
  /// - The buf argument is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - buf arg is NULL.
  ///
  /// AAFRESULT_DATA_SIZE
  ///   - The requested space is not available.
  /// 
  /// @param buf [in, size_is(bufSize)] Buffer from which data is written
  /// @param bufSize [in] Number of bytes
  /// @param position [in] The position in bytes at which to read
  ///
  HRESULT WriteAt (
    [in, size_is(bufSize)] aafMemPtr_t  buf,
    [in] aafUInt32  bufSize,
    [in] aafUInt64  position);


  //***********************************************************
  //
  // SetSize()
  //
  /// Attempts to reserve size bytes of storage.
  ///
  /// Succeeds if:
  /// - The requested space is available.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_DATA_SIZE
  ///   - size bytes are not available.
  /// 
  /// @param size [in] The requested file size
  ///
  HRESULT SetSize (
    [in] aafUInt64  size);
}



// ************************
//
// Interface IAAFSoundDescriptor
//
// ************************
///
/// The IAAFSoundDescriptor interface is implemented by objects
/// which describe the basic parameters of Sound used by all
/// compression or coding schemes.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///


///
/// Objects that implement IAAFSoundDescriptor also implement the following interfaces:
///  - IAAFFileDescriptor
///  - IAAFFileDescriptor2
///  - IAAFEssenceDescriptor
///  - IAAFObject
[
    object,
    uuid(DDC8931E-1A32-4362-BD78-450D0D970047),
    helpstring("IAAFSoundDescriptor Interface"),
    pointer_default(unique)
]
interface IAAFSoundDescriptor : IUnknown
{

  //***********************************************************
  //
  // SetCompression()
  //
  /// Sets the kind of compression and format of compression
  /// information of the sound essence data. This property is
  /// optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the Compression property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param compression [in] Identifies kind of compression and format of
  /// compression information.
  ///
  HRESULT SetCompression (
    [in] aafUID_constref  compression);


  //***********************************************************
  //
  // GetCompression()
  //
  /// Gets the kind of compression and format of compression
  /// information of the sound essence data. This property is
  /// optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pCompression pointer is valid.
  /// - the property is present.
  /// 
  /// If this method fails nothing will be written to *pCompression.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCompression arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pCompression [out] Compression of the sound essence data.
  ///
  HRESULT GetCompression (
    [out] aafUID_t *  pCompression);


  //***********************************************************
  //
  // SetChannelCount()
  //
  /// Sets the number of channels of sound represented by
  /// this descriptor. This property is required.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the Channels property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param channelCount [in] The number of channels of sound represented
  /// by this descriptor.
  ///
  HRESULT SetChannelCount (
    [in] aafUInt32  channelCount);


  //***********************************************************
  //
  // GetChannelCount()
  //
  /// Gets the number of channels of sound represented by
  /// this descriptor. This property is required.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pChannelCount pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pChannelCount.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pChannelCount arg is NULL.
  /// 
  /// @param pChannelCount [out] The number of channels of sound represented
  /// by this descriptor.
  ///
  HRESULT GetChannelCount (
    [out] aafUInt32 *  pChannelCount);


  //***********************************************************
  //
  // SetAudioSamplingRate()
  //
  /// Sets the sample rate of audio represented by this descriptor.
  /// This property is required.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the AudioSamplingRate property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param rate [in] Sample rate of audio essence.
  ///
  HRESULT SetAudioSamplingRate (
    [in] aafRational_t  rate);


  //***********************************************************
  //
  // GetAudioSamplingRate()
  //
  /// Gets the sample rate of audio represented by this descriptor.
  /// This property is required.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pRate pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pRate.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pRate arg is NULL.
  /// 
  /// @param pRate [out] Sample rate of audio essence.
  ///
  HRESULT GetAudioSamplingRate (
    [out] aafRational_t *  pRate);


  //***********************************************************
  //
  // SetIsLocked()
  //
  /// Sets the Locked flag which indicates whether the number of
  /// samples per frame is locked or unlocked. This property is
  /// optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the Locked property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param locked [in] Is number of samples per frame locked to video?
  ///
  HRESULT SetIsLocked (
    [in] aafBoolean_t  locked);


  //***********************************************************
  //
  // IsLocked()
  //
  /// Gets the Locked flag which indicates whether the number of
  /// samples per frame is locked or unlocked. This property is
  /// optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pLocked pointer is valid.
  /// - the property is present.
  /// 
  /// If this method fails nothing will be written to *pLocked.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLocked arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pLocked [out] Is number of samples per frame locked to video?
  ///
  HRESULT IsLocked (
    [out] aafBoolean_t *  pLocked);


  //***********************************************************
  //
  // SetElectroSpatialFormulation()
  //
  /// Sets the electro-spatial form of the signal. This property is
  /// optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the ElectroSpatial property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param formulation [in] Electro-spatial form of the signal.
  ///
  HRESULT SetElectroSpatialFormulation (
    [in] aafElectroSpatialFormulation_t  formulation);


  //***********************************************************
  //
  // GetElectroSpatialFormulation()
  //
  /// Gets the electro-spatial form of the signal. This property is
  /// optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pFormulation pointer is valid.
  /// - the property is present.
  /// 
  /// If this method fails nothing will be written to *pFormulation.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFormulation arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pFormulation [out] Electro-spatial form of the signal.
  ///
  HRESULT GetElectroSpatialFormulation (
    [out] aafElectroSpatialFormulation_t *  pFormulation);


  //***********************************************************
  //
  // SetAudioRefLevel()
  //
  /// Sets the audio reference level. This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the AudioRefLevel property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param level [in] Audio reference level.
  ///
  HRESULT SetAudioRefLevel (
    [in] aafInt8  level);


  //***********************************************************
  //
  // GetAudioRefLevel()
  //
  /// Gets the audio reference level. This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pLevel pointer is valid.
  /// - the property is present.
  /// 
  /// If this method fails nothing will be written to *pLevel.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLevel arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pLevel [out] Audio reference level.
  ///
  HRESULT GetAudioRefLevel (
    [out] aafInt8 *  pLevel);


  //***********************************************************
  //
  // SetDialNorm()
  //
  /// Sets the dial norm. This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the DialNorm property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param dialNorm [in] Dial norm.
  ///
  HRESULT SetDialNorm (
    [in] aafInt8  dialNorm);


  //***********************************************************
  //
  // GetDialNorm()
  //
  /// Gets the dial norm. This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pDialNorm pointer is valid.
  /// - the property is present.
  /// 
  /// If this method fails nothing will be written to *pDialNorm.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDialNorm arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pDialNorm [out] Dial norm.
  ///
  HRESULT GetDialNorm (
    [out] aafInt8 *  pDialNorm);


  //***********************************************************
  //
  // SetQuantizationBits()
  //
  /// Sets the number of quantization bits. This property is required.
  ///  
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the QuantizationBits property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param bitsCount [in] Number of quantization bits.
  ///
  HRESULT SetQuantizationBits (
    [in] aafUInt32  bitsCount);


  //***********************************************************
  //
  // GetQuantizationBits()
  //
  /// Gets the number of quantization bits. This property is required.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pBitsCount pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pBitsCount.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBitsCount arg is NULL.
  /// 
  /// @param pBitsCount [out] Number of quantization bits.
  ///
  HRESULT GetQuantizationBits (
    [out] aafUInt32 *  pBitsCount);
}



// ************************
//
// Interface IAAFSourceClip
//
// ************************
///
/// The IAAFSourceClip interface is implemented by objects that
/// reference the content data and identify the source of the content
/// data.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
///
/// Objects that implement IAAFSourceClip also implement the following interfaces:
///  - IAAFSourceReference
///  - IAAFSourceReference2
///  - IAAFSegment
///  - IAAFComponent
///  - IAAFComponent2
///  - IAAFObject
[
    object,
    uuid(38e6f8a7-2a2c-11d2-8411-00600832acb8),
    helpstring("IAAFSourceClip Interface"),
    pointer_default(unique)
]
interface IAAFSourceClip : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// This method initializes a source clip object with
  /// the given properties.  Only required properties are set.
  /// Optional properties are added with separate functions.
  ///
  /// Succeds if:
  /// - This object has not already been Initialize()d.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDataDef argument is NULL.
  /// 
  /// @param pDataDef [in] Data Definition object
  /// @param length [in] Length property value
  /// @param sourceRef [in] Source Reference
  ///
  HRESULT Initialize (
    [in] IAAFDataDef * pDataDef,
    [in] aafLength_constref  length,
    [in] aafSourceRef_t  sourceRef);


  //***********************************************************
  //
  // GetFade()
  //
  /// This function returns the optional fade information from a
  /// source clip.  This function only applies to audio source clips.
  /// Length units are specified by the containing mob slot's edit
  /// rate.
  ///
  /// Succeeds if all of the following are true:
  /// - This object has already been Initialize()d.
  /// - the all argument pointers are valid.
  /// 
  /// If this method fails nothing will be written to any of the
  /// locations specified by the arguments.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - any argument is NULL.
  /// 
  /// @param pFadeInLen [out] Fade In Length
  /// @param pFadeInType [out] Fade In Type
  /// @param pFadeInPresent [out] Fade In Type
  /// @param pFadeOutLen [out] Fade Out Length
  /// @param pFadeOutType [out] Fade Out Type
  /// @param pFadeOutPresent [out] Fade In Type
  ///
  HRESULT GetFade (
    [out] aafLength_t *  pFadeInLen,
    [out] aafFadeType_t *  pFadeInType,
    [out] aafBoolean_t *  pFadeInPresent,
    [out] aafLength_t *  pFadeOutLen,
    [out] aafFadeType_t *  pFadeOutType,
    [out] aafBoolean_t *  pFadeOutPresent);


  //***********************************************************
  //
  // ResolveRef()
  //
  /// Given a source clip object, this function returns a pointer
  /// to the mob that it references.
  ///
  /// The returned mob is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - This object has already been Initialize()d.
  /// - the ppMob pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppMob.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppMob arg is NULL.
  ///
  /// AAFRESULT_MOB_NOT_FOUND
  ///   - this mob does not exist.
  /// 
  /// @param ppMob [out] Referenced mob
  ///
  HRESULT ResolveRef (
    [out] IAAFMob ** ppMob);


  //***********************************************************
  //
  // GetSourceReference()
  //
  /// This function returns the source reference of this source clip.
  ///
  /// Note: the 3 properties of a source Clip that make up the "source
  /// reference" are sourceID, sourceTrackID, and startTime.
  ///
  /// Succeeds if all of the following are true:
  /// - This object has already been Initialize()d.
  /// - the pSourceRef pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pSourceRef.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSourceRef arg is NULL.
  /// 
  /// @param pSourceRef [out] Source Reference
  ///
  HRESULT GetSourceReference (
    [out] aafSourceRef_t *  pSourceRef);


  //***********************************************************
  //
  // SetFade()
  //
  /// This function sets the optional fade properties on this source
  /// clip object.  The fade properties only apply to a source clip of
  /// data definition (or convertible to a data definition) of type
  /// Sound.  All arguments should be specified.  Length units are
  /// specified by the containing mob slot's edit rate.
  /// 
  /// Succeeds if all of the following are true:
  /// - This object has already been Initialize()d.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param fadeInLen [in] Fade In Length
  /// @param fadeInType [in] Fade In Type
  /// @param fadeOutLen [in] Fade Out Length
  /// @param fadeOutType [in] Fade Out Type
  ///
  HRESULT SetFade (
    [in] aafInt32  fadeInLen,
    [in] aafFadeType_t  fadeInType,
    [in] aafInt32  fadeOutLen,
    [in] aafFadeType_t  fadeOutType);


  //***********************************************************
  //
  // SetSourceReference()
  //
  /// This function sets the source reference of this source clip.
  ///
  /// Note: the  3 properties of a source Clip that make up the "source
  /// reference" are sourceID, sourceTrackID, and startTime.
  /// 
  /// Succeeds if all of the following are true:
  /// - This object has already been Initialize()d.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param sourceRef [in] Source Reference
  ///
  HRESULT SetSourceReference (
    [in] aafSourceRef_t  sourceRef);
}



// ************************
//
// Interface IAAFSourceMob
//
// ************************
///
/// This interface is used with an object representing a SourceMob
/// containing some form of AAFEssenceDescriptor, either an
/// AAFTapeDescriptor, AAFFileDescriptor AAFFilmDescriptor, or some
/// extended descriptor not in the v1 specification. Some methods
/// exist here which exist only for one kind of AAFEssenceDescriptor. 
///
///      - AppendTimecodeClip -- Works only on tape AAFSourceMobs
///      - ValidateTimecodeRange -- Works only on tape AAFSourceMobs
///      - AppendEdgecodeClip -- Works only on film AAFSourceMobs
///
/// These will return an error if the wrong descriptor is present.
/// 
/// If an AAFSourceMob points to another AAFSourceMob at the same rate
/// [or non-picture], then AppendPhysMobRef is used to create the
/// relationship.
///
/// If an AAFSourceMob points to picture on another AAFSourceMob at a different
/// sample rate, then AddPulldownRef is used to create the relationship, and the
/// AAFPulldown which describes how to map between the two rates.
///
/// In an AAFSourceMob is the end of the derivation chain for a particular track, then
/// AddNilReference should be called for that slot, to say that that slot does exist
/// on the SourceMob.  For example, a video file mob with no derivation would have
/// a single slot or type video, with a NIL reference to show that video exist, and was
/// not derived from anything else on record.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
///
/// Objects that implement IAAFSourceMob also implement the following interfaces:
///  - IAAFSearchSource
///  - IAAFMob
///  - IAAFMob2
///  - IAAFObject
[
    object,
    uuid(B1A2137C-1A7D-11D2-BF78-00104BC9156D),
    helpstring("IAAFSourceMob Interface"),
    pointer_default(unique)
]
interface IAAFSourceMob : IUnknown
{
  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty IAAFSourceMob-supporting
  /// object.  This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  /// 
  HRESULT Initialize ();


  //***********************************************************
  //
  // GetEssenceDescriptor()
  //
  /// Places the Essence Descriptor object attached to this Mob into the
  /// *ppEssence argument.  If none exists yet, NULL is placed into the
  /// *ppEssence argument.
  ///
  /// The returned essence descriptor object, if it exists, is
  /// AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppEssence pointer is valid.
  /// - A valid essence descriptor exists.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEssence is null.
  ///
  /// AAFRESULT_NO_ESSENCE_DESC
  ///   - There is no essence descriptor.  There has to be one of some
  ///     kind for this to be a valid Mob.
  /// 
  /// @param ppEssence [out] Returned Essence Descriptor object
  ///
  HRESULT GetEssenceDescriptor (
    [out] IAAFEssenceDescriptor ** ppEssence);


  //***********************************************************
  //
  // SetEssenceDescriptor()
  //
  /// Sets the Essence Descriptor of this Mob to be the given one.
  ///
  /// Succeeds if all of the following are true:
  /// - the pEssence pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEssence is null.
  /// 
  /// @param pEssence [in] Essence Descriptor object
  ///
  HRESULT SetEssenceDescriptor (
    [in] IAAFEssenceDescriptor * pEssence);


  //***********************************************************
  //
  // AddNilReference()
  //
  /// This function adds a slot containing a NIL [sourceID 0.0....]
  /// Source Clip.  This special SourceID indicates that the mob chain
  /// ends here, which indicates that no record exists of what the
  /// essence was derived from.  Some AAFSourceClip is still required
  /// on the track to indicate that the track exists, and may be
  /// referenced from other Mobs.
  ///
  /// Examples of Source Mobs that are not derived from a previous
  /// source of essence are: Tape Source Mobs that were not created
  /// from film; File Source Mobs whose digital essence data was
  /// originally generated by computer and was not digitized from
  /// videotape.
  ///
  /// Succeeds if all of the following are true:
  /// - The pDataDef parameter is valid.
  /// - editRate is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - the pDataDef parameter is NULL.
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_BADRATE
  ///   - the editRate is not valid.
  /// 
  /// @param slotID [in] SlotID to be assigned to the new slot
  /// @param length [in] Duration of the Source Clip to be added to the new slot
  /// @param pDataDef [in] Data definition of the new slot
  /// @param editRate [in] Edit rate of the new slot
  ///
  HRESULT AddNilReference (
    [in] aafSlotID_t  slotID,
    [in] aafLength_t  length,
    [in] IAAFDataDef * pDataDef,
    [in] aafRational_t  editRate);


  //***********************************************************
  //
  // AppendTimecodeSlot()
  //
  /// This function adds a Timecode slot to a specified tape Mob or
  /// film Mob, with a specified starting timecode, length, and edit
  /// rate.  Your must also call SpecifyValidCodeRange to add the
  /// Filler to the other essence slots to indicate that the Timecode
  /// is valid for that channel.
  /// 
  /// Note: The startTC parameter is expressed in frames since
  /// midnight.
  /// 
  /// The length32 parameter can be the value FULL_RANGE, in which
  /// case the length is 24 hours.
  ///
  /// Succeeds if all of the following are true:
  /// - The specified slot ID is not yet used.
  /// - This source mob references an AAFTapeDescriptor as an essence
  ///   descriptor.
  /// 
  /// If this method fails no state is changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_SLOT_EXISTS
  ///   - The specified slotID already exists.
  ///
  /// AAFRESULT_TAPEDESC_ONLY
  ///   - Valid only for AAFSourceMob referencing an AAFTapeDescriptor
  ///     as EssenceDescriptor.
  /// 
  /// @param editrate [in] Edit rate of Timecode slot
  /// @param slotID [in] SlotID of Timecode slot
  /// @param startTC [in] Starting time code
  /// @param length32 [in] Duration of Timecode.
  ///
  HRESULT AppendTimecodeSlot (
    [in] aafRational_t  editrate,
    [in] aafInt32  slotID,
    [in] aafTimecode_t  startTC,
    [in] aafFrameLength_t  length32);


  //***********************************************************
  //
  // AppendEdgecodeSlot()
  //
  /// Adds an Edgecode slot to a specified film Mob, with a specified
  /// starting edgecode, length, and edit rate. You must add a essence
  /// slot with SpecifyValidCodeRange to make the edgecode slot valid.
  ///
  /// Succeeds if all of the following are true:
  /// - The specified slot ID is not yet used.
  /// - This source mob references an AAFFilmDescriptor as an essence
  ///   descriptor.
  /// 
  /// If this method fails no state is changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_SLOT_EXISTS
  ///   - The specified slotID already exists.
  ///
  /// AAFRESULT_FILMDESC_ONLY
  ///   - Valid only for AAFSourceMob referencing an AAFFilmDescriptor
  ///     as EssenceDescriptor.
  /// 
  /// @param editrate [in] Edit rate of the Edgecode slot
  /// @param slotID [in] SlotID to assign to the new Edgecode slot
  /// @param startEC [in] Starting Edgecode
  /// @param length32 [in] Length of the Edgecode component in the slot
  /// @param filmKind [in] The film kind.
  /// Can be one of:
  /// - kFtNull
  /// - kFt35MM
  /// - kFt16MM
  /// - kFt8MM
  /// - kFt65MM
  /// @param codeFormat [in] The code format.
  /// Can be one of:
  /// - kEtNull
  /// - kEtKeycode
  /// - kEtEdgenum4
  /// - kEtEdgenum5
  /// @param header [in] The Edgecode's 8-byte header
  ///
  HRESULT AppendEdgecodeSlot (
    [in] aafRational_t  editrate,
    [in] aafInt32  slotID,
    [in] aafFrameOffset_t  startEC,
    [in] aafFrameLength_t  length32,
    [in] aafFilmType_t  filmKind,
    [in] aafEdgeType_t  codeFormat,
    [in] aafEdgecodeHeader_t  header);


  //***********************************************************
  //
  // SpecifyValidCodeRange()
  //
  /// Adds slot containing Source Clips to a Source Mob to indicate
  /// that the Timecode or Edgecode is valid for that channel.
  ///
  /// Note: The pEssenceKind parameter requires a data kind valid for a
  /// essence stream.  Valid data kinds are:
  /// - Picture
  /// - Sound
  ///
  /// Succeeds if all of the following are true:
  /// - the pEssenceKind pointer is valid.
  /// - The specified slot ID is not yet used.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEssenceKind is null.
  ///
  /// AAFRESULT_SLOT_EXISTS
  ///   - The specified slotID already exists.
  /// 
  /// @param pEssenceKind [in] Data kind for the slot to be added
  /// @param slotID [in] SlotID for the slot to be added
  /// @param editrate [in] Edit rate for the slot to be added
  /// @param startOffset [in] Start offset for the slot to be added
  /// @param length32 [in] Duration of the Source Clip in the slot
  ///
  HRESULT SpecifyValidCodeRange (
    [in] IAAFDataDef * pEssenceKind,
    [in] aafSlotID_t  slotID,
    [in] aafRational_t  editrate,
    [in] aafFrameOffset_t  startOffset,
    [in] aafFrameLength_t  length32);


  //***********************************************************
  //
  // AppendPhysSourceRef()
  //
  /// Connects this Source Mob with the physical Source Mob that
  /// describes the previous generation of essence, appending it to
  /// existing Mob data.  If a physical Source Mob, such as a File
  /// Source Mob or tape Source Mob, references another physical
  /// Source Mob as its ancestor, with no pulldown, then this
  /// function makes the connection between the two.
  ///
  /// Functionally, this is a helper function to create a slot with an
  /// AAFSourceClip referencing a particular piece of media.  This
  /// function takes many parameters because the components of an
  /// aafSourceRef_t have been broken out as separate parameters.
  ///
  /// The ancestor of an AAFSourceMob with an AAFFileDescriptor is often an
  /// AAFTapeDescriptor or NIL.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSourceRefObj pointer is valid.
  /// - the pEssenceKind pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSourceRefObj or pEssenceKind is null.
  /// 
  /// @param editrate [in] Edit rate of slot to contain reference
  /// @param aMobSlot [in] SlotID of slot to contain reference
  /// @param pEssenceKind [in] Data kind of slot to contain reference.  Requires a data kind
  /// valid for a essence stream.  Valid data kinds are:
  /// - Picture
  /// - Sound
  /// @param ref [in] Reference to a Physical Source Mob
  /// @param srcRefLength [in] Length of the Source Clip
  ///
  HRESULT AppendPhysSourceRef (
    [in] aafRational_t  editrate,
    [in] aafSlotID_t  aMobSlot,
    [in] IAAFDataDef * pEssenceKind,
    [in] aafSourceRef_t  ref,
    [in] aafLength_t  srcRefLength);


  //***********************************************************
  //
  // NewPhysSourceRef()
  //
  /// Connects this Source Mob with the physical Source Mob that
  /// describes the previous generation of essence, replacing any
  /// existing Mob data.  If a physical Source Mob, such as a File
  /// Source Mob or tape Source Mob, references another physical
  /// Source Mob as its ancestor, with no pulldown, then this
  /// function makes the connection between the two.
  ///
  /// Functionally, this is a helper function to create a slot with an
  /// AAFSourceClip referencing a particular piece of media.  This
  /// function takes many parameters because the components of an
  /// aafSourceRef_t have been broken out as separate parameters.
  ///
  /// The ancestor of an AAFSourceMob with an AAFFileDescriptor is often an
  /// AAFTapeDescriptor or NIL.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSourceRefObj pointer is valid.
  /// - the pEssenceKind pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSourceRefObj or pEssenceKind is null.
  /// 
  /// @param editrate [in] Edit rate of slot to contain reference
  /// @param aMobSlot [in] SlotID of slot to contain reference
  /// @param pEssenceKind [in] Data kind of slot to contain reference.  Requires a data kind
  /// valid for a essence stream.  Valid data kinds are:
  /// - Picture
  /// - Sound
  /// @param ref [in] Reference to a Physical Source Mob
  /// @param srcRefLength [in] Length of the Source Clip
  ///
  HRESULT NewPhysSourceRef (
    [in] aafRational_t  editrate,
    [in] aafSlotID_t  aMobSlot,
    [in] IAAFDataDef * pEssenceKind,
    [in] aafSourceRef_t  ref,
    [in] aafLength_t  srcRefLength);


  //***********************************************************
  //
  // AddPulldownRef()
  //
  /// Connects the specified Source Mob with the physical Source Mob
  /// that describes the previous generation of essence, with an
  /// additional AAFPulldown as part of the reference to indicate a non
  /// 1-1 relationship Between the two. 
  ///
  /// Functionally, this is a helper function to create a slot with an
  /// AAFPulldown object which references an AAFSourceClip, which
  /// references a particular piece of media.  This function takes many
  /// parameters because the components of an aafSourceRef_t and the
  /// AAFPulldown object have been broken out as separate parameters.
  ///
  /// The ancestor of an AAFSourceMob with an AAFTapeDescriptor is
  /// often an AAFFilmDescriptor or NIL.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSourceRefObj pointer is valid.
  /// - the pEssenceKind pointer is valid.
  /// - a valid pulldown direction was specified.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSourceRefObj or pEssenceKind is null.
  ///
  /// AAFRESULT_PULLDOWN_DIRECTION
  ///   - an invalid pulldown direction was specified.
  /// 
  /// @param addType [in] Tells whether to overwrite an existing slot segment, or create
  /// a sequence and append
  /// @param editrate [in] Edit rate of slot to contain reference
  /// @param aMobSlot [in] SlotID of slot to contain reference
  /// @param pEssenceKind [in] Data kind of slot to contain reference.  Requires a data kind
  /// valid for a essence stream.  Valid data kinds are:
  /// - Picture
  /// - Sound
  /// @param ref [in] Reference to a Physical Source Mob
  /// @param srcRefLength [in] Length of the Source Clip in the Source Mob
  /// @param pulldownKind [in] Method of conversion.  Possible values are:
  /// - kAAFTwoThreePD	    -- Normal NTSC-20fps pulldown
  /// - kAAFPALPD
  /// - kAAFOneToOneNTSC   -- NTSC recorded as 1 frame == 1 film frame.
  /// - kAAFOneToOnePAL    -- PAL recorded as 1 frame == 1 film frame.
  /// @param phaseFrame [in] phase of first frame
  /// @param direction [in] Direction of the pulldown conversion. Possible values are:
  ///
  ///  - kAAFTapeToFilmSpeed -- Used to link a file descriptor with a
  ///							 tape descriptor.
  ///  - kAAFFilmToTapeSpeed -- Used to link a tape descriptor with a
  ///							 film descriptor.
  ///
  HRESULT AddPulldownRef (
    [in] aafAppendOption_t  addType,
    [in] aafRational_t  editrate,
    [in] aafSlotID_t  aMobSlot,
    [in] IAAFDataDef * pEssenceKind,
    [in] aafSourceRef_t  ref,
    [in] aafLength_t  srcRefLength,
    [in] aafPulldownKind_t  pulldownKind,
    [in] aafPhaseFrame_t  phaseFrame,
    [in] aafPulldownDir_t  direction);

}



// ************************
//
// Interface IAAFSourceReference
//
// ************************
///
/// The IAAFSourceReference interface is implemented by objects that
/// represent the essence or other data described by a MobSlot in a
/// Mob.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it through
///     this object's primary interface.  Note that IAAFSourceReference
///     is a primary interface for an abstract class, so it is not
///     appropriate for the Initialize() method to exist in this
///     interface.  The Initialize() method is available through the
///     concrete object's primary interface.
///


///
/// Objects that implement IAAFSourceReference also implement the following interfaces:
///  - IAAFSourceReference2
///  - IAAFSegment
///  - IAAFComponent
///  - IAAFComponent2
///  - IAAFObject
[
    object,
    uuid(92B88033-2B2B-11d2-BF7E-00104BC9156D),
    helpstring("IAAFSourceReference Interface"),
    pointer_default(unique)
]
interface IAAFSourceReference : IUnknown
{
  //***********************************************************
  //
  // GetSourceID()
  //
  /// Gets the SourceID and places it into the pSourceID argument.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSourceID pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pSourceID.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSourceID arg is NULL.
  /// 
  /// @param pSourceID [retval][out] Place to put source ID
  ///
  HRESULT GetSourceID (
    [retval][out] aafMobID_t *  pSourceID);


  //***********************************************************
  //
  // SetSourceID()
  //
  /// Sets the SourceID using the sourceID argument.
  /// 
  /// Always succeeds.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param sourceID [in] Source ID to set
  ///
  HRESULT SetSourceID (
    [in] aafMobID_constref   sourceID);


  //***********************************************************
  //
  // GetSourceMobSlotID()
  //
  /// Gets the Mob Slot ID and places it into the pMobSlotID argument.
  ///
  /// Succeeds if all of the following are true:
  /// - the pMobSlotID pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pMobSlotID.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMobSlotID arg is NULL.
  /// 
  /// @param pMobSlotID [retval][out] Place to put source mob slot ID
  ///
  HRESULT GetSourceMobSlotID (
    [retval][out] aafSlotID_t *  pMobSlotID);


  //***********************************************************
  //
  // SetSourceMobSlotID()
  //
  /// Sets the mob slot ID using the mobSlotID argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - (preconditions here)
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// (other error codes here.)
  /// 
  /// @param mobSlotID [in] Source Mob ID to set
  ///
  HRESULT SetSourceMobSlotID (
    [in] aafSlotID_t   mobSlotID);









}


// ************************
//
// Interface IAAFStaticMobSlot
//
// ************************

///
/// StaticMobSlot describes essence data that has no relationship to time,
/// such as a static image; consequently, a StaticMobSlot does not define an
/// edit rate.
///
///
/// Objects that implement IAAFStaticMobSlot also implement the following interfaces:
///  - IAAFMobSlot
///  - IAAFObject
[
    object,
    uuid(e684d764-b935-11d2-bf9d-00104bc9156d),
    helpstring("IAAFStaticMobSlot Interface"),
    pointer_default(unique)
]
interface IAAFStaticMobSlot : IUnknown
{


}



// ************************
//
// Interface IAAFTIFFDescriptor
//
// ************************


///
/// The IAAFTIFFDescriptor interface is implemented by objects which
/// describe TIFF format media.  A TIFFDescriptor object
/// shall be the EssenceDescription of a  physical Source Mob.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///  


///
/// Objects that implement IAAFTIFFDescriptor also implement the following interfaces:
///  - IAAFFileDescriptor
///  - IAAFFileDescriptor2
///  - IAAFEssenceDescriptor
///  - IAAFObject
[
    object,
    uuid(e684d76c-b935-11d2-bf9d-00104bc9156d),
    helpstring("IAAFTIFFDescriptor Interface"),
    pointer_default(unique)
]
interface IAAFTIFFDescriptor : IUnknown
{

  //***********************************************************
  //
  // SetIsUniform()
  //
  /// Set to TRUE if essence data has the same number of rows per strip
  /// throughout.
  ///
  /// Always succeeds.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param IsUniform [in] Sets the IsUniform flag value
  ///
  HRESULT SetIsUniform (
    [in] aafBoolean_t  IsUniform);


  //***********************************************************
  //
  // GetIsUniform()
  //
  /// Places TRUE into *pIsUniform if the data has the same number of
  /// rows per strip throughout.
  ///
  /// Succeeds if all of the following are true:
  /// - the pIsUniform pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pIsUniform.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pIsUniform arg is NULL.
  /// 
  /// @param pIsUniform [out] Gets the IsUniform flag value
  ///
  HRESULT GetIsUniform (
    [out] aafBoolean_t *  pIsUniform);


  //***********************************************************
  //
  // SetIsContiguous()
  //
  /// Set to TRUE if essence data is stored in contiguous bytes.
  /// 
  /// Always succeeds.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param IsContiguous [in] is data stores in contiguous bytes
  ///
  HRESULT SetIsContiguous (
    [in] aafBoolean_t  IsContiguous);


  //***********************************************************
  //
  // GetIsContiguous()
  //
  /// Places TRUE into *pIsContiguous if essence data is stored in
  /// contiguous bytes.
  ///
  /// Succeeds if all of the following are true:
  /// - the pIsContiguous pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pIsContiguous.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pIsContiguous arg is NULL.
  /// 
  /// @param pIsContiguous [out] is this data stored in contiguous bytes
  ///
  HRESULT GetIsContiguous (
    [out] aafBoolean_t *  pIsContiguous);


  //***********************************************************
  //
  // SetLeadingLines()
  //
  /// Sets the number of leading lines in the TIFF image file.
  /// 
  /// This method succeeds if all of the following are true:
  /// - LeadingLines is  equal or greater than 0(zero).
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param LeadingLines [in] Number of leading lines to be thrown away Optional
  ///
  HRESULT SetLeadingLines (
    [in] aafInt32  LeadingLines);


  //***********************************************************
  //
  // GetLeadingLines()
  //
  /// Gets the leading lines of the TIFF image.
  ///
  /// This method succeeds if all of the following are true:
  /// - the pLeadingLines pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pLeadingLines.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLeadingLines arg is NULL.
  /// 
  /// @param pLeadingLines [out] Address to store the number of leading lines
  ///
  HRESULT GetLeadingLines (
    [out] aafInt32 *  pLeadingLines);


  //***********************************************************
  //
  // SetTrailingLines()
  //
  /// Sets the number of trailing lines in the TIFF image file
  /// 
  /// This method succeeds if all of the following are true:
  /// - TrailingLines is  equal or greater than 0(zero).
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param TrailingLines [in] Number of trailing lines to be thrown away Optional.
  ///
  HRESULT SetTrailingLines (
    [in] aafInt32  TrailingLines);


  //***********************************************************
  //
  // GetTrailingLines()
  //
  /// Gets the trailing lines of the TIFF image.
  ///
  /// This method succeeds if all of the following are true:
  /// - the pTrailingLines pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pTrailingLines.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTrailingLines arg is NULL.
  /// 
  /// @param pTrailingLines [out] Address to store the number of trailing lines.
  ///
  HRESULT GetTrailingLines (
    [out] aafInt32 *  pTrailingLines);


  //***********************************************************
  //
  // SetJPEGTableID()
  //
  /// Sets the JPEG table code for  the TIFF image file
  /// 
  /// This method always succeeds .
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param JPEGTableID [in] Registered JPEG table code or JT_NULL.
  ///
  HRESULT SetJPEGTableID (
    [in] aafJPEGTableID_t  JPEGTableID);


  //***********************************************************
  //
  // GetJPEGTableID()
  //
  /// Gets the JPEG table code of the TIFF image.
  ///
  /// This method succeeds if all of the following are true:
  /// - the pJPEGTableID pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pJPEGTableID.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pJPEGTableID arg is NULL.
  /// 
  /// @param pJPEGTableID [out] Address to store the nJPEG table code
  ///
  HRESULT GetJPEGTableID (
    [out] aafJPEGTableID_t *  pJPEGTableID);


  //***********************************************************
  //
  // GetSummary()
  //
  /// Gets a copy of the TIFF IFD file information without the media.
  /// 
  /// Succeeds if all of the following are true:
  /// - pSummary is a valid pointer.
  /// - The size of the buffer is large enough to hold the TIFF IFD
  ///   file information. 
  /// 
  /// If this method fails pSummary will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSummary arg is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - The buffer is too small to hold the WAVE file information.
  /// 
  /// @param size [in] Size of preallocated buffer
  /// @param pSummary [out, size_is(size)] Preallocated buffer to hold the TIFF IFD file information
  ///
  HRESULT GetSummary (
    [in] aafUInt32  size,
    [out, size_is(size)] aafDataValue_t  pSummary);


  //***********************************************************
  //
  // GetSummaryBufferSize()
  //
  /// Returns the size of the buffer required for the GetSummary()
  /// method.  The value is placed into the location specified by pSize.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSize pointer is valid.
  ///
  /// If this method fails nothing will be written to *pSize.
  ///
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSize arg is NULL.
  /// 
  /// @param pSize [out] required buffer size
  ///
  HRESULT GetSummaryBufferSize (
    [out] aafUInt32 *  pSize);


  //***********************************************************
  //
  // SetSummary()
  //
  /// Sets the TIFF IFD file information.
  /// 
  /// Succeeds if all of the following are true:
  /// - pSummary is a valid pointer
  /// 
  /// If this method fails the summary property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSummary arg is NULL.
  /// 
  /// @param size [in] Size of preallocated buffer
  /// @param pSummary [in, size_is(size)] buffer containing value
  ///
  HRESULT SetSummary (
    [in] aafUInt32  size,
    [in, size_is(size)] aafDataValue_t  pSummary);
}



// ************************
//
// Interface IAAFTaggedValue
//
// ************************
///
/// The IAAFTaggedValue interface is implemented by objects that
/// specify an User defined tag and value.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
///
/// Objects that implement IAAFTaggedValue also implement the following interfaces:
///  - IAAFObject
[
    object,
    uuid(e684d762-b935-11d2-bf9d-00104bc9156d),
    helpstring("IAAFTaggedValue Interface"),
    pointer_default(unique)
]
interface IAAFTaggedValue : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a new tagged value object to be identified with the
  /// given the given type, and with the given human-legible name.
  ///
  /// This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  /// - pName is a valid pointer.
  /// - pTypeDef is a valid pointer and registered
  /// - pValue is a valid pointer
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - This object has already had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName or pTypeDef or pValue arg is NULL.
  /// 
  /// 
  /// @param pName [in, string] User defined name (tag) of this tagged value object
  /// @param pTypeDef [in] Type Definition of the following value data
  /// @param valueSize [in] Size of preallocated buffer
  /// @param pValue [in, size_is(valueSize)] buffer containing value
  ///
  HRESULT Initialize (
    [in, string] aafCharacter_constptr  pName,
    [in] IAAFTypeDef * pTypeDef,
    [in] aafUInt32  valueSize,
    [in, size_is(valueSize)] aafDataBuffer_t  pValue);


  //***********************************************************
  //
  // GetName()
  //
  /// Gets the Name string property.
  /// 
  /// Writes the Name property, with a trailing null
  /// character, into the pName buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the Name property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetNameBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pName.
  /// 
  /// Succeeds if:
  /// - The pName pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   Name.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold Name.
  /// 
  /// @param pName [out, string, size_is(bufSize)] buffer into which Name is to be written
  /// @param bufSize [in] size of *pName buffer in bytes
  ///
  HRESULT GetName (
    [out, string, size_is(bufSize)] aafCharacter *  pName,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetNameBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetName().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetNameBufLen (
    [out] aafUInt32 *  pBufSize);


  //***********************************************************
  //
  // GetTypeDefinition()
  //
  /// Returns the type definition for this invocation.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppTypeDef pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppTypeDef.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - This property does not exist in the file.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTypeDef arg is NULL.
  /// 
  /// @param ppTypeDef [out] Type definition object
  ///
  HRESULT GetTypeDefinition (
    [out] IAAFTypeDef ** ppTypeDef);


  //***********************************************************
  //
  // GetValue()
  //
  /// Writes the value into the pValue buffer.  The buffer is allocated
  /// by the caller, and the size of the buffer is given by
  /// valueSize.
  /// 
  /// Caller may call GetValueBufLen() to determine the
  /// required buffer size.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pValue pointer is valid.
  /// - valueSize indicates the buffer is large enough to hold the name.
  /// 
  /// If this method fails nothing will be written to *pValue.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pValue arg is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - valueSize indicates the buffer is too small to hold the value.
  /// 
  /// @param valueSize [in] Size of preallocated buffer
  /// @param pValue [out, size_is(valueSize), length_is(*bytesRead)] Preallocated buffer to hold value
  /// @param bytesRead [out] Number of actual bytes read
  ///
  HRESULT GetValue (
    [in] aafUInt32  valueSize,
    [out, size_is(valueSize), length_is(*bytesRead)] aafDataBuffer_t  pValue,
    [out] aafUInt32 *  bytesRead);


  //***********************************************************
  //
  // GetValueBufLen()
  //
  /// Returns the length of buffer required for the GetValue() method.
  /// The value is placed into the location specified by pLen.
  ///
  /// Succeeds if all of the following are true:
  /// - the pLen pointer is valid.
  ///
  /// If this method fails nothing will be written to *pLen.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLen arg is NULL.
  /// 
  /// @param pLen [out] Pointer to an variable used to return the length
  ///
  HRESULT GetValueBufLen (
    [out] aafUInt32 *  pLen);

  //***********************************************************
  //
  // SetValue()
  //
  /// The data value is set from a buffer of size valueSize and type.
  ///
  /// Succeeds if all of the following are true:
  /// - pTypeDef is valid and registered with the object's dictionary.
  /// - the pValue pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTypeDef is null.
  /// 
  /// @param valueSize [in] Size of preallocated buffer
  /// @param pValue [in, size_is(valueSize)] buffer containing value
  ///
  HRESULT SetValue (
    [in] aafUInt32  valueSize,
    [in, size_is(valueSize)] aafDataBuffer_t  pValue);

}



// ************************
//
// Interface IAAFTaggedValueDefinition
//
// ************************
///
/// This interface is used to describe the data type of a value stored
/// in an AAFTaggedValue object.
///
///
/// Objects that implement IAAFTaggedValueDefinition also implement the following interfaces:
///  - IAAFDefObject
///  - IAAFObject
[
    object,
    uuid(c358428a-bf73-4558-bfdf-482160719823),
    helpstring("IAAFTaggedValueDefinition Interface"),
    pointer_default(unique)
]

interface IAAFTaggedValueDefinition : IUnknown
{


  //***********************************************************
  //
  // Initialize()
  //
  /// Init all fields of a definition object.
  /// 
  /// @param id [in, ref] AUID for new DefObject
  /// @param pName [in, string] Name for new DefObject
  /// @param pDescription [in, string] Description for new DefObject
  ///
  HRESULT Initialize (
    [in, ref] aafUID_constref  id,
    [in, string] aafCharacter_constptr  pName,
    [in, string] aafCharacter_constptr  pDescription);

  //***********************************************************
  //
  // AddParentProperty()
  //
  /// Add a property definition to the tagged value definition.
  ///
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pParentProperty is null.
  /// 
  /// @param pParentProperty [in] Property definition to add.
  ///
  HRESULT AddParentProperty (
    [in] IAAFPropertyDef * pParentProperty);

  //***********************************************************
  //
  // GetParentProperties()
  //
  /// Writes an enumerator for the property definitions into *ppEnum.
  /// A reference is added to the new enumerator before it is returned.
  ///
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  /// 
  /// @param ppEnum [out] Property definition enumerator.
  ///
  HRESULT GetParentProperties (
    [out] IEnumAAFPropertyDefs ** ppEnum);

  //***********************************************************
  //
  // CountParentProperties()
  //
  /// Writes the total number of property definitions into *pNumProperties if,
  /// and only if, the method succeeds.
  ///
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  /// 
  /// @param pNumProperties [out] Number of property definitions.
  ///
  HRESULT CountParentProperties (
    [out] aafUInt32*  pNumProperties);

  //***********************************************************
  //
  // RemoveParentProperty()
  //
  /// Removes the given property definition.
  ///
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - The property definition is not in this tagged value definition.
  /// 
  /// @param pParentProperty [in] Property to remove.
  ///
  HRESULT RemoveParentProperty (
    [in] IAAFPropertyDef * pParentProperty);

}



// ************************
//
// Interface IAAFTapeDescriptor
//
// ************************

///
/// The IAAFTapeDescriptor interface is implemented by objects which
/// describe audio tape or videotape media.  A TapeDescriptor object
/// shall be the EssenceDescription of a  physical Source Mob.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///


///
/// Objects that implement IAAFTapeDescriptor also implement the following interfaces:
///  - IAAFEssenceDescriptor
///  - IAAFObject
[
    object,
    uuid(e58a8569-2a3e-11D2-bfa4-006097116212),
    helpstring("IAAFTapeDescriptor Interface"),
    pointer_default(unique)
]
interface IAAFTapeDescriptor : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty
  /// IAAFTapeDescriptor-supporting object.  This method must be called
  /// after allocation, and before any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  /// 
  HRESULT Initialize ();


  //***********************************************************
  //
  // SetTapeManufacturer()
  //
  /// Sets the Tape Manufacturer string property.
  ///
  /// Set the TapeManufacturer property to the value specified in
  /// pTapeManufacturer.  A copy is made of the data so the caller
  /// retains ownership of the *pTapeManufacturer buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pTapeManufacturer pointer is valid.
  /// 
  /// If this method fails the TapeManufacturer property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTapeManufacturer arg is NULL.
  /// 
  /// @param pTapeManufacturer [in, string] buffer from which TapeManufacturer is to be read
  ///
  HRESULT SetTapeManufacturer (
    [in, string] aafCharacter_constptr  pTapeManufacturer);


  //***********************************************************
  //
  // GetTapeManufacturer()
  //
  /// Gets the Tape Manufacturer string property.
  /// 
  /// Writes the TapeManufacturer property, with a trailing null
  /// character, into the pTapeManufacturer buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the TapeManufacturer property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetTapeManufacturerBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pTapeManufacturer.
  /// 
  /// Succeeds if:
  /// - The pTapeManufacturer pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   TapeManufacturer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTapeManufacturer arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold TapeManufacturer.
  /// 
  /// @param pTapeManufacturer [out, string, size_is(bufSize)] buffer into which TapeManufacturer is to be written
  /// @param bufSize [in] size of *pTapeManufacturer buffer in bytes
  ///
  HRESULT GetTapeManufacturer (
    [out, string, size_is(bufSize)] aafCharacter *  pTapeManufacturer,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetTapeManufacturerBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetTapeManufacturer().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetTapeManufacturerBufLen (
    [out] aafUInt32 *  pBufSize);


  //***********************************************************
  //
  // SetTapeModel()
  //
  /// Sets the Tape Model string property.
  ///
  /// Set the TapeModel property to the value specified in
  /// pTapeModel.  A copy is made of the data so the caller
  /// retains ownership of the *pTapeModel buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pTapeModel pointer is valid.
  /// 
  /// If this method fails the TapeModel property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTapeModel arg is NULL.
  /// 
  /// @param pTapeModel [in, string] buffer from which TapeModel is to be read
  ///
  HRESULT SetTapeModel (
    [in, string] aafCharacter_constptr  pTapeModel);


  //***********************************************************
  //
  // GetTapeModel()
  //
  /// Gets the Tape Model string property.
  /// 
  /// Writes the TapeModel property, with a trailing null
  /// character, into the pTapeModel buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the TapeModel property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetTapeModelBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pTapeModel.
  /// 
  /// Succeeds if:
  /// - The pTapeModel pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   TapeModel.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTapeModel arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold TapeModel.
  /// 
  /// @param pTapeModel [out, string, size_is(bufSize)] buffer into which TapeModel is to be written
  /// @param bufSize [in] size of *pTapeModel buffer in bytes
  ///
  HRESULT GetTapeModel (
    [out, string, size_is(bufSize)] aafCharacter *  pTapeModel,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetTapeModelBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetTapeModel().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetTapeModelBufLen (
    [out] aafUInt32 *  pBufSize);


  //***********************************************************
  //
  // SetTapeFormFactor()
  //
  /// Sets the form factor [case size] of the tape.
  /// 
  /// This method succeeds if all of the following are true:
  /// - formFactor represents a valid format.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_BAD_TYPE
  ///	- formFactor is invalid.
  /// 
  /// @param formFactor [in] ex: kVHSVideoTape, kDATCartridge 
  ///
  HRESULT SetTapeFormFactor (
    [in] aafTapeCaseType_t  formFactor);


  //***********************************************************
  //
  // GetTapeFormFactor()
  //
  /// Gets the form factor [case size] of the tape.
  /// 
  /// This method succeeds if all of the following are true:
  /// - the pFormFactor pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFormFactor arg is NULL.
  /// 
  /// @param formFactor [out] ex: kVHSVideoTape, kDATCartridge
  ///
  HRESULT GetTapeFormFactor (
    [out] aafTapeCaseType_t *  formFactor);


  //***********************************************************
  //
  // SetSignalType()
  //
  /// Sets the signal standard recorded on the tape.
  /// 
  /// This method succeeds if all of the following are true:
  ///	videoSignal represents a valid video signal type.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_BAD_TYPE
  ///	- videoSignal is invalid.
  /// 
  /// @param videoSignal [in] ex: kNTSCSignal
  ///
  HRESULT SetSignalType (
    [in] aafVideoSignalType_t  videoSignal);


  //***********************************************************
  //
  // GetSignalType()
  //
  /// Gets the signal standard recorded on the tape.
  /// 
  /// This method succeeds if all of the following are true:
  /// - the pVideoSignal pointer is valid.
  ///
  /// If this method fails nothing will be written to *pVideoSignal.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pVideoSignal arg is NULL.
  /// 
  /// @param pVideoSignal [out] ex: kNTSCSignal
  ///
  HRESULT GetSignalType (
    [out] aafVideoSignalType_t *  pVideoSignal);


  //***********************************************************
  //
  // SetTapeFormat()
  //
  /// Sets the recording method of the tape.
  /// 
  /// This method succeeds if all of the following are true:
  /// - tapeFormat represents a valid tape format type.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_BAD_TYPE
  ///	- tapeFormat is invalid.
  /// 
  /// @param tapeFormat [in] ex: kBetacamFormat, kBetacamSPFormat
  ///
  HRESULT SetTapeFormat (
    [in] aafTapeFormatType_t  tapeFormat);


  //***********************************************************
  //
  // GetTapeFormat()
  //
  /// Gets the recording method of the tape.
  ///
  /// Succeeds if all of the following are true:
  /// - the pTapeFormat pointer is valid.
  /// 
  /// This method succeeds if all of the following are true:
  /// - the pTapeFormat pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTapeFormat arg is NULL.
  /// 
  /// @param pTapeFormat [out] ex: kBetacamFormat, kBetacamSPFormat
  ///
  HRESULT GetTapeFormat (
    [out] aafTapeFormatType_t *  pTapeFormat);


  //***********************************************************
  //
  // SetTapeLength()
  //
  /// Sets the length of the tape in minutes.
  /// 
  /// This method succeeds if all of the following are true:
  /// - tapeLength is a positive number.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_BAD_LENGTH
  ///	- tapeLength is negative.
  /// 
  /// @param tapeLength [in] The length of the tape in minutes.
  ///
  HRESULT SetTapeLength (
    [in] aafUInt32  tapeLength);


  //***********************************************************
  //
  // GetTapeLength()
  //
  /// Gets the length of the tape in minutes.
  ///
  /// This method succeeds if all of the following are true:
  /// - the pTapeLength pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pTapeLength.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTapeLength arg is NULL.
  /// 
  /// @param pTapeLength [out] The length of the tape in minutes.
  ///
  HRESULT GetTapeLength (
    [out] aafUInt32 *  pTapeLength);
}



// ************************
//
// Interface IAAFTextLocator
//
// ************************
///
/// The IAAFTextLocator interface is implemented by objects which
/// provide information to help find a file containing essence data
/// in a descriptive way for files that are held off-line.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it through
///     this object's primary interface.
///
///
/// Objects that implement IAAFTextLocator also implement the following interfaces:
///  - IAAFLocator
///  - IAAFObject
[
    object,
    uuid(e684d768-b935-11d2-bf9d-00104bc9156d),
    helpstring("IAAFTextLocator Interface"),
    pointer_default(unique)
]
interface IAAFTextLocator : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty
  /// IAAFNetworkLocator-supporting object.  This method must be called
  /// after allocation, and before any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  /// 
  HRESULT Initialize ();


  //***********************************************************
  //
  // SetName()
  //
  /// Sets the Name string property.
  ///
  /// Set the Name property to the value specified in
  /// pName.  A copy is made of the data so the caller
  /// retains ownership of the *pName buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pName pointer is valid.
  /// 
  /// If this method fails the Name property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  /// 
  /// @param pName [in, string] buffer from which Name is to be read
  ///
  HRESULT SetName (
    [in, string] aafCharacter_constptr  pName);


  //***********************************************************
  //
  // GetName()
  //
  /// Gets the Name string property.
  /// 
  /// Writes the Name property, with a trailing null
  /// character, into the pName buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the Name property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetNameBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pName.
  /// 
  /// Succeeds if:
  /// - The pName pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   Name.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold Name.
  /// 
  /// @param pName [out, string, size_is(bufSize)] buffer into which Name is to be written
  /// @param bufSize [in] size of *pName buffer in bytes
  ///
  HRESULT GetName (
    [out, string, size_is(bufSize)] aafCharacter *  pName,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetNameBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetName().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetNameBufLen (
    [out] aafUInt32 *  pBufSize);
}



// ************************
//
// Interface IAAFTimecode
//
// ************************
///
/// The IAAFTimecode interface is implemented by objects which store
/// videotape or audio tape timecode information.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///


///
/// Objects that implement IAAFTimecode also implement the following interfaces:
///  - IAAFSegment
///  - IAAFComponent
///  - IAAFComponent2
///  - IAAFObject
[
    object,
    uuid(92B88035-2B2B-11d2-BF7E-00104BC9156D),
    helpstring("IAAFTimecode Interface"),
    pointer_default(unique)
]
interface IAAFTimecode : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes this object with the given length and timecode
  /// values.  Length is specified in units of the edit rate of the
  /// containing timeline mob slot.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has not yet been initialized.
  /// - the pTimecode pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTimecode argument is NULL.
  /// 
  /// @param length [in] Length Property Value
  /// @param pTimecode [in] Timecode Value (startFrame, drop, fps)
  ///
  HRESULT Initialize (
    [in] aafLength_t  length,
    [in] aafTimecode_t*  pTimecode);


  //***********************************************************
  //
  // GetTimecode()
  //
  /// Get the timecode fields.
  ///
  /// Succeeds if all of the following are true:
  /// - the pTimecode pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pTimecode.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTimecode arg is NULL.
  /// 
  /// @param pTimecode [out] Timecode (startFrame, drop, fps)
  ///
  HRESULT GetTimecode (
    [out] aafTimecode_t *  pTimecode);


  //***********************************************************
  //
  // SetTimecode()
  //
  /// Set the timecode fields.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pTimecode pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTimecode arg is NULL.
  /// 
  /// @param timecode [in] Timecode (startFrame, drop, fps)
  ///
  HRESULT SetTimecode (
    [in] aafTimecode_t *  timecode);




}



// ************************
//
// Interface IAAFTimecodeStream
//
// ************************
///
/// Objects which support IAAFTimecodeStream specify a stream of
/// timecode data.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it through
///     this object's primary interface.  Note that IAAFSearchSource is
///     not a primary interface for a concrete class, so it is not
///     appropriate for the Initialize() method to exist in this
///     interface.  The Initialize() method is available through the
///     concrete object's primary interface.
///
///
/// Objects that implement IAAFTimecodeStream also implement the following interfaces:
///  - IAAFSegment
///  - IAAFComponent
///  - IAAFComponent2
///  - IAAFObject
[
    object,
    uuid(7B007BF2-2D39-11d2-8043-006008143E6F),
    helpstring("IAAFTimecodeStream Interface"),
    pointer_default(unique)
]
interface IAAFTimecodeStream : IUnknown
{

  //***********************************************************
  //
  // GetPositionTimecode()
  //
  /// Get the timecode fields at the given position.
  /// 
  /// @param position [in] Zero based offset to set the timecode at
  /// @param timecode [out] Timecode [startFrame drop fps]
  ///
  HRESULT GetPositionTimecode (
    [in] aafPosition_t  position,
    [out] aafTimecode_t *  timecode);


  //***********************************************************
  //
  // SetPositionTimecode()
  //
  /// Set the timecode fields for a given frame.  The frame index must
  /// be within the length of the object.
  /// 
  /// @param position [in] Zero-based offset to set the timecode at
  /// @param timecode [in] Timecode [startFrame  drop  fps]
  ///
  HRESULT SetPositionTimecode (
    [in] aafPosition_t  position,
    [in] aafTimecode_t  timecode);


  //***********************************************************
  //
  // GetUserDataLength()
  //
  /// Gets the length of the user data for one frame.
  /// 
  /// @param length [out] Fixed length of the user data [userbits] in bytes
  ///
  HRESULT GetUserDataLength (
    [out] aafInt32 *  length);


  //***********************************************************
  //
  // GetUserDataAtPosition()
  //
  /// Gets the user data [userbits] for a particular frame.
  /// 
  /// @param position [in] Zero-based offset
  /// @param buflen [in] Length of the buffer
  /// @param buffer [out] Passed in and filled with user data
  ///
  HRESULT GetUserDataAtPosition (
    [in] aafPosition_t  position,
    [in] aafInt32  buflen,
    [out] aafDataBuffer_t  buffer);


  //***********************************************************
  //
  // SetUserDataAtPosition()
  //
  /// Gets the user data [userbits] for a particular frame.
  /// 
  /// @param position [in] Zero-based offset to set the userbits at
  /// @param buflen [in] Length of the buffer
  /// @param buffer [in] user data for the given frame
  ///
  HRESULT SetUserDataAtPosition (
    [in] aafPosition_t  position,
    [in] aafInt32  buflen,
    [in] aafDataBuffer_t  buffer);
							 

  //***********************************************************
  //
  // SetSampleRate()
  //
  /// Sets the sample rate of the timecode data.
  /// 
  /// @param sampleRate [in] The sample rate of the timecode data
  ///
  HRESULT SetSampleRate (
    [in] aafRational_t  sampleRate);


  //***********************************************************
  //
  // GetSampleRate()
  //
  /// Gets the sample rate of the timecode data.
  /// 
  /// @param pSampleRate [out] The sample rate of the timecode data
  ///
  HRESULT GetSampleRate (
    [out] aafRational_t *  pSampleRate);


  //***********************************************************
  //
  // SetSourceType()
  //
  /// Sets the type (LTC or VITC) of the timecode data.
  /// 
  /// @param sourceType [in] The type (LTC or VITC) of the timecode data
  ///
  HRESULT SetSourceType (
    [in] aafTimecodeSourceType_t  sourceType);


  //***********************************************************
  //
  // GetSourceType()
  //
  /// Gets the type (LTC or VITC) of the timecode data.
  /// 
  /// @param pSourceType [out] The type (LTC or VITC) of the timecode data
  ///
  HRESULT GetSourceType (
    [out] aafTimecodeSourceType_t *  pSourceType);


  //***********************************************************
  //
  // GetSampleSize()
  //
  /// Gets the size (in samples) of one sample of the timecode data.
  /// 
  /// @param pSampleSize [out] The size (in bytes) of one sample of the timecode data
  ///
  HRESULT GetSampleSize (
    [out] aafUInt32 *  pSampleSize);


  //***********************************************************
  //
  // GetSource()
  //
  /// Writes the entire timecode data value into the pValue buffer.
  /// The buffer is allocated by the caller, and the size of the
  /// buffer is given by valueSize.
  /// 
  /// Caller may call GetValueBufLen() to determine the
  /// required buffer size.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pValue pointer is valid.
  /// - valueSize indicates the buffer is large enough to hold the name.
  /// 
  /// If this method fails nothing will be written to *pValue.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pValue arg is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - valueSize indicates the buffer is too small to hold the value.
  /// 
  /// @param valueSize [in] Size of preallocated buffer
  /// @param pValue [out, size_is(valueSize),length_is(*bytesRead)] Preallocated buffer to hold value
  /// @param bytesRead [out] Number of actual bytes read
  ///
  HRESULT GetSource (
    [in] aafUInt32  valueSize,
    [out, size_is(valueSize),length_is(*bytesRead)] aafDataBuffer_t  pValue,
    [out] aafUInt32*  bytesRead);


  //***********************************************************
  //
  // GetSourceBufLen()
  //
  /// Returns the length of buffer required for the GetValue()
  /// method.  The value is placed into the location specified by
  /// pLen.
  ///
  /// Succeeds if all of the following are true:
  /// - the pLen pointer is valid.
  ///
  /// If this method fails nothing will be written to *pLen.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLen arg is NULL.
  /// 
  /// @param pLen [out] Pointer to an variable used to return the length
  ///
  HRESULT GetSourceBufLen (
    [out] aafUInt32 *  pLen);


  //***********************************************************
  //
  // SetSource()
  //
  /// The data value is set from a buffer of size valueSize.
  ///
  /// Succeeds if all of the following are true:
  /// - the pValue pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pValue is null.
  /// 
  /// @param valueSize [in] Size of preallocated buffer
  /// @param pValue [in, size_is(valueSize)] buffer containing value
  ///
  HRESULT SetSource (
    [in] aafUInt32  valueSize,
    [in, size_is(valueSize)] aafDataBuffer_t  pValue);






}



// ************************
//
// Interface IAAFTimecodeStream12M
//
// ************************
///
/// Objects that implement IAAFTimecodeStream12M also implement the following interfaces:
///  - IAAFTimecodeStream
///  - IAAFSegment
///  - IAAFComponent
///  - IAAFComponent2
///  - IAAFObject
[
    object,
    uuid(EBF5EDB2-2D3A-11d2-8043-006008143E6F),
    helpstring("IAAFTimecodeStream12M Interface"),
    pointer_default(unique)
]

interface IAAFTimecodeStream12M : IUnknown
{




}



// ************************
//
// Interface IAAFTimelineMobSlot
//
// ************************
///
///
/// This interface is DEPRECATED, please use IAAFTimelineMobSlot2.
///
/// The IAAFTimelineMobSlot interface is implemented by objects which
/// contain time-varying timeline essence.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// Types required by this module:
///
/// aafBool
/// aafRational_t
/// aafPosition_t
/// aafTrackID_t
///


///
/// Objects that implement IAAFTimelineMobSlot also implement the following interfaces:
///  - IAAFTimelineMobSlot2
///  - IAAFMobSlot
///  - IAAFObject
[
    object,
    uuid(B1A21378-1A7D-11D2-BF78-00104BC9156D),
    helpstring("IAAFTimelineMobSlot Interface"),
    pointer_default(unique)
]
interface IAAFTimelineMobSlot : IUnknown
{
  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty
  /// IAAFTimelineMobSlot-supporting object.  This method must be
  /// called after allocation, and before any other method can be
  /// called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  /// 
  HRESULT Initialize ();


  //***********************************************************
  //
  // GetEditRate()
  //
  /// This method will get the edit rate for this mob slot.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pEditRate pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEditRate arg is NULL.
  /// 
  /// @param pEditRate [out,retval] Edit rate property value
  ///
  HRESULT GetEditRate (
    [out,retval] aafRational_t *  pEditRate);


  //***********************************************************
  //
  // SetEditRate()
  //
  /// This method will get set edit rate for this mob slot.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param editRate [in] Edit rate property value
  ///
  HRESULT SetEditRate (
    [in] aafRational_constref  editRate);


  //***********************************************************
  //
  // GetOrigin()
  //
  /// This method will return the origin of this mob slot.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pOrigin pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pOrigin arg is NULL.
  /// 
  /// @param pOrigin [out,retval] Origin property value
  ///
  HRESULT GetOrigin (
    [out,retval] aafPosition_t *  pOrigin);


  //***********************************************************
  //
  // SetOrigin()
  //
  /// This method will set the origin of this mob slot.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.).
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param origin [in] Origin property value
  ///
  HRESULT SetOrigin (
    [in] aafPosition_t  origin);







}


// ************************
//
// Interface IAAFTransition
//
// ************************
///
/// The IAAFTransition interface is implemented by objects describe a
/// change or transition from one piece of essence to another.
/// Transitions must exist in the context of a sequence, and must be
/// surrounded on both sides by segments (an object which has an
/// IAAFSegment interface).
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it through
///     this object's primary interface.  Note that IAAFMob is a
///     primary interface for an abstract class, so it is not
///     appropriate for the Initialize() method to exist in this
///     interface.  The Initialize() method is available through the
///     concrete object's primary interface.
///
///
/// Objects that implement IAAFTransition also implement the following interfaces:
///  - IAAFComponent
///  - IAAFComponent2
///  - IAAFObject
[
    object,
    uuid(E3F38312-2D3C-11d2-8043-006008143E6F),
    helpstring("IAAFTransition Interface"),
    pointer_default(unique)
]
interface IAAFTransition : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Constructor which allows specification of starting values.
  /// 
  /// @param pDataDef [in] Data Definition Object
  /// @param length [in] Length property value
  /// @param cutPoint [in] The point at which a cut would be inserted if the transition
	/// were removed
  /// @param op [in] A reference to an operation group object
  ///
  HRESULT Initialize (
    [in] IAAFDataDef * pDataDef,
    [in] aafLength_t  length,
    [in] aafPosition_t  cutPoint,
    [in] IAAFOperationGroup * op);	 


  //***********************************************************
  //
  // GetCutPoint()
  //
  /// Gets the point at which a cut would be inserted if the transition
  /// were removed.
  /// 
  /// @param cutPoint [out] Cut Point
  ///
  HRESULT GetCutPoint (
    [out] aafPosition_t *  cutPoint);


  //***********************************************************
  //
  // GetOperationGroup()
  //
  /// Gets the OperationGroup associated with the transition.
  /// 
  /// @param groupObj [out] OperationGroup used by transition
  ///
  HRESULT GetOperationGroup (
    [out] IAAFOperationGroup ** groupObj);


  //***********************************************************
  //
  // SetCutPoint()
  //
  /// Sets the point at which a cut would be inserted if the transition
  /// were removed.
  /// 
  /// @param cutPoint [in] Cut Point
  ///
  HRESULT SetCutPoint (
    [in] aafPosition_t  cutPoint);


  //***********************************************************
  //
  // SetOperationGroup()
  //
  /// Sets the operation group associated with the transition.
  /// 
  /// @param opgroup [in] Operation group used by transition
  ///
  HRESULT SetOperationGroup (
    [in] IAAFOperationGroup * opgroup);
}



// ************************
//
// Interface IAAFTypeDef
//
// ************************
///
/// This interface is used to define types used in AAF persistent
/// objects.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it through
///     this object's primary interface.  Note that IAAFObject is a
///     primary interface for an abstract class, so it is not
///     appropriate for the Initialize() method to exist in this
///     interface.  The Initialize() method is available through the
///     concrete object's primary interface.


///
/// Objects that implement IAAFTypeDef also implement the following interfaces:
///  - IAAFMetaDefinition
[
    object,
    uuid(dfbd6523-1d81-11d2-bf96-006097116212),
    helpstring("IAAFTypeDef Interface"),
    pointer_default(unique)
]
interface IAAFTypeDef : IUnknown
{

  //***********************************************************
  //
  // GetTypeCategory()
  //
  /// Returns the type category to which this type definition belongs.
  /// 
  /// Succeeds if:
  /// - The pTid argument is valid
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTid arg is NULL.
  /// 
  /// @param pTid [out] Returned type category
  ///
  HRESULT GetTypeCategory (
    [out] eAAFTypeCategory_t *  pTid);


  //***********************************************************
  //
  // RawAccessType()
  //
  /// This method returns the type def through which values of this
  /// type may be accessed if the client wishes to access the value as
  /// as raw data.
  ///
  /// NOTE! Stub only.   Implementation not yet added.
  /// 
  /// Succeeds if:
  /// - The ppRawTYPEDEF argument is valid
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppRawTypeDef arg is NULL.
  /// 
  /// @param ppRawTypeDef [out] the raw access type definition
  ///
  HRESULT RawAccessType (
    [out] IAAFTypeDef ** ppRawTypeDef);


}



// ************************
//
// Interface IAAFTypeDefCharacter
//
// ************************
///
/// This interface is used to define Integer types used in AAF persistent
/// objects.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// Objects that implement IAAFTypeDefCharacter also implement the following interfaces:
///  - IAAFTypeDef
///  - IAAFMetaDefinition
[
    object,
    uuid(FE717CAA-F04C-11d3-800B-00104BC9156D),
    helpstring("IAAFTypeDefCharacter Interface"),
    pointer_default(unique)
]
interface IAAFTypeDefCharacter : IUnknown
{


  //***********************************************************
  //
  // CreateValueFromCharacter()
  //
  /// Gets a property value corresponding to the character data. 
  /// 
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - The pCharacterValue pointer is valid.
  /// - The ppActualPropertyValue pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppCharacterValue is not a valid pointer.
  ///
  /// 
  /// @param character [in] character data to write the the new value
  /// @param ppCharacterValue [out] character property value with the given character
  ///
  HRESULT CreateValueFromCharacter (
    [in] aafCharacter  character,
    [out] IAAFPropertyValue ** ppCharacterValue);

  //***********************************************************
  //
  // GetCharacter()
  //
  /// Gets a character from the property value. 
  /// 
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - The pCharacterValue pointer is valid.
  /// - The ppActualPropertyValue pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - pCharacterValue is not a valid character property value.
  ///
  /// 
  /// @param pCharacterValue [in] character property value to read
  /// @param pCharacter [out] character that is read
  ///
  HRESULT GetCharacter (
    [in] IAAFPropertyValue * pCharacterValue,
    [out] aafCharacter *  pCharacter);

  //***********************************************************
  //
  // SetCharacter()
  //
  /// Sets a character into the given property value. 
  /// 
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - The pCharacterValue pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - pCharacterValue is not a valid character property value.
  ///
  /// 
  /// @param pCharacterValue [in] character property value to modify
  /// @param character [in] character that is written
  ///
  HRESULT SetCharacter (
    [in] IAAFPropertyValue * pCharacterValue,
    [in] aafCharacter  character);



}



// ************************
//
// Interface IAAFTypeDefEnum
//
// ************************
///
/// This interface is used to define enumerated types used in AAF
/// persistent objects.  Enumerated types are assumed to be based on
/// integers of no larger than 64 bits.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// Objects that implement IAAFTypeDefEnum also implement the following interfaces:
///  - IAAFTypeDef
///  - IAAFMetaDefinition
[
    object,
    uuid(307e9e64-dcb2-11d2-8429-00600832acb8),
    helpstring("IAAFTypeDefEnum Interface"),
    pointer_default(unique)
]
interface IAAFTypeDefEnum : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes this type def to be identified by the given guid, to
  /// be implemented as the given data type, and to contain the given
  /// elements (names and values).  The given data type must be an
  /// integral type.  It is considered an error if multiple elements
  /// have the same name or the same value.  The values and names are
  /// given in parallel arrays, each of which has numElements
  /// elements.
  ///
  /// This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  /// - pID is a valid pointer.
  /// - pType is a valid pointer.
  /// - pElementValues is a valid pointer.
  /// - pElementNames is a valid pointer.
  /// - pTypeName is a valid pointer.
  /// - base type is integral type.
  /// - no duplicate names or values are found.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - This object has already had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - any pointer argument arg is NULL.
  ///
  /// AAFRESULT_DUPLICATE
  ///   - duplicate name or value is found.
  ///
  /// AAFRESULT_BAD_TYPE
  ///   - base type is not integral type.
  /// 
  /// @param id [in, ref] auid to be used to identify this type
  /// @param pType [in] Type of values in this enumeration.
  /// Has to be of type Int
  /// @param pElementValues [in, size_is(numElems)] array of element values to be represented in this enumerated
  /// type
  /// @param pElementNames [in, size_is(numElems)] array of element names to be represented in this enumerated
  /// type
  /// @param numElems [in] number of members in pElementValues and pElementNames arrays
  /// @param pTypeName [in] friendly name of this type definition
  ///
  HRESULT Initialize (
    [in, ref] aafUID_constref  id,
    [in] IAAFTypeDef * pType,
    [in, size_is(numElems)] aafInt64 *  pElementValues,
    [in, size_is(numElems)] aafString_t *  pElementNames,
    [in] aafUInt32  numElems,
    [in] aafCharacter_constptr  pTypeName);


  //***********************************************************
  //
  // CreateValueFromName()
  //
  /// Creates a property value which contains an Enum type.  A
  /// lookup on the Name is done to find a match in the list of 
  /// legal enumerations for this type. If the Name specified is not
  /// found to exist then an INVALID_PARAM error code is returned.
  /// If it succeeds then a newly-created property value in ppPropVal
  /// is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the Name pointer is valid.
  /// - the ppPropVal pointer is valid.
  ///
  /// If this method fails nothing will be written to *ppPropVal.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppPropVal arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - the Name specified is not in the list of legal Enumerations.
  /// 
  /// @param Name [in] the Name of a valid Enum symbol
  /// @param ppPropVal [out] newly created property value
  ///
  HRESULT CreateValueFromName (
    [in] aafCharacter_constptr  Name,
    [out] IAAFPropertyValue ** ppPropVal);
  
  
  
  //***********************************************************
  //
  // GetElementType()
  //
  /// Returns the type definition of the values which are found in this
  /// enumeration.
  /// 
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - The ppTypeDef pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTypeDef arg is NULL.
  /// 
  /// @param ppTypeDef [out] type definition of values of this enumeration
  ///
  HRESULT GetElementType (
    [out] IAAFTypeDef ** ppTypeDef);

  //***********************************************************
  //
  // GetElementValue()
  //
  /// Gets the indexed element in this enumerated type.  The
  /// value is written into the client-allocated *pOutValue.  Index
  /// must be less than the value returned by CountElements().
  ///
  /// Succeeds if:
  /// - pOutValue is a valid pointer.
  /// - index is less than CountElements().
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pOutValue arg is NULL.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is not less than CountElements().
  /// 
  /// @param index [in] index of element to retrieve
  /// @param pOutValue [out] requested value
  ///
  HRESULT GetElementValue (
    [in] aafUInt32  index,
    [out] aafInt64 *  pOutValue);

  //***********************************************************
  //
  // GetElementName()
  //
  /// Gets the indexed element in this enumerated type.  The
  /// Name is written into the client-allocated *pOutValue. The
  /// bufSize argument should be large enough to hold the pOutValue.
  /// Index must be less than the value returned by CountElements().
  ///
  /// Caller may call GetElementNameBufLen() to determine the
  /// required buffer size.
  ///  
  /// Succeeds if:
  /// - pOutValue is a valid pointer.
  /// - index is less than CountElements().
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pOutValue arg is NULL.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is not less than CountElements().
  ///
  /// AAFRESULT_SMALLBUF
  ///   - bufSize indicates the buffer is too small to hold the string.
  ///
  /// 
  /// @param index [in] index of element to retrieve
  /// @param pOutValue [out, size_is(bufSize)] requested value
  /// @param bufSize [in] The size of the pOutValue buffer in bytes
  ///
  HRESULT GetElementName (
    [in] aafUInt32  index,
    [out, size_is(bufSize)] aafCharacter *  pOutValue,
    [in] aafUInt32  bufSize);
  
  

  //***********************************************************
  //
  // GetElementNameBufLen()
  //
  /// Returns the length of buffer required for the GetElementName()
  /// method, in bytes.  The value is placed into the location
  /// specified by pLen. The value will include space required for the
  /// trailing null character.
  ///
  /// Succeeds if the following is true:
  /// - the pLen pointer is valid.
  /// - index is less than CountElements().
  ///
  /// If this method fails nothing will be written to *pLen.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLen arg is NULL.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is not less than CountElements().
  ///
  /// 
  /// @param index [in] index of element to retrieve
  /// @param pLen [out] required buffer length, in bytes
  ///
  HRESULT GetElementNameBufLen (
    [in] aafUInt32  index,
    [out] aafUInt32 *  pLen);



  
  //***********************************************************
  //
  // CountElements()
  //
  /// Returns number of enumeration elements contained.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pCount is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCount arg is NULL.
  /// 
  /// @param pCount [out] count of elements within this enumeration
  ///
  HRESULT CountElements (
    [out] aafUInt32 *  pCount);



  //***********************************************************
  //
  // GetNameFromValue()
  //
  /// Writes the human-legible tag associated with the given value in
  /// this enumerated type.  The name is written, with a trailing null
  /// character, into the pName buffer.  The buffer is allocated by
  /// the caller.  The size of the buffer is given by bufSize.
  /// 
  /// Caller may call GetNameBufLenFromValue() to determine the
  /// required buffer size.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pValue pointer is valid.
  /// - the pName pointer is valid.
  /// - bufSize indicates the buffer is large enough to hold the name.
  /// - the integer value is associated with an element of this
  ///   enumerated type.
  /// 
  /// If this method fails nothing will be written to
  /// *pName.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pValue or pName arg is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - bufSize indicates the buffer is too small to hold the string.
  ///
  /// AAFRESULT_BAD_PARAM
  ///   - the given value is not associated with an element of
  ///     this type.
  /// 
  /// @param pValue [in] value of element to get
  /// @param pName [out, size_is(bufSize), string] buffer into which the element name is written
  /// @param bufSize [in] The size of the pName buffer, in bytes
  ///
  HRESULT GetNameFromValue (
    [in] IAAFPropertyValue * pValue,
    [out, size_is(bufSize), string] aafCharacter *  pName,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetNameBufLenFromValue()
  //
  /// Returns the length of buffer required for the GetNameFromValue()
  /// method, in bytes.  The value is placed into the location
  /// specified by pLen. The value will include space required for the
  /// trailing null character.
  ///
  /// Succeeds if all of the following are true:
  /// - the pValue pointer is valid.
  /// - the pLen pointer is valid.
  /// - the value is associated with an element of this enumerated
  ///   type.
  ///
  /// If this method fails nothing will be written to *pLen.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pValue or pLen arg is NULL.
  ///
  /// AAFRESULT_BAD_PARAM
  ///   - the given value is not associated with an element of this
  ///     type.
  /// 
  /// @param pValue [in] value of element to get
  /// @param pLen [out] required buffer length, in bytes
  ///
  HRESULT GetNameBufLenFromValue (
    [in] IAAFPropertyValue * pValue,
    [out] aafUInt32 *  pLen);


  //***********************************************************
  //
  // GetNameFromInteger()
  //
  /// Writes the human-legible tag associated with the given value in
  /// this enumerated type.  The name is written, with a trailing null
  /// character, into the pName buffer.  The buffer is allocated by
  /// the caller.  The size of the buffer is given by bufSize.
  /// 
  /// Caller may call GetNameBufLenFromInteger() to determine the
  /// required buffer size.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pName pointer is valid.
  /// - bufSize indicates the buffer is large enough to hold the name.
  /// - the integer value is associated with an element of this
  ///   enumerated type.
  /// 
  /// If this method fails nothing will be written to
  /// *pName.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - bufSize indicates the buffer is too small to hold the string.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - the given value is not associated with an element of
  ///     this type.
  /// 
  /// @param value [in] value of element to get
  /// @param pName [out, size_is(bufSize), string] buffer into which the element name is written
  /// @param bufSize [in] The size of the pName buffer, in bytes
  ///
  HRESULT GetNameFromInteger (
    [in] aafInt64  value,
    [out, size_is(bufSize), string] aafCharacter *  pName,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetNameBufLenFromInteger()
  //
  /// Returns the length of buffer required for the GetNameFromInteger()
  /// method, in bytes.  The value is placed into the location
  /// specified by pLen. The value will include space required for the
  /// trailing null character.
  ///
  /// Succeeds if all of the following are true:
  /// - the pLen pointer is valid.
  /// - the value is associated with an element of this enumerated
  ///   type.
  ///
  /// If this method fails nothing will be written to *pLen.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLen arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - the given value is not associated with an element of this
  ///     type.
  /// 
  /// @param value [in] value of element to get
  /// @param pLen [out] required buffer length, in bytes
  ///
  HRESULT GetNameBufLenFromInteger (
    [in] aafInt64  value,
    [out] aafUInt32 *  pLen);


  //***********************************************************
  //
  // GetIntegerValue()
  //
  /// Gets the value from the given property value and writes it as an
  /// integer into *pValueOut.
  ///
  /// Succeeds if:
  /// - The pPropValIn pointer is valid.
  /// - The pValueOut pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pPropValIn or ppPropValOut arg is NULL.
  /// 
  /// @param pPropValIn [in] property value to read
  /// @param pValueOut [out] value of the enum represented by the given input property value
  ///
  HRESULT GetIntegerValue (
    [in] IAAFPropertyValue * pPropValIn,
    [out] aafInt64 *  pValueOut);


  //***********************************************************
  //
  // SetIntegerValue()
  //
  /// Sets the given property to the value given in pValueIn.
  ///
  /// Succeeds if:
  /// - The pPropValToSet pointer is valid.
  /// - valueIn is a correct value for this enumerated type.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPropValToSet arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - valueIn is not a correct value for this enumerated type.
  ///   - pPropValIn's type doesn't match GetElementType()
  /// 
  /// @param pPropValToSet [in] property value to set
  /// @param valueIn [in] new value of the enum represented by the given property value
  ///
  HRESULT SetIntegerValue (
    [in] IAAFPropertyValue * pPropValToSet,
    [in] aafInt64  valueIn);


  //***********************************************************
  //
  // RegisterSize()
  //
  /// Allows client to register to the reference implementation a
  /// runtime C enum to represent objects of this TypeDef.  The size of
  /// the enum to be represented should be passed as the enumSize
  /// argument.  This allows the reference implementation to write
  /// property values into compile-time-defined C enums intelligible
  /// by the local machine and compiler.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param enumSize [in] size of this enum
  ///
  HRESULT RegisterSize (
    [in] aafUInt32  enumSize);

}



// ************************
//
// Interface IAAFTypeDefExtEnum
//
// ************************
///
/// This interface is used to define field-extendible enumerated types
/// used in AAF persistent objects.  Enumerated types are assumed to be
/// based on AUIDs.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// Objects that implement IAAFTypeDefExtEnum also implement the following interfaces:
///  - IAAFTypeDef
///  - IAAFMetaDefinition
[
    object,
    uuid(a5456f01-0ef2-11d3-842e-00600832acb8),
    helpstring("IAAFTypeDefExtEnum Interface"),
    pointer_default(unique)
]
interface IAAFTypeDefExtEnum : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes this type def to be identified by the given guid.  No
  /// element values are initially specified; they must be supplied
  /// later using the AppendElement method.
  ///
  /// This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  /// - pID is a valid pointer.
  /// - pTypeName is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - This object has already had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTypeName arg is NULL.
  ///
  /// AAFRESULT_DUPLICATE
  ///   - duplicate name or value is found.
  /// 
  /// @param id [in, ref] auid to be used to identify this type
  /// @param pTypeName [in] friendly name of this type definition
  ///
  HRESULT Initialize (
    [in, ref] aafUID_constref  id,
    [in] aafCharacter_constptr  pTypeName);

  //***********************************************************
  //
  // CreateValueFromName()
  //
  /// Creates a property value which contains an Enum type.  A
  /// lookup on the Name is done to find a match in the list of 
  /// legal enumerations for this type. If the Name specified is not
  /// found to exist then an INVALID_PARAM error code is returned.
  /// If it succeeds then a newly-created property value in ppPropVal
  /// is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the Name pointer is valid.
  /// - the ppPropVal pointer is valid.
  ///
  /// If this method fails nothing will be written to *ppPropVal.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppPropVal arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - the Name specified is not in the list of legal Enumerations.
  /// 
  /// @param Name [in] the Name of a valid Enum symbol
  /// @param ppPropVal [out] newly created property value
  ///
  HRESULT CreateValueFromName (
    [in] aafCharacter_constptr  Name,
    [out] IAAFPropertyValue ** ppPropVal);
  

  //***********************************************************
  //
  // CountElements()
  //
  /// Returns number of enumeration elements contained.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pCount is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCount arg is NULL.
  /// 
  /// @param pCount [out] count of elements within this enumeration
  ///
  HRESULT CountElements (
    [out] aafUInt32 *  pCount);


  //***********************************************************
  //
  // GetElementValue()
  //
  /// Gets the indexed element in this enumerated type.  The
  /// value is written into the client-allocated *pOutValue.  Index
  /// must be less than the value returned by CountElements().
  ///
  /// Succeeds if:
  /// - pOutValue is a valid pointer.
  /// - index is less than CountElements().
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pOutValue arg is NULL.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is not less than CountElements().
  /// 
  /// @param index [in] index of element to retrieve
  /// @param pOutValue [out] requested value
  ///
  HRESULT GetElementValue (
    [in] aafUInt32  index,
    [out] aafUID_t *  pOutValue);


  //***********************************************************
  //
  // GetElementName()
  //
  /// Gets the indexed element in this enumerated type.  The
  /// Name is written into the client-allocated *pOutValue. The
  /// bufSize argument should be large enough to hold the pOutValue.
  /// Index must be less than the value returned by CountElements().
  ///
  /// Caller may call GetElementNameBufLen() to determine the
  /// required buffer size.
  ///  
  /// Succeeds if:
  /// - pOutValue is a valid pointer.
  /// - index is less than CountElements().
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pOutValue arg is NULL.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is not less than CountElements().
  ///
  /// AAFRESULT_SMALLBUF
  ///   - bufSize indicates the buffer is too small to hold the string.
  ///
  /// 
  /// @param index [in] index of element to retrieve
  /// @param pOutValue [out, size_is(bufSize)] requested value
  /// @param bufSize [in] The size of the pOutValue buffer in bytes
  ///
  HRESULT GetElementName (
    [in] aafUInt32  index,
    [out, size_is(bufSize)] aafCharacter *  pOutValue,
    [in] aafUInt32  bufSize);
  
  //***********************************************************
  //
  // GetElementNameBufLen()
  //
  /// Returns the length of buffer required for the GetElementName()
  /// method, in bytes.  The value is placed into the location
  /// specified by pLen. The value will include space required for the
  /// trailing null character.
  ///
  /// Succeeds if the following is true:
  /// - the pLen pointer is valid.
  /// - index is less than CountElements().
  ///
  /// If this method fails nothing will be written to *pLen.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLen arg is NULL.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is not less than CountElements().
  ///
  /// 
  /// @param index [in] index of element to retrieve
  /// @param pLen [out] required buffer length, in bytes
  ///
  HRESULT GetElementNameBufLen (
    [in] aafUInt32  index,
    [out] aafUInt32 *  pLen);


  //***********************************************************
  //
  // GetNameFromValue()
  //
  /// Writes the human-legible tag associated with the given value in
  /// this enumerated type.  The name is written, with a trailing null
  /// character, into the pName buffer.  The buffer is allocated by
  /// the caller.  The size of the buffer is given by bufSize.
  /// 
  /// Caller may call GetNameBufLenFromValue() to determine the
  /// required buffer size.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pValue pointer is valid.
  /// - the pName pointer is valid.
  /// - bufSize indicates the buffer is large enough to hold the name.
  /// - the integer value is associated with an element of this
  ///   enumerated type.
  /// 
  /// If this method fails nothing will be written to
  /// *pName.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pValue or pName arg is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - bufSize indicates the buffer is too small to hold the string.
  ///
  /// AAFRESULT_BAD_PARAM
  ///   - the given value is not associated with an element of
  ///     this type.
  /// 
  /// @param pValue [in] value of element to get
  /// @param pName [out, size_is(bufSize), string] buffer into which the element name is written
  /// @param bufSize [in] The size of the pName buffer, in bytes
  ///
  HRESULT GetNameFromValue (
    [in] IAAFPropertyValue * pValue,
    [out, size_is(bufSize), string] aafCharacter *  pName,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetNameBufLenFromValue()
  //
  /// Returns the length of buffer required for the GetNameFromValue()
  /// method, in bytes.  The value is placed into the location
  /// specified by pLen. The value will include space required for the
  /// trailing null character.
  ///
  /// Succeeds if all of the following are true:
  /// - the pValue pointer is valid.
  /// - the pLen pointer is valid.
  /// - the value is associated with an element of this enumerated
  ///   type.
  ///
  /// If this method fails nothing will be written to *pLen.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pValue or pLen arg is NULL.
  ///
  /// AAFRESULT_BAD_PARAM
  ///   - the given value is not associated with an element of this
  ///     type.
  /// 
  /// @param pValue [in] value of element to get
  /// @param pLen [out] required buffer length, in bytes
  ///
  HRESULT GetNameBufLenFromValue (
    [in] IAAFPropertyValue * pValue,
    [out] aafUInt32 *  pLen);


  //***********************************************************
  //
  // GetNameFromAUID()
  //
  /// Writes the human-legible tag associated with the given value in
  /// this enumerated type.  The name is written, with a trailing null
  /// character, into the pName buffer.  The buffer is allocated by
  /// the caller.  The size of the buffer is given by bufSize.
  /// 
  /// Caller may call GetNameBufLenFromAUID() to determine the
  /// required buffer size.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pName pointer is valid.
  /// - bufSize indicates the buffer is large enough to hold the name.
  /// - the integer value is associated with an element of this
  ///   enumerated type.
  /// 
  /// If this method fails nothing will be written to
  /// *pName.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - bufSize indicates the buffer is too small to hold the string.
  ///
  /// AAFRESULT_BAD_PARAM
  ///   - the given value is not associated with an element of
  ///     this type.
  /// 
  /// @param value [in, ref] value of element to get
  /// @param pName [out, size_is(bufSize), string] buffer into which the element name is written
  /// @param bufSize [in] The size of the pName buffer, in bytes
  ///
  HRESULT GetNameFromAUID (
    [in, ref] aafUID_constref  value,
    [out, size_is(bufSize), string] aafCharacter *  pName,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetNameBufLenFromAUID()
  //
  /// Returns the length of buffer required for the GetNameFromInteger()
  /// method, in bytes.  The value is placed into the location
  /// specified by pLen. The value will include space required for the
  /// trailing null character.
  ///
  /// Succeeds if all of the following are true:
  /// - the pLen pointer is valid.
  /// - the value is associated with an element of this enumerated
  ///   type.
  ///
  /// If this method fails nothing will be written to *pLen.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLen arg is NULL.
  ///
  /// AAFRESULT_BAD_PARAM
  ///   - the given value is not associated with an element of this
  ///     type.
  /// 
  /// @param value [in, ref] value of element to get
  /// @param pLen [out] required buffer length, in bytes
  ///
  HRESULT GetNameBufLenFromAUID (
    [in, ref] aafUID_constref  value,
    [out] aafUInt32 *  pLen);


  //***********************************************************
  //
  // GetAUIDValue()
  //
  /// Gets the value from the given property value and writes it as an
  /// AUID into *pValueOut.
  ///
  /// Succeeds if:
  /// - The pPropValIn pointer is valid.
  /// - The pValueOut pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pPropValIn or ppPropValOut arg is NULL.
  /// 
  /// @param pPropValIn [in] property value to read
  /// @param pValueOut [out] value of the enum represented by the given input property value
  ///
  HRESULT GetAUIDValue (
    [in] IAAFPropertyValue * pPropValIn,
    [out] aafUID_t *  pValueOut);


  //***********************************************************
  //
  // SetAUIDValue()
  //
  /// Sets the given property to the value given in valueIn.
  ///
  /// Succeeds if:
  /// - The pPropValToSet pointer is valid.
  /// - valueIn is a correct value for this enumerated type.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPropValToSet arg is NULL.
  ///
  /// AAFRESULT_BAD_PARAM
  ///   - valueIn is not a correct value for this enumerated type.
  ///   - pPropValIn's type doesn't match GetElementType()
  /// 
  /// @param pPropValToSet [in] property value to set
  /// @param valueIn [in, ref] new value of the enum represented by the given property value
  ///
  HRESULT SetAUIDValue (
    [in] IAAFPropertyValue * pPropValToSet,
    [in, ref] aafUID_constref  valueIn);


  //***********************************************************
  //
  // AppendElement()
  //
  /// Appends a new element to this extendible enumeration.  The
  /// element will have the given name and value.  It is not legal to
  /// have elements with duplicate names or values.
  /// 
  /// Succeeds if:
  /// - the pName pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  ///
  /// AAFRESULT_DUPLICATE
  ///   - duplicate name or value is found.
  /// 
  /// @param value [in, ref] value of appended element
  /// @param pName [in] name of appended element
  ///
  HRESULT AppendElement (
    [in, ref] aafUID_constref  value,
    [in] aafCharacter_constptr  pName);



}



// ************************
//
// Interface IAAFTypeDefFixedArray
//
// ************************
///
/// This interface is used to define fixed-sized Array types used in
/// AAF persistent objects.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// Objects that implement IAAFTypeDefFixedArray also implement the following interfaces:
///  - IAAFTypeDef
///  - IAAFMetaDefinition
[
    object,
    uuid(c3274646-9467-11d2-841f-00600832acb8),
    helpstring("IAAFTypeDefFixedArray Interface"),
    pointer_default(unique)
]
interface IAAFTypeDefFixedArray : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes this type def to contain elements of the given type,
  /// and have the given fixed size.  Note that it is only possible to
  /// use certain types as the element type.  Those permissible types
  /// include:
  /// - AAFTypeDefInt
  /// - AAFTypeDefRecord
  /// - AAFTypeDefEnum
  /// - AAFTypeDefExtEnum
  /// - AAFTypeDefFixedArray
  ///
  /// This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  /// - pID is a valid pointer.
  /// - pTypeDef is a valid pointer.
  /// - pTypeName is a valid pointer.
  /// - element type is permissible for use in a FixedArray.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - This object has already had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pTypeDef or pTypeName arg is NULL.
  ///
  /// AAFRESULT_BAD_TYPE
  ///   - an illegal element type was given.
  /// 
  /// @param id [in, ref] auid to be used to identify this type
  /// @param pTypeDef [in] type of each element to be contained in this array
  /// @param nElements [in] number of elements to be in this array
  /// @param pTypeName [in] friendly name of this type definition
  ///
  HRESULT Initialize (
    [in, ref] aafUID_constref  id,
    [in] IAAFTypeDef * pTypeDef,
    [in] aafUInt32  nElements,
    [in] aafCharacter_constptr  pTypeName);


  //***********************************************************
  //
  // GetType()
  //
  /// Returns the type of elements in this array.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - ppTypeDef is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTypeDef arg is NULL.
  /// 
  /// @param ppTypeDef [out] type of elements in this array
  ///
  HRESULT GetType (
    [out] IAAFTypeDef ** ppTypeDef);


  //***********************************************************
  //
  // GetCount()
  //
  /// Returns number of elements in this array.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pCount is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCount arg is NULL.
  /// 
  /// @param pCount [out] count of elements in this array
  ///
  HRESULT GetCount (
    [out] aafUInt32 *  pCount);


  //***********************************************************
  //
  // CreateValueFromValues()
  //
  /// Creates a property value which contains a fixed array type.  The
  /// array elements in the property value are initialized to contain
  /// the given values, passed in the pElementValues array.
  /// numElements, which indicates the size of the pElementValues
  /// array, must match the value returned by GetCount().  Returns
  /// the newly-created property value in ppPropVal.
  ///
  /// Succeeds if all of the following are true:
  /// - the pElementValues pointer is valid.
  /// - the ppPropVal pointer is valid.
  /// - numElements matches the number of elements in this array
  ///
  /// If this method fails nothing will be written to *ppPropVal.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pElementValues or ppPropVal arg is NULL.
  ///
  /// AAFRESULT_BAD_PARAM
  ///   - numElements does not match GetCount().
  /// 
  /// @param ppElementValues [in, size_is(numElements)] array of property values for elements of array value which
  /// is to be created.
  /// @param numElements [in] size of pElementValues array.
  /// @param ppPropVal [out] newly-created property value
  ///
  HRESULT CreateValueFromValues (
    [in, size_is(numElements)] IAAFPropertyValue ** ppElementValues,
    [in] aafUInt32  numElements,
    [out] IAAFPropertyValue ** ppPropVal);


  //***********************************************************
  //
  // CreateValueFromCArray()
  //
  /// Creates a property value which contains a fixed array type.  The
  /// array elements in the property value are initialized from data in
  /// a C array which is pointed to by pInitData.  Requires that any
  /// structures declared within this array typedef have had their
  /// offsets registered with that type.  Returns the newly-created
  /// property value in ppPropVal.
  ///
  /// Succeeds if all of the following are true:
  /// - the pInitData pointer is valid.
  /// - the ppPropVal pointer is valid.
  /// - initDataSize indicates pInitData is the correct size.
  /// - compile-time struct has had its member offests registered.
  ///
  /// If this method fails nothing will be written to *ppPropVal.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pInitData or ppPropVal arg is NULL.
  ///
  /// AAFRESULT_BAD_PARAM
  ///   - initDataSize indicates pInitData is of the wrong size.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - any contained struct offsets have not yet been registered for
  ///    that typedef.
  /// 
  /// @param pInitData [in, size_is(initDataSize)] pointer to compile-time C array containing data to use
  /// @param initDataSize [in] size of data in pInitData, in bytes
  /// @param ppPropVal [out] newly created property value
  ///
  HRESULT CreateValueFromCArray (
    [in, size_is(initDataSize)] aafMemPtr_t  pInitData,
    [in] aafUInt32  initDataSize,
    [out] IAAFPropertyValue ** ppPropVal);


  //***********************************************************
  //
  // GetElementValue()
  //
  /// Gets a single property value corresponding to the indexed array
  /// element.  Places a property value representing the array element
  /// identified by the index into ppOutPropval.  Index is zero-based,
  /// and must be less than the value returned by GetCount().
  /// 
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - the index exists in this array type def.
  /// - The pInPropVal pointer is valid.
  /// - The ppOutPropVal pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pInPropVal or ppOutPropVal arg is NULL.
  ///
  /// AAFRESULT_BAD_PARAM
  ///   - The given index is out of range for this array type def.
  /// 
  /// @param pInPropVal [in] property value to read
  /// @param index [in] zero-based index into elements in this array type
  /// @param ppOutPropVal [out] value that is read
  ///
  HRESULT GetElementValue (
    [in] IAAFPropertyValue * pInPropVal,
    [in] aafUInt32  index,
    [out] IAAFPropertyValue ** ppOutPropVal);


  //***********************************************************
  //
  // GetCArray()
  //
  /// Copies all the array data contained in the given property value,
  /// interpreted as a fixed array of this type, into the C array
  /// pointed to by pData.  Requires that any structures declared
  /// within this array typedef have had their offsets registered with
  /// that type.
  ///
  /// Succeeds if all of the following are true:
  /// - the pPropVal pointer is valid.
  /// - the pData pointer is valid.
  /// - dataSize indicates pData is large enough to hold the data.
  /// - compile-time struct has had its member offests registered.
  ///
  /// If this method fails nothing will be written to *ppPropVal.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pPropVal or pData arg is NULL.
  ///
  /// AAFRESULT_BAD_PARAM
  ///   - dataSize indicates pData is too small.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for this typedef.
  /// 
  /// @param pPropVal [in] property value to read
  /// @param pData [out, size_is(dataSize)] buffer into which C array data should be written
  /// @param dataSize [in] size of pData buffer in bytes
  ///
  HRESULT GetCArray (
    [in] IAAFPropertyValue * pPropVal,
    [out, size_is(dataSize)] aafMemPtr_t  pData,
    [in] aafUInt32  dataSize);


  //***********************************************************
  //
  // SetElementValue()
  //
  /// Sets the value of the single, indicated element of the fixed
  /// array contained in pPropVal, to the value contained in
  /// pMemberPropVal.  Index is zero-based, and must be less than the
  /// value returned by GetCount().  Property value must be of the
  /// same type as returned by GetType().
  /// 
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - the index exists in this array type def.
  /// - The pInPropVal pointer is valid.
  /// - The ppOutPropVal pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pInPropVal or ppOutPropVal arg is NULL.
  ///
  /// AAFRESULT_BAD_PARAM
  ///   - The given index is out of range for this array type def.
  /// 
  /// @param pPropVal [in] property value to write
  /// @param index [in] zero-based index into members in this array type
  /// @param pMemberPropVal [in] value to be placed into this array
  ///
  HRESULT SetElementValue (
    [in] IAAFPropertyValue * pPropVal,
    [in] aafUInt32  index,
    [in] IAAFPropertyValue * pMemberPropVal);


  //***********************************************************
  //
  // SetCArray()
  //
  /// Copies all the array data contained in the C array pointed to by
  /// pData into the given property value, interpreting the data as a
  /// fixed array of this type.  Requires that any structures declared
  /// within this typedef have had their offsets registered with that
  /// type.
  ///
  /// Succeeds if all of the following are true:
  /// - the pPropVal pointer is valid.
  /// - the pData pointer is valid.
  /// - dataSize indicates pData contains the correct amount of data.
  /// - any contained compile-time struct has had its member offests
  ///   registered.
  ///
  /// If this method fails nothing will be written to *ppPropVal.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pPropVal or pData arg is NULL.
  ///
  /// AAFRESULT_BAD_PARAM
  ///  - dataSize indicates pData is not the correct size.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - offsets of any contained struct have not yet been registered.
  /// 
  /// @param pPropVal [in] property value to write
  /// @param pData [in, size_is(dataSize)] buffer from which C array data should be read
  /// @param dataSize [in] size of pData buffer in bytes
  ///
  HRESULT SetCArray (
    [in] IAAFPropertyValue * pPropVal,
    [in, size_is(dataSize)] aafMemPtr_t  pData,
    [in] aafUInt32  dataSize);




  //***********************************************************
  //
  // GetElements()
  //
  /// Returns an enumerator across elements in this set.
  /// 
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - The PSetPropVal pointer is valid.
  /// - The ppEnum pointer is valid.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either PSetPropVal or ppEnum arg is NULL.
  /// 
  /// @param PSetPropVal [in] property value to read
  /// @param ppEnum [out] enumerator across property values
  ///
  HRESULT GetElements (
    [in] IAAFPropertyValue * PSetPropVal,
    [out] IEnumAAFPropertyValues ** ppEnum);

}



// ************************
//
// Interface IAAFTypeDefIndirect
//
// ************************
///
/// This interface is used to define Integer types used in AAF persistent
/// objects.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// Objects that implement IAAFTypeDefIndirect also implement the following interfaces:
///  - IAAFTypeDef
///  - IAAFMetaDefinition
[
    object,
    uuid(FE717CA8-F04C-11d3-800B-00104BC9156D),
    helpstring("IAAFTypeDefIndirect Interface"),
    pointer_default(unique)
]
interface IAAFTypeDefIndirect : IUnknown
{



  //***********************************************************
  //
  // CreateValueFromActualValue()
  //
  /// Creates an indirect property value which contains the actual type.  
  /// Returns the newly-created property value in ppIndirectPropertyValue.
  ///
  /// Succeeds if all of the following are true:
  /// - the pActualValue pointer is valid.
  /// - the ppIndirectPropertyValue pointer is valid.
  ///
  /// If this method fails nothing will be written to *ppIndirectPropertyValue.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pActualValue or ppIndirectPropertyValue arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - initDataSize indicates pInitData is of the wrong size.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for this typedef.
  /// 
  /// @param pActualValue [in] pointer to actual value
  /// @param ppIndirectPropertyValue [out] newly created property value
  ///
  HRESULT CreateValueFromActualValue (
    [in] IAAFPropertyValue * pActualValue,
    [out] IAAFPropertyValue ** ppIndirectPropertyValue);

  //***********************************************************
  //
  // CreateValueFromActualData()
  //
  /// Creates an indirect property value which contains data of the 
  /// actual type.  Returns the newly-created property value in
  /// ppIndirectPropertyValue.
  ///
  /// Succeeds if all of the following are true:
  /// - the pActualType pointer is valid and registered
  /// - the pInitData pointer is valid.
  /// - the ppIndirectPropertyValue pointer is valid.
  /// - initDataSize indicates pInitData is the correct size for 
  ///   the actual type.
  /// - compile-time struct has had its member offests registered.
  ///
  /// If this method fails nothing will be written to *ppIndirectPropertyValue.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pActualType or InitData or ppIndirectPropertyValue arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - initDataSize indicates pInitData is of the wrong size.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for this typedef.
  /// 
  /// @param pActualType [in] the actual type of the data
  /// @param pInitData [in, size_is(initDataSize)] pointer to buffer containing data to use
  /// @param initDataSize [in] size of data in pInitData
  /// @param ppIndirectPropertyValue [out] newly created property value
  ///
  HRESULT CreateValueFromActualData (
    [in] IAAFTypeDef * pActualType,
    [in, size_is(initDataSize)] aafMemPtr_t  pInitData,
    [in] aafUInt32  initDataSize,
    [out] IAAFPropertyValue ** ppIndirectPropertyValue);


  //***********************************************************
  //
  // GetActualValue()
  //
  /// Gets a property value corresponding to the actual data. 
  /// 
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - The pIndirectPropertyValue pointer is valid.
  /// - The ppActualPropertyValue pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pIndirectPropertyValue or ppActualPropertyValue arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - initDataSize indicates pInitData is of the wrong size.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for this typedef.
  /// 
  /// @param pIndirectPropertyValue [in] indirect property value to read
  /// @param ppActualPropertyValue [out] value that is read
  ///
  HRESULT GetActualValue (
    [in] IAAFPropertyValue * pIndirectPropertyValue,
    [out] IAAFPropertyValue ** ppActualPropertyValue);
  ///)

  //***********************************************************
  //
  // GetActualSize()
  //
  /// Return the size of the actual data withing the indirect property value.
  ///
  ///
  /// Succeeds if all of the following are true:
  /// - the pIndirectPropertyValue pointer is valid.
  /// - the pActualSize pointer is valid.
  ///
  /// If this method fails nothing will be written to *pActualSize.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pIndirectPropertyValue or pActualSize arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - the type of pIndirectPropertyValue was not indirect. 
  ///
  /// AAFRESULT_TYPE_NOT_FOUND
  ///   - the actual type cannot be found in the dictionary.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for 
  ///    the actual typedef.
  /// 
  /// @param pIndirectPropertyValue [in] indirect property value to read
  /// @param pActualSize [out] actual data size
  ///
  HRESULT GetActualSize (
    [in] IAAFPropertyValue * pIndirectPropertyValue,
    [out] aafUInt32 *  pActualSize);
  //***********************************************************
  //
  // GetActualType()
  //
  /// Return the type definition of the  actual data within the indirect property value.
  ///
  ///
  /// Succeeds if all of the following are true:
  /// - the pIndirectPropertyValue pointer is valid.
  /// - the pActualType pointer is valid.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pIndirectPropertyValue or pActualType arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - the type of pIndirectPropertyValue was not indirect. 
  ///
  /// AAFRESULT_TYPE_NOT_FOUND
  ///   - the actual type cannot be found in the dictionary.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for 
  ///    the actual typedef.
  /// 
  /// @param pIndirectPropertyValue [in] indirect property value to read
  /// @param pActualType [out] the type definition of the actual data
  ///
  HRESULT GetActualType (
    [in] IAAFPropertyValue * pIndirectPropertyValue,
    [out] IAAFTypeDef ** pActualType);

  //***********************************************************
  //
  // GetActualData()
  //
  /// Copies all the actual data contained in the given indirect property value,
  /// interpreted as the actual type for this indirect property value, into the 
  /// buffer pointed to by pData.
  ///
  /// Succeeds if all of the following are true:
  /// - the pPropVal pointer is valid.
  /// - the pData pointer is valid.
  /// - dataSize indicates pData is large enough to hold the data.
  ///
  /// If this method fails nothing will be written to *ppPropVal.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pPropVal or pData arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - dataSize indicates pData is too small.
  ///
  /// AAFRESULT_TYPE_NOT_FOUND
  ///   - the actual type cannot be found in the dictionary.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for 
  ///    the actual typedef.
  /// 
  /// @param pPropVal [in] indirect property value to read
  /// @param pData [out, size_is(dataSize)] buffer into which actual data should be written
  /// @param dataSize [in] size of pData buffer in bytes
  ///
  HRESULT GetActualData (
    [in] IAAFPropertyValue * pPropVal,
    [out, size_is(dataSize)] aafMemPtr_t  pData,
    [in] aafUInt32  dataSize);



}



// ************************
//
// Interface IAAFTypeDefInt
//
// ************************
///
/// This interface is used to define Integer types used in AAF persistent
/// objects.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// Objects that implement IAAFTypeDefInt also implement the following interfaces:
///  - IAAFTypeDef
///  - IAAFMetaDefinition
[
    object,
    uuid(809c8ca2-9884-11d2-841f-00600832acb8),
    helpstring("IAAFTypeDefInt Interface"),
    pointer_default(unique)
]
interface IAAFTypeDefInt : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes this type def to be identified by the given guid, to
  /// have the given size in bytes, and to be signed or unsigned.
  ///
  /// The implementation of this method may only allow certain values
  /// for intSize.  It *will* allow at least 1, 2, 4, and 8-byte
  /// integers; some implementations may allow more than that.
  ///
  /// This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  /// - intSize is a valid value.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - This object has already had Initialize() called on it.
  ///
  /// AAFRESULT_BAD_SIZE
  ///  - intSize is not a valid value.
  /// 
  /// @param id [in, ref] auid to be used to identify this type
  /// @param intSize [in] the size of this integer type in bytes
  /// @param isSigned [in] true if this integer type is signed; false for unsigned
  /// @param pTypeName [in, string] friendly name of this type definition
  ///
  HRESULT Initialize (
    [in, ref] aafUID_constref  id,
    [in] aafUInt8  intSize,
    [in] aafBoolean_t  isSigned,
    [in, string] aafCharacter_constptr  pTypeName);


  //***********************************************************
  //
  // CreateValue()
  //
  /// Creates a property value which contains an integer.  Initializes
  /// it to contain the given integer value.  The initialization value
  /// is passed through pVal; the size of the initialzation value is
  /// given in valSize.
  ///
  /// valSize may be smaller than GetSize() for this typedef; if so,
  /// the value is lsb-justified and sign-extended (for signed) or
  /// zero-filled (for unsigned).
  ///
  /// The implementation of this method may only allow certain values
  /// for valSize.  It *will* allow at least 1, 2, 4, and 8-byte
  /// integers; some implementations may allow more than that.
  ///
  /// Succeeds if:
  /// - The pVal pointer is valid.
  /// - The ppPropVal pointer is valid.
  /// - valSize is no larger than GetSize() for this typedef.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pVal or ppPropVal arg is NULL.
  ///
  /// AAFRESULT_BAD_SIZE
  ///   - valSize is larger than GetSize() for this typedef, or
  ///     valSize is not a supported value.
  /// 
  /// @param pVal [in, size_is(valSize)] pointer to integer initialization value
  /// @param valSize [in] size of integer, in bytes, in pVal
  /// @param ppPropVal [out] newly created property value
  ///
  HRESULT CreateValue (
    [in, size_is(valSize)] aafMemPtr_t  pVal,
    [in] aafUInt32  valSize,
    [out] IAAFPropertyValue ** ppPropVal);


  //***********************************************************
  //
  // GetInteger()
  //
  /// Returns the integer value of this property.  The value
  /// to set is passed through pVal.  The size of the pVal buffer is
  /// given in valSize.  valSize may be larger than GetSize(); if so,
  /// the value is lsb-justified and sign-extended (for signed) or
  /// zero-filled (for unsigned).
  ///
  /// valSize may be smaller than GetSize() for this typedef; if so,
  /// the value is lsb-justified and sign-extended (for signed) or
  /// zero-filled (for unsigned).
  ///
  /// The implementation of this method may only allow certain values
  /// for valSize.  It *will* allow at least 1, 2, 4, and 8-byte
  /// integers; some implementations may allow more than that.
  ///
  /// Succeeds if:
  /// - The pPropVal pointer is valid.
  /// - The pVal pointer is valid.
  /// - valSize indicates that pVal is large enough to hold the value.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pPropVal or pVal arg is NULL.
  ///
  /// AAFRESULT_BAD_SIZE
  ///   - valSize is smaller than GetSize() for this typedef, or
  ///     valSize is not a supported value.
  ///
  /// AAFRESULT_BAD_TYPE
  ///   - The type associated with pPropVal cannot be read as an
  ///     integral type, or the int size of pPropVal is larger than the
  ///     int size of this type.
  /// 
  /// @param pPropVal [in] property value from which value is to be read
  /// @param pVal [out, size_is(valSize)] buffer into which value is written
  /// @param valSize [in] size of pVal buffer in bytes
  ///
  HRESULT GetInteger (
    [in] IAAFPropertyValue * pPropVal,
    [out, size_is(valSize)] aafMemPtr_t  pVal,
    [in] aafUInt32  valSize);


  //***********************************************************
  //
  // SetInteger()
  //
  /// Sets this property value to the given integer value.  The value
  /// to set is passed in pVal, and the size of the value in pVal is
  /// given in valSize.  valSize may be smaller than GetSize(); if so,
  /// the value is lsb-justified and sign-extended (for signed) or
  /// zero-filled (for unsigned).
  ///
  /// Succeeds if:
  /// - The pPropVal pointer is valid.
  /// - The pVal pointer is valid.
  /// - valSize indicates that pVal is large enough to hold the value.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pPropVal or pVal arg is NULL.
  ///
  /// AAFRESULT_BAD_SIZE
  ///   - valSize is larger than GetSize() for this typedef.
  /// 
  /// @param pPropVal [in] property value from which value is to be read
  /// @param pVal [in, size_is(valSize)] buffer from which value is read
  /// @param valSize [in] size of pVal buffer in bytes
  ///
  HRESULT SetInteger (
    [in] IAAFPropertyValue * pPropVal,
    [in, size_is(valSize)] aafMemPtr_t  pVal,
    [in] aafUInt32  valSize);


  //***********************************************************
  //
  // GetSize()
  //
  /// Returns the size of the integral value defined by this type
  /// definition. 
  ///
  /// Succeeds if:
  /// - The pSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSize arg is NULL.
  /// 
  /// @param pSize [out] the returned size of this integral value, in bytes
  ///
  HRESULT GetSize (
    [out] aafUInt32 *  pSize);


  //***********************************************************
  //
  // IsSigned()
  //
  /// Puts true in *pSigned if property values defined with this type
  /// def are signed; puts false there for unsigned property values.
  ///
  /// Succeeds if:
  /// - The pSigned pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSigned arg is NULL.
  /// 
  /// @param pSigned [out] set to true if this integer type is signed; set to false for
  /// unsigned
  ///
  HRESULT IsSigned (
    [out] aafBoolean_t *  pSigned);



}



// ************************
//
// Interface IAAFTypeDefObjectRef
//
// ************************
///
/// This interface is used to define Object references (either strong
/// or weak) used in AAF persistent objects.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// Objects that implement IAAFTypeDefObjectRef also implement the following interfaces:
///  - IAAFTypeDef
///  - IAAFMetaDefinition
[
    object,
    uuid(c3274644-9467-11d2-841f-00600832acb8),
    helpstring("IAAFTypeDefObjectRef Interface"),
    pointer_default(unique)
]
interface IAAFTypeDefObjectRef : IUnknown
{


  //***********************************************************
  //
  // GetObjectType()
  //
  /// Returns the class def representing objects to which this type def
  /// can refer.  The returned type def is the class definition of the
  /// least-derived type which is permissible to be represented.
  ///
  /// Succeeds if:
  /// - this object has been Initialize()d.
  /// - The ppObjType pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppObjType arg is NULL.
  /// 
  /// @param ppObjType [out] class def of objects permitted to be referenced
  ///
  HRESULT GetObjectType (
    [out] IAAFClassDef ** ppObjType);

  //***********************************************************
  //
  // CreateValue()
  //
  /// Creates a property value which contains an object reference.
  /// Initializes it to refer to the given object, and returns the
  /// newly-created property value in ppPropVal.
  ///
  /// Succeeds if:
  /// - The pObj pointer is valid.
  /// - The ppPropVal pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pObj or ppPropVal arg is NULL.
  /// 
  /// @param pObj [in] object with which to initialize this object reference
  /// @param ppPropVal [out] newly created property value
  ///
  HRESULT CreateValue (
    [in] IUnknown * pObj,
    [out] IAAFPropertyValue ** ppPropVal);

  //***********************************************************
  //
  // GetObject()
  //
  /// Returns the object contained in the named property value.
  /// Requires that pPropVal be a strong object reference or a weak
  /// object reference.
  ///
  /// Succeeds if:
  /// - The pPropVal pointer is valid.
  /// - The ppObject pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pPropVal or ppObject arg is NULL.
  /// 
  /// @param pPropVal [in] property value from which value is to be read
  /// @param iid [in] interface id of the required output
  /// @param ppObject [out, iid_is(iid)] pointer to object value
  ///
  HRESULT GetObject (
    [in] IAAFPropertyValue * pPropVal,
    [in] REFIID  iid,
    [out, iid_is(iid)] IUnknown ** ppObject);


  //***********************************************************
  //
  // SetObject()
  //
  /// Sets the named property value to refer to the named object.
  /// Requires that pPropVal be a strong object reference or a weak
  /// object reference.
  ///
  /// Succeeds if:
  /// - The pPropVal pointer is valid.
  /// - The ppObject pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pPropVal or ppObject arg is NULL.
  /// 
  /// @param pPropVal [in] property value from which value is to be read
  /// @param pObject [in] pointer to object value
  ///
  HRESULT SetObject (
    [in] IAAFPropertyValue * pPropVal,
    [in] IUnknown * pObject);



}



// ************************
//
// Interface IAAFTypeDefOpaque
//
// ************************
///
/// This interface is used to define Integer types used in AAF persistent
/// objects.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// Objects that implement IAAFTypeDefOpaque also implement the following interfaces:
///  - IAAFTypeDefIndirect
///  - IAAFTypeDef
///  - IAAFMetaDefinition
[
    object,
    uuid(FE717CAC-F04C-11d3-800B-00104BC9156D),
    helpstring("IAAFTypeDefOpaque Interface"),
    pointer_default(unique)
]
interface IAAFTypeDefOpaque : IUnknown
{


  //***********************************************************
  //
  // GetActualTypeID()
  //
  /// Return the type id of the  actual data within the opaque property value.
  ///
  ///
  /// Succeeds if all of the following are true:
  /// - the pOpaquePropertyValue pointer is valid.
  /// - the pActualType pointer is valid.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pOpaquePropertyValue or pActualTypeID arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - the type of pOpaquePropertyValue was not opaque. 
  ///
  /// 
  /// @param pOpaquePropertyValue [in] indirect property value to read
  /// @param pActualTypeID [out] the type id of the actual data
  ///
  HRESULT GetActualTypeID (
    [in] IAAFPropertyValue * pOpaquePropertyValue,
    [out] aafUID_t *  pActualTypeID);

  //***********************************************************
  //
  // GetHandle()
  //
  /// Used to read and save an unknown property without having to know its contents.
  /// This call fills in a handle to a block of data which can be saved in you application, and
  /// later written to another file using SetHandle().  Writes the data into the pHandle buffer. 
  /// The buffer is allocated by the caller, and the size of the buffer is given by
  /// handleSize.
  /// 
  /// Caller may call GetHandleBufLen() to determine the
  /// required buffer size.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pHandle pointer is valid.
  /// - handleSize indicates the buffer is large enough to hold the
  ///   name.
  /// 
  /// If this method fails nothing will be written to *pHandle.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pHandle arg is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - handleSize indicates the buffer is too small to hold the
  ///     handle.
  /// 
  /// @param pPropVal [in] value to get data from.
  /// @param handleSize [in] Size of preallocated buffer
  /// @param pHandle [out, size_is(handleSize),length_is(*bytesRead)] Preallocated buffer to hold handle
  /// @param bytesRead [out] Number of actual bytes read
  ///
  HRESULT GetHandle (
    [in] IAAFPropertyValue * pPropVal,
    [in] aafUInt32  handleSize,
    [out, size_is(handleSize),length_is(*bytesRead)] aafDataBuffer_t  pHandle,
    [out] aafUInt32*  bytesRead);


  //***********************************************************
  //
  // GetHandleBufLen()
  //
  /// Returns the length of buffer required for the GetHandle()
  /// method.  The handle is placed into the location specified by
  /// pLen.
  ///
  /// Succeeds if all of the following are true:
  /// - the pLen pointer is valid.
  ///
  /// If this method fails nothing will be written to *pLen.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLen arg is NULL.
  /// 
  /// @param pPropVal [in] value to set.
  /// @param pLen [out] Pointer to an variable used to return the length
  ///
  HRESULT GetHandleBufLen (
    [in] IAAFPropertyValue * pPropVal,
    [out] aafUInt32 *  pLen);

  //***********************************************************
  //
  // SetHandle()
  //
  /// This call takes a block of unknown data created by a previous call to GetHandle()
  /// and saved in you application, and sets an opaque property value.
  ///
  /// Succeeds if all of the following are true:
  /// - the pHandle pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pHandle is null.
  /// 
  /// @param pPropVal [in] value to write data to.
  /// @param handleSize [in] Size of preallocated buffer
  /// @param pHandle [in, size_is(handleSize)] buffer containing handle
  ///
  HRESULT SetHandle (
    [in] IAAFPropertyValue * pPropVal,
    [in] aafUInt32  handleSize,
    [in, size_is(handleSize)] aafDataBuffer_t  pHandle);

  //***********************************************************
  //
  // CreateValueFromHandle()
  //
  /// This call takes a block of unknown data created by GetHandle()
  /// and saved in you application, and creates an opaque property value.
  /// Returns the newly-created property value in ppOpaquePropertyValue.
  ///
  /// Succeeds if all of the following are true:
  /// - the pInitData pointer is valid.
  /// - the ppOpaquePropertyValue pointer is valid.
  /// - initDataSize indicates pInitData is the correct size for 
  ///   the actual type.
  /// - compile-time struct has had its member offests registered.
  ///
  /// If this method fails nothing will be written to *ppOpaquePropertyValue.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pInitData or ppOpaquePropertyValue arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - initDataSize indicates pInitData is of the wrong size.
  /// 
  /// @param pInitData [in, size_is(initDataSize)] pointer to buffer containing handle to use
  /// @param initDataSize [in] size of handle in pInitData
  /// @param ppOpaquePropertyValue [out] newly created property value
  ///
  HRESULT CreateValueFromHandle (
    [in, size_is(initDataSize)] aafMemPtr_t  pInitData,
    [in] aafUInt32  initDataSize,
    [out] IAAFPropertyValue ** ppOpaquePropertyValue);



}



// ************************
//
// Interface IAAFTypeDefRecord
//
// ************************
///
/// This interface is used to define C-like structured types used in
/// AAF persistent objects.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// Objects that implement IAAFTypeDefRecord also implement the following interfaces:
///  - IAAFTypeDef
///  - IAAFMetaDefinition
[
    object,
    uuid(809c8ca6-9884-11d2-841f-00600832acb8),
    helpstring("IAAFTypeDefRecord Interface"),
    pointer_default(unique)
]
interface IAAFTypeDefRecord : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes this type def to be identified by the given guid, and
  /// to contain the given members (types and names).  It is considered
  /// an error if multiple members have the same name.  Note that it is
  /// only possible to use certain types as member types.  Those
  /// permissible types include:
  /// - AAFTypeDefInt
  /// - AAFTypeDefRecord
  /// - AAFTypeDefEnum
  /// - AAFTypeDefExtEnum
  /// - AAFTypeDefFixedArray
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  /// - pID is a valid pointer.
  /// - pMemberTypes is a valid pointer.
  /// - pMemberNames is a valid pointer.
  /// - pTypeName is a valid pointer.
  /// - all specified member types are permissible for use in a Record.
  /// - all member names are unique.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - This object has already had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMemberTypes, pMemberNames, or pTypeName arg is NULL.
  ///
  /// AAFRESULT_BAD_TYPE
  ///   - an illegal member type was given.
  ///
  /// AAFRESULT_DUPLICATE
  ///   - a duplicate member name was given.
  /// 
  /// @param id [in, ref] auid to be used to identify this type
  /// @param ppMemberTypes [in, size_is(numMembers)] array of member types to be represented in this record
  /// type
  /// @param pMemberNames [in, size_is(numMembers)] array of member names to be represented in this enumerated
  /// type
  /// @param numMembers [in] number of members in pMemberInfo array
  /// @param pTypeName [in] friendly name of this type definition
  ///
  HRESULT Initialize (
    [in, ref] aafUID_constref  id,
    [in, size_is(numMembers)] IAAFTypeDef ** ppMemberTypes,
    [in, size_is(numMembers)] aafString_t *  pMemberNames,
    [in] aafUInt32  numMembers,
    [in] aafCharacter_constptr  pTypeName);


  //***********************************************************
  //
  // GetMemberType()
  //
  /// Returns the type definition of the indexed member in this
  /// record type.  Index is zero-based, and must be less than the
  /// value returned by GetCount().
  /// 
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - the index exists in this record type def.
  /// - The ppTypeDef pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTypeDef arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - The given index is out of range for this record type def.
  /// 
  /// @param index [in] zero-based index into members in this record type
  /// @param ppTypeDef [out] type definition of indexed member
  ///
  HRESULT GetMemberType (
    [in] aafUInt32  index,
    [out] IAAFTypeDef ** ppTypeDef);


  //***********************************************************
  //
  // GetMemberName()
  //
  /// Writes the human-legible tag associated with the indexed member
  /// in this record type.  Index is zero-based, and must be less
  /// than the value returned by GetCount().  The name is written,
  /// with a trailing null character, into the pName buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.
  /// 
  /// Caller may call GetMemberNameBufLen() to determine the required
  /// buffer size.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pName pointer is valid.
  /// - bufSize indicates the buffer is large enough to hold the name.
  /// 
  /// If this method fails nothing will be written to
  /// *pName.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  /// 
  /// AAFRESULT_SMALLBUF
  ///   - bufSize indicates the buffer is too small to hold the string.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - the given integer value is not associated with a member of
  ///     this type.
  /// 
  /// @param index [in] zero-based index into members in this record type
  /// @param pName [out, size_is(bufSize), string] buffer into which the member name is written
  /// @param bufSize [in] The size of the pName buffer, in bytes
  ///
  HRESULT GetMemberName (
    [in] aafUInt32  index,
    [out, size_is(bufSize), string] aafCharacter *  pName,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetMemberNameBufLen()
  //
  /// Returns the length of buffer required for the GetMemberName()
  /// method.  Index is zero-based, and must be less than the value
  /// returned by GetCount().  The value is placed into the location
  /// specified by pLen. The value will include space required for the
  /// trailing null character.
  ///
  /// Succeeds if all of the following are true:
  /// - the pLen pointer is valid.
  /// - the integer value is associated with a member of this
  ///   enumerated type.
  ///
  /// If this method fails nothing will be written to *pLen.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLen arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - the given integer value is not associated with a member of
  ///     this type.
  /// 
  /// @param index [in] zero-based index into members in this record type
  /// @param pLen [out] required buffer length, in bytes
  ///
  HRESULT GetMemberNameBufLen (
    [in] aafUInt32  index,
    [out] aafUInt32 *  pLen);


  //***********************************************************
  //
  // CreateValueFromValues()
  //
  /// Creates a property value which contains a record type.  The
  /// record members in the property value are initialized to
  /// contain the given values, passed in the pMemberValues array.
  /// numMembers, which indicates the size of the pMemberValues array,
  /// must match the value returned by GetCount().  Returns the
  /// newly-created property value in ppPropVal.
  ///
  /// Succeeds if all of the following are true:
  /// - the pMemberValues pointer is valid.
  /// - the ppPropVal pointer is valid.
  /// - numMembers matches the number of members in this record.
  ///
  /// If this method fails nothing will be written to *ppPropVal.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pMemberValues or ppPropVal arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - numMembers does not match GetCount().
  /// 
  /// @param pMemberValues [in, size_is(numMembers)] array of property values for members of record value which
  /// is to be created.
  /// @param numMembers [in] size of pMemberValues array.
  /// @param ppPropVal [out] newly-created property value
  ///
  HRESULT CreateValueFromValues (
    [in, size_is(numMembers)] IAAFPropertyValue ** pMemberValues,
    [in] aafUInt32  numMembers,
    [out] IAAFPropertyValue ** ppPropVal);


  //***********************************************************
  //
  // CreateValueFromStruct()
  //
  /// Creates a property value which contains a record type.  The
  /// record members in the property value are initialized from data
  /// in a struct which is pointed to by pInitData.  Requires that the
  /// structure pointed to by pInitData has had its offsets registered
  /// with this type.  Returns the newly-created property value in
  /// ppPropVal.
  ///
  /// Succeeds if all of the following are true:
  /// - the pInitData pointer is valid.
  /// - the ppPropVal pointer is valid.
  /// - initDataSize indicates pInitData is the correct size.
  /// - compile-time struct has had its member offests registered.
  ///
  /// If this method fails nothing will be written to *ppPropVal.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pInitData or ppPropVal arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - initDataSize indicates pInitData is of the wrong size.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for this typedef.
  /// 
  /// @param pInitData [in, size_is(initDataSize)] pointer to compile-time struct containing data to use
  /// @param initDataSize [in] size of data in pInitData
  /// @param ppPropVal [out] newly created property value
  ///
  HRESULT CreateValueFromStruct (
    [in, size_is(initDataSize)] aafMemPtr_t  pInitData,
    [in] aafUInt32  initDataSize,
    [out] IAAFPropertyValue ** ppPropVal);


  //***********************************************************
  //
  // GetValue()
  //
  /// Gets a single property value corresponding to the indicated
  /// record member.  Places a property value representing the
  /// record member identified by the index into ppOutPropval.
  /// Index is zero-based, and must be less than the value returned by
  /// GetCount().
  /// 
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - the index exists in this record type def.
  /// - The pInPropVal pointer is valid.
  /// - The ppOutPropVal pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pInPropVal or ppOutPropVal arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - The given index is out of range for this record type def.
  /// 
  /// @param pInPropVal [in] property value to read
  /// @param index [in] zero-based index into members in this record type
  /// @param ppOutPropVal [out] value that is read
  ///
  HRESULT GetValue (
    [in] IAAFPropertyValue * pInPropVal,
    [in] aafUInt32  index,
    [out] IAAFPropertyValue ** ppOutPropVal);


  //***********************************************************
  //
  // GetStruct()
  //
  /// Copies all the member data contained in the given property value,
  /// interpreted as a record of this type, into the struct pointed
  /// to by pData.  Requires that the struct pointed to by pData has
  /// had its offsets registered with this type.
  ///
  /// Succeeds if all of the following are true:
  /// - the pPropVal pointer is valid.
  /// - the pData pointer is valid.
  /// - dataSize indicates pData is large enough to hold the data.
  /// - compile-time struct has had its member offests registered.
  ///
  /// If this method fails nothing will be written to *ppPropVal.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pPropVal or pData arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - dataSize indicates pData is too small.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for this typedef.
  /// 
  /// @param pPropVal [in] property value to read
  /// @param pData [out, size_is(dataSize)] buffer into which struct data should be written
  /// @param dataSize [in] size of pData buffer in bytes
  ///
  HRESULT GetStruct (
    [in] IAAFPropertyValue * pPropVal,
    [out, size_is(dataSize)] aafMemPtr_t  pData,
    [in] aafUInt32  dataSize);


  //***********************************************************
  //
  // SetValue()
  //
  /// Sets the value of the single, indicated record member of the
  /// record contained in pPropVal, to the value contained in
  /// pMemberPropVal.  Index is zero-based, and must be less than the
  /// value returned by GetCount().
  /// 
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - the index exists in this record type def.
  /// - The pInPropVal pointer is valid.
  /// - The ppOutPropVal pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pInPropVal or ppOutPropVal arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - The given index is out of range for this record type def.
  /// 
  /// @param pPropVal [in] property value to write
  /// @param index [in] zero-based index into members in this record type
  /// @param pMemberPropVal [in] value to be placed into this record
  ///
  HRESULT SetValue (
    [in] IAAFPropertyValue * pPropVal,
    [in] aafUInt32  index,
    [in] IAAFPropertyValue * pMemberPropVal);


  //***********************************************************
  //
  // SetStruct()
  //
  /// Copies all the member data contained in the struct pointed to by
  /// pData into the given property value, interpreting the data as a record of
  /// this type.  Requires that the struct pointed to by pData has had
  /// its offsets registered with this type.
  ///
  /// Succeeds if all of the following are true:
  /// - the pPropVal pointer is valid.
  /// - the pData pointer is valid.
  /// - dataSize indicates pData contains the correct amount of data.
  /// - compile-time struct has had its member offests registered.
  ///
  /// If this method fails nothing will be written to *ppPropVal.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pPropVal or pData arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - dataSize indicates pData is not the correct size.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for this typedef.
  /// 
  /// @param pPropVal [in] property value to write
  /// @param pData [in, size_is(dataSize)] buffer from which struct data should be read
  /// @param dataSize [in] size of pData buffer in bytes
  ///
  HRESULT SetStruct (
    [in] IAAFPropertyValue * pPropVal,
    [in, size_is(dataSize)] aafMemPtr_t  pData,
    [in] aafUInt32  dataSize);


  //***********************************************************
  //
  // GetCount()
  //
  /// Returns number of members in this record type.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pCount is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCount arg is NULL.
  /// 
  /// @param pCount [out] count of members in this record type
  ///
  HRESULT GetCount (
    [out] aafUInt32 *  pCount);


  //***********************************************************
  //
  // RegisterMembers()
  //
  /// Allows client to register to the reference implementation a
  /// runtime C struct to represent objects of this TypeDef.  Offsets
  /// for each member in the struct are passed in as an array of
  /// integers; size indicates the number of members in the array.
  /// The offset is given in bytes from the start address of the
  /// struct.  This allows the reference implementation to write
  /// property values into compile-time-defined C structs intelligible
  /// by the local machine and compiler.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pOffsets is a valid pointer.
  /// - numMembers matches the number of members defined for this
  ///   record type.
  /// - all types of the fields in this record already have their
  ///   offsets registered.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pOffsets arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - numMembers does not match number of members in this record
  ///     type.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///   - The type of any field in this record has not yet had its
  ///     offsets registered.
  ///
  /// AAFRESULT_DEFAULT_ALREADY_USED
  ///   - The default registration for this type has already been used
  ///     to persist or unpersist a property containing this type.
  /// 
  /// @param pOffsets [in] array containing offset for each record member
  /// @param numMembers [in] number of members in pOffsets
  /// @param structSize [in] size of this struct
  ///
  HRESULT RegisterMembers (
    [in] aafUInt32 *  pOffsets,
    [in] aafUInt32  numMembers,
    [in] aafUInt32  structSize);
}



// ************************
//
// Interface IAAFTypeDefRename
//
// ************************
///
/// This interface is used to define Renamed types (analogous to C
/// typedefs) used in AAF persistent objects.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
///
/// Objects that implement IAAFTypeDefRename also implement the following interfaces:
///  - IAAFTypeDef
///  - IAAFMetaDefinition
[
    object,
    uuid(307e9e6a-dcb2-11d2-8429-00600832acb8),
    helpstring("IAAFTypeDefRename Interface"),
    pointer_default(unique)
]
interface IAAFTypeDefRename : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes this type def to be an alias for the given type
  /// (similar to a C typedef).
  /// 
  /// This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  /// - pBaseType is a valid pointer.
  /// - pTypeName is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// AAFRESULT_NULL_PARAM
  ///   - pBaseType or pTypeName is null.
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  /// 
  /// @param id [in, ref] auid to be used to identify this type
  /// @param pBaseType [in] type to which this is an alias
  /// @param pTypeName [in, string] friendly name of this type definition
  ///
  HRESULT Initialize (
    [in, ref] aafUID_constref  id,
    [in] IAAFTypeDef * pBaseType,
    [in, string] aafCharacter_constptr  pTypeName);


  //***********************************************************
  //
  // GetBaseType()
  //
  /// Returns the type definition to which this type def is an alias.
  ///
  /// Succeeds if:
  /// - this object has been Initialize()d.
  /// - The ppBaseType pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppBaseType pointer is NULL.
  /// 
  /// @param ppBaseType [out] type definition for which this is an alias
  ///
  HRESULT GetBaseType (
    [out] IAAFTypeDef ** ppBaseType);


  //***********************************************************
  //
  // GetBaseValue()
  //
  /// Gets the property value of the base type from the given property
  /// value of the typedef type and places a pointer to the base type's
  /// property value into *ppOutPropVal.
  ///
  /// Succeeds if:
  /// - The pInPropVal pointer is valid.
  /// - The ppOutPropVal pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pInPropVal or ppOutPropVal is NULL.
  /// 
  /// @param pInPropVal [in] property value from which value is to be read
  /// @param ppOutPropVal [out] pointer to property value represented by base type
  ///
  HRESULT GetBaseValue (
    [in] IAAFPropertyValue * pInPropVal,
    [out] IAAFPropertyValue ** ppOutPropVal);

  //***********************************************************
  //
  // CreateValue()
  //
  /// Gets the property value of the typedef type from the given property
  /// value of the base type and places a pointer to the base type's
  /// property value into *ppOutPropVal.
  ///
  /// Succeeds if:
  /// - The pInPropVal pointer is valid.
  /// - The ppOutPropVal pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pInPropVal or ppOutPropVal is NULL.
  /// 
  /// @param pInPropVal [in] property value from which value is to be read
  /// @param ppOutPropVal [out] pointer to property value represented by rename type
  ///
  HRESULT CreateValue (
    [in] IAAFPropertyValue * pInPropVal,
    [out] IAAFPropertyValue ** ppOutPropVal);


}



// ************************
//
// Interface IAAFTypeDefSet
//
// ************************
///
/// This interface is used to define variably-sized set types used in
/// AAF persistent objects.
///
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// Objects that implement IAAFTypeDefSet also implement the following interfaces:
///  - IAAFTypeDef
///  - IAAFMetaDefinition
[
    object,
    uuid(381e1f22-e7bb-11d2-842a-00600832acb8),
    helpstring("IAAFTypeDefSet Interface"),
    pointer_default(unique)
]
interface IAAFTypeDefSet : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes this type def to contain elements of the given type.
  ///
  /// This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  /// - pTypeName is a valid pointer.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - This object has already had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTypeName arg is NULL.
  /// 
  /// @param id [in] auid to be used to identify this type
  /// @param pTypeDef [in] type of each element to be contained in this set
  /// @param pTypeName [in,string] friendly name of this type definition
  ///
  HRESULT Initialize (
    [in] aafUID_constref  id,
    [in] IAAFTypeDef * pTypeDef,
    [in,string] aafCharacter_constptr  pTypeName);

  //***********************************************************
  //
  // GetElementType()
  //
  /// Returns the type of elements in this set.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - ppTypeDef is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTypeDef arg is NULL.
  /// 
  /// @param ppTypeDef [out] type of elements in this array
  ///
  HRESULT GetElementType (
    [out] IAAFTypeDef ** ppTypeDef);

  //***********************************************************
  //
  // AddElement()
  //
  /// Adds an element to the set, setting it to the
  /// value given in pElementPropertyValue.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pSetPropertyValue pointer is valid.
  /// - pElementPropertyValue pointer is valid.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pSetPropertyValue or pElementPropertyValue arg is NULL.
  /// 
  /// @param pSetPropertyValue [in] property value corresponding to set to which element is added
  /// @param pElementPropertyValue [in] value to be added to this set
  ///
  HRESULT AddElement (
    [in] IAAFPropertyValue * pSetPropertyValue,
    [in] IAAFPropertyValue * pElementPropertyValue);

  //***********************************************************
  //
  // RemoveElement()
  //
  /// Removes an element from the set.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pSetPropertyValue pointer is valid.
  /// - pElementPropertyValue pointer is valid.
  /// - The given element was in the set.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pSetPropertyValue or pElementPropertyValue arg is NULL.
  /// 
  /// @param pSetPropertyValue [in] property value corresponding to set from which element is removed
  /// @param pElementPropertyValue [in] value to be removed from this set
  ///
  HRESULT RemoveElement (
    [in] IAAFPropertyValue * pSetPropertyValue,
    [in] IAAFPropertyValue * pElementPropertyValue);

  //***********************************************************
  //
  // ContainsElement()
  //
  /// Tests if an element is in the set.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pSetPropertyValue pointer is valid.
  /// - pElementPropertyValue pointer is valid.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pSetPropertyValue or pElementPropertyValue arg is NULL.
  /// 
  /// @param pSetPropertyValue [in] property value corresponding to set to which element is added
  /// @param pElementPropertyValue [in] value whose presence is being tested in this set
  /// @param pContainsElement [out] value to be added to this set
  ///
  HRESULT ContainsElement (
    [in] IAAFPropertyValue * pSetPropertyValue,
    [in] IAAFPropertyValue * pElementPropertyValue,
    [out] aafBoolean_t*  pContainsElement);



  //***********************************************************
  //
  // GetCount()
  //
  /// Returns number of elements in the referenced property value.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pSetPropertyValue is a valid pointer.
  /// - pCount is a valid pointer.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pSetPropertyValue or pCount arg is NULL.
  /// 
  /// @param pSetPropertyValue [in] property value of array
  /// @param pCount [out] count of elements in the specified set property value
  ///
  HRESULT GetCount (
    [in] IAAFPropertyValue * pSetPropertyValue,
    [out] aafUInt32 *  pCount);


  //***********************************************************
  //
  // CreateKey()
  //
  /// Returns number of elements in the referenced property value.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pSetPropertyValue is a valid pointer.
  /// - pCount is a valid pointer.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pSetPropertyValue or pCount arg is NULL.
  /// 
  /// @param pKeyPtr [in,size_is(length)] Pointer to the key value bytes
  /// @param length [in] The size of the key in bytes
  /// @param ppKey [out] An interface which may be passed to LookupElement() or ContainsKey()
  ///
  HRESULT CreateKey (
    [in,size_is(length)] aafDataBuffer_t  pKeyPtr,
    [in] aafUInt32  length,
    [out] IAAFPropertyValue ** ppKey);


  //***********************************************************
  //
  // LookupElement()
  //
  /// Looks up the given key (created by CreateKey()) and returns the propertyValue
  /// of the entry, or an error if the entry is not present.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pSetPropertyValue is a valid pointer.
  /// - pCount is a valid pointer.
  /// - An entry with the correct key is present in the set.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pSetPropertyValue or pSetPropertyValue or ppElementPropertyValue arg is NULL.
  /// 
  /// @param pSetPropertyValue [in] property value of set
  /// @param pKey [in] A key returned from CreateKey()
  /// @param ppElementPropertyValue [out] The returned property value
  ///
  HRESULT LookupElement (
    [in] IAAFPropertyValue * pSetPropertyValue,
    [in] IAAFPropertyValue * pKey,
    [out] IAAFPropertyValue ** ppElementPropertyValue);

  //***********************************************************
  //
  // ContainsKey()
  //
  /// Looks up the given key (created by CreateKey()) and returns AAFTrue if the entry
  /// is present, or AAFFalse if the entry is not present.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pSetPropertyValue is a valid pointer.
  /// - pCount is a valid pointer.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pSetPropertyValue or pContainsKey arg is NULL.
  /// 
  /// @param pSetPropertyValue [in] property value of set
  /// @param pKey [in] A key returned from CreateKey()
  /// @param pContainsKey [out] Value returned is AAFTrue if an entry with the correct key is present
  ///
  HRESULT ContainsKey (
    [in] IAAFPropertyValue * pSetPropertyValue,
    [in] IAAFPropertyValue * pKey,
    [out] aafBoolean_t*  pContainsKey);


  //***********************************************************
  //
  // GetElements()
  //
  /// Returns an enumerator across elements in this set.
  /// 
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - The pSetPropertyValue pointer is valid.
  /// - The ppEnum pointer is valid.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pSetPropertyValue or ppEnum arg is NULL.
  /// 
  /// @param pSetPropertyValue [in] property value to read
  /// @param ppEnum [out] enumerator across property values
  ///
  HRESULT GetElements (
    [in] IAAFPropertyValue * pSetPropertyValue,
    [out] IEnumAAFPropertyValues ** ppEnum);


}



// ************************
//
// Interface IAAFTypeDefStream
//
// ************************
///
/// AAFTypeDefStream is DEPRECATED, please use AAFTypeDefStream3
///
/// This interface is used to define Stream types used in AAF
/// persistent objects.  Streams are conceptually similar to
/// variably-sized arrays except that they are intended to be used for
/// very large pieces of data (such as essence).
/// Note: All reads/and writes advance the current position.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// Objects that implement IAAFTypeDefStream also implement the following interfaces:
///  - IAAFTypeDef
///  - IAAFMetaDefinition
[
    object,
    uuid(307e9e6e-dcb2-11d2-8429-00600832acb8),
    helpstring("IAAFTypeDefStream Interface"),
    pointer_default(unique)
]
interface IAAFTypeDefStream : IUnknown
{

  //***********************************************************
  //
  // GetSize()
  //
  /// Returns number of bytes contained in the referenced property
  /// value.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  /// - pSize is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pStreamPropertyValue or pSize arg is NULL.
  /// 
  /// @param pStreamPropertyValue [in] stream property value
  /// @param pSize [out] count of bytes in the specified stream property value
  ///
  HRESULT GetSize (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [out] aafInt64 *  pSize);

  //***********************************************************
  //
  // SetSize()
  //
  /// Set the number of bytes contained in the give stream property value
  /// to newElementCount
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - If pStreamPropertyValue arg is NULL.
  /// 
  /// @param pStreamPropertyValue [in] stream property value
  /// @param newSize [in] new count of bytes in the specified stream property value
  ///
  HRESULT SetSize (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [in] aafInt64  newSize);

  //***********************************************************
  //
  // GetPosition()
  //
  /// Returns the byte position of the current element in the stream. 
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  /// - pPosition is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pStreamPropertyValue or pPosition arg is NULL.
  /// 
  /// @param pStreamPropertyValue [in] stream property value
  /// @param pPosition [out] current byte position in the specified stream property value
  ///
  HRESULT GetPosition (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [out] aafInt64 *  pPosition);

  //***********************************************************
  //
  // SetPosition()
  //
  /// Make the current byte position to the one at newPosition in the stream 
  /// property value. 
  ///
  /// Succeeds if:
  /// - pStreamPropertyValue is a valid pointer.
  /// - the new position is valid
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - If pStreamPropertyValue arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - newPosition is outside the bounds of the stream.
  /// 
  /// @param pStreamPropertyValue [in] stream property value
  /// @param newPosition [in] the new position in the specified stream property value
  ///
  HRESULT SetPosition (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [in] aafInt64  newPosition);


  //***********************************************************
  //
  // Read()
  //
  /// Sequential access.
  /// Copies the data at the position of the stream to the given
  /// buffer.
  ///
  /// Succeeds if all of the following are true:
  /// - the pStreamPropertyValue pointer is valid.
  /// - the pData pointer is valid.
  /// - the indicated bytes exist in the stream.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pStreamPropertyValue or pData arg is NULL.
  /// 
  /// @param pStreamPropertyValue [in] stream property value to read
  /// @param dataSize [in] number of bytes to read
  /// @param pData [out, size_is(dataSize), length_is(*bytesRead)] buffer into which one element from the stream should be written
  /// @param bytesRead [out,ref] number of bytes actually read (will be either dataSize or 0 if there 
  /// is in error)
  ///
  HRESULT Read (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [in] aafUInt32  dataSize,
    [out, size_is(dataSize), length_is(*bytesRead)] aafMemPtr_t  pData,
    [out,ref] aafUInt32 *  bytesRead);

  //***********************************************************
  //
  // Write()
  //
  /// Sequential access.
  /// Copies the data in the given buffer into the stream at the 
  /// current position of the stream..
  ///
  /// Succeeds if all of the following are true:
  /// - the pStreamPropertyValue pointer is valid.
  /// - the pData pointer is valid.
  /// - the indicated bytes could be written to the stream.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pStreamPropertyValue or pData arg is NULL.
  /// 
  /// @param pStreamPropertyValue [in] stream property value to modify
  /// @param dataSize [in] number of bytes to write
  /// @param pData [in, ref, size_is(dataSize)] buffer into which should contain one element to be written to the stream
  ///
  HRESULT Write (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [in] aafUInt32  dataSize,
    [in, ref, size_is(dataSize)] aafMemPtr_t  pData);

  //***********************************************************
  //
  // Append()
  //
  /// Extending the stream.
  /// Copies the data in the given buffer into the stream at the 
  /// end of the stream.
  ///
  /// Succeeds if all of the following are true:
  /// - the pStreamPropertyValue pointer is valid.
  /// - the pData pointer is valid.
  /// - the indicated bytes could be appended to the stream.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pStreamPropertyValue or pData arg is NULL.
  /// 
  /// @param pStreamPropertyValue [in] stream property value to modify
  /// @param dataSize [in] number of bytes to write (must be equal to the element type length)
  /// @param pData [in, ref, size_is(dataSize)] buffer into which should contain one element to be written to the stream
  ///
  HRESULT Append (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [in] aafUInt32  dataSize,
    [in, ref, size_is(dataSize)] aafMemPtr_t  pData);


  //***********************************************************
  //
  // HasStoredByteOrder()
  //
  /// Returns kAAFTrue if the stream has a stored byte order or 
  /// kAAFFalse otherwise.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  /// - pHasByteOrder is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pStreamPropertyValue or pHasByteOrder arg is NULL.
  /// 
  /// @param pStreamPropertyValue [in] stream property value
  /// @param pHasByteOrder [out] kAAFTrue if this stream has a stored byte order
  ///
  HRESULT HasStoredByteOrder (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [out] aafBoolean_t *  pHasByteOrder);

  //***********************************************************
  //
  // GetStoredByteOrder()
  //
  /// Access byte order of the stream.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  /// - pByteOrder is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pStreamPropertyValue or pByteOrder arg is NULL.
  /// 
  /// @param pStreamPropertyValue [in] stream property value
  /// @param pByteOrder [out] Pointer to variable where byte order is to be copied
  ///
  HRESULT GetStoredByteOrder (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [out] eAAFByteOrder_t *  pByteOrder);

  //***********************************************************
  //
  // SetStoredByteOrder()
  //
  /// Sets the byte order to be associated with this stream. Note: the stream
  /// must be empty.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  /// - stream is empty.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - If pStreamPropertyValue arg is NULL.
  /// 
  /// @param pStreamPropertyValue [in] stream property value
  /// @param byteOrder [in] byte order is to be stored with the stream
  ///
  HRESULT SetStoredByteOrder (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [in] eAAFByteOrder_t  byteOrder);

  //***********************************************************
  //
  // ClearStoredByteOrder()
  //
  /// Clears the byte order to be associated with this stream. Note: the stream
  /// must be empty.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  /// - stream is empty.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - If pStreamPropertyValue arg is NULL.
  /// 
  /// @param pStreamPropertyValue [in] stream property value
  ///
  HRESULT ClearStoredByteOrder (
    [in] IAAFPropertyValue * pStreamPropertyValue);

  //***********************************************************
  //
  // ReadElements()
  //
  /// Access in typed chunks of Elements.
  /// Copies the data at the current position of the stream to the given
  /// buffer. Requires that any structures declared within element 
  /// typedef have had their offsets registered with that type.
  ///
  /// Succeeds if all of the following are true:
  /// - the pStreamPropertyValue pointer is valid.
  /// - the pElementType pointer is valid.
  /// - the pData pointer is valid.
  /// - dataSize indicates pData is large enough to hold the data.
  /// - compile-time struct has had its member offests registered.
  /// - the indicated elements exist in this stream type def.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pStreamPropertyValue or pElementType or pBytesRead or pData arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - dataSize indicates pData is too small.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for element typedef.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - there are not dataSize bytes left in the stream.
  /// 
  /// @param pStreamPropertyValue [in] stream property value to read
  /// @param pElementType [in] the type definition of the elements to read
  /// @param dataSize [in] number of bytes to read (must be evenly divisible by the element 
  /// type length)
  /// @param pData [out, size_is(dataSize), length_is(*pBytesRead)] buffer into which elements from the stream should be written
  /// @param pBytesRead [out,ref] number of bytes actually read (will be either dataSize or 0 if 
  /// there is in error)
  ///
  HRESULT ReadElements (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [in] IAAFTypeDef * pElementType,
    [in] aafUInt32  dataSize,
    [out, size_is(dataSize), length_is(*pBytesRead)] aafMemPtr_t  pData,
    [out,ref] aafUInt32 *  pBytesRead);

  //***********************************************************
  //
  // WriteElements()
  //
  /// Access in typed chunks of Elements.
  /// Copies the data in the given buffer into the stream at the  
  /// current position of the stream. Requires that any structures 
  /// declared within element 
  /// typedef have had their offsets registered with that type..
  ///
  /// Succeeds if all of the following are true:
  /// - the pStreamPropertyValue pointer is valid.
  /// - the pElementType pointer is valid.
  /// - the pData pointer is valid.
  /// - dataSize indicates pData is large enough to hold the data.
  /// - compile-time struct has had its member offests registered.
  /// - the indicated elements exist in this stream type def.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pStreamPropertyValue or pElementType or pData arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - dataSize indicates pData is an even multiple of the given 
  ///     element type size.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for the element typedef.
  /// 
  /// @param pStreamPropertyValue [in] stream property value to modify
  /// @param pElementType [in] the type definition of the elements to read
  /// @param dataSize [in] number of bytes to write (must be evenly divisible by the element type 
  /// length)
  /// @param pData [in, ref, size_is(dataSize)] buffer into which elements from the stream should be written
  ///
  HRESULT WriteElements (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [in] IAAFTypeDef * pElementType,
    [in] aafUInt32  dataSize,
    [in, ref, size_is(dataSize)] aafMemPtr_t  pData);


cpp_quote("  /// Extend in chunks of typed Elements") 

  //***********************************************************
  //
  // AppendElements()
  //
  /// Access in typed chunks of Elements.
  /// Copies the data in the given buffer onto the end of the stream. 
  /// Requires that any structures declared within element 
  /// typedef have had their offsets registered with that type..
  ///
  /// Succeeds if all of the following are true:
  /// - the pStreamPropertyValue pointer is valid.
  /// - the pElementType pointer is valid.
  /// - the pData pointer is valid.
  /// - dataSize indicates pData is large enough to hold the data.
  /// - compile-time struct has had its member offests registered.
  /// - the indicated elements exist in this stream type def.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pStreamPropertyValue or pElementType or pData arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - dataSize indicates pData is an even multiple of the given 
  ///     element type size.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for the element typedef.
  /// 
  /// @param pStreamPropertyValue [in] stream property value to modify
  /// @param pElementType [in] the type definition of the elements to read
  /// @param dataSize [in] number of bytes to write (must be evenly divisible by the element type 
  /// length)
  /// @param pData [in, ref, size_is(dataSize)] buffer into which elements from the stream should be written
  ///
  HRESULT AppendElements (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [in] IAAFTypeDef * pElementType,
    [in] aafUInt32  dataSize,
    [in, ref, size_is(dataSize)] aafMemPtr_t  pData);




}


// ************************
//
// Interface IAAFTypeDefString
//
// ************************
///
/// This interface is used to define variably-sized Array types whose
/// length is determined by a special terminator element value.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// Objects that implement IAAFTypeDefString also implement the following interfaces:
///  - IAAFTypeDef
///  - IAAFMetaDefinition
[
    object,
    uuid(307e9e68-dcb2-11d2-8429-00600832acb8),
    helpstring("IAAFTypeDefString Interface"),
    pointer_default(unique)
]
interface IAAFTypeDefString : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes this type def to contain elements of the given type.
  /// Note that it is only possible to use certain types as the element
  /// type.  Those permissible types include:
  ///
  /// - AAFTypeDefInt
  ///
  /// This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  /// - pID is a valid pointer.
  /// - pTypeDef is a valid pointer.
  /// - pTypeName is a valid pointer.
  /// - element type is permissible for use in a String.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - This object has already had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pTypeDef or pTypeName arg is NULL.
  /// 
  /// @param id [in, ref] auid to be used to identify this type
  /// @param pTypeDef [in] type of each element to be contained in this array
  /// @param pTypeName [in] friendly name of this type definition
  ///
  HRESULT Initialize (
    [in, ref] aafUID_constref  id,
    [in] IAAFTypeDef * pTypeDef,
    [in] aafCharacter_constptr  pTypeName);


  //***********************************************************
  //
  // GetType()
  //
  /// Returns the type of elements in this string.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - ppTypeDef is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTypeDef arg is NULL.
  /// 
  /// @param ppTypeDef [out] type of elements in this array
  ///
  HRESULT GetType (
    [out] IAAFTypeDef ** ppTypeDef);


  //***********************************************************
  //
  // GetCount()
  //
  /// Returns number of elements contained in the referenced property
  /// value.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pPropVal is a valid pointer.
  /// - pCount is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pPropVal or pCount arg is NULL.
  /// 
  /// @param pPropVal [in] property value of array
  /// @param pCount [out] count of elements in the specified string property value
  ///
  HRESULT GetCount (
    [in] IAAFPropertyValue * pPropVal,
    [out] aafUInt32 *  pCount);


  //***********************************************************
  //
  // CreateValueFromCString()
  //
  /// Creates a property value which contains a string type.  The
  /// string in the property value are initialized from data in a C
  /// string which is pointed to by pInitData.  Returns the
  /// newly-created property value in ppPropVal.  The size of the
  /// newly-created string property value will be determined by the
  /// size of the initialization C array, as communicated by
  /// initDataSize.
  ///
  /// Succeeds if all of the following are true:
  /// - the pInitData pointer is valid.
  /// - the ppPropVal pointer is valid.
  ///
  /// If this method fails nothing will be written to *ppPropVal.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pInitData or ppPropVal arg is NULL.
  /// 
  /// @param pInitData [in, size_is(initDataSize)] pointer to compile-time C string containing data to use
  /// @param initDataSize [in] size of data in pInitData, in bytes
  /// @param ppPropVal [out] newly created property value
  ///
  HRESULT CreateValueFromCString (
    [in, size_is(initDataSize)] aafMemPtr_t  pInitData,
    [in] aafUInt32  initDataSize,
    [out] IAAFPropertyValue ** ppPropVal);


  //***********************************************************
  //
  // SetCString()
  //
  /// Copies all the string data contained in the C array pointed to by
  /// pData into the given property value, interpreting the data as a
  /// string of this type.  If dataSize indicates an array size
  /// different from the size currently in the indicated array property
  /// value, that array property value will be resized.
  ///
  /// Succeeds if all of the following are true:
  /// - the pPropVal pointer is valid.
  /// - the pData pointer is valid.
  ///
  /// If this method fails nothing will be written to *ppPropVal.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pPropVal or pData arg is NULL.
  /// 
  /// @param pPropVal [in] property value to write
  /// @param pData [in, size_is(dataSize)] buffer from which C string data should be read
  /// @param dataSize [in] size of pData buffer in bytes
  ///
  HRESULT SetCString (
    [in] IAAFPropertyValue * pPropVal,
    [in, size_is(dataSize)] aafMemPtr_t  pData,
    [in] aafUInt32  dataSize);


  //***********************************************************
  //
  // AppendElements()
  //
  /// Appends elements to the end of the array, setting them to the
  /// values given in the pElements array.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pInPropVal pointer is valid.
  /// - pElements pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pInPropVal or pElements arg is NULL.
  /// 
  /// @param pInPropVal [in] property value corresponding to string to which elements are to
  /// be appended
  /// @param pElements [in] Null-terminated array of elements to be appended
  ///
  HRESULT AppendElements (
    [in] IAAFPropertyValue * pInPropVal,
    [in] aafMemPtr_t  pElements);


  //***********************************************************
  //
  // GetElements()
  //
  /// Gets the value of this property as a string and places it into
  /// pBuffer.  bufferSize indicates the size of the buffer, in bytes.
  /// 
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - The pInPropVal pointer is valid.
  /// - bufferSize indicates that pBuffer is large enough to hold the
  ///   data.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pInPropVal arg is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - bufferSize indicates that pBuffer is too small to hold the
  ///     data.
  /// 
  /// @param pInPropVal [in] property value to read
  /// @param pBuffer [out] array of values that are read
  /// @param bufferSize [in] size of pBuffer, in bytes
  ///
  HRESULT GetElements (
    [in] IAAFPropertyValue * pInPropVal,
    [out] aafMemPtr_t  pBuffer,
    [in] aafUInt32  bufferSize);



}



// ************************
//
// Interface IAAFTypeDefStrongObjRef
//
// ************************
///
/// This interface is used to implement Strong Object references.
///
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// Objects that implement IAAFTypeDefStrongObjRef also implement the following interfaces:
///  - IAAFTypeDefObjectRef
///  - IAAFTypeDef
///  - IAAFMetaDefinition
[
    object,
    uuid(381e1f26-e7bb-11d2-842a-00600832acb8),
    helpstring("IAAFTypeDefStrongObjRef Interface"),
    pointer_default(unique)
]
interface IAAFTypeDefStrongObjRef : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes this type def to be a reference to objects of
  /// the given type, and assigns this object the given AUID.  pObjType
  /// points to the class definition of the least-derived class which
  /// is possible to be contained in property values of this type.
  /// 
  /// This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  /// - pObjType is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - This object has already had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pObjType or pTypeName arg is NULL.
  /// 
  /// @param id [in, ref] auid to be used to identify this type
  /// @param pObjType [in] class def of objects permitted to be referenced
  /// @param pTypeName [in, string] friendly name of this type definition
  ///
  HRESULT Initialize (
    [in, ref] aafUID_constref  id,
    [in] IAAFClassDef * pObjType,
    [in, string] aafCharacter_constptr  pTypeName);




}



// ************************
//
// Interface IAAFTypeDefVariableArray
//
// ************************
///
/// This interface is used to define variably-sized Array types used in
/// AAF persistent objects.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// Objects that implement IAAFTypeDefVariableArray also implement the following interfaces:
///  - IAAFTypeDefVariableArrayEx
///  - IAAFTypeDef
///  - IAAFMetaDefinition
[
    object,
    uuid(307e9e66-dcb2-11d2-8429-00600832acb8),
    helpstring("IAAFTypeDefVariableArray Interface"),
    pointer_default(unique)
]
interface IAAFTypeDefVariableArray : IUnknown
{
  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes this type def to contain elements of the given type.
  /// Note that it is only possible to use certain types as the element
  /// type.  Those permissible types include:
  /// - AAFTypeDefInt
  /// - AAFTypeDefRecord
  /// - AAFTypeDefEnum
  /// - AAFTypeDefExtEnum
  /// - AAFTypeDefFixedArray
  /// - AAFTypeDefObjectRef
  ///
  /// This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  /// - pID is a valid pointer.
  /// - pTypeDef is a valid pointer.
  /// - pTypeName is a valid pointer.
  /// - element type is permissible for use in a VariableArray.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - This object has already had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pTypeDef or pTypeName arg is NULL.
  ///
  /// AAFRESULT_BAD_TYPE
  ///   - an illegal element type was given.
  /// 
  /// @param id [in, ref] auid to be used to identify this type
  /// @param pTypeDef [in] type of each element to be contained in this array
  /// @param pTypeName [in] friendly name of this type definition
  ///
  HRESULT Initialize (
    [in, ref] aafUID_constref  id,
    [in] IAAFTypeDef * pTypeDef,
    [in] aafCharacter_constptr  pTypeName);


  //***********************************************************
  //
  // GetType()
  //
  /// Returns the type of elements in this array.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - ppTypeDef is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTypeDef arg is NULL.
  /// 
  /// @param ppTypeDef [out] type of elements in this array
  ///
  HRESULT GetType (
    [out] IAAFTypeDef ** ppTypeDef);


  //***********************************************************
  //
  // GetCount()
  //
  /// Returns number of array elements in the referenced property
  /// value.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pPropVal is a valid pointer.
  /// - pCount is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pPropVal or pCount arg is NULL.
  /// 
  /// @param pPropVal [in] property value of array
  /// @param pCount [out] count of elements in the specified array property value
  ///
  HRESULT GetCount (
    [in] IAAFPropertyValue * pPropVal,
    [out] aafUInt32 *  pCount);


  //***********************************************************
  //
  // AppendElement()
  //
  /// Appends an element to the end of the array, setting it to the
  /// value given in pMemberPropVal.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pInPropVal pointer is valid.
  /// - pMemberPropVal pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pInPropVal or pMemberPropVal arg is NULL.
  /// 
  /// @param pInPropVal [in] property value corresponding to array to which element is appended
  /// @param pMemberPropVal [in] value to be appended to this array
  ///
  HRESULT AppendElement (
    [in] IAAFPropertyValue * pInPropVal,
    [in] IAAFPropertyValue * pMemberPropVal);


  //***********************************************************
  //
  // CreateEmptyValue()
  //
  /// Creates an empty property value which contains a variable array
  /// type that initially is empty (that is, contains no elements
  /// yet).
  ///
  /// Succeeds if all of the following are true:
  /// - the ppPropVal pointer is valid.
  ///
  /// If this method fails nothing will be written to *ppPropVal.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppPropVal arg is NULL.
  /// 
  /// @param ppPropVal [out] newly-created empty property value
  ///
  HRESULT CreateEmptyValue (
    [out] IAAFPropertyValue ** ppPropVal);


  //***********************************************************
  //
  // CreateValueFromValues()
  //
  /// Creates a property value which contains a variable array type.
  /// The array elements in the property value are initialized to
  /// contain the given values, passed in the pElementValues array.
  /// numElements, which indicates the size of the pElementValues
  /// array, determines the size of the array in the new array
  /// property value.
  ///
  /// Succeeds if all of the following are true:
  /// - the pElementValues pointer is valid.
  /// - the ppPropVal pointer is valid.
  ///
  /// If this method fails nothing will be written to *ppPropVal.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pElementValues or ppPropVal arg is NULL.
  /// 
  /// @param pElementValues [in, size_is(numElements)] array of property values for elements of array value which
  /// is to be created.
  /// @param numElements [in] size of pElementValues array.
  /// @param ppPropVal [out] newly-created property value
  ///
  HRESULT CreateValueFromValues (
    [in, size_is(numElements)] IAAFPropertyValue ** pElementValues,
    [in] aafUInt32  numElements,
    [out] IAAFPropertyValue ** ppPropVal);


  //***********************************************************
  //
  // CreateValueFromCArray()
  //
  /// Creates a property value which contains a fixed array type.  The
  /// array elements in the property value are initialized from data in
  /// a C array which is pointed to by pInitData.  Requires that any
  /// structures declared within this array typedef have had their
  /// offsets registered with that type.  Returns the newly-created
  /// property value in ppPropVal.  The size of the newly-created array
  /// property value will be determined by the number of elements in
  /// the initialization C array, as communicated by initDataSize.
  ///
  /// Succeeds if all of the following are true:
  /// - the pInitData pointer is valid.
  /// - the ppPropVal pointer is valid.
  /// - compile-time struct has had its member offests registered.
  ///
  /// If this method fails nothing will be written to *ppPropVal.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pInitData or ppPropVal arg is NULL.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - any contained struct offsets have not yet been registered for
  ///    that typedef.
  /// 
  /// @param pInitData [in, size_is(initDataSize)] pointer to compile-time C array containing data to use
  /// @param initDataSize [in] size of data in pInitData, in bytes
  /// @param ppPropVal [out] newly created property value
  ///
  HRESULT CreateValueFromCArray (
    [in, size_is(initDataSize)] aafMemPtr_t  pInitData,
    [in] aafUInt32  initDataSize,
    [out] IAAFPropertyValue ** ppPropVal);


  //***********************************************************
  //
  // GetElementValue()
  //
  /// Gets a single property value corresponding to the indexed array
  /// element.  Places a property value representing the array element
  /// identified by the index into ppOutPropval.  Index is zero-based,
  /// and must be less than the value returned by GetCount().
  /// 
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - the index exists in this array type def.
  /// - The pInPropVal pointer is valid.
  /// - The ppOutPropVal pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pInPropVal or ppOutPropVal arg is NULL.
  ///
  /// AAFRESULT_BAD_PARAM
  ///   - The given index is out of range for this array type def.
  /// 
  /// @param pInPropVal [in] property value to read
  /// @param index [in] zero-based index into elements in this array type
  /// @param ppOutPropVal [out] value that is read
  ///
  HRESULT GetElementValue (
    [in] IAAFPropertyValue * pInPropVal,
    [in] aafUInt32  index,
    [out] IAAFPropertyValue ** ppOutPropVal);


  //***********************************************************
  //
  // GetCArray()
  //
  /// Copies all the array data contained in the given property value,
  /// interpreted as a fixed array of this type, into the C array
  /// pointed to by pData.  Requires that any structures declared
  /// within this array typedef have had their offsets registered with
  /// that type.
  ///
  /// Succeeds if all of the following are true:
  /// - the pPropVal pointer is valid.
  /// - the pData pointer is valid.
  /// - dataSize indicates pData is large enough to hold the data.
  /// - compile-time struct has had its member offests registered.
  ///
  /// If this method fails nothing will be written to *ppPropVal.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pPropVal or pData arg is NULL.
  ///
  /// AAFRESULT_BAD_PARAM
  ///   - dataSize indicates pData is too small.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for this typedef.
  /// 
  /// @param pPropVal [in] property value to read
  /// @param pData [out, size_is(dataSize)] buffer into which C array data should be written
  /// @param dataSize [in] size of pData buffer in bytes
  ///
  HRESULT GetCArray (
    [in] IAAFPropertyValue * pPropVal,
    [out, size_is(dataSize)] aafMemPtr_t  pData,
    [in] aafUInt32  dataSize);


  //***********************************************************
  //
  // SetElementValue()
  //
  /// Sets the value of the single, indicated element of the fixed
  /// array contained in pPropVal, to the value contained in
  /// pMemberPropVal.  Index is zero-based, and must be less than the
  /// value returned by GetCount().  Property value must be of the
  /// same type as returned by GetType().
  /// 
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - the index exists in this array type def.
  /// - The pInPropVal pointer is valid.
  /// - The ppOutPropVal pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pInPropVal or ppOutPropVal arg is NULL.
  ///
  /// AAFRESULT_BAD_PARAM
  ///   - The given index is out of range for this array type def.
  /// 
  /// @param pPropVal [in] property value to write
  /// @param index [in] zero-based index into members in this array type
  /// @param pMemberPropVal [in] value to be placed into this array
  ///
  HRESULT SetElementValue (
    [in] IAAFPropertyValue * pPropVal,
    [in] aafUInt32  index,
    [in] IAAFPropertyValue * pMemberPropVal);


  //***********************************************************
  //
  // SetCArray()
  //
  /// Copies all the array data contained in the C array pointed to by
  /// pData into the given property value, interpreting the data as a
  /// fixed array of this type.  Requires that any structures declared
  /// within this typedef have had their offsets registered with that
  /// type.  If dataSize indicates an array size different from the
  /// size currently in the indicated array property value, that array
  /// property value will be resized.
  ///
  /// Succeeds if all of the following are true:
  /// - the pPropVal pointer is valid.
  /// - the pData pointer is valid.
  /// - any contained compile-time struct has had its member offests
  ///   registered.
  ///
  /// If this method fails nothing will be written to *ppPropVal.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pPropVal or pData arg is NULL.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - offsets of any contained struct have not yet been registered.
  /// 
  /// @param pPropVal [in] property value to write
  /// @param pData [in, size_is(dataSize)] buffer from which C array data should be read
  /// @param dataSize [in] size of pData buffer in bytes
  ///
  HRESULT SetCArray (
    [in] IAAFPropertyValue * pPropVal,
    [in, size_is(dataSize)] aafMemPtr_t  pData,
    [in] aafUInt32  dataSize);




  //***********************************************************
  //
  // GetElements()
  //
  /// Returns an enumerator across elements in this set.
  /// 
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - The PSetPropVal pointer is valid.
  /// - The ppEnum pointer is valid.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either PSetPropVal or ppEnum arg is NULL.
  /// 
  /// @param PSetPropVal [in] property value to read
  /// @param ppEnum [out] enumerator across property values
  ///
  HRESULT GetElements (
    [in] IAAFPropertyValue * PSetPropVal,
    [out] IEnumAAFPropertyValues ** ppEnum);





}


// ************************
//
// Interface IAAFTypeDefWeakObjRef
//
// ************************
///
/// This interface is used to implement Weak Object references.
///
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// Objects that implement IAAFTypeDefWeakObjRef also implement the following interfaces:
///  - IAAFTypeDefObjectRef
///  - IAAFTypeDef
///  - IAAFMetaDefinition
[
    object,
    uuid(381e1f24-e7bb-11d2-842a-00600832acb8),
    helpstring("IAAFTypeDefWeakObjRef Interface"),
    pointer_default(unique)
]
interface IAAFTypeDefWeakObjRef : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes this type def to be a reference to objects of
  /// the given type, and assigns this object the given AUID.  pObjType
  /// points to the class definition of the least-derived class which
  /// is possible to be contained in property values of this type.
  /// 
  /// pTargetSet points to an array of Property Def AUIDs which
  /// indicate the location of the property containing the target of
  /// this weak reference.  The AUIDs indicate the containment path to
  /// the target property, starting at the root Header object.  For
  /// example, if the containment hierarchy is:
  ///
  /// Header->A->B->C
  ///
  /// then the first AUID corresponds to the Header's property which
  /// contains Object A; the second AUID corresponds to Object A's
  /// property which contains Object B; and the third AUID corresponds
  /// to Object B's property C which contans the target of this weak
  /// reference.  If any intermediate property is a vector or set,
  /// *all* objects in that vector or set are searched for the target.
  /// Note that the final AUID *must* correspond to a Set property.
  /// 
  /// The number of AUIDs in pTargetSet is noted by ids.
  /// 
  /// This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  /// - pObjType is a valid pointer.
  /// - pTargetSet is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - This object has already had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pObjType, pTypeName, or pTargetSet arg is NULL.
  /// 
  /// @param id [in, ref] auid to be used to identify this type
  /// @param pObjType [in] class def of objects permitted to be referenced
  /// @param pTypeName [in, string] friendly name of this type definition
  /// @param ids [in] Number of property def IDs in pTargetSet
  /// @param pTargetSet [in, size_is(ids)] List of property definition IDs indicating the property where
  /// the target is to be found.
  ///
  HRESULT Initialize (
    [in, ref] aafUID_constref  id,
    [in] IAAFClassDef * pObjType,
    [in, string] aafCharacter_constptr  pTypeName,
    [in] aafUInt32  ids,
    [in, size_is(ids)] aafUID_constptr  pTargetSet);
}



// ************************
//
// Interface IAAFVaryingValue
//
// ************************
///
/// The IAAFVaryingValue interface is implemented by objects that
/// specify a parameter whose value changes during the operation group.
/// The actual values are stored in one or more IAAFControlPoints.  For
/// parameters which are constant in value during the operation group,
/// use IAAFConstantValue.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
///
/// Objects that implement IAAFVaryingValue also implement the following interfaces:
///  - IAAFParameter
///  - IAAFObject
[
    object,
    uuid(91920d60-2a2e-11D2-bfA3-006097116212),
    helpstring("IAAFVaryingValue Interface"),
    pointer_default(unique)
]
interface IAAFVaryingValue : IUnknown
{


  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a new varying value object to be identified with the
  /// given the given parameter definition and interpolation definition.
  ///
  /// This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  /// - pParameterDef and pInterpolation are a valid pointers.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - This object has already had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pParameterDef or pInterpolation arg is NULL.
  /// 
  /// 
  /// @param pParameterDef [in] Parameter definition for this object (this determines the type of the varying value)
  /// @param pInterpolation [in] InterpolationDefinition object
  ///
  HRESULT Initialize (
    [in] IAAFParameterDef * pParameterDef,
    [in] IAAFInterpolationDef * pInterpolation);

  //***********************************************************
  //
  // AddControlPoint()
  //
  /// Adds a control point to the AAFVaryingValue object.
  /// The point will be sorted by time order, not the order in which
  /// the points were added.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pControlPoint pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pControlPoint is null.
  /// 
  /// @param pControlPoint [in] pointer to IAAFControlPoint object
  ///
  HRESULT AddControlPoint (
    [in] IAAFControlPoint * pControlPoint);


  //***********************************************************
  //
  // GetControlPoints()
  //
  /// Return an enumerator for the list of IAAFControlPoints.  The list
  /// will be returned in time order, not the order in which the
  /// points were added.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  /// 
  /// @param ppEnum [out,retval] Parameter definition enumeration
  ///
  HRESULT GetControlPoints (
    [out,retval] IEnumAAFControlPoints ** ppEnum);


  //***********************************************************
  //
  // CountControlPoints()
  //
  /// This function returns the number of control points in the sequence.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails no state is changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  /// 
  /// @param pResult [out] Number of control points
  ///
  HRESULT CountControlPoints (
    [out] aafUInt32 *  pResult);


  //***********************************************************
  //
  // GetControlPointAt()
  //
  /// This function retrieves the input control point at the given index in
  /// the given sequence.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the ppControlPoint pointer is valid.
  /// - index is less than the value returned by
  ///   CountControlPoints().
  /// 
  /// If this method fails nothing will be written to *ppControlPoint.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pControlPoint is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than or equal to the value returned by
  ///     CountControlPoints().
  /// 
  /// @param index [in] index of control point to retrieve
  /// @param ppControlPoint [out, retval] Retrieved control point
  ///
  HRESULT GetControlPointAt (
    [in] aafUInt32  index,
    [out, retval] IAAFControlPoint ** ppControlPoint);


  //***********************************************************
  //
  // RemoveControlPointAt()
  //
  /// This function removes the input control point at the given index in
  /// the given sequence.  Control points already existing at indices
  /// higher than the given index will be moved to the next lower index
  /// to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - index is less than the value returned by
  ///   CountControlPoints().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than or equal to the value returned by
  ///     CountControlPoints().
  /// 
  /// @param index [in] index of control point to remove
  ///
  HRESULT RemoveControlPointAt (
    [in] aafUInt32  index);


  //***********************************************************
  //
  // GetInterpolationDefinition()
  //
  /// Places the InterpolationDefinition object attached to this
  /// VaryingValue into the *ppInterpolation argument.  If none exists
  /// yet, NULL is placed into the *ppInterpolation argument.
  ///
  /// The returned InterpolationDefinition object, if it exists, is
  /// AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppInterpolation pointer is valid.
  /// - A valid InterpolationDefinition exists.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppInterpolation is null.
  /// 
  /// @param ppInterpolation [out] Returned InterpolationDefinition object
  ///
  HRESULT GetInterpolationDefinition (
    [out] IAAFInterpolationDef ** ppInterpolation);

  //***********************************************************
  //
  // GetValueBufLen()
  //
  /// Returns the length of buffer required for the
  /// GetInterpolatedValue() method.  The value is placed into the
  /// location specified by pLen.
  ///
  /// Succeeds if all of the following are true:
  /// - the pLen pointer is valid.
  ///
  /// If this method fails nothing will be written to *pLen.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLen arg is NULL.
  /// 
  /// @param pLen [out] Mob Name
  ///
  HRESULT GetValueBufLen (
    [out] aafInt32 *  pLen);


  //***********************************************************
  //
  // GetInterpolatedValue()
  //
  /// Writes the interpolated value of the IAAFVaryingValue at a given
  /// position into the pValue buffer.  The buffer is allocated by the
  /// caller, and the size of the buffer is given by valueSize.
  /// 
  /// Caller may call GetValueBufLen() to determine the
  /// required buffer size.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pValue pointer is valid.
  /// - valueSize indicates the buffer is large enough to hold the name.
  /// 
  /// If this method fails nothing will be written to *pValue.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pValue arg is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - valueSize indicates the buffer is too small to hold the value.
  /// 
  /// @param inputValue [in] Position along the operation group
  /// @param valueSize [in] Size of preallocated buffer
  /// @param pValue [out,size_is(valueSize),length_is(*bytesRead)] Preallocated buffer to hold value
  /// @param bytesRead [out] Number of actual bytes read
  ///
  HRESULT GetInterpolatedValue (
    [in] aafRational_t  inputValue,
    [in] aafInt32  valueSize,
    [out,size_is(valueSize),length_is(*bytesRead)] aafDataBuffer_t  pValue,
    [out] aafInt32 *  bytesRead);
}



// ************************
//
// Interface IAAFWAVEDescriptor
//
// ************************
///
/// The IAAFWaveDescriptor interface is implemented by objects which
/// describe audio content data formatted according to the RIFF
/// Waveform Audio File Format (WAVE).
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///


///
/// Objects that implement IAAFWAVEDescriptor also implement the following interfaces:
///  - IAAFFileDescriptor
///  - IAAFFileDescriptor2
///  - IAAFEssenceDescriptor
///  - IAAFObject
[
    object,
    uuid(4c2e1692-8ae6-11d2-813c-006097310172),
    helpstring("IAAFWAVEDescriptor Interface"),
    pointer_default(unique)
]
interface IAAFWAVEDescriptor : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty
  /// IAAFWaveDescriptor-supporting object.  This method must be
  /// called after allocation, and before any other method can be
  /// called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  /// 
  HRESULT Initialize ();


  //***********************************************************
  //
  // GetSummary()
  //
  /// Gets a copy of the WAVE file information without the media.
  /// 
  /// Succeeds if all of the following are true:
  /// - pSummary is a valid pointer.
  /// - The size of the buffer is large enough to hold the WAVE file
  ///   information.
  /// 
  /// If this method fails pSummary will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSummary arg is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - The buffer is too small to hold the WAVE file information.
  /// 
  /// @param size [in] Size of preallocated buffer
  /// @param pSummary [out, size_is(size)] Preallocated buffer to hold the WAVE file information
  ///
  HRESULT GetSummary (
    [in] aafUInt32  size,
    [out, size_is(size)] aafDataValue_t  pSummary);


  //***********************************************************
  //
  // GetSummaryBufferSize()
  //
  /// Returns the size of the buffer required for the GetSummary()
  /// method.  The value is placed into the location specified by pSize.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSize pointer is valid.
  ///
  /// If this method fails nothing will be written to *pSize.
  ///
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSize arg is NULL.
  /// 
  /// @param pSize [out] required buffer size
  ///
  HRESULT GetSummaryBufferSize (
    [out] aafUInt32 *  pSize);


  //***********************************************************
  //
  // SetSummary()
  //
  /// Sets the WAVE file information.
  /// 
  /// Succeeds if all of the following are true:
  /// - pSummary is a valid pointer
  /// 
  /// If this method fails the summary property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSummary arg is NULL.
  /// 
  /// @param size [in] Size of preallocated buffer
  /// @param pSummary [in, size_is(size)] buffer containing value
  ///
  HRESULT SetSummary (
    [in] aafUInt32  size,
    [in, size_is(size)] aafDataValue_t  pSummary);


}



// ************************
//
// Interface IEnumAAFClassDefs
//
// ************************
///
/// This interface is used to enumerate across Class Definition
/// objects.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
[
    object,
    uuid(B1A2138E-1A7D-11D2-BF78-00104BC9156D),
    helpstring("IEnumAAFClassDefs Interface"),
    pointer_default(unique)
]
interface IEnumAAFClassDefs : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppClassDefs pointer is valid.
  /// - there are Class Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppClassDefs.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppClassDefs arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Class Definition objects remaining to be returned.
  /// 
  /// @param ppClassDefs [out,retval] The Next Class Definition
  ///
  HRESULT NextOne (
    [out,retval] IAAFClassDef ** ppClassDefs);


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFClassDef pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppClassDefs pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are Class Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppClassDefs or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppClassDefs or pNumFetched arg is NULL.
  /// 
  /// @param count [in] number of ClassDefs requested
  /// @param ppClassDefs [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual Class Definition objects fetched into ppClassDefs array
  ///
  HRESULT Next (
    [in] aafUInt32  count,
    [out, size_is(count), length_is(*pNumFetched)] IAAFClassDef ** ppClassDefs,
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  /// 
  /// @param count [in] Number of elements to skip
  ///
  HRESULT Skip (
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  /// 
  /// @param ppEnum [out,retval] new enumeration
  ///
  HRESULT Clone (
    [out,retval] IEnumAAFClassDefs ** ppEnum);
}



// ************************
//
// Interface IEnumAAFCodecDefs
//
// ************************
[
    object,
    uuid(3B2C9AD4-022A-11d3-80A6-006008143E6F),
    helpstring("IEnumAAFCodecDefs Interface"),
    pointer_default(unique)
]
interface IEnumAAFCodecDefs : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppCodecDefs pointer is valid.
  /// - there are Codec Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppCodecDefs.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppCodecDefs arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Codec Definition objects remaining to be returned.
  /// 
  /// @param ppCodecDefs [out,retval] The Next Codec Definition
  ///
  HRESULT NextOne (
    [out,retval] IAAFCodecDef ** ppCodecDefs);


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFCodecDef pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppCodecDefs pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are Codec Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppCodecDefs or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppCodecDefs or pNumFetched arg is NULL.
  /// 
  /// @param count [in] number of CodecDefs requested
  /// @param ppCodecDefs [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual Codec Definition objects fetched into ppCodecDefs array
  ///
  HRESULT Next (
    [in] aafUInt32  count,
    [out, size_is(count), length_is(*pNumFetched)] IAAFCodecDef ** ppCodecDefs,
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  /// 
  /// @param count [in] Number of elements to skip
  ///
  HRESULT Skip (
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  /// 
  /// @param ppEnum [out,retval] new enumeration
  ///
  HRESULT Clone (
    [out,retval] IEnumAAFCodecDefs ** ppEnum);
}



// ************************
//
// Interface IEnumAAFCodecFlavours
//
// ************************
///
/// An object which allows iteration over all of the flavour codes
/// which a given codec is able to handle.
///
/// Flavours are used when a single codec can support multiple formats.
/// An Example would be a codec which would accept a "resolution ID"
/// for a particular manufacturer and set up all of the parameters.
/// When a new resolution ID is released, then a new codec plugin
/// would give users the ability to use the new resolutions without
/// upgrading the application.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///


[
    object,
    uuid(AB4D9F12-DD69-11d2-809C-006008143E6F),
    helpstring("IEnumAAFCodecFlavours Interface"),
    pointer_default(unique)
]
interface IEnumAAFCodecFlavours : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for passing in a pointer to an aafUID_t,
  /// and retains control over the pointer.
  ///
  /// This is a just simplified version of the Next method. 
  /// 
  /// @param pAAFCodecFlavour [out,retval] The Next flavour code
  ///
  HRESULT NextOne (
    [out,retval] aafUID_t *  pAAFCodecFlavour);


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (codec flavour IDs) in
  /// the enumerator's list, returning them in the given array along
  /// with the actual number of enumerated elements in pFetched. The
  /// caller is responsible for passing in a pointer to an array of
  /// aafUID_t, and retains control over the pointer.
  /// 
  /// @param count [in] number of AAFPluggableDefs requested
  /// @param pAAFCodecFlavours [out, size_is(count), length_is(*pFetched)] array to receive flavour codes
  /// @param pFetched [out,ref] number of actual flavour IDs fetched into pAAFCodecFlavours array
  ///
  HRESULT Next (
    [in] aafUInt32  count,
    [out, size_is(count), length_is(*pFetched)] aafUID_t *  pAAFCodecFlavours,
    [out,ref] aafUInt32 *  pFetched);


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to EnumAAFCodecFlavours::Next
  /// will not return those elements.
  /// 
  /// @param count [in] Number of elements to skip
  ///
  HRESULT Skip (
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// There is no guarantee that the same set of elements will be
  /// enumerated on each pass through the list, nor will the elements
  /// necessarily be enumerated in the same order. The exact behavior
  /// depends on the collection being enumerated.
  /// 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another EnumAAFCodecFlavours enumerator with the same
  /// state as the current enumerator to iterate over the same
  /// list.  This method makes it possible to record a point in the
  /// enumeration sequence in order to return to that point at a later
  /// time.
  /// 
  /// The caller must release this new enumerator separately from the
  /// first enumerator.
  /// 
  /// @param ppEnum [out,retval] new enumeration
  ///
  HRESULT Clone (
    [out,retval] IEnumAAFCodecFlavours ** ppEnum);
}



// ************************
//
// Interface IEnumAAFComponents
//
// ************************
///
/// This interface is used to enumerate over the AAFComponents contained
/// in an AAFSequence.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
[
    object,
    uuid(B1A21394-1A7D-11D2-BF78-00104BC9156D),
    helpstring("IEnumAAFComponents Interface"),
    pointer_default(unique)
]
interface IEnumAAFComponents : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppComponent pointer is valid.
  /// - there are Component objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppComponent.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppComponent is null.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Components remaining to be returned.
  /// 
  /// @param ppComponent [out,retval] The Next Component
  ///
  HRESULT NextOne (
    [out,retval] IAAFComponent ** ppComponent);


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFComponent pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppComponents pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched can be NULL.
  /// - There are Component objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppComponents or
  /// pNumFetched.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either ppComponents or pNumFetched is null.
  /// 
  /// @param count [in] number of components requested
  /// @param ppComponents [out, size_is(count), length_is(*pNumFetched)] array to receive components
  /// @param pNumFetched [out,ref] number of actual Components fetched into ppComponents array
  ///
  HRESULT Next (
    [in] aafUInt32  count,
    [out, size_is(count), length_is(*pNumFetched)] IAAFComponent ** ppComponents,
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not
  /// return those elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  /// 
  /// @param count [in] Number of elements to skip
  ///
  HRESULT Skip (
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  /// 
  /// Always succeeds.
  /// 
  /// This method will return the following code:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another component enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  /// 
  /// @param ppEnum [out,retval] new enumeration
  ///
  HRESULT Clone (
    [out,retval] IEnumAAFComponents ** ppEnum);
}



// ************************
//
// Interface IEnumAAFContainerDefs
//
// ************************
[
    object,
    uuid(3B2C9AD2-022A-11d3-80A6-006008143E6F),
    helpstring("IEnumAAFContainerDefs Interface"),
    pointer_default(unique)
]
interface IEnumAAFContainerDefs : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppContainerDefs pointer is valid.
  /// - there are Container Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppContainerDefs.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppContainerDefs arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Container Definition objects remaining to be returned.
  /// 
  /// @param ppContainerDefs [out,retval] The Next Container Definition
  ///
  HRESULT NextOne (
    [out,retval] IAAFContainerDef ** ppContainerDefs);


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFContainerDef pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppContainerDefs pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are Container Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppContainerDefs or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppContainerDefs or pNumFetched arg is NULL.
  /// 
  /// @param count [in] number of ContainerDefs requested
  /// @param ppContainerDefs [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual Container Definition objects fetched into ppContainerDefs array
  ///
  HRESULT Next (
    [in] aafUInt32  count,
    [out, size_is(count), length_is(*pNumFetched)] IAAFContainerDef ** ppContainerDefs,
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  /// 
  /// @param count [in] Number of elements to skip
  ///
  HRESULT Skip (
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  /// 
  /// @param ppEnum [out,retval] new enumeration
  ///
  HRESULT Clone (
    [out,retval] IEnumAAFContainerDefs ** ppEnum);
}



// ************************
//
// Interface IEnumAAFControlPoints
//
// ************************
[
    object,
    uuid(B1A2139C-1A7D-11D2-BF78-00104BC9156D),
    helpstring("IEnumAAFControlPoints Interface"),
    pointer_default(unique)
]
interface IEnumAAFControlPoints : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppControlPoints pointer is valid.
  /// - there are Control Point objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppControlPoints.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppControlPoints arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Control Point objects remaining to be returned.
  /// 
  /// @param ppControlPoints [out,retval] The Next Control Point
  ///
  HRESULT NextOne (
    [out,retval] IAAFControlPoint ** ppControlPoints);


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFControlPoint pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppControlPoints pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are Control Point objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppControlPoints or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppControlPoints or pNumFetched arg is NULL.
  /// 
  /// @param count [in] number of ControlPoints requested
  /// @param ppControlPoints [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual Control Point objects fetched into ppControlPoints array
  ///
  HRESULT Next (
    [in] aafUInt32  count,
    [out, size_is(count), length_is(*pNumFetched)] IAAFControlPoint ** ppControlPoints,
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  /// 
  /// @param count [in] Number of elements to skip
  ///
  HRESULT Skip (
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  /// 
  /// @param ppEnum [out,retval] new enumeration
  ///
  HRESULT Clone (
    [out,retval] IEnumAAFControlPoints ** ppEnum);
}



// ************************
//
// Interface IEnumAAFDataDefs
//
// ************************
[
    object,
    uuid(d8000382-498e-11d2-841B-00600832ACB8),
    helpstring("IEnumAAFDataDefs Interface"),
    pointer_default(unique)
]
interface IEnumAAFDataDefs : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppDataDefs pointer is valid.
  /// - there are Data Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppDataDefs.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDataDefs arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Data Definition objects remaining to be returned.
  /// 
  /// @param ppDataDefs [out,retval] The Next Data Definition
  ///
  HRESULT NextOne (
    [out,retval] IAAFDataDef ** ppDataDefs);


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFDataDef pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppDataDefs pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are Data Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppDataDefs or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppDataDefs or pNumFetched arg is NULL.
  /// 
  /// @param count [in] number of DataDefs requested
  /// @param ppDataDefs [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual Data Definition objects fetched into ppDataDefs array
  ///
  HRESULT Next (
    [in] aafUInt32  count,
    [out, size_is(count), length_is(*pNumFetched)] IAAFDataDef ** ppDataDefs,
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  /// 
  /// @param count [in] Number of elements to skip
  ///
  HRESULT Skip (
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  /// 
  /// @param ppEnum [out,retval] new enumeration
  ///
  HRESULT Clone (
    [out,retval] IEnumAAFDataDefs ** ppEnum);
}



// ************************
//
// Interface IEnumAAFEssenceData
//
// ************************
///
/// The IEnumAAFEssenceData interface is used enumerate all of the
/// AAFEssenceData objects in a file.  The AAFEssenceData objects
/// contain the actual essence data (ex. WAVE) when it is contained
/// within an AAF file.  Normally the client application would access the
/// essence through the IAAFEssenceAccess interface, which handles the work
/// of finding and (de)compressing the data.  However, in rare cases
/// direct access to the data is required, so this interface is exposed.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
///
/// AAFRESULT_NULL_PARAM
///   - One of the passed in pointers is NULL.
///
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
[
    object,
    uuid(B1A21392-1A7D-11D2-BF78-00104BC9156D),
    helpstring("IEnumAAFEssenceData Interface"),
    pointer_default(unique)
]
interface IEnumAAFEssenceData : IUnknown
{


  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The caller is responsible for 
  /// properly releasing the returned pointer when it is no longer needed.
  /// @comm This is a just simplified version of the Next method. 
  /// 
  /// @param ppEssenceData [out,retval] The Next EssenceData
  ///
  HRESULT NextOne (
    [out,retval] IAAFEssenceData ** ppEssenceData);

  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFEssenceData pointers) in 
  /// the enumerator's list, returning them in the given array along with the actual 
  /// number of enumerated elements in pcFetched. The caller is responsible for 
  /// properly releasing the returned pointers.
  /// 
  /// @param count [in] number of essence data requested
  /// @param ppEssenceData [out, size_is(count), length_is(*pFetched)] array to receive EssenceData
  /// @param pFetched [out,ref] number of actual EssenceData fetched into ppEssenceData array
  ///
  HRESULT Next (
    [in] aafUInt32  count,
    [out, size_is(count), length_is(*pFetched)] IAAFEssenceData ** ppEssenceData,
    [out,ref] aafUInt32 *  pFetched);

  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the enumeration so that 
  /// the next call to EnumAAFEssenceData::Next will not return 
  /// those elements.
  /// 
  /// @param count [in] Number of elements to skip
  ///
  HRESULT Skip (
    [in] aafUInt32  count);

  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of the list of elements. 
  /// @comm There is no guarantee that the same set of elements will be enumerated on 
  /// each pass through the list, nor will the elements necessarily be enumerated in 
  /// the same order. The exact behavior depends on the collection being enumerated.
  /// 
  HRESULT Reset ();

  //***********************************************************
  //
  // Clone()
  //
  /// Creates another essence data enumerator with the same state as the current 
  /// enumerator to iterate over the same list. This method makes it possible to 
  /// record a point in the enumeration sequence in order to return to that point 
  /// at a later time.
  /// @comm The caller must release this new enumerator separately from the first enumerator.
  /// 
  /// @param ppEnum [out,retval] new enumeration
  ///
  HRESULT Clone (
    [out,retval] IEnumAAFEssenceData ** ppEnum);

}



// ************************
//
// Interface IEnumAAFFileDescriptors
//
// ************************
///
/// This interface is used to enumerate across File Descriptor objects.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
[
    object,
    uuid(FD4B6BC0-0787-4F5E-9FBD-37282B8706E7),
    helpstring("IEnumAAFFileDescriptors Interface"),
    pointer_default(unique)
]
interface IEnumAAFFileDescriptors : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppFileDescriptors pointer is valid.
  /// - there are FileDescriptor objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppFileDescriptors.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppFileDescriptors arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no FileDescriptor objects remaining to be returned.
  /// 
  /// @param ppFileDescriptors [out,retval] The Next FileDescriptor
  ///
  HRESULT NextOne (
    [out,retval] IAAFFileDescriptor ** ppFileDescriptors);


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFFileDescriptor pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppFileDescriptors pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are FileDescriptor objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppFileDescriptors or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppFileDescriptors or pNumFetched arg is NULL.
  /// 
  /// @param count [in] number of FileDescriptors requested
  /// @param ppFileDescriptors [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual FileDescriptor objects fetched into ppFileDescriptors array
  ///
  HRESULT Next (
    [in] aafUInt32  count,
    [out, size_is(count), length_is(*pNumFetched)] IAAFFileDescriptor ** ppFileDescriptors,
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  /// 
  /// @param count [in] Number of elements to skip
  ///
  HRESULT Skip (
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  /// 
  /// @param ppEnum [out,retval] new enumeration
  ///
  HRESULT Clone (
    [out,retval] IEnumAAFFileDescriptors ** ppEnum);
}



// ************************
//
// Interface IEnumAAFFileEncodings
//
// ************************
//
// This interface is used to enumerate across Class Definition
// objects.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
//
/***********************************************\
*   Stub only.   Implementation not yet added   *
\***********************************************/
//
[
    object,
    uuid(6173c2cf-9a7a-4ff1-a8fc-be0819aea2de),
    helpstring("IEnumAAFFileEncodings Interface"),
    pointer_default(unique)
]
interface IEnumAAFFileEncodings : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppFileEncodings pointer is valid.
  /// - there are File Encoding objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppFileEncodings.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppFileEncodings arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no File Encoding objects remaining to be returned.
  /// 
  /// @param ppFileEncodings [out,retval] The Next File Encoding
  ///
  HRESULT NextOne (
    [out,retval] IAAFFileEncoding ** ppFileEncodings);


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFFileEncoding pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppFileEncodings pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are File Encoding objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppFileEncodings or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppFileEncodings or pNumFetched arg is NULL.
  /// 
  /// @param count [in] number of FileEncodings requested
  /// @param ppFileEncodings [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual File Encoding objects fetched into ppFileEncodings array
  ///
  HRESULT Next (
    [in] aafUInt32  count,
    [out, size_is(count), length_is(*pNumFetched)] IAAFFileEncoding ** ppFileEncodings,
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  /// 
  /// @param count [in] Number of elements to skip
  ///
  HRESULT Skip (
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  /// 
  /// @param ppEnum [out,retval] new enumeration
  ///
  HRESULT Clone (
    [out,retval] IEnumAAFFileEncodings ** ppEnum);
}



// ************************
//
// Interface IEnumAAFIdentifications
//
// ************************
///
/// This interfaces allows access to individual
/// IAAFIdentification-supporting objects within a collection.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
[
    object,
    uuid(B1A21384-1A7D-11D2-BF78-00104BC9156D),
    helpstring("IEnumAAFIdentifications Interface"),
    pointer_default(unique)
]
interface IEnumAAFIdentifications : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed. 
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppIdentification pointer is valid.
  /// - there are Identification objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppIdentification.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppIdentification is null.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Identifications remaining to be returned.
  /// 
  /// @param ppIdentification [out, retval] The Next Identification
  ///
  HRESULT NextOne (
    [out, retval] IAAFIdentification ** ppIdentification);


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFIdentification pointers)
  /// in the enumerator's list, returning them in the given array
  /// along with the actual number of enumerated elements in
  /// pNumFetched. The caller is responsible for properly releasing the
  /// returned pointers when thery are no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppIdentifications pointer is valid.
  /// - the pNumFetched pointer is valid.
  /// - there are Identification objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppIdentifications or
  /// pNumFetched.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either ppIdentification or pNumFetched is null.
  /// 
  /// @param count [in] number of identifications requested
  /// @param ppIdentifications [out, size_is(count), length_is(*pNumFetched)] array to receive identification objects
  /// @param pNumFetched [out] number of actual Identifications fetched into ppIdentifications array
  ///
  HRESULT Next (
    [in] aafUInt32  count,
    [out, size_is(count), length_is(*pNumFetched)] IAAFIdentification ** ppIdentifications,
    [out] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to EnumAAFIdentifications::Next
  /// will not return those elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  /// 
  /// @param count [in] Number of elements to skip
  ///
  HRESULT Skip (
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  /// 
  /// Always succeeds.
  /// 
  /// This method will return the following code:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another identification enumerator with the same state as
  /// the current enumerator to iterate over the same list. This method
  /// makes it possible to record a point in the enumeration sequence
  /// in order to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  /// 
  /// @param ppEnum [out, retval] new enumeration
  ///
  HRESULT Clone (
    [out, retval] IEnumAAFIdentifications ** ppEnum);
}



// ************************
//
// Interface IEnumAAFInterpolationDefs
//
// ************************
[
    object,
    uuid(293600A5-0D37-11d3-80A9-006008143E6F),
    helpstring("IEnumAAFInterpolationDefs Interface"),
    pointer_default(unique)
]
interface IEnumAAFInterpolationDefs : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppInterpolationDefs pointer is valid.
  /// - there are Interpolation Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppInterpolationDefs.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppInterpolationDefs arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Interpolation Definition objects remaining to be returned.
  /// 
  /// @param ppInterpolationDefs [out,retval] The Next Interpolation Definition
  ///
  HRESULT NextOne (
    [out,retval] IAAFInterpolationDef ** ppInterpolationDefs);


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFInterpolationDef pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppInterpolationDefs pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are Interpolation Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppInterpolationDefs or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppInterpolationDefs or pNumFetched arg is NULL.
  /// 
  /// @param count [in] number of InterpolationDefs requested
  /// @param ppInterpolationDefs [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual Interpolation Definition objects fetched into ppInterpolationDefs array
  ///
  HRESULT Next (
    [in] aafUInt32  count,
    [out, size_is(count), length_is(*pNumFetched)] IAAFInterpolationDef ** ppInterpolationDefs,
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  /// 
  /// @param count [in] Number of elements to skip
  ///
  HRESULT Skip (
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  /// 
  /// @param ppEnum [out,retval] new enumeration
  ///
  HRESULT Clone (
    [out,retval] IEnumAAFInterpolationDefs ** ppEnum);
}



// ************************
//
// Interface IEnumAAFKLVData
//
// ************************
[
    object,
    uuid(46114416-0676-11d4-A356-009027DFCA6A),
    helpstring("IEnumAAFKLVData Interface"),
    pointer_default(unique)
]
interface IEnumAAFKLVData : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppKLVData pointer is valid.
  /// - there are KLV Data objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppKLVData.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppKLVData arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no KLV Data objects remaining to be returned.
  /// 
  /// @param ppKLVData [out,retval] The Next KLV Data
  ///
  HRESULT NextOne (
    [out,retval] IAAFKLVData ** ppKLVData);


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFKLVData pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppKLVData pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are KLV Data objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppKLVData or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppKLVData or pNumFetched arg is NULL.
  /// 
  /// @param count [in] number of KLVData requested
  /// @param ppKLVData [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual KLV Data objects fetched into ppKLVData array
  ///
  HRESULT Next (
    [in] aafUInt32  count,
    [out, size_is(count), length_is(*pNumFetched)] IAAFKLVData ** ppKLVData,
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  /// 
  /// @param count [in] Number of elements to skip
  ///
  HRESULT Skip (
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  /// 
  /// @param ppEnum [out,retval] new enumeration
  ///
  HRESULT Clone (
    [out,retval] IEnumAAFKLVData ** ppEnum);
}



// ************************
//
// Interface IEnumAAFKLVDataDefs
//
// ************************
[
    object,
    uuid(2a368c5c-e5af-43c8-8e5a-e78ba02f5f3b),
    helpstring("IEnumAAFKLVDataDefs Interface"),
    pointer_default(unique)
]

interface IEnumAAFKLVDataDefs : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppKLVDataDefs pointer is valid.
  /// - there are KLVData Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppKLVDataDefs.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppKLVDataDefs arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no KLVData Definition objects remaining to be returned.
  /// 
  /// @param ppKLVDataDefs [out,retval] The Next KLVData Definition
  ///
  HRESULT NextOne (
    [out,retval] IAAFKLVDataDefinition ** ppKLVDataDefs);


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFKLVDataDefinition pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppKLVDataDefs pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are KLVData Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppKLVDataDefs or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppKLVDataDefs or pNumFetched arg is NULL.
  /// 
  /// @param count [in] number of KLVDataDefs requested
  /// @param ppKLVDataDefs [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual KLVData Definition objects fetched into ppKLVDataDefs array
  ///
  HRESULT Next (
    [in] aafUInt32  count,
    [out, size_is(count), length_is(*pNumFetched)] IAAFKLVDataDefinition ** ppKLVDataDefs,
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  /// 
  /// @param count [in] Number of elements to skip
  ///
  HRESULT Skip (
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  /// 
  /// @param ppEnum [out,retval] new enumeration
  ///
  HRESULT Clone (
    [out,retval] IEnumAAFKLVDataDefs ** ppEnum);
}



// ************************
//
// Interface IEnumAAFLoadedPlugins
//
// ************************
///
/// An object which allows iteration over all of the AAFDefObject
/// managed by the AAFPluginManager.  This is useful when adding something pluggable
/// into an AAF file, as you know what choices are locally available.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
[
    object,
    uuid(AB4D9F14-DD69-11d2-809C-006008143E6F),
    helpstring("IEnumAAFLoadedPlugins Interface"),
    pointer_default(unique)
]
interface IEnumAAFLoadedPlugins : IUnknown
{


  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The caller is responsible 
  /// for properly releasing the returned pointer when it is no longer needed.
  /// @comm This is a just simplified version of the Next method. 
  /// 
  /// @param ppAAFPluginID [out,retval] The Next AAFPluginID
  ///
  HRESULT NextOne (
    [out,retval] aafUID_t*  ppAAFPluginID);

  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFPluginDesc pointers) in 
  /// the enumerator's list, returning them in the given array along with the actual 
  /// number of enumerated elements in pFetched. The caller is responsible for 
  /// properly releasing the returned pointers.
  /// 
  /// @param count [in] number of AAFPluginDef requested
  /// @param pAAFPluginIDs [out, size_is(count), length_is(*pFetched)] array to receive aafUID_t
  /// @param pFetched [out,ref] number of actual AAFPluginDef fetched into ppAAFPluginDef array
  ///
  HRESULT Next (
    [in] aafUInt32  count,
    [out, size_is(count), length_is(*pFetched)] aafUID_t*  pAAFPluginIDs,
    [out,ref] aafUInt32 *  pFetched);

  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the enumeration so that 
  /// the next call to EnumAAFLoadedPlugins::Next will not return 
  /// those elements.
  /// 
  /// @param count [in] Number of elements to skip
  ///
  HRESULT Skip (
    [in] aafUInt32  count);

  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of the list of elements. 
  /// @comm There is no guarantee that the same set of elements will be enumerated on 
  /// each pass through the list, nor will the elements necessarily be enumerated in 
  /// the same order. The exact behavior depends on the collection being enumerated.
  /// 
  HRESULT Reset ();

  //***********************************************************
  //
  // Clone()
  //
  /// Creates another EnumAAFLoadedPlugins enumerator with the same state as the current 
  /// enumerator to iterate over the same list. This method makes it possible to 
  /// record a point in the enumeration sequence in order to return to that point 
  /// at a later time.
  /// @comm The caller must release this new enumerator separately from the first
  /// enumerator.
  /// 
  /// @param ppEnum [out,retval] new enumeration
  ///
  HRESULT Clone (
    [out,retval] IEnumAAFLoadedPlugins ** ppEnum);

}



// ************************
//
// Interface IEnumAAFLocators
//
// ************************
///
/// This interface is for the enumerator which is generated by
/// IAAFEssenceDescriptor and is used for enumerating over IAAFLocators
/// attached to EssenceDescriptor attached to an AAFSourceMob.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
[
    object,
    uuid(B1A2139E-1A7D-11D2-BF78-00104BC9156D),
    helpstring("IEnumAAFLocators Interface"),
    pointer_default(unique)
]
interface IEnumAAFLocators : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppLocator pointer is valid.
  /// - there are Locator objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppLocator.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppLocator is null.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Locators remaining to be returned.
  /// 
  /// @param ppLocator [out,retval] The Next Locator
  ///
  HRESULT NextOne (
    [out,retval] IAAFLocator ** ppLocator);


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFLocator pointers) in 
  /// the enumerator's list, returning them in the given array along
  /// with the actual number of enumerated elements in pcFetched. The
  /// caller is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppLocators pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched can be NULL.
  /// - There are Locator objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppLocators or
  /// pNumFetched.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either ppLocators or pNumFetched is null.
  /// 
  /// @param count [in] number of locators requested
  /// @param ppLocators [out, size_is(count), length_is(*pFetched)] array to receive locators
  /// @param pFetched [out,ref] number of actual Locators fetched into ppLocators array
  ///
  HRESULT Next (
    [in] aafUInt32  count,
    [out, size_is(count), length_is(*pFetched)] IAAFLocator ** ppLocators,
    [out,ref] aafUInt32 *  pFetched);


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to EnumAAFLocators::Next will
  /// not return those elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  /// 
  /// @param count [in] Number of elements to skip
  ///
  HRESULT Skip (
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  /// 
  /// Always succeeds.
  /// 
  /// This method will return the following code:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another locator enumerator with the same state as the
  /// current enumerator to iterate over the same list. This method
  /// makes it possible to record a point in the enumeration sequence
  /// in order to return to that point at a later time.
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  /// 
  /// @param ppEnum [out,retval] new enumeration
  ///
  HRESULT Clone (
    [out,retval] IEnumAAFLocators ** ppEnum);
}



// ************************
//
// Interface IEnumAAFMobSlots
//
// ************************
///
/// This interface is for the enumerator which is generated by IAAFMob
/// and is used for enumerating over IAAFMobSlots attached to the mob.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
[
    object,
    uuid(B1A21388-1A7D-11D2-BF78-00104BC9156D),
    helpstring("IEnumAAFMobSlots Interface"),
    pointer_default(unique)
]
interface IEnumAAFMobSlots : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppMobSlot pointer is valid.
  /// - there are Mob Slot objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppMobSlot.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppMobSlot is null.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - Hit the end of the list of slots being enumerated over.
  /// 
  /// @param ppMobSlot [out,retval] The Next MobSlot
  ///
  HRESULT NextOne (
    [out,retval] IAAFMobSlot ** ppMobSlot);


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFMobSlot pointers) in 
  /// the enumerator's list, returning them in the given array along
  /// with the actual number of enumerated elements in pNumFetched. The
  /// caller is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppMobSlots pointer is valid.
  /// - the pNumFetched pointer is valid.
  /// - there are Mob Slot objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppMobSlots or
  /// pNumFetched.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either ppMob or pNumFetched is null.
  ///
  /// E_INVALIDARG
  ///   - Hit the end of the list of slots being enumerated over.
  /// 
  /// @param count [in] number of mob slots requested
  /// @param ppMobSlots [out, size_is(count), length_is(*pNumFetched)] array to receive mob slots
  /// @param pNumFetched [out,ref] number of actual MobSlots fetched into ppMobSlots array
  ///
  HRESULT Next (
    [in] aafUInt32  count,
    [out, size_is(count), length_is(*pNumFetched)] IAAFMobSlot ** ppMobSlots,
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to EnumAAFMobSlots::Next will
  /// not return those elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  /// 
  /// @param count [in] Number of elements to skip
  ///
  HRESULT Skip (
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  /// 
  /// Always succeeds.
  /// 
  /// This method will return the following code:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another mob slot enumerator with the same state as the
  /// current enumerator to iterate over the same list. This method
  /// makes it possible to record a point in the enumeration sequence
  /// in order to return to that point at a later time.
  /// 
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  /// 
  /// @param ppEnum [out,retval] new enumeration
  ///
  HRESULT Clone (
    [out,retval] IEnumAAFMobSlots ** ppEnum);
}



// ************************
//
// Interface IEnumAAFMobs
//
// ************************
///
/// This interface is for the enumerator which is generated by
/// IAAFHeader and is used for enumerating over IAAFMobs attached to
/// the content storage attached to the header.  The call to generate
/// this enumerator takes a mob kind [see below], and enumerates over
/// a subset of the mobs attached to the content storage.  This is
/// because importing programs often import starting with the source
/// mobs, and ending with the composition mobs, so that no dangling
/// references must be maintained in their internal representation.
/// The possible values for mobKind are:
///  kCompMob   -- Iterate over AAFCompositionMob.
///  kMasterMob -- iterate over AAFMasterMob.
///  kFileMob   -- Iterate over AAFSourceMob with attached
///                AAFFileDescriptor. 
///  kTapeMob   -- Iterate over AAFSourceMob with attached
///                AAFTapeDescriptor.
///  kFilmMob   -- Iterate over AAFSourceMob with attached
///                AAFFilmDescriptor.
///  kAllMob    -- Iterate over all IAAMob.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
[
    object,
    uuid(B1A21386-1A7D-11D2-BF78-00104BC9156D),
    helpstring("IEnumAAFMobs Interface"),
    pointer_default(unique)
]
interface IEnumAAFMobs : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppMob pointer is valid.
  /// - there are Mob objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppMob.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppMob is null.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Mobs remaining to be returned.
  /// 
  /// @param ppMob [out, retval] The Next Mob
  ///
  HRESULT NextOne (
    [out, retval] IAAFMob ** ppMob);


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFMob pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppMobs pointer is valid.
  /// - the pNumFetched pointer is valid.
  /// - there are Mob objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppMobs or
  /// pNumFetched.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either ppMob or pNumFetched is null.
  /// 
  /// @param count [in] number of mobs requested
  /// @param ppMobs [out, size_is(count), length_is(*pNumFetched)] array to receive mobs
  /// @param pNumFetched [out] number of actual Mobs fetched into ppMobs array
  ///
  HRESULT Next (
    [in] aafUInt32  count,
    [out, size_is(count), length_is(*pNumFetched)] IAAFMob ** ppMobs,
    [out] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to EnumAAFMobs::Next will not
  /// return those elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  /// 
  /// @param count [in] Number of elements to skip
  ///
  HRESULT Skip (
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  /// 
  /// Always succeeds.
  /// 
  /// This method will return the following code:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another mob enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  /// 
  /// @param ppEnum [out, retval] new enumeration
  ///
  HRESULT Clone (
    [out, retval] IEnumAAFMobs ** ppEnum);
}



// ************************
//
// Interface IEnumAAFOperationDefs
//
// ************************
[
    object,
    uuid(92B88021-2B2B-11D2-BF7E-00104BC9156D),
    helpstring("IEnumAAFOperationDefs Interface"),
    pointer_default(unique)
]
interface IEnumAAFOperationDefs : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppOperationDefs pointer is valid.
  /// - there are Operation Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppOperationDefs.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppOperationDefs arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Operation Definition objects remaining to be returned.
  /// 
  /// @param ppOperationDefs [out,retval] The Next Operation Definition
  ///
  HRESULT NextOne (
    [out,retval] IAAFOperationDef ** ppOperationDefs);


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFOperationDef pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppOperationDefs pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are Operation Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppOperationDefs or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppOperationDefs or pNumFetched arg is NULL.
  /// 
  /// @param count [in] number of OperationDefs requested
  /// @param ppOperationDefs [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual Operation Definition objects fetched into ppOperationDefs array
  ///
  HRESULT Next (
    [in] aafUInt32  count,
    [out, size_is(count), length_is(*pNumFetched)] IAAFOperationDef ** ppOperationDefs,
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  /// 
  /// @param count [in] Number of elements to skip
  ///
  HRESULT Skip (
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  /// 
  /// @param ppEnum [out,retval] new enumeration
  ///
  HRESULT Clone (
    [out,retval] IEnumAAFOperationDefs ** ppEnum);
}



// ************************
//
// Interface IEnumAAFParameterDefs
//
// ************************
///
/// This interface is used to enumerate over the AAFParameterDefinitions referenced
/// from in an AAFOperationDefinition or AAFParameter, and contained within
/// the AAFDictionary.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
[
    object,
    uuid(B1A213A4-1A7D-11D2-BF78-00104BC9156D),
    helpstring("IEnumAAFParameterDefs Interface"),
    pointer_default(unique)
]
interface IEnumAAFParameterDefs : IUnknown
{


  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppParameterDef pointer is valid.
  /// - there are ParameterDef objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppParameterDef.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppParameterDef is null.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no ParameterDefs remaining to be returned.
  /// 
  /// @param ppParameterDef [out,retval] The Next ParameterDefinition
  ///
  HRESULT NextOne (
    [out,retval] IAAFParameterDef ** ppParameterDef);

  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFParameterDef pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppParameterDefs pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched can be NULL.
  /// - There are AAFParameterDef objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppComponents or
  /// pNumFetched.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either ppParameterDefs or pNumFetched is null.
  /// 
  /// @param count [in] number of control code definitions requested
  /// @param ppParameterDefs [out, size_is(count), length_is(*pFetched)] array to receive control code definitions
  /// @param pFetched [out,ref] number of actual ParameterDefs fetched into ppParameterDefs array
  ///
  HRESULT Next (
    [in] aafUInt32  count,
    [out, size_is(count), length_is(*pFetched)] IAAFParameterDef ** ppParameterDefs,
    [out,ref] aafUInt32 *  pFetched);

  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not
  /// return those elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  /// 
  /// @param count [in] Number of elements to skip
  ///
  HRESULT Skip (
    [in] aafUInt32  count);

  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  /// 
  /// Always succeeds.
  /// 
  /// This method will return the following code:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  HRESULT Reset ();
  /// @comm There is no guarantee that the same set of elements will be enumerated on 
  /// each pass through the list\, nor will the elements necessarily be enumerated in 
  /// the same order. The exact behavior depends on the collection being enumerated.)

  //***********************************************************
  //
  // Clone()
  //
  /// Creates another EnumAAFParameterDefs enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  /// 
  /// @param ppEnum [out,retval] new enumeration
  ///
  HRESULT Clone (
    [out,retval] IEnumAAFParameterDefs ** ppEnum);

}



// ************************
//
// Interface IEnumAAFParameters
//
// ************************
///
/// This interface is used to enumerate over the AAFParameters
/// referenced from in an AAFOperationDefinition or AAFParameter, and
/// contained within the AAFDictionary.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
[
    object,
    uuid(7227261E-A8C9-11D3-A3ED-0004AC96A937),
    helpstring("IEnumAAFParameters Interface"),
    pointer_default(unique)
]
interface IEnumAAFParameters : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppParameter pointer is valid.
  /// - there are Parameter objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppParameter.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppParameter is null.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Parameters remaining to be returned.
  /// 
  /// @param ppParameter [out,retval] The Next Parameter
  ///
  HRESULT NextOne (
    [out,retval] IAAFParameter ** ppParameter);

  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFParameter pointers) in
  /// the enumerator's list, returning them in the given array along
  /// with the actual number of enumerated elements in pNumFetched. The
  /// caller is responsible for properly releasing the returned
  /// pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppParameters pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are AAFParameter objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppComponents or
  /// pNumFetched.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either ppParameters or pNumFetched is null.
  /// 
  /// @param count [in] number of parameter objects requested
  /// @param ppParameters [out, size_is(count), length_is(*pFetched)] array to receive parameter objects
  /// @param pFetched [out,ref] number of actual Parameters fetched into ppParameters array
  ///
  HRESULT Next (
    [in] aafUInt32  count,
    [out, size_is(count), length_is(*pFetched)] IAAFParameter ** ppParameters,
    [out,ref] aafUInt32 *  pFetched);


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not
  /// return those elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  /// 
  /// @param count [in] Number of elements to skip
  ///
  HRESULT Skip (
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  /// 
  /// Always succeeds.
  /// 
  /// This method will return the following code:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// There is no guarantee that the same set of elements will be
  /// enumerated on each pass through the list, nor will the elements
  /// necessarily be enumerated in the same order. The exact behavior
  /// depends on the collection being enumerated.
  /// 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another EnumAAFParameters enumerator with the same state
  /// as the current enumerator to iterate over the same list. This
  /// method makes it possible to record a point in the enumeration
  /// sequence in order to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  /// 
  /// @param ppEnum [out,retval] new enumeration
  ///
  HRESULT Clone (
    [out,retval] IEnumAAFParameters ** ppEnum);
}



// ************************
//
// Interface IEnumAAFPluginDefs
//
// ************************
///
/// An object which allows iteration over all of the AAFPluginDefinitions
/// in the dictionary.  These descriptors describe particular
/// implementation of the particular plugin interface.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
[
    object,
    uuid(AD1BB85F-DBB2-11d2-809C-006008143E6F),
    helpstring("IEnumAAFPluginDefs Interface"),
    pointer_default(unique)
]
interface IEnumAAFPluginDefs : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppPluginDefs pointer is valid.
  /// - there are Plugin Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppPluginDefs.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppPluginDefs arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Plugin Definition objects remaining to be returned.
  /// 
  /// @param ppPluginDefs [out,retval] The Next Plugin Definition
  ///
  HRESULT NextOne (
    [out,retval] IAAFPluginDef ** ppPluginDefs);


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFPluginDef pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppPluginDefs pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are Plugin Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppPluginDefs or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppPluginDefs or pNumFetched arg is NULL.
  /// 
  /// @param count [in] number of PluginDefs requested
  /// @param ppPluginDefs [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual Plugin Definition objects fetched into ppPluginDefs array
  ///
  HRESULT Next (
    [in] aafUInt32  count,
    [out, size_is(count), length_is(*pNumFetched)] IAAFPluginDef ** ppPluginDefs,
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  /// 
  /// @param count [in] Number of elements to skip
  ///
  HRESULT Skip (
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  /// 
  /// @param ppEnum [out,retval] new enumeration
  ///
  HRESULT Clone (
    [out,retval] IEnumAAFPluginDefs ** ppEnum);
}



// ************************
//
// Interface IEnumAAFPluginLocators
//
// ************************
///
/// An object which allows iteration over all of the AAFLocators
/// attached to an AAFPluginDescriptor.  These locators describe how to
/// locate the exact object code described in the AAFPluginDescriptor.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
[
    object,
    uuid(AD1BB861-DBB2-11d2-809C-006008143E6F),
    helpstring("IEnumAAFPluginLocators Interface"),
    pointer_default(unique)
]
interface IEnumAAFPluginLocators : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// @param ppAAFLocator [out,retval] The Next AAFLocator
  ///
  HRESULT NextOne (
    [out,retval] IAAFLocator ** ppAAFLocator);


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFLocator pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// @param count [in] number of AAFLocators requested
  /// @param ppAAFLocators [out, size_is(count), length_is(*pFetched)] array to receive AAFLocators
  /// @param pFetched [out,ref] number of actual AAFLocators fetched into ppAAFLocators array
  ///
  HRESULT Next (
    [in] aafUInt32  count,
    [out, size_is(count), length_is(*pFetched)] IAAFLocator ** ppAAFLocators,
    [out,ref] aafUInt32 *  pFetched);


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to EnumAAFPluginLocators::Next
  /// will not return  those elements.
  /// 
  /// @param count [in] Number of elements to skip
  ///
  HRESULT Skip (
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// There is no guarantee that the same set of elements will be
  /// enumerated on each pass through the list, nor will the elements
  /// necessarily be enumerated inthe same order. The exact behavior
  /// depends on the collection being enumerated.
  /// 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another AAFPluginLocators enumerator with the same state
  /// as the current enumerator to iterate over the same list. This
  /// method makes it possible to record a point in the enumeration
  /// sequence in order to return to that point at a later time.
  ///
  /// The caller must release this new enumerator separately from the
  /// first enumerator.
  /// 
  /// @param ppEnum [out,retval] new enumeration
  ///
  HRESULT Clone (
    [out,retval] IEnumAAFPluginLocators ** ppEnum);
}



// ************************
//
// Interface IEnumAAFProperties
//
// ************************
///
/// This interface is used to enumerate over the AAFProperties
/// contained in a collection.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
[
    object,
    uuid(BE316DB2-7E73-11D2-841D-00600832ACB8),
    helpstring("IEnumAAFProperties Interface"),
    pointer_default(unique)
]
interface IEnumAAFProperties : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppProperties pointer is valid.
  /// - there are Property objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppProperties.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppProperties arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Property objects remaining to be returned.
  /// 
  /// @param ppProperties [out,retval] The Next Property
  ///
  HRESULT NextOne (
    [out,retval] IAAFProperty ** ppProperties);


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFProperty pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppProperties pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are Property objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppProperties or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppProperties or pNumFetched arg is NULL.
  /// 
  /// @param count [in] number of Properties requested
  /// @param ppProperties [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual Property objects fetched into ppProperties array
  ///
  HRESULT Next (
    [in] aafUInt32  count,
    [out, size_is(count), length_is(*pNumFetched)] IAAFProperty ** ppProperties,
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  /// 
  /// @param count [in] Number of elements to skip
  ///
  HRESULT Skip (
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  /// 
  /// @param ppEnum [out,retval] new enumeration
  ///
  HRESULT Clone (
    [out,retval] IEnumAAFProperties ** ppEnum);
}



// ************************
//
// Interface IEnumAAFPropertyDefs
//
// ************************
[
    object,
    uuid(245343C1-2D59-11D2-BF80-00104BC9156D),
    helpstring("IEnumAAFPropertyDefs Interface"),
    pointer_default(unique)
]
interface IEnumAAFPropertyDefs : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppPropertyDefs pointer is valid.
  /// - there are Property Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppPropertyDefs.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppPropertyDefs arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Property Definition objects remaining to be returned.
  /// 
  /// @param ppPropertyDefs [out,retval] The Next Property Definition
  ///
  HRESULT NextOne (
    [out,retval] IAAFPropertyDef ** ppPropertyDefs);


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFPropertyDef pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppPropertyDefs pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are Property Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppPropertyDefs or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppPropertyDefs or pNumFetched arg is NULL.
  /// 
  /// @param count [in] number of PropertyDefs requested
  /// @param ppPropertyDefs [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual Property Definition objects fetched into ppPropertyDefs array
  ///
  HRESULT Next (
    [in] aafUInt32  count,
    [out, size_is(count), length_is(*pNumFetched)] IAAFPropertyDef ** ppPropertyDefs,
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  /// 
  /// @param count [in] Number of elements to skip
  ///
  HRESULT Skip (
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  /// 
  /// @param ppEnum [out,retval] new enumeration
  ///
  HRESULT Clone (
    [out,retval] IEnumAAFPropertyDefs ** ppEnum);
}



// ************************
//
// Interface IEnumAAFPropertyValues
//
// ************************
///
/// This interface is used to enumerate over the AAFPropertyValues
/// contained in a collection.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
[
    object,
    uuid(809c8caa-9884-11d2-841f-00600832acb8),
    helpstring("IEnumAAFPropertyValues Interface"),
    pointer_default(unique)
]
interface IEnumAAFPropertyValues : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppPropertyValue pointer is valid.
  /// - there are Property Values remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppPropertyValue.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppPropertyValue is null.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Components remaining to be returned.
  /// 
  /// @param ppPropertyValue [out,retval] The Next Property Value
  ///
  HRESULT NextOne (
    [out,retval] IAAFPropertyValue ** ppPropertyValue);


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFPropertyValue pointers)
  /// in the enumerator's list, returning them in the given array
  /// along with the actual number of enumerated elements in
  /// pNumFetched. The caller is responsible for properly releasing the
  /// returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppMobs pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL. 
  /// - There are Property Value objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppPropertyValues or
  /// pNumFetched.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either ppCompoents or pNumFetched is null.
  /// 
  /// @param count [in] number of objects requested
  /// @param ppPropertyValues [out, size_is(count), length_is(*pFetched)] array to receive Property Values
  /// @param pFetched [out,ref] number of actual Property Values fetched into ppPropertyValues
	/// array
  ///
  HRESULT Next (
    [in] aafUInt32  count,
    [out, size_is(count), length_is(*pFetched)] IAAFPropertyValue ** ppPropertyValues,
    [out,ref] aafUInt32 *  pFetched);


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not
  /// return those elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  /// 
  /// @param count [in] Number of elements to skip
  ///
  HRESULT Skip (
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// Always succeeds.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another Property Value enumerator with the same state as
  /// the current enumerator to iterate over the same list. This method
  /// makes it possible to record a point in the enumeration sequence
  /// in order to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  /// 
  /// @param ppEnum [out,retval] new enumeration
  ///
  HRESULT Clone (
    [out,retval] IEnumAAFPropertyValues ** ppEnum);
}



// ************************
//
// Interface IEnumAAFRIFFChunks
//
// ************************
///
/// This interface is used to enumerate across RIFFChunk
/// objects.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
[
    object,
    uuid(54716785-ae2a-4e4b-864d-c8831a7f3c61),
    helpstring("IEnumAAFRIFFChunks Interface"),
    pointer_default(unique)
]
interface IEnumAAFRIFFChunks : IUnknown
{


  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppRIFFChunks pointer is valid.
  /// - there are RIFFChunk objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppRIFFChunks.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppRIFFChunks arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no RIFFChunk objects remaining to be returned.
  /// 
  /// @param ppRIFFChunks [out,retval] The Next RIFFChunk
  ///
  HRESULT NextOne (
    [out,retval] IAAFRIFFChunk ** ppRIFFChunks);


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFRIFFChunk pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppRIFFChunks pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are RIFFChunk objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppRIFFChunks or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppRIFFChunks or pNumFetched arg is NULL.
  /// 
  /// @param count [in] number of RIFFChunks requested
  /// @param ppRIFFChunks [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual RIFFChunk objects fetched into ppRIFFChunks array
  ///
  HRESULT Next (
    [in] aafUInt32  count,
    [out, size_is(count), length_is(*pNumFetched)] IAAFRIFFChunk ** ppRIFFChunks,
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  /// 
  /// @param count [in] Number of elements to skip
  ///
  HRESULT Skip (
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  /// 
  /// @param ppEnum [out,retval] new enumeration
  ///
  HRESULT Clone (
    [out,retval] IEnumAAFRIFFChunks ** ppEnum);

}



// ************************
//
// Interface IEnumAAFSegments
//
// ************************
[
    object,
    uuid(B1A213A2-1A7D-11D2-BF78-00104BC9156D),
    helpstring("IEnumAAFSegments Interface"),
    pointer_default(unique)
]
interface IEnumAAFSegments : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppSegments pointer is valid.
  /// - there are Segment objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppSegments.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppSegments arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Segment objects remaining to be returned.
  /// 
  /// @param ppSegments [out,retval] The Next Segment
  ///
  HRESULT NextOne (
    [out,retval] IAAFSegment ** ppSegments);


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFSegment pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppSegments pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are Segment objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppSegments or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppSegments or pNumFetched arg is NULL.
  /// 
  /// @param count [in] number of Segments requested
  /// @param ppSegments [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual Segment objects fetched into ppSegments array
  ///
  HRESULT Next (
    [in] aafUInt32  count,
    [out, size_is(count), length_is(*pNumFetched)] IAAFSegment ** ppSegments,
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  /// 
  /// @param count [in] Number of elements to skip
  ///
  HRESULT Skip (
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  /// 
  /// @param ppEnum [out,retval] new enumeration
  ///
  HRESULT Clone (
    [out,retval] IEnumAAFSegments ** ppEnum);
}



// ************************
//
// Interface IEnumAAFTaggedValueDefs
//
// ************************
[
    object,
    uuid(9d1bd790-16a8-488c-8743-f9a60a1cba95),
    helpstring("IEnumAAFTaggedValueDefs Interface"),
    pointer_default(unique)
]

interface IEnumAAFTaggedValueDefs : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppTaggedValueDefs pointer is valid.
  /// - there are TaggedValue Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppTaggedValueDefs.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTaggedValueDefs arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no TaggedValue Definition objects remaining to be returned.
  /// 
  /// @param ppTaggedValueDefs [out,retval] The Next TaggedValue Definition
  ///
  HRESULT NextOne (
    [out,retval] IAAFTaggedValueDefinition ** ppTaggedValueDefs);


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFTaggedValueDefinition pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppTaggedValueDefs pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are TaggedValue Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppTaggedValueDefs or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppTaggedValueDefs or pNumFetched arg is NULL.
  /// 
  /// @param count [in] number of TaggedValueDefs requested
  /// @param ppTaggedValueDefs [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual TaggedValue Definition objects fetched into ppTaggedValueDefs array
  ///
  HRESULT Next (
    [in] aafUInt32  count,
    [out, size_is(count), length_is(*pNumFetched)] IAAFTaggedValueDefinition ** ppTaggedValueDefs,
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  /// 
  /// @param count [in] Number of elements to skip
  ///
  HRESULT Skip (
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  /// 
  /// @param ppEnum [out,retval] new enumeration
  ///
  HRESULT Clone (
    [out,retval] IEnumAAFTaggedValueDefs ** ppEnum);
}



// ************************
//
// Interface IEnumAAFTaggedValues
//
// ************************
[
    object,
    uuid(5f7916f1-0f87-11d3-8a3e-0050040ef7d2),
    helpstring("IEnumAAFTaggedValues Interface"),
    pointer_default(unique)
]
interface IEnumAAFTaggedValues : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppTaggedValues pointer is valid.
  /// - there are Tagged Value objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppTaggedValues.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTaggedValues arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Tagged Value objects remaining to be returned.
  /// 
  /// @param ppTaggedValues [out,retval] The Next Tagged Value
  ///
  HRESULT NextOne (
    [out,retval] IAAFTaggedValue ** ppTaggedValues);


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFTaggedValue pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppTaggedValues pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are Tagged Value objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppTaggedValues or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppTaggedValues or pNumFetched arg is NULL.
  /// 
  /// @param count [in] number of TaggedValues requested
  /// @param ppTaggedValues [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual Tagged Value objects fetched into ppTaggedValues array
  ///
  HRESULT Next (
    [in] aafUInt32  count,
    [out, size_is(count), length_is(*pNumFetched)] IAAFTaggedValue ** ppTaggedValues,
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  /// 
  /// @param count [in] Number of elements to skip
  ///
  HRESULT Skip (
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  /// 
  /// @param ppEnum [out,retval] new enumeration
  ///
  HRESULT Clone (
    [out,retval] IEnumAAFTaggedValues ** ppEnum);
}



// ************************
//
// Interface IEnumAAFTypeDefs
//
// ************************
[
    object,
    uuid(B1A2138C-1A7D-11D2-BF78-00104BC9156D),
    helpstring("IEnumAAFTypeDefs Interface"),
    pointer_default(unique)
]
interface IEnumAAFTypeDefs : IUnknown
{

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppTypeDefs pointer is valid.
  /// - there are Type Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppTypeDefs.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTypeDefs arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Type Definition objects remaining to be returned.
  /// 
  /// @param ppTypeDefs [out,retval] The Next Type Definition
  ///
  HRESULT NextOne (
    [out,retval] IAAFTypeDef ** ppTypeDefs);


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFTypeDef pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppTypeDefs pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are Type Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppTypeDefs or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppTypeDefs or pNumFetched arg is NULL.
  /// 
  /// @param count [in] number of TypeDefs requested
  /// @param ppTypeDefs [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual Type Definition objects fetched into ppTypeDefs array
  ///
  HRESULT Next (
    [in] aafUInt32  count,
    [out, size_is(count), length_is(*pNumFetched)] IAAFTypeDef ** ppTypeDefs,
    [out,ref] aafUInt32 *  pNumFetched);


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  /// 
  /// @param count [in] Number of elements to skip
  ///
  HRESULT Skip (
    [in] aafUInt32  count);


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  HRESULT Reset ();


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  /// 
  /// @param ppEnum [out,retval] new enumeration
  ///
  HRESULT Clone (
    [out,retval] IEnumAAFTypeDefs ** ppEnum);
}



// ************************
//
// Interface IAAFAES3PCMDescriptor2
//
// ************************
///
/// The IAAFAES3PCMDescriptor2 interface is implemented by objects which
/// describe video essence formatted with one luminance component and 
/// two color-difference components.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///


///
/// Objects that implement IAAFAES3PCMDescriptor2 also implement the following interfaces:
///  - IAAFPCMDescriptor
///  - IAAFSoundDescriptor
///  - IAAFFileDescriptor
///  - IAAFFileDescriptor2
///  - IAAFEssenceDescriptor
///  - IAAFObject
[
    object,
    uuid(5d7d099b-02eb-4dc8-afe8-01ce131f5663),
    helpstring("IAAFAES3PCMDescriptor2 Interface"),
    pointer_default(unique)
]
interface IAAFAES3PCMDescriptor2 : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, IAAFAES3PCMDescriptor-supporting
  /// object. This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  /// 
  HRESULT Initialize ();

  //***********************************************************
  //
  // GetEmphasis()
  //
  /// Gets the Emphasis type property.
  /// Succeeds if all of the following are true:
  /// - pEmphasisType is a valid pointer.
  ///
  /// If this method fails, *pEmphasisType will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEmphasisType arg is NULL.
  /// 
  /// @param pEmphasisType [out] Address to store the emphasis type.
  ///
  HRESULT GetEmphasis (
    [out] aafEmphasisType_t *  pEmphasisType);

  //***********************************************************
  //
  // SetEmphasis()
  //
  /// Gets the Emphasis type property.
  /// Succeeds if all of the following are true:
  /// 
  ///
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param EmphasisType [in] Sets the Emphasis type property.
  ///
  HRESULT SetEmphasis (
    [in] aafEmphasisType_t  EmphasisType);

  //***********************************************************
  //
  // GetBlockStartOffset()
  //
  /// Gets the BlockStartOffset.
  /// Succeeds if all of the following are true:
  /// - pBlockStartOffset is a valid pointer.
  ///
  /// If this method fails, *pBlockStartOffset will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBlockStartOffset arg is NULL.
  /// 
  /// @param pBlockStartOffset [out] Address to store the BlockStartOffset.
  ///
  HRESULT GetBlockStartOffset (
    [out] aafUInt16 *  pBlockStartOffset);

  //***********************************************************
  //
  // SetBlockStartOffset()
  //
  /// Sets the BlockStartOffset.
  /// Succeeds if all of the following are true:
  /// 
  ///
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param BlockStartOffset [in] Sets the BlockStartOffset.
  ///
  HRESULT SetBlockStartOffset (
    [in] aafUInt16  BlockStartOffset);

  //***********************************************************
  //
  // GetAuxBitsMode()
  //
  /// Gets the AuxBitsMode.
  /// Succeeds if all of the following are true:
  /// - pAuxBitsMode is a valid pointer.
  ///
  /// If this method fails, *pAuxBitsMode will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pAuxBitsMode arg is NULL.
  /// 
  /// @param pAuxBitsMode [out] Address to store the AuxBitsMode.
  ///
  HRESULT GetAuxBitsMode (
    [out] aafAuxBitsModeType_t *  pAuxBitsMode);

  //***********************************************************
  //
  // SetAuxBitsMode()
  //
  /// Sets the AuxBitsMode.
  /// Succeeds if all of the following are true:
  /// 
  ///
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param AuxBitsMode [in] Sets the AuxBitsMode.
  ///
  HRESULT SetAuxBitsMode (
    [in] aafAuxBitsModeType_t  AuxBitsMode);

  //***********************************************************
  //
  // GetChannelStatusModeAt()
  //
  /// Gets the ChannelStatusMode for the channel referenced by the index
	/// Succeeds if all of the following are true:
	///	
	/// - pChannelStatusMode is a valid pointer
	/// - index is a valid index with the array of channels
	///
	/// this method will return the following codes
	///
	/// AAFRESULT_SUCCESS
	///   - succeeded.  (This is the only code indicating success.)
	///
	/// AAFRESULT_NOT_INITIALIZED
	///   - This object has not yet had Initialize() called on it.
	///
	/// AAFRESULT_NULL_PARAM
	///	 - pChannelStatusMode arg is NULL
	///
	///	AAFRESULT_BADINDEX
	///	 - index is not a valid index
  /// 
  /// @param index [in] Index of the channel desired.
  /// @param pChannelStatusMode [out] Address to store ChannelStatusMode for the index given.
  ///
  HRESULT GetChannelStatusModeAt (
    [in] aafUInt32  index,
    [out] aafChannelStatusModeType_t *  pChannelStatusMode);

  //***********************************************************
  //
  // SetChannelStatusModeAt()
  //
  /// Sets the ChannelStatusMode for the channel referenced by the index
	/// Succeeds if all of the following are true:
	///	
	/// - index is a valid index with the array of channels
	///
	/// this method will return the following codes
	///
	/// AAFRESULT_SUCCESS
	///   - succeeded.  (This is the only code indicating success.)
	///
	/// AAFRESULT_NOT_INITIALIZED
	///   - This object has not yet had Initialize() called on it.
	///
	///	AAFRESULT_BADINDEX
	///	 - index is not a valid index
  /// 
  /// @param index [in] Index of the channel desired.
  /// @param ChannelStatusMode [in] Set ChannelStatusMode for the index given.
  ///
  HRESULT SetChannelStatusModeAt (
    [in] aafUInt32  index,
    [in] aafChannelStatusModeType_t  ChannelStatusMode);

  //***********************************************************
  //
  // GetFixedChannelStatusDataAt()
  //
  /// Gets the FixedChannelStatusData for the channel referenced by the index
	///		each channel's status is a 24 byte array that gets copied into the 
	///		the address pointed to by pFixedChannelStatusData.
	/// Succeeds if all of the following are true:
	///	
	/// - pFixedChannelStatusData is a valid pointer
	/// - index is a valid index with the array of channels
	/// - sizeOfBuffer must be 24
	///
	/// this method will return the following codes
	///
	/// AAFRESULT_SUCCESS
	///   - succeeded.  (This is the only code indicating success.)
	///
	/// AAFRESULT_NOT_INITIALIZED
	///   - This object has not yet had Initialize() called on it.
	///
	/// AAFRESULT_NULL_PARAM
	///	 - pFixedChannelStatusData arg is NULL
	///
	///	AAFRESULT_BADINDEX
	///	 - index is not a valid index
	///
	/// AAFRESULT_WRONG_SIZE
	///  - buffer size is not correct
  /// 
  /// @param index [in] Index of the channel desired.
  /// @param sizeOfBuffer [in] Size of pFixedChannelStatusData buffer in bytes.
  /// @param pFixedChannelStatusData [out] Address to store FixedChannelStatusData for the index given.
  ///
  HRESULT GetFixedChannelStatusDataAt (
    [in] aafUInt32  index,
    [in] aafUInt32  sizeOfBuffer,
    [out] aafUInt8 *  pFixedChannelStatusData);

  //***********************************************************
  //
  // SetFixedChannelStatusDataAt()
  //
  /// Sets the FixedChannelStatusData for the channel referenced by the index
	///		each channel's status is a 24 byte array that gets copied from the 
	///		the address pointed to by pFixedChannelStatusData .
	/// Succeeds if all of the following are true:
	///	
	/// - pFixedChannelStatusData is a valid pointer
	/// - index is a valid index with the array of channels
	/// - sizeOfBuffer must be 24
	///
	/// this method will return the following codes
	///
	/// AAFRESULT_SUCCESS
	///   - succeeded.  (This is the only code indicating success.)
	///
	/// AAFRESULT_NOT_INITIALIZED
	///   - This object has not yet had Initialize() called on it.
	///
	/// AAFRESULT_NULL_PARAM
	///	 - pFixedChannelStatusData arg is NULL
	///
	///	AAFRESULT_BADINDEX
	///	 - index is not a valid index
	///
	/// AAFRESULT_WRONG_SIZE
	///  - buffer size is not correct
  /// 
  /// @param index [in] Index of the channel desired.
  /// @param sizeOfBuffer [in] Size of pFixedChannelStatusData buffer in bytes.
  /// @param pFixedChannelStatusData [in] Set FixedChannelStatusData for the index given.
  ///
  HRESULT SetFixedChannelStatusDataAt (
    [in] aafUInt32  index,
    [in] aafUInt32  sizeOfBuffer,
    [in] aafUInt8 *  pFixedChannelStatusData);

  //***********************************************************
  //
  // GetUserDataModeAt()
  //
  /// Gets the UserDataMode for the channel referenced by the index
	/// Succeeds if all of the following are true:
	///	
	/// - pUserDataMode is a valid pointer
	/// - index is a valid index with the array of channels
	///
	/// this method will return the following codes
	///
	/// AAFRESULT_SUCCESS
	///   - succeeded.  (This is the only code indicating success.)
	///
	/// AAFRESULT_NOT_INITIALIZED
	///   - This object has not yet had Initialize() called on it.
	///
	/// AAFRESULT_NULL_PARAM
	///	 - pUserDataMode arg is NULL
	///
	///	AAFRESULT_BADINDEX
	///	 - index is not a valid index
  /// 
  /// @param index [in] Index of the channel desired.
  /// @param pUserDataMode [out] Address to store UserDataMode for the index given.
  ///
  HRESULT GetUserDataModeAt (
    [in] aafUInt32  index,
    [out] aafUserDataModeType_t *  pUserDataMode);

  //***********************************************************
  //
  // SetUserDataModeAt()
  //
  /// Sets the UserDataMode for the channel referenced by the index
	/// Succeeds if all of the following are true:
	///	
	/// - index is a valid index with the array of channels
	///
	/// this method will return the following codes
	///
	/// AAFRESULT_SUCCESS
	///   - succeeded.  (This is the only code indicating success.)
	///
	/// AAFRESULT_NOT_INITIALIZED
	///   - This object has not yet had Initialize() called on it.
	///
	///	AAFRESULT_BADINDEX
	///	 - index is not a valid index
  /// 
  /// @param index [in] Index of the channel desired.
  /// @param UserDataMode [in] Set UserDataMode for the index given.
  ///
  HRESULT SetUserDataModeAt (
    [in] aafUInt32  index,
    [in] aafUserDataModeType_t  UserDataMode);

  //***********************************************************
  //
  // GetFixedUserDataAt()
  //
  /// Gets the FixedUserData for the channel referenced by the index
	///		each channel's status is a 24 byte array that gets copied into the 
	///		the address pointed to by pFixedUserData.
	/// Succeeds if all of the following are true:
	///	
	/// - pFixedUserData is a valid pointer
	/// - index is a valid index with the array of channels
	/// - sizeOfBuffer must be 24
	///
	/// this method will return the following codes
	///
	/// AAFRESULT_SUCCESS
	///   - succeeded.  (This is the only code indicating success.)
	///
	/// AAFRESULT_NOT_INITIALIZED
	///   - This object has not yet had Initialize() called on it.
	///
	/// AAFRESULT_NULL_PARAM
	///	 - pFixedUserData arg is NULL
	///
	///	AAFRESULT_BADINDEX
	///	 - index is not a valid index
	///
	/// AAFRESULT_WRONG_SIZE
	///  - buffer size is not correct
  /// 
  /// @param index [in] Index of the channel desired.
  /// @param sizeOfBuffer [in] Size of pFixedUserData buffer in bytes.
  /// @param pFixedUserData [out] Address to store FixedUserData for the index given.
  ///
  HRESULT GetFixedUserDataAt (
    [in] aafUInt32  index,
    [in] aafUInt32  sizeOfBuffer,
    [out] aafUInt8 *  pFixedUserData);

  //***********************************************************
  //
  // SetFixedUserDataAt()
  //
  /// Sets the FixedUserData for the channel referenced by the index
	///		each channel's status is a 24 byte array that gets copied from the 
	///		the address pointed to by pFixedUserData .
	/// Succeeds if all of the following are true:
	///	
	/// - pFixedUserData is a valid pointer
	/// - index is a valid index with the array of channels
	/// - sizeOfBuffer must be 24
	///
	/// this method will return the following codes
	///
	/// AAFRESULT_SUCCESS
	///   - succeeded.  (This is the only code indicating success.)
	///
	/// AAFRESULT_NOT_INITIALIZED
	///   - This object has not yet had Initialize() called on it.
	///
	/// AAFRESULT_NULL_PARAM
	///	 - pFixedUserData arg is NULL
	///
	///	AAFRESULT_BADINDEX
	///	 - index is not a valid index
	///
	/// AAFRESULT_WRONG_SIZE
	///  - buffer size is not correct
  /// 
  /// @param index [in] Index of the channel desired.
  /// @param sizeOfBuffer [in] Size of pFixedUserData buffer in bytes.
  /// @param pFixedUserData [in] Set FixedUserData for the index given.
  ///
  HRESULT SetFixedUserDataAt (
    [in] aafUInt32  index,
    [in] aafUInt32  sizeOfBuffer,
    [in] aafUInt8 *  pFixedUserData);

}



// ************************
//
// Interface IAAFCDCIDescriptor2
//
// ************************
///
/// The IAAFCDCIDescriptor2 interface is implemented by objects which
/// describe video essence formatted with one luminance component and 
/// two color-difference components.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///


///
/// Objects that implement IAAFCDCIDescriptor2 also implement the following interfaces:
///  - IAAFDigitalImageDescriptor
///  - IAAFDigitalImageDescriptor2
///  - IAAFFileDescriptor
///  - IAAFFileDescriptor2
///  - IAAFEssenceDescriptor
///  - IAAFObject
[
    object,
    uuid(82B83210-7E2C-417E-92BA-8F42C195906E),
    helpstring("IAAFCDCIDescriptor2 Interface"),
    pointer_default(unique)
]
interface IAAFCDCIDescriptor2 : IUnknown
{


  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty
  /// IAAFCDCIDescriptor2-supporting object.  This method must be called
  /// after allocation, and before any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  /// 
  HRESULT Initialize ();


  //***********************************************************
  //
  // SetComponentWidth()
  //
  /// Sets the ComponentWidth property.  Specifies the number of bits
  /// used to store each component.  Typical values can be 8, 10,
  /// 12, 14, or 16, but others are permitted by the reference
  /// implementation.  Each component in a sample is packed
  /// contiguously; the sample is filled with the number of bits
  /// specified by the optional PaddingBits property.  If  the
  /// PaddingBits property is omitted, samples are packed
  /// contiguously.
  ///
  /// If this method fails, the ComponentWidth property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param ComponentWidth [in] Number of bits.
  ///
  HRESULT SetComponentWidth (
    [in] aafInt32  ComponentWidth);


  //***********************************************************
  //
  // GetComponentWidth()
  //
  /// Gets the ComponentWidth property.  Specifies the number of bits
  /// used to store each component.  Typical values can be 8, 10,
  /// 12, 14, or 16, but others are permitted by the reference
  /// implementation.  Each component in a sample is packed
  /// contiguously; the sample is filled with the number of bits
  /// specified by the optional PaddingBits property.  If the
  /// PaddingBits property is omitted, samples are packed
  /// contiguously.
  ///
  /// Succeeds if all of the following are true:
  /// - pComponentWidth is a valid pointer.
  /// 
  /// If this method fails, *pComponentWidth will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pComponentWidth arg is NULL.
  /// 
  /// @param pComponentWidth [out] Address to store the number of bits.
  ///
  HRESULT GetComponentWidth (
    [out] aafInt32 *  pComponentWidth);


  //***********************************************************
  //
  // SetHorizontalSubsampling()
  //
  /// Sets the HorizontalSubsampling property.  Specifies the ratio of
  /// luminance sampling to chrominance sampling in the horizontal direction.
  /// For 4:2:2 video, the value is 2, which means that there are twice as
  /// many luminance values as there are color-difference values.
  /// Another typical value is 1; however other values are permitted by
  /// the reference implementation.
  ///
  /// If this method fails, the HorizontalSubsampling property will
  /// not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param HorizontalSubsampling [in] Integer value.
  ///
  HRESULT SetHorizontalSubsampling (
    [in] aafUInt32  HorizontalSubsampling);


  //***********************************************************
  //
  // GetHorizontalSubsampling()
  //
  /// Gets the HorizontalSubsampling property.  Specifies the ratio of
  /// luminance sampling to chrominance sampling in the horizontal
  /// direction.  For 4:2:2 video, the value is 2, which means that
  /// there are twice as many luminance values as there are
  /// color-difference values.  Another typical value is 1; however
  /// other values are permitted by the reference implementation.
  ///
  /// Succeeds if all of the following are true:
  /// - pHorizontalSubsampling is a valid pointer.
  /// 
  /// If this method fails, *pHorizontalSubsampling will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pHorizontalSubsampling arg is NULL.
  /// 
  /// @param pHorizontalSubsampling [out] Address to store the integer value.
  ///
  HRESULT GetHorizontalSubsampling (
    [out] aafUInt32 *  pHorizontalSubsampling);


  //***********************************************************
  //
  // SetVerticalSubsampling()
  //
  /// Sets the VerticalSubsampling property.  Specifies the ratio of
  /// luminance sampling to chrominance sampling in the vertical direction.
  /// For 4:2:2 video, the value is 2, which means that there are twice as
  /// many luminance values as there are color-difference values.
  /// Another typical value is 1; however other values are permitted by
  /// the reference implementation.
  ///
  /// If this method fails, the VerticalSubsampling property will
  /// not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param VerticalSubsampling [in] Integer value.
  ///
  HRESULT SetVerticalSubsampling (
    [in] aafUInt32  VerticalSubsampling);


  //***********************************************************
  //
  // GetVerticalSubsampling()
  //
  /// Gets the VerticalSubsampling property.  Specifies the ratio of
  /// luminance sampling to chrominance sampling in the vertical
  /// direction.  For 4:2:2 video, the value is 2, which means that
  /// there are twice as many luminance values as there are
  /// color-difference values.  Another typical value is 1; however
  /// other values are permitted by the reference implementation.
  ///
  /// Succeeds if all of the following are true:
  /// - pVerticalSubsampling is a valid pointer.
  /// 
  /// If this method fails, *pVerticalSubsampling will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pVerticalSubsampling arg is NULL.
  /// 
  /// @param pVerticalSubsampling [out] Address to store the integer value.
  ///
  HRESULT GetVerticalSubsampling (
    [out] aafUInt32 *  pVerticalSubsampling);


  //***********************************************************
  //
  // SetColorSiting()
  //
  /// Sets the ColorSiting property.  Specifies how to compute subsampled
  /// chrominance values.
  ///
  /// Valid values are:
  ///
  ///     kCoSiting  - To calculate subsampled pixels, take the preceding's pixels
  ///                  color value, discard the other color values and cosite the
  ///                  color with the first luminance value.
  ///
  ///     kAveraging - To calculate subsampled pixels, take the average of the two
  ///                  adjacent pixels' color values and site the color in the center
  ///                  of the luminance pixels.
  ///
  ///     kThreeTap  - To calculate subsampled pixels, take 25 percent of the the previous
  ///                  pixel's color value, 50 percent of the first value and 25 percent
  ///                  of the second value.  For the first value in a row, use 75 percent
  ///                  of that value since there is no previous value.  The kThreeTap value
  ///                  is only meaningful when the HorizontalSubsampling propert has a value
  ///                  of 2.
  ///
  /// This property is optional.  The default value is kCoSiting.
  ///
  /// Succeeds if all of the following are true:
  /// - ColorSiting is valid
  ///
  /// If this method fails, the ColorSiting property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param ColorSiting [in] Color siting value.
  ///
  HRESULT SetColorSiting (
    [in] aafColorSiting_t  ColorSiting);


  //***********************************************************
  //
  // GetColorSiting()
  //
  /// Gets the ColorSiting property.  Specifies how to compute
  /// subsampled chrominance values.
  ///
  /// Valid values are:
  ///
  ///     kCoSiting  - To calculate subsampled pixels, take the
  ///                  preceding's pixels color value, discard the
  ///                  other color values and cosite the color with the
  ///                  first luminance value.
  ///
  ///     kAveraging - To calculate subsampled pixels, take the
  ///                  average of the two adjacent pixels' color values
  ///                  and site the color in the center of the
  ///                  luminance pixels.
  ///
  ///     kThreeTap  - To calculate subsampled pixels, take 25 percent
  ///                  of the the previous pixel's color value, 50
  ///                  percent of the first value and 25 percent of the
  ///                  second value.  For the first value in a row,
  ///                  use 75 percent of that value since there is no
  ///                  previous value.  The kThreeTap value is only
  ///                  meaningful when the HorizontalSubsampling
  ///                  propert has a value of 2.
  ///
  /// Succeeds if all of the following are true:
  /// - pColorSiting is a valid pointer.
  ///
  /// If this method fails, *pColorSiting will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pColorSiting arg is NULL.
  /// 
  /// @param pColorSiting [out] Address to store the color siting value.
  ///
  HRESULT GetColorSiting (
    [out] aafColorSiting_t *  pColorSiting);


  //***********************************************************
  //
  // SetBlackReferenceLevel()
  //
  /// Sets the BlackReferenceLevel property.  Specifies the digital luminance
  /// component component value associated with black.
  ///
  /// For CCIR-601/2, the value is 16 for 8-bit video and 64 for
  /// 10-bit video.  For YUV, the value is 0.  These are typical
  /// values; other values will not be disallowed by the reference
  /// implementation.
  ///
  /// The same value is used in CDCI and RGBA when standard colorspace
  /// conversion is used.
  ///
  /// This property is optional.  The default value is 0.
  ///
  /// If this method fails, the BlackReferenceLevel property will not
  /// be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param BlackReferenceLevel [in] Integer value.
  ///
  HRESULT SetBlackReferenceLevel (
    [in] aafUInt32  BlackReferenceLevel);


  //***********************************************************
  //
  // GetBlackReferenceLevel()
  //
  /// Gets the BlackReferenceLevel property.  Specifies the digital
  /// luminance component value associated with black.
  ///
  /// For CCIR-601/2, the value is 16 for 8-bit video and 64 for
  /// 10-bit video.  For YUV, the value is 0.  These are typical
  /// values; other values will not be disallowed by the reference
  /// implementation.
  ///
  /// The same value is used in CDCI and RGBA when standard colorspace
  /// conversion is used.
  ///
  /// Succeeds if all of the following are true:
  /// - pBlackReferenceLevel is a valid pointer.
  /// 
  /// If this method fails, *pBlackReferenceLevel will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBlackReferenceLevel arg is NULL.
  /// 
  /// @param pBlackReferenceLevel [out] Address to store the integer value.
  ///
  HRESULT GetBlackReferenceLevel (
    [out] aafUInt32 *  pBlackReferenceLevel);


  //***********************************************************
  //
  // SetWhiteReferenceLevel()
  //
  /// Sets the WhiteReferenceLevel property.  Specifies the digital
  /// luminance component component value associated with white.
  ///
  /// For CCIR-601/2, the value is 235 for 8-bit video and 940 for
  /// 10-bit video.  For YUV, the value is 255 for 8-bit video and
  /// 1023 for 10-bit video.  These are typical values; other values
  /// will not be disallowed by the reference implementation.
  ///
  /// This property is optional.  The default value is the maximum
  /// unsigned interger value for component size.
  ///
  /// If this method fails, the WhiteReferenceLevel property will not
  /// be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param WhiteReferenceLevel [in] Integer value.
  ///
  HRESULT SetWhiteReferenceLevel (
    [in] aafUInt32  WhiteReferenceLevel);


  //***********************************************************
  //
  // GetWhiteReferenceLevel()
  //
  /// Gets the WhiteReferenceLevel property.  Specifies the digital
  /// luminance component component value associated with white.
  ///
  /// For CCIR-601/2, the value is 235 for 8-bit video and 940 for
  /// 10-bit video.  For YUV, the value is 255 for 8-bit video and
  /// 1023 for 10-bit video.  These are typical values; other values
  /// will not be disallowed by the reference implementation.
  ///
  /// Succeeds if all of the following are true:
  /// - pWhiteReferenceLevel is a valid pointer.
  /// 
  /// If this method fails, *pWhiteReferenceLevel will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pWhiteReferenceLevel arg is NULL.
  /// 
  /// @param pWhiteReferenceLevel [out] Address to store the integer value.
  ///
  HRESULT GetWhiteReferenceLevel (
    [out] aafUInt32 *  pWhiteReferenceLevel);


  //***********************************************************
  //
  // SetColorRange()
  //
  /// Sets the ColorRange property.  Specifies the range of allowable
  /// digital chrominance component values.  Chrominance values are
  /// unsigned and the range is centered on 128 for 8-bit video and 512
  /// for 10-bit video.  This value is used for both chrominance
  /// components.
  ///
  /// For CCIR-601/2, the range is 225 for 8-bit video and 897 for
  /// 10-bit video.  For YUV, the range is 255 for 8-bit video and
  /// 1023 for 10-bit video.  These are typical values; other values will
  /// not be disallowed by the reference implementation.
  ///
  /// This property is optional.  The default value is the maximum
  /// unsigned integer value for component size.
  ///
  /// Succeeds if all of the following are true:
  /// 
  /// If this method fails, the ColorRange property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param ColorRange [in] Integer value.
  ///
  HRESULT SetColorRange (
    [in] aafUInt32  ColorRange);


  //***********************************************************
  //
  // GetColorRange()
  //
  /// Gets the ColorRange property.  Specifies the range of allowable
  /// digital chrominance component values.  Chrominance values are
  /// unsigned and the range is centered on 128 for 8-bit video and 512
  /// for 10-bit video.  This value is used for both chrominance
  /// components.
  ///
  /// For CCIR-601/2, the range is 225 for 8-bit video and 897 for
  /// 10-bit video.  For YUV, the range is 255 for 8-bit video and
  /// 1023 for 10-bit video.  These are typical values; other values will
  /// not be disallowed by the reference implementation.
  ///
  /// Succeeds if all of the following are true:
  /// - pColorRange is a valid pointer.
  /// 
  /// If this method fails, *pColorRange will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pColorRange arg is NULL.
  /// 
  /// @param pColorRange [out] Address to store the integer value.
  ///
  HRESULT GetColorRange (
    [out] aafUInt32 *  pColorRange);


  //***********************************************************
  //
  // SetPaddingBits()
  //
  /// Sets the PaddingBits property.  Specifies the number of bits
  /// padded to each pixel.
  ///
  /// This property is optional.  The default value is 0.
  ///
  /// If this method fails, the PaddingBits property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param PaddingBits [in] Number of bits.
  ///
  HRESULT SetPaddingBits (
    [in] aafInt16  PaddingBits);


  //***********************************************************
  //
  // GetPaddingBits()
  //
  /// Gets the PaddingBits property.  Specifies the number of bits
  /// padded to each pixel.
  ///
  ///
  /// Succeeds if all of the following are true:
  /// - pPaddingBits is a valid pointer.
  /// 
  /// If this method fails, pPaddingBits will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPaddingBits arg is NULL.
  /// 
  /// @param pPaddingBits [out] Address to store the number of bits.
  ///
  HRESULT GetPaddingBits (
    [out] aafInt16 *  pPaddingBits);


  //***********************************************************
  //
  // SetAlphaSamplingWidth()
  //
  /// Sets the AlphaSamplingWidth property.
  ///
  /// Succeeds if all of the following are true:
  ///
  /// If this method fails, the AlphaSamplingWidth property will not be
  /// changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param alphaSamplingWidth [in] Optional.
  ///
  HRESULT SetAlphaSamplingWidth (
    [in] aafUInt32  alphaSamplingWidth);

  //***********************************************************
  //
  // GetAlphaSamplingWidth()
  //
  /// Gets the AlphaSamplingWidth property.
  ///
  /// Succeeds if all of the following are true:
  /// - pAlphaSamplingWidth is a valid pointer
  /// - the property is present.
  ///
  /// If this method fails, pAlphaSamplingWidth will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pAlphaSamplingWidth is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pAlphaSamplingWidth [out] Optional.
  ///
  HRESULT GetAlphaSamplingWidth (
    [out] aafUInt32 *  pAlphaSamplingWidth);

  //***********************************************************
  //
  // SetReversedByteOrder()
  //
  /// Sets the ReversedByteOrder property.
  ///
  /// Succeeds if all of the following are true:
  ///
  /// If this method fails, the ReversedByteOrder property will not be
  /// changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param reversedByteOrder [in] Optional.
  ///
  HRESULT SetReversedByteOrder (
    [in] aafBoolean_t  reversedByteOrder);

  //***********************************************************
  //
  // GetReversedByteOrder()
  //
  /// Gets the ReversedByteOrder property.
  ///
  /// Succeeds if all of the following are true:
  /// - pReversedByteOrder is a valid pointer
  /// - the property is present.
  ///
  /// If this method fails, pReversedByteOrder will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pReversedByteOrder is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pReversedByteOrder [out] Optional.
  ///
  HRESULT GetReversedByteOrder (
    [out] aafBoolean_t *  pReversedByteOrder);


}



// ************************
//
// Interface IAAFComponent2
//
// ************************
///
/// The component class represents an essence element.  A Component is
/// an abastract class with two subclasses: Segment and Transition.
/// The GetLength and SetLength only aplies to time-varying media and
/// it is an  optional property. Non time-varying objects DO NOT
/// support this property.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it through
///     this object's primary interface.  Note that IAAFComponent2 is a
///     primary interface for an abstract class, so it is not
///     appropriate for the Initialize() method to exist in this
///     interface.  The Initialize() method is available through the
///     concrete object's primary interface.
///
///
/// Objects that implement IAAFComponent2 also implement the following interfaces:
///  - IAAFObject
[
    object,
    uuid(c703e7f5-b97f-44fb-87da-a412e60ea6aa),
    helpstring("IAAFComponent2 Interface"),
    pointer_default(unique)
]
interface IAAFComponent2 : IUnknown
{




  //***********************************************************
  //
  // SetLength()
  //
  /// Sets the length property value on this component object.
  /// 
  /// Succeeds if all of the following are true:
  /// - the optional length property is present for this object.
  ///
  /// This method deals with an optional property, which will only be
  /// present for time-varying media.
  /// 
  /// If this method fails the length property will not be
  /// changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_BAD_PROP
  ///   - the optional length property is not present for this object.
  /// 
  /// @param length [in] The duration in edit units of this component
  ///
  HRESULT SetLength (
    [in] aafLength_constref  length);


  //***********************************************************
  //
  // GetLength()
  //
  /// Gets the duration in edit units of this component.
  ///	
  /// Succeeds if all of the following are true:
  /// - the pLength pointer is valid.
  /// - the optional length property is present for this object.
  ///
  /// This method deals with an optional property, which will only be
  /// present for time-varying media.
  /// 
  /// If this method fails nothing will be written to *pLength.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLength arg is NULL.
  ///
  /// AAFRESULT_BAD_PROP
  ///   - the optional length property is not present for this object.
  /// 
  /// @param pLength [retval][out] Length of this component
  ///
  HRESULT GetLength (
    [retval][out] aafLength_t *  pLength);
	

  //***********************************************************
  //
  // SetDataDef()
  //
  /// Sets the data definition property AUID on this component.
  /// 
  /// If this method fails the Data Definition property will not be
  /// changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDataDef arg is NULL.
  /// 
  /// @param pDataDef [in] DataDef of this object
  ///
  HRESULT SetDataDef (
    [in] IAAFDataDef * pDataDef);


  //***********************************************************
  //
  // GetDataDef()
  //
  /// Returns data definition object.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppDatadef pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppDatadef.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDatadef arg is NULL.
  /// 
  /// @param ppDatadef [out, retval] DataDef of this object
  ///
  HRESULT GetDataDef (
    [out, retval] IAAFDataDef ** ppDatadef);

  //***********************************************************
  //
  // AppendKLVData()
  //
  /// Appends a pre-existing KLV Data object to the specified
  /// component.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pKLV pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - the pData arg is NULL.
  /// 
  /// @param pData [in] KLV object
  ///
  HRESULT AppendKLVData (
    [in] IAAFKLVData * pData);


  //***********************************************************
  //
  // CountKLVData()
  //
  /// Return total number of KLV data objects attached to this component.
  ///
  /// Succeeds if all of the following are true:
  /// - the pNumData pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pNumComments.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumData arg is NULL.
  /// 
  /// @param pNumData [out] Number of KLV data objects
  ///
  HRESULT CountKLVData (
    [out] aafUInt32 *  pNumData);


  //***********************************************************
  //
  // GetKLVData()
  //
  /// Return the enumeration for all KLV data objects on this component.  The returned
  /// enumerator is AddRef()ed before it is returned.  The enumerator
  /// is implemented as a EnumAAFKLVData.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  /// 
  /// @param ppEnum [out] KLV data objects
  ///
  HRESULT GetKLVData (
    [out] IEnumAAFKLVData ** ppEnum);


  //***********************************************************
  //
  // RemoveKLVData()
  //
  /// Removes the given KLV data object from this component.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pData pointer is valid.
  /// - the given KLV data object is present in the component.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pData is null.
  ///
  /// AAFRESULT_OBJECT_NOT_FOUND
  ///   - the given KLV data object is not in this component.
  /// 
  /// @param pData [in] KLV data object to remove
  ///
  HRESULT RemoveKLVData (
    [in] IAAFKLVData * pData);



  //***********************************************************
  //
  // AppendComment()
  //
  /// Append an attribute name/value pair to the attribute list.
  ///
  /// Creates a new tagged value, initializes it with the specified comment
  /// name/value pair, and appends it to the comment list.
  ///
  /// Succeeds if:
  ///   - pName and pValue are valid pointers.
  ///
  /// Return codes:
  ///
  ///   AAFRESULT_SUCCESS
  ///
  ///   AAFRESULT_NULL_PARAM
  ///	     - pName or pValue is null.
  /// 
  /// @param pName [in] The attribute name.
  /// @param pValue [in] The attribute value.
  ///
  HRESULT AppendComment (
    [in] aafCharacter_constptr  pName,
    [in] aafCharacter_constptr  pValue);

  //***********************************************************
  //
  // CountComments()
  //
  /// Return the number of comments contained in this component.
  ///
  /// Succeeds if:
  ///   - pNumComments is a valid pointer
  ///
  /// Return codes:
  ///
  ///   AAFRESULT_SUCCESS
  ///
  ///   AAFRESULT_NULL_PARAM
  ///	     - pNumComments is null.
  /// 
  /// @param pNumComments [out] Pointer to comment count.
  ///
  HRESULT CountComments (
    [out] aafUInt32*  pNumComments);
  

  //***********************************************************
  //
  // GetComments()
  //
  /// Return a comment enumerator for this component.
  ///
  /// Creates an enumerator for this component's comments.  The new enumerator is
  /// AddRef()ed before it is returned.
  ///
  /// Succeeds if:
  ///   - pName and pValue are valid pointers.
  ///
  /// Return codes:
  ///
  ///   AAFRESULT_SUCCESS
  ///
  ///   AAFRESULT_NULL_PARAM
  ///	     - pEnum was null.
  /// 
  /// @param ppEnum [out] Pointer to the new enumerator object created by this method.
  ///
  HRESULT GetComments (
    [out] IEnumAAFTaggedValues ** ppEnum);


  //***********************************************************
  //
  // RemoveComment()
  //
  /// Remove a component comment (tagged value).
  ///
  /// Succeeds if:
  ///   - pName and pValue are valid pointers.
  ///
  /// Return codes:
  ///
  ///   AAFRESULT_SUCCESS
  ///
  ///   AAFRESULT_NULL_PARAM
  ///	     - pName or pValue is null.
  /// 
  /// @param pComment [in] Pointer to the tagged value comment.
  ///
  HRESULT RemoveComment (
    [in] IAAFTaggedValue * pComment);

  //***********************************************************
  //
  // AppendAttribute()
  //
  /// Append an attribute name/value pair to the attribute list.
  ///
  /// Creates a new tagged value, initializes it with the specified attribute
  /// name/value pair, and appends it to the attribute list.
  ///
  /// Succeeds if:
  ///   - pName and pValue are valid pointers.
  ///
  /// Return codes:
  ///
  ///   AAFRESULT_SUCCESS
  ///
  ///   AAFRESULT_NULL_PARAM
  ///	     - pName or pValue is null.
  /// 
  /// @param pName [in] The attribute name.
  /// @param pValue [in] The attribute value.
  ///
  HRESULT AppendAttribute (
    [in] aafCharacter_constptr  pName,
    [in] aafCharacter_constptr  pValue);

  //***********************************************************
  //
  // CountAttributes()
  //
  /// Return the number of attributes contained in this component.
  ///
  /// Succeeds if:
  ///   - pNumAttributes is a valid pointer
  ///
  /// Return codes:
  ///
  ///   AAFRESULT_SUCCESS
  ///
  ///   AAFRESULT_NULL_PARAM
  ///	     - pNumAttributes is null.
  /// 
  /// @param pNumAttributes [out] Pointer to attribute count.
  ///
  HRESULT CountAttributes (
    [out] aafUInt32*  pNumAttributes);
  

  //***********************************************************
  //
  // GetAttributes()
  //
  /// Return an attribute enumerator for this component.
  ///
  /// Creates an enumerator for this component's attributes.  The new enumerator is
  /// AddRef()ed before it is returned.
  ///
  /// Succeeds if:
  ///   - pName and pValue are valid pointers.
  ///
  /// Return codes:
  ///
  ///   AAFRESULT_SUCCESS
  ///
  ///   AAFRESULT_NULL_PARAM
  ///	     - pEnum was null.
  /// 
  /// @param ppEnum [out] Pointer to the new enumerator object created by this method.
  ///
  HRESULT GetAttributes (
    [out] IEnumAAFTaggedValues ** ppEnum);


  //***********************************************************
  //
  // RemoveAttribute()
  //
  /// Remove a component attribute (tagged value).
  ///
  /// Succeeds if:
  ///   - pName and pValue are valid pointers.
  ///
  /// Return codes:
  ///
  ///   AAFRESULT_SUCCESS
  ///
  ///   AAFRESULT_NULL_PARAM
  ///	     - pName or pValue is null.
  /// 
  /// @param pAttribute [in] Pointer to the tagged value attribute.
  ///
  HRESULT RemoveAttribute (
    [in] IAAFTaggedValue * pAttribute);

}



// ************************
//
// Interface IAAFCompositionMob2
//
// ************************
///
/// The IAAFCompositionMob2 interface is implemented on objects which
/// can specify how to combine content data elements into a sequence,
/// how to modify content data elements, and how to synchronize content
/// data elements.	   
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///


///
/// Objects that implement IAAFCompositionMob2 also implement the following interfaces:
///  - IAAFMob
///  - IAAFMob2
///  - IAAFObject
[
    object,
    uuid(188a82c7-0d87-4af3-89e0-5f96e56ff9de),
    helpstring("IAAFCompositionMob2 Interface"),
    pointer_default(unique)
]
interface IAAFCompositionMob2 : IUnknown
{



  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes this object with the given name.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has not yet been initialized.
  /// - the pName pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName argument is NULL.
  /// 
  /// @param pName [in, string] Mob name [optional]
  ///
  HRESULT Initialize (
    [in, string] aafCharacter_constptr  pName);


  //***********************************************************
  //
  // GetDefaultFade()
  //
  /// Get the default fade for this composition.  If there is no
  /// default fade, this function returns with no error, but the VALID
  /// field of the structure is false.  This allows you to pass this
  /// struct to SourceClip::GetFade() in all cases.
  ///
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the pResult pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult argument is NULL.
  /// 
  /// @param pResult [out] a default fade struct
  ///
  HRESULT GetDefaultFade (
    [out] aafDefaultFade_t *  pResult);
	

  //***********************************************************
  //
  // SetDefaultFade()
  //
  /// Adds the default crossfade properties to the Mob.
  ///
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_BAD_TYPE
  ///   - invalid fadeType.
  ///
  /// AAFRESULT_BAD_LENGTH
  ///   - invalid fadeLength.
  /// 
  /// @param fadeLength [in] Default fade length
  /// @param fadeType [in] default fade type
  /// @param fadeEditUnit [in] default fade edit unit
  ///
  HRESULT SetDefaultFade (
    [in] aafLength_t  fadeLength,
    [in] aafFadeType_t  fadeType,
    [in] aafRational_t  fadeEditUnit);


  //***********************************************************
  //
  // SetRendering()
  //
  /// set the MobID of a rendering of this CompositionMob.

  /// This method will return the following codes:
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param mobID [in, ref] Rendering MobID
  ///
  HRESULT SetRendering (
    [in, ref] aafMobID_constref  mobID);

  //***********************************************************
  //
  // GetRendering()
  //
  /// return the MobID of a rendering of this CompositionMob.

  /// Succeeds if all of the following are true:
  /// - the pMobID pointer is valid.
  ///
  /// If this method fails nothing will be written to *pMobID.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMobID arg is NULL.
  /// 
  /// @param pMobID [out] Rendering MobID
  ///
  HRESULT GetRendering (
    [out] aafMobID_t *  pMobID);


}



// ************************
//
// Interface IAAFDataDef2
//
// ************************

///
/// Objects that implement IAAFDataDef2 also implement the following interfaces:
///  - IAAFDefObject
///  - IAAFObject
[
    object,
    uuid(588951c1-2f10-46da-a20d-6e8e7ac6963c),
    helpstring("IAAFDataDef2 Interface"),
    pointer_default(unique)
]
interface IAAFDataDef2 : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Init all fields of a definition object.
  /// 
  /// @param id [in, ref] AUID for new DefObject
  /// @param pName [in, string] Name for new DefObject
  /// @param pDescription [in, string] Description for new DefObject
  ///
  HRESULT Initialize (
    [in, ref] aafUID_constref  id,
    [in, string] aafCharacter_constptr  pName,
    [in, string] aafCharacter_constptr  pDescription);


  //***********************************************************
  //
  // IsPictureKind()
  //
  /// Sets return value to TRUE if DataDef is a picture.
  /// 
  /// @param bIsPictureKind [retval,out] pointer to the return value
  ///
  HRESULT IsPictureKind (
    [retval,out] aafBoolean_t *  bIsPictureKind);


  //***********************************************************
  //
  // IsMatteKind()
  //
  /// Sets return value to TRUE if DataDef is a matte.
  /// 
  /// @param bIsMatteKind [retval,out] pointer to the return value
  ///
  HRESULT IsMatteKind (
    [retval,out] aafBoolean_t *  bIsMatteKind);


  //***********************************************************
  //
  // IsPictureWithMatteKind()
  //
  /// Sets return value to TRUE if DataDef is a picture with matte.
  /// 
  /// @param bIsPictureWithMatteKind [retval,out] pointer to the return value
  ///
  HRESULT IsPictureWithMatteKind (
    [retval,out] aafBoolean_t *  bIsPictureWithMatteKind);


  //***********************************************************
  //
  // IsSoundKind()
  //
  /// Sets return value to TRUE if DataDef is a sound.
  /// 
  /// @param bIsSoundKind [retval,out] pointer to the return value
  ///
  HRESULT IsSoundKind (
    [retval,out] aafBoolean_t *  bIsSoundKind);


  //***********************************************************
  //
  // DoesDataDefConvertTo()
  //
  /// Sets return value to TRUE if the DataDef of the given object
  /// can be converted to the DataDef specified in the IN 
  /// parameter with the DataDefName string.
  /// 
  /// @param id [in] data def to compare against
  /// @param bDoesConvertTo [retval, out] pointer to result
  ///
  HRESULT DoesDataDefConvertTo (
    [in] IAAFDataDef * id,
    [retval, out] aafBoolean_t *  bDoesConvertTo);
		   

  //***********************************************************
  //
  // IsDataDefOf()
  //
  /// Sets the value to TRUE if the DataDef of the given object
  /// matches the DataDef specified in the IN parameter with the
  /// DataDefName string.
  /// 
  /// @param pDataDef [in] data def to compare against
  /// @param bIsDataDefOf [retval, out] pointer to result
  ///
  HRESULT IsDataDefOf (
    [in] IAAFDataDef * pDataDef,
    [retval, out] aafBoolean_t *  bIsDataDefOf);


  //***********************************************************
  //
  // DoesDataDefConvertFrom()
  //
  /// Sets return value to TRUE if the DataDef of the given object
  /// can be converted from the DataDef specified in the IN 
  /// parameter specified with the DataDefName string.
  /// 
  /// @param pDataDef [in] data def to compare against
  /// @param bDoesConvertFrom [retval, out] pointer to result
  ///
  HRESULT DoesDataDefConvertFrom (
    [in] IAAFDataDef * pDataDef,
    [retval, out] aafBoolean_t *  bDoesConvertFrom);


  //***********************************************************
  //
  // IsEdgecodeKind()
  //
  /// Sets return value to TRUE if DataDef is an edgecode.
  /// 
  /// @param bIsEdgecodeKind [retval,out] pointer to the return value
  ///
  HRESULT IsEdgecodeKind (
    [retval,out] aafBoolean_t *  bIsEdgecodeKind);

  //***********************************************************
  //
  // IsTimecodeKind()
  //
  /// Sets return value to TRUE if DataDef is a timecode.
  /// 
  /// @param bIsTimecodeKind [retval,out] pointer to the return value
  ///
  HRESULT IsTimecodeKind (
    [retval,out] aafBoolean_t *  bIsTimecodeKind);

}



// ************************
//
// Interface IAAFDataDef3
//
// ************************

///
/// Objects that implement IAAFDataDef3 also implement the following interfaces:
///  - IAAFDefObject
///  - IAAFObject
[
    object,
    uuid(858109c4-cb51-48ad-9086-a3fcfe9739fa),
    helpstring("IAAFDataDef3 Interface"),
    pointer_default(unique)
]
interface IAAFDataDef3 : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Init all fields of a definition object.
  /// 
  /// @param id [in, ref] AUID for new DefObject
  /// @param pName [in, string] Name for new DefObject
  /// @param pDescription [in, string] Description for new DefObject
  ///
  HRESULT Initialize (
    [in, ref] aafUID_constref  id,
    [in, string] aafCharacter_constptr  pName,
    [in, string] aafCharacter_constptr  pDescription);


  //***********************************************************
  //
  // IsPictureKind()
  //
  /// Sets return value to TRUE if DataDef is a picture.
  /// 
  /// @param bIsPictureKind [retval,out] pointer to the return value
  ///
  HRESULT IsPictureKind (
    [retval,out] aafBoolean_t *  bIsPictureKind);


  //***********************************************************
  //
  // IsMatteKind()
  //
  /// Sets return value to TRUE if DataDef is a matte.
  /// 
  /// @param bIsMatteKind [retval,out] pointer to the return value
  ///
  HRESULT IsMatteKind (
    [retval,out] aafBoolean_t *  bIsMatteKind);


  //***********************************************************
  //
  // IsPictureWithMatteKind()
  //
  /// Sets return value to TRUE if DataDef is a picture with matte.
  /// 
  /// @param bIsPictureWithMatteKind [retval,out] pointer to the return value
  ///
  HRESULT IsPictureWithMatteKind (
    [retval,out] aafBoolean_t *  bIsPictureWithMatteKind);


  //***********************************************************
  //
  // IsSoundKind()
  //
  /// Sets return value to TRUE if DataDef is a sound.
  /// 
  /// @param bIsSoundKind [retval,out] pointer to the return value
  ///
  HRESULT IsSoundKind (
    [retval,out] aafBoolean_t *  bIsSoundKind);


  //***********************************************************
  //
  // DoesDataDefConvertTo()
  //
  /// Sets return value to TRUE if the DataDef of the given object
  /// can be converted to the DataDef specified in the IN 
  /// parameter with the DataDefName string.
  /// 
  /// @param id [in] data def to compare against
  /// @param bDoesConvertTo [retval, out] pointer to result
  ///
  HRESULT DoesDataDefConvertTo (
    [in] IAAFDataDef * id,
    [retval, out] aafBoolean_t *  bDoesConvertTo);
		   

  //***********************************************************
  //
  // IsDataDefOf()
  //
  /// Sets the value to TRUE if the DataDef of the given object
  /// matches the DataDef specified in the IN parameter with the
  /// DataDefName string.
  /// 
  /// @param pDataDef [in] data def to compare against
  /// @param bIsDataDefOf [retval, out] pointer to result
  ///
  HRESULT IsDataDefOf (
    [in] IAAFDataDef * pDataDef,
    [retval, out] aafBoolean_t *  bIsDataDefOf);


  //***********************************************************
  //
  // DoesDataDefConvertFrom()
  //
  /// Sets return value to TRUE if the DataDef of the given object
  /// can be converted from the DataDef specified in the IN 
  /// parameter specified with the DataDefName string.
  /// 
  /// @param pDataDef [in] data def to compare against
  /// @param bDoesConvertFrom [retval, out] pointer to result
  ///
  HRESULT DoesDataDefConvertFrom (
    [in] IAAFDataDef * pDataDef,
    [retval, out] aafBoolean_t *  bDoesConvertFrom);


  //***********************************************************
  //
  // IsEdgecodeKind()
  //
  /// Sets return value to TRUE if DataDef is an edgecode.
  /// 
  /// @param bIsEdgecodeKind [retval,out] pointer to the return value
  ///
  HRESULT IsEdgecodeKind (
    [retval,out] aafBoolean_t *  bIsEdgecodeKind);

  //***********************************************************
  //
  // IsTimecodeKind()
  //
  /// Sets return value to TRUE if DataDef is a timecode.
  /// 
  /// @param bIsTimecodeKind [retval,out] pointer to the return value
  ///
  HRESULT IsTimecodeKind (
    [retval,out] aafBoolean_t *  bIsTimecodeKind);


  //***********************************************************
  //
  // IsAuxiliaryKind()
  //
  /// Sets return value to TRUE if DataDef is auxiliary.
  /// 
  /// @param bIsAuxiliaryKind [retval,out] pointer to the return value
  ///
  HRESULT IsAuxiliaryKind (
    [retval,out] aafBoolean_t *  bIsAuxiliaryKind);

  //***********************************************************
  //
  // IsDescriptiveMetadataKind()
  //
  /// Sets return value to TRUE if DataDef is descriptive metadata.
  /// 
  /// @param bIsDescriptiveMetadataKind [retval,out] pointer to the return value
  ///
  HRESULT IsDescriptiveMetadataKind (
    [retval,out] aafBoolean_t *  bIsDescriptiveMetadataKind);

}



// ************************
//
// Interface IAAFDiagnosticOutput
//
// ************************
///
/// This interface is used by AAF Toolkit as an output stream to which
/// it writes diagnostic messages. AAF Toolkit clients can create their
/// own implementation of this interface  The default implementation of
/// AAFDiagnosticOutput is a wrapper for the standard error stream (stderr).
///
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.


[
    object,
    uuid(C9346826-1CFE-4AEF-BA4D-54D414138739),
    helpstring("IAAFDiagnosticOutput Interface"),
    pointer_default(unique)
]

interface IAAFDiagnosticOutput : IUnknown
{


  //***********************************************************
  //
  // PutString()
  //
  /// This method is called by the AAF toolkit to write a string
  /// to this diagnostic output.
  /// 
  /// @param pString [in, string] string to print out
  ///
  HRESULT PutString (
    [in, string] aafCharacter_constptr  pString);

}



// ************************
//
// Interface IAAFDictionary2
//
// ************************
///
/// This interface is used to access dictionary services in an AAF
/// file.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// Objects that implement IAAFDictionary2 also implement the following interfaces:
///  - IAAFObject
[
    object,
    uuid(952a5c85-dcec-4c99-8e40-978d88a0cdc1),
    helpstring("IAAFDictionary2 Interface"),
    pointer_default(unique)
]
interface IAAFDictionary2 : IUnknown
{

  //***********************************************************
  //
  // CreateInstance()
  //
  /// Creates a single uninitialized AAF object of the class associated 
  /// with a specified stored object id. 
  ///
  /// @param[in] id Class identifier (id) of the stored object. This is the
  ///               corresponding SMPTE identifier (as a GUID) for all
  ///               predefined built-in classes.
  /// @param[in] riid Reference to the identifier of the interface
  /// @param[out] ppvObject Address of output variable that receives the
  ///                       interface pointer requested in riid
  ///
  HRESULT CreateInstance(
    [in, ref] aafUID_constref id,
    [in, ref] REFIID riid,
    [out, iid_is(riid)] IUnknown ** ppvObject);


  //***********************************************************
  //
  // CreateMetaInstance()
  //
  /// Creates a single uninitialized AAF meta class or type associated 
  /// with a specified stored object id. 
  /// 
  /// @param[in] id Identifier (id) of a class or type definition. This is
  ///               the corresponding SMPTE identifier (as a GUID) for all
  ///               predefined built-in definitions.
  /// @param[in] riid Reference to the identifier of the interface
  /// @param[out] ppMetaDefinition Address of output variable that receives
  ///                              the interface pointer requested in riid
  ///
  HRESULT CreateMetaInstance(
    [in, ref] aafUID_constref id,
    [in, ref] REFIID riid,
    [out, iid_is(riid)] IUnknown ** ppMetaDefinition);




  //***********************************************************
  //
  // RegisterClassDef()
  //
  /// Add the class definition object to the dictionary.
  /// 
  /// Succeeds if:
  /// - The pClassDef pointer is valid.
  /// - the ID contained in the class def is not already been
  ///   registered.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pClassDef arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The class def ID has already been registered.
  /// 
  /// @param pClassDef [in] Class Definition
  ///
  HRESULT RegisterClassDef (
    [in] IAAFClassDef * pClassDef);


  //***********************************************************
  //
  // LookupClassDef()
  //
  /// Return the class definition with the given id.
  /// 
  /// Succeeds if:
  /// - The pClassID pointer is valid.
  /// - The ppClassDef pointer is valid.
  /// - the ID is a recognized id for a class definition.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pClassID or ppClassDef arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given ID is not recognized as a class definition ID.
  /// 
  /// @param classId [in, ref] Class Unique ID
  /// @param ppClassDef [out,retval] Class Definition
  ///
  HRESULT LookupClassDef (
    [in, ref] aafUID_constref  classId,
    [out,retval] IAAFClassDef ** ppClassDef);


  //***********************************************************
  //
  // GetClassDefs()
  //
  /// Return an enumerator for all class definitions.
  ///
  /// Succeeds if:
  /// - The ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  /// 
  /// @param ppEnum [out,retval] Class Definition Enumeration
  ///
  HRESULT GetClassDefs (
    [out,retval] IEnumAAFClassDefs ** ppEnum);


  //***********************************************************
  //
  // CountClassDefs()
  //
  /// Writes the number of class definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  /// 
  /// @param pResult [out, retval] Total number of class definition objects
  ///
  HRESULT CountClassDefs (
    [out, retval] aafUInt32 *  pResult);

  //***********************************************************
  //
  // CreateForwardClassReference()
  //
  /// Return the class definition with the given id.
  /// 
  /// Succeeds if:
  /// - The classId does not represent an existing forward class reference
  ///   or a class definition that has already been successfully registered.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given ID is not recognized as a class definition ID.
  /// 
  /// @param classId [in, ref] Class Unique ID
  ///
  HRESULT CreateForwardClassReference (
    [in, ref] aafUID_constref  classId);

  //***********************************************************
  //
  // HasForwardClassReference()
  //
  /// Return kAAFTrue if the given class identification is a forward reference.
  /// 
  /// Succeeds if:
  /// - The pClassID pointer is valid.
  /// - The ppClassDef pointer is valid.
  /// - the ID is a recognized id for a class definition.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pClassID or ppClassDef arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given ID is not recognized as a class definition ID.
  /// 
  /// @param classId [in, ref] Class Unique ID
  /// @param pResult [out,retval] true if forward class reference; false if not a forward class reference
  ///
  HRESULT HasForwardClassReference (
    [in, ref] aafUID_constref  classId,
    [out,retval] aafBoolean_t *  pResult);

  //***********************************************************
  //
  // RegisterTypeDef()
  //
  /// Add the type definition object to the dictionary.
  /// 
  /// Succeeds if:
  /// - The pTypeDef pointer is valid.
  /// - the ID is not already been registered.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pClassDef arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given type has already been registered.
  /// 
  /// @param pTypeDef [in] Type Definition Object
  ///
  HRESULT RegisterTypeDef (
    [in] IAAFTypeDef * pTypeDef);


  //***********************************************************
  //
  // LookupTypeDef()
  //
  /// Return the type definition object with the given id.
  /// 
  /// Succeeds if:
  /// - The pTypeID pointer is valid.
  /// - The ppTypeDef pointer is valid.
  /// - the ID is a recognized id for a type definition.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pTypeID or ppTypeDef arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given ID is not recognized as a type definition ID.
  /// 
  /// @param typeId [in, ref] Type Unique ID
  /// @param ppTypeDef [out,retval] Type Definition Object
  ///
  HRESULT LookupTypeDef (
    [in, ref] aafUID_constref  typeId,
    [out,retval] IAAFTypeDef ** ppTypeDef);


  //***********************************************************
  //
  // GetTypeDefs()
  //
  /// Return an enumerator for all type definitions.
  ///
  /// Succeeds if:
  /// - The ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  /// 
  /// @param ppEnum [out,retval] Type Def Enumeration
  ///
  HRESULT GetTypeDefs (
    [out,retval] IEnumAAFTypeDefs ** ppEnum);


  //***********************************************************
  //
  // CountTypeDefs()
  //
  /// Writes the number of type definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  /// 
  /// @param pResult [out, retval] Total number of type definition objects
  ///
  HRESULT CountTypeDefs (
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // RegisterOpaqueTypeDef()
  //
  /// Add the opaquetype definition object to the dictionary.
  /// 
  /// Succeeds if:
  /// - The pTypeDef pointer is valid.
  /// - the definition is not already been registered with RegisterTypeDef.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTypeDef arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given type has already been registered.
  /// 
  /// @param pTypeDef [in] Type Definition Object
  ///
  HRESULT RegisterOpaqueTypeDef (
    [in] IAAFTypeDef * pTypeDef);


  //***********************************************************
  //
  // LookupOpaqueTypeDef()
  //
  /// Return the opaque type definition object with the given id.
  /// 
  /// Succeeds if:
  /// - The pTypeID pointer is valid.
  /// - The ppTypeDef pointer is valid.
  /// - the ID is a recognized id for an opaque type definition.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either typeId or ppTypeDef arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given ID is not recognized as a type definition ID.
  /// 
  /// @param typeId [in, ref] Type Unique ID
  /// @param ppTypeDef [out,retval] Type Definition Object
  ///
  HRESULT LookupOpaqueTypeDef (
    [in, ref] aafUID_constref  typeId,
    [out,retval] IAAFTypeDef ** ppTypeDef);


  //***********************************************************
  //
  // GetOpaqueTypeDefs()
  //
  /// Return an enumerator for all registered opaque type definitions.
  ///
  /// Succeeds if:
  /// - The ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  /// 
  /// @param ppEnum [out,retval] Type Def Enumeration
  ///
  HRESULT GetOpaqueTypeDefs (
    [out,retval] IEnumAAFTypeDefs ** ppEnum);


  //***********************************************************
  //
  // CountOpaqueTypeDefs()
  //
  /// Writes the number of opaque type definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  /// 
  /// @param pResult [out, retval] Total number of opaque type definition objects
  ///
  HRESULT CountOpaqueTypeDefs (
    [out, retval] aafUInt32 *  pResult);

  //***********************************************************
  //
  // RegisterKLVDataKey()
  //
  /// Add the definition for the given KLV key to the runtime dictionary.
  /// The pTypeDef will often be kAAFTypeID_UInt8Array,
  /// but may be something else.
  /// 
  /// Succeeds if:
  /// - The pTypeDef pointer is valid.
  /// - the definition is not already been registered with RegisterTypeDef.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTypeDef arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given type has already been registered.
  /// 
  /// @param pUID [in] Key to define
  /// @param pTypeDef [in] Type Definition Object
  ///
  HRESULT RegisterKLVDataKey (
    [in] aafUID_t  pUID,
    [in] IAAFTypeDef * pTypeDef);

  //***********************************************************
  //
  // RegisterDataDef()
  //
  /// Add the data definition object to the header's list of definitions.
  /// 
  /// @param pDataDef [in] Data Definition Object
  ///
  HRESULT RegisterDataDef (
    [in] IAAFDataDef * pDataDef);


  //***********************************************************
  //
  // LookupDataDef()
  //
  /// Return the data definition object with the given id.
  /// 
  /// @param dataDefinitionId [in, ref] Data Definition Unique ID
  /// @param ppDataDef [out,retval] Data Definition Object
  ///
  HRESULT LookupDataDef (
    [in, ref] aafUID_constref  dataDefinitionId,
    [out,retval] IAAFDataDef ** ppDataDef);


  //***********************************************************
  //
  // GetDataDefs()
  //
  /// Return an enumerator for aff data definitions.
  /// 
  /// @param ppEnum [out,retval] Definition Enumeration
  ///
  HRESULT GetDataDefs (
    [out,retval] IEnumAAFDataDefs ** ppEnum);


  //***********************************************************
  //
  // CountDataDefs()
  //
  /// Writes the number of data definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  /// 
  /// @param pResult [out, retval] Total number of data definition objects
  ///
  HRESULT CountDataDefs (
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // RegisterOperationDef()
  //
  /// Add the operation definition object to the header's list of definitions.
  /// 
  /// @param pOperationDef [in] Operation Definition Object
  ///
  HRESULT RegisterOperationDef (
    [in] IAAFOperationDef * pOperationDef);


  //***********************************************************
  //
  // LookupOperationDef()
  //
  /// Return the operation definition object with the given id.
  /// 
  /// @param operationId [in, ref] Operation Def Unique ID
  /// @param ppOperationDef [out,retval] Operation definition object
  ///
  HRESULT LookupOperationDef (
    [in, ref] aafUID_constref  operationId,
    [out,retval] IAAFOperationDef ** ppOperationDef);


  //***********************************************************
  //
  // GetOperationDefs()
  //
  /// Return an enumerator for all operation definitions.
  /// 
  /// @param ppEnum [out,retval] Definition Enumeration
  ///
  HRESULT GetOperationDefs (
    [out,retval] IEnumAAFOperationDefs ** ppEnum);


  //***********************************************************
  //
  // CountOperationDefs()
  //
  /// Writes the number of operation definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  /// 
  /// @param pResult [out, retval] Total number of operation definition objects
  ///
  HRESULT CountOperationDefs (
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // RegisterParameterDef()
  //
  /// Add the parameter definition object to the header's list of definitions.
  /// 
  /// @param pParmDef [in] Parameter Definition Object
  ///
  HRESULT RegisterParameterDef (
    [in] IAAFParameterDef * pParmDef);


  //***********************************************************
  //
  // LookupParameterDef()
  //
  /// Return the parameter definition object with the given id.
  /// 
  /// @param parameterId [in, ref] Parameter Unique ID
  /// @param ppParmDef [out,retval] Parameter definition object
  ///
  HRESULT LookupParameterDef (
    [in, ref] aafUID_constref  parameterId,
    [out,retval] IAAFParameterDef ** ppParmDef);


  //***********************************************************
  //
  // GetParameterDefs()
  //
  /// Return an enumerator for all parameter definitions.
  /// 
  /// @param ppEnum [out,retval] Definition Enumeration
  ///
  HRESULT GetParameterDefs (
    [out,retval] IEnumAAFParameterDefs ** ppEnum);


  //***********************************************************
  //
  // CountParameterDefs()
  //
  /// Writes the number of parameter definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  /// 
  /// @param pResult [out, retval] Total number of parameter definition objects
  ///
  HRESULT CountParameterDefs (
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // RegisterCodecDef()
  //
  /// Add the codec definition object to the header's list of definitions.
  /// 
  /// @param pParmDef [in] Codec Definition Object
  ///
  HRESULT RegisterCodecDef (
    [in] IAAFCodecDef * pParmDef);


  //***********************************************************
  //
  // LookupCodecDef()
  //
  /// Return the codec definition object with the given id.
  /// 
  /// @param parameterId [in, ref] Parameter Unique ID
  /// @param ppParmDef [out,retval] Codec definition object
  ///
  HRESULT LookupCodecDef (
    [in, ref] aafUID_constref  parameterId,
    [out,retval] IAAFCodecDef ** ppParmDef);


  //***********************************************************
  //
  // GetCodecDefs()
  //
  /// Return an enumerator for all codec definitions.
  /// 
  /// @param ppEnum [out,retval] Definition Enumeration
  ///
  HRESULT GetCodecDefs (
    [out,retval] IEnumAAFCodecDefs ** ppEnum);


  //***********************************************************
  //
  // CountCodecDefs()
  //
  /// Writes the number of codec definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  /// 
  /// @param pResult [out, retval] Total number of codec definition objects
  ///
  HRESULT CountCodecDefs (
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // RegisterContainerDef()
  //
  /// Add the container definition object to the header's list of definitions.
  /// 
  /// @param pParmDef [in] Container Definition Object
  ///
  HRESULT RegisterContainerDef (
    [in] IAAFContainerDef * pParmDef);


  //***********************************************************
  //
  // LookupContainerDef()
  //
  /// Return the container definition object with the given id.
  /// 
  /// @param parameterId [in, ref] Parameter Unique ID
  /// @param ppParmDef [out,retval] Container definition object
  ///
  HRESULT LookupContainerDef (
    [in, ref] aafUID_constref  parameterId,
    [out,retval] IAAFContainerDef ** ppParmDef);


  //***********************************************************
  //
  // GetContainerDefs()
  //
  /// Return an enumerator for all container definitions.
  /// 
  /// @param ppEnum [out,retval] Definition Enumeration
  ///
  HRESULT GetContainerDefs (
    [out,retval] IEnumAAFContainerDefs ** ppEnum);


  //***********************************************************
  //
  // CountContainerDefs()
  //
  /// Writes the number of container definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  /// 
  /// @param pResult [out, retval] Total number of container definition objects
  ///
  HRESULT CountContainerDefs (
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // RegisterInterpolationDef()
  //
  /// Add the Interpolation definition object to the header's list of definitions.
  /// 
  /// @param pInterpolationDef [in] Interpolation Definition Object
  ///
  HRESULT RegisterInterpolationDef (
    [in] IAAFInterpolationDef * pInterpolationDef);


  //***********************************************************
  //
  // LookupInterpolationDef()
  //
  /// Return the Interpolation definition object with the given id.
  /// 
  /// @param parameterId [in, ref] Parameter Unique ID
  /// @param ppInterpolationDef [out,retval] Interpolation definition object
  ///
  HRESULT LookupInterpolationDef (
    [in, ref] aafUID_constref  parameterId,
    [out,retval] IAAFInterpolationDef ** ppInterpolationDef);


  //***********************************************************
  //
  // GetInterpolationDefs()
  //
  /// Return an enumerator for aff Interpolation definitions.
  /// 
  /// @param ppEnum [out,retval] Definition Enumeration
  ///
  HRESULT GetInterpolationDefs (
    [out,retval] IEnumAAFInterpolationDefs ** ppEnum);


  //***********************************************************
  //
  // CountInterpolationDefs()
  //
  /// Writes the number of interpolation definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  /// 
  /// @param pResult [out, retval] Total number of interpolation definition objects
  ///
  HRESULT CountInterpolationDefs (
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // RegisterPluginDef()
  //
  /// Add the plugin definition object to the header's list of definitions.
  /// 
  /// @param pPlugDef [in] plugin definition Object
  ///
  HRESULT RegisterPluginDef (
    [in] IAAFPluginDef * pPlugDef);


  //***********************************************************
  //
  // LookupPluginDef()
  //
  /// Return the plugin descriptor object with the given id.
  /// 
  /// @param parameterId [in, ref] Parameter Unique ID
  /// @param ppPlugDef [out,retval] plugin descriptor object
  ///
  HRESULT LookupPluginDef (
    [in, ref] aafUID_constref  parameterId,
    [out,retval] IAAFPluginDef ** ppPlugDef);


  //***********************************************************
  //
  // GetPluginDefs()
  //
  /// Return an enumerator for all plugin descriptors.
  /// 
  /// @param ppEnum [out,retval] Definition Enumeration
  ///
  HRESULT GetPluginDefs (
    [out,retval] IEnumAAFPluginDefs ** ppEnum);


  //***********************************************************
  //
  // CountPluginDefs()
  //
  /// Writes the number of plugin definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  /// 
  /// @param pResult [out, retval] Total number of plugin definition objects
  ///
  HRESULT CountPluginDefs (
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // RegisterKLVDataDef()
  //
  /// Add the KLVData definition object to the header's list of definitions.
  /// 
  /// @param pDef [in] plugin definition object
  ///
  HRESULT RegisterKLVDataDef (
    [in] IAAFKLVDataDefinition * pDef);


  //***********************************************************
  //
  // LookupKLVDataDef()
  //
  /// Return the KLVData descriptor object with the given id.
  /// 
  /// @param defId [in, ref] KLV data definition Unique ID
  /// @param ppDef [out,retval] KLVData descriptor object
  ///
  HRESULT LookupKLVDataDef (
    [in, ref] aafUID_constref  defId,
    [out,retval] IAAFKLVDataDefinition ** ppDef);


  //***********************************************************
  //
  // GetKLVDataDefs()
  //
  /// Return an enumerator for all KLVData descriptors.
  /// 
  /// @param ppEnum [out,retval] Definition Enumeration
  ///
  HRESULT GetKLVDataDefs (
    [out,retval] IEnumAAFKLVDataDefs ** ppEnum);


  //***********************************************************
  //
  // CountKLVDataDefs()
  //
  /// Writes the number of KLVData definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  /// 
  /// @param pResult [out, retval] Total number of KLVData definition objects
  ///
  HRESULT CountKLVDataDefs (
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // RegisterTaggedValueDef()
  //
  /// Add the tagged value definition object to the header's list of definitions.
  /// 
  /// @param pDef [in] tagged value definition Object
  ///
  HRESULT RegisterTaggedValueDef (
    [in] IAAFTaggedValueDefinition * pDef);


  //***********************************************************
  //
  // LookupTaggedValueDef()
  //
  /// Return the tagged value descriptor object with the given id.
  /// 
  /// @param defId [in, ref] tagged value definition ID
  /// @param ppDef [out,retval] tagged value descriptor object
  ///
  HRESULT LookupTaggedValueDef (
    [in, ref] aafUID_constref  defId,
    [out,retval] IAAFTaggedValueDefinition ** ppDef);


  //***********************************************************
  //
  // GetTaggedValueDefs()
  //
  /// Return an enumerator for all tagged value descriptors.
  /// 
  /// @param ppEnum [out,retval] Definition Enumeration
  ///
  HRESULT GetTaggedValueDefs (
    [out,retval] IEnumAAFTaggedValueDefs ** ppEnum);


  //***********************************************************
  //
  // CountTaggedValueDefs()
  //
  /// Writes the number of tagged value definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  /// 
  /// @param pResult [out, retval] Total number of tagged value definition objects
  ///
  HRESULT CountTaggedValueDefs (
    [out, retval] aafUInt32 *  pResult);

  //***********************************************************
  //
  // LookupAuxiliaryDataDef()
  //
  /// Return the Auxiliary Data Definition Object.
  /// 
  /// Succeeds if:
  /// - The ppDataDef pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDataDef arg is NULL.
  /// 
  /// @param ppDataDef [out,retval] Data Definition Object
  ///
  HRESULT LookupAuxiliaryDataDef (
    [out,retval] IAAFDataDef ** ppDataDef);

  //***********************************************************
  //
  // LookupDescriptiveMetadataDataDef()
  //
  /// Return the Descriptive Metadata Data Definition Object.
  /// 
  /// Succeeds if:
  /// - The ppDataDef pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDataDef arg is NULL.
  /// 
  /// @param ppDataDef [out,retval] Data Definition Object
  ///
  HRESULT LookupDescriptiveMetadataDataDef (
    [out,retval] IAAFDataDef ** ppDataDef);


  //***********************************************************
  //
  // LookupEdgecodeDataDef()
  //
  /// Return the Edgecode Data Definition Object.
  /// 
  /// Succeeds if:
  /// - The ppDataDef pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDataDef arg is NULL.
  /// 
  /// @param ppDataDef [out,retval] Data Definition Object
  ///
  HRESULT LookupEdgecodeDataDef (
    [out,retval] IAAFDataDef ** ppDataDef);


  //***********************************************************
  //
  // LookupLegacyPictureDataDef()
  //
  /// Return the legacy Picture Data Definition Object.
  /// 
  /// Succeeds if:
  /// - The ppDataDef pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDataDef arg is NULL.
  /// 
  /// @param ppDataDef [out,retval] Data Definition Object
  ///
  HRESULT LookupLegacyPictureDataDef (
    [out,retval] IAAFDataDef ** ppDataDef);


  //***********************************************************
  //
  // LookupLegacySoundDataDef()
  //
  /// Return the legacy Sound Data Definition Object.
  /// 
  /// Succeeds if:
  /// - The ppDataDef pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDataDef arg is NULL.
  /// 
  /// @param ppDataDef [out,retval] Data Definition Object
  ///
  HRESULT LookupLegacySoundDataDef (
    [out,retval] IAAFDataDef ** ppDataDef);


  //***********************************************************
  //
  // LookupLegacyTimecodeDataDef()
  //
  /// Return the legacy Timecode Data Definition Object.
  /// 
  /// Succeeds if:
  /// - The ppDataDef pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDataDef arg is NULL.
  /// 
  /// @param ppDataDef [out,retval] Data Definition Object
  ///
  HRESULT LookupLegacyTimecodeDataDef (
    [out,retval] IAAFDataDef ** ppDataDef);


  //***********************************************************
  //
  // LookupMatteDataDef()
  //
  /// Return the Matte Data Definition Object.
  /// 
  /// Succeeds if:
  /// - The ppDataDef pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDataDef arg is NULL.
  /// 
  /// @param ppDataDef [out,retval] Data Definition Object
  ///
  HRESULT LookupMatteDataDef (
    [out,retval] IAAFDataDef ** ppDataDef);


  //***********************************************************
  //
  // LookupPictureDataDef()
  //
  /// Return the Picture Data Definition Object.
  /// 
  /// Succeeds if:
  /// - The ppDataDef pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDataDef arg is NULL.
  /// 
  /// @param ppDataDef [out,retval] Data Definition Object
  ///
  HRESULT LookupPictureDataDef (
    [out,retval] IAAFDataDef ** ppDataDef);


  //***********************************************************
  //
  // LookupPictureWithMatteDataDef()
  //
  /// Return the PictureWithMatte Data Definition Object.
  /// 
  /// Succeeds if:
  /// - The ppDataDef pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDataDef arg is NULL.
  /// 
  /// @param ppDataDef [out,retval] Data Definition Object
  ///
  HRESULT LookupPictureWithMatteDataDef (
    [out,retval] IAAFDataDef ** ppDataDef);


  //***********************************************************
  //
  // LookupSoundDataDef()
  //
  /// Return the Sound Data Definition Object.
  /// 
  /// Succeeds if:
  /// - The ppDataDef pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDataDef arg is NULL.
  /// 
  /// @param ppDataDef [out,retval] Data Definition Object
  ///
  HRESULT LookupSoundDataDef (
    [out,retval] IAAFDataDef ** ppDataDef);


  //***********************************************************
  //
  // LookupTimecodeDataDef()
  //
  /// Return the Timecode Data Definition Object.
  /// 
  /// Succeeds if:
  /// - The ppDataDef pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDataDef arg is NULL.
  /// 
  /// @param ppDataDef [out,retval] Data Definition Object
  ///
  HRESULT LookupTimecodeDataDef (
    [out,retval] IAAFDataDef ** ppDataDef);


}



// ************************
//
// Interface IAAFDigitalImageDescriptor2
//
// ************************
///
/// The IAAFDigitalImageDescriptor2 interface is implemented by objects
/// which describe video content data formatted either using RGBA or
/// luminance/chrominance formatting.
///
/// The geometry properties accessed by Set/GetStoredView(),
/// Set/GetSampledView(), and Set/GetDisplayView() describe the
/// dimensions and meaning of the stored pixels in the image.  The
/// geometry describes the pixels of an uncompressed image.
/// Consequently, the geometry properties are independent of the
/// compression and subsampling.
///
/// Three separate geometries - stored, sampled, and display views -
/// are used to define a set of different views on uncompressed digital
/// data. All views are constrained to rectangular regions, which means
/// that storage and sampling has to be rectangular.
/// 
/// The relationships among the views can be shown by the following
/// rectangles, representing areas of a video image:
/// 
/// +------------------+
/// |                  |
/// |   Stored View    |
/// |                  |           +--------------+
/// +------------------+ <-------- |              |
/// |                  |  Sample   | Analog Video |
/// |   Sampled View   |  Process  |    Source    |
/// |                  |           | Information  |
/// | +--------------+ |           |              |
/// | |              | |           |              |
/// | | Display View | |           |              |
/// | |              | |           |              |
/// | +--------------+ |           |              |
/// |                  |           |              |
/// +------------------+ <-------- |              |
///                                +--------------+
///
/// The stored view is the entire data region corresponding to a single
/// uncompressed frame or field of the image, and is defined by its
/// horizontal and vertical dimension properties. The stored view may
/// include data that is not derived from, and would not usually be
/// translated back to, analog data.
///
/// The sampled view is defined to be the rectangular dimensions in
/// pixels corresponding to the digital data derived from an analog or
/// digital source. These pixels reside within the rectangle defined by
/// the stored view. This would include the image and auxiliary
/// information included in the analog or digital source. For the
/// capture of video signals, the mapping of these views to the
/// original signal is determined by the VideoLineMap property.
///
/// The display view is the rectangular size in pixels corresponding to
/// the viewable area. These pixels contain image data suitable for
/// scaling, display, warping, and other image processing. The display
/// view offsets are relative to the stored view, not to the sampled
/// view.
///
/// Although typically the display view is a subset of the sampled
/// view, it is possible that the viewable area may not be a subset of
/// the sampled data. It may overlap or even encapsulate the sampled
/// data. For example, a subset of the input image might be centered in
/// a computer-generated blue screen for use in a chroma key effect. In
/// this case the viewable pixels on disk would contain more than the
/// sampled image.
///
/// Each of these data views will have a width and height value. Both
/// the sampled view and the display view also have offsets relative to
/// the top left corner of the stored view.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it through
///     this object's primary interface.  Note that
///     IAAFDigitalImageDescriptor2 is a primary interface for an
///     abstract class, so it is not appropriate for the
///     Initialize() method to exist in this interface.  The
///     Initialize() method is available through the concrete
///     object's primary interface.
///
///
/// Objects that implement IAAFDigitalImageDescriptor2 also implement the following interfaces:
///  - IAAFFileDescriptor
///  - IAAFFileDescriptor2
///  - IAAFEssenceDescriptor
///  - IAAFObject
[
    object,
    uuid(F7B9D3BE-773E-4910-9888-C9C4D71561CC),
    helpstring("IAAFDigitalImageDescriptor2 Interface"),
    pointer_default(unique)
]
interface IAAFDigitalImageDescriptor2 : IUnknown
{


  //***********************************************************
  //
  // SetCompression()
  //
  /// ///
  /// Sets the kind of compression and format of compression
  /// information of the video essence data.  This property is
  /// optional.  If there is no compression, the property is omitted.
  /// 
  /// If this method fails the Data Definition property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param compression [in] Optional.
  ///
  HRESULT SetCompression (
    [in] aafUID_constref  compression);


  //***********************************************************
  //
  // GetCompression()
  //
  /// /// Gets the kind of compression and format of compression
  /// information of the video essence data.  This property is
  /// optional.
  ///
  /// Succeeds if all of the following are true:
  /// - the pCompression pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pCompression.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pComporession arg is NULL.
  /// 
  /// @param pCompression [out] Optional.
  ///
  HRESULT GetCompression (
    [out] aafUID_t *  pCompression);


  //***********************************************************
  //
  // SetStoredView()
  //
  /// Sets the dimension of the stored view.  Typically this includes
  /// leading blank video lines, any VITC lines, as well as the active
  /// picture area.
  /// 
  /// If this method fails the Stored Height and Stored Width
  /// properties will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param StoredHeight [in] Number of pixels in vertical dimension of stored view.
  /// @param StoredWidth [in] Number of pixels in horizontal dimension of stored view.
  ///
  HRESULT SetStoredView (
    [in] aafUInt32  StoredHeight,
    [in] aafUInt32  StoredWidth);


  //***********************************************************
  //
  // GetStoredView()
  //
  /// Gets the dimension of the stored view.  Typically this includes
  /// leading blank video lines, any VITC lines, as well as the active
  /// picture area.
  /// 
  /// Succeeds if all of the following are true:
  /// - pStoredHieght and pStoredWidth are valid pointers.
  /// 
  /// If this method fails, the *pStoredHieght and *pStoredWidth will
  /// not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pStoredHeight or pStoredWidth is NULL.
  /// 
  /// @param pStoredHeight [out] Number of pixels in vertical dimension of stored view.
  /// @param pStoredWidth [out] Number of pixels in horizontal dimension of stored view.
  ///
  HRESULT GetStoredView (
    [out] aafUInt32 *  pStoredHeight,
    [out] aafUInt32 *  pStoredWidth);


  //***********************************************************
  //
  // SetSampledView()
  //
  /// Sets the dimensions of sampled view.  Typically this includes
  /// any VITC lines as well as the active picture area, but excludes
  /// leading blank video lines.  The offset is specified relative to
  /// the rectangle specified by Set/GetStoredView().
  ///
  /// The following properties are optional:
  ///
  ///     SampledXOffset - The default value is 0.  Use a value of 0 to
  ///                      select the default.
  ///     SampledYOffset - The default value is 0.  Use a value of 0 to
  ///                      select the default.
  ///
  /// Succeeds if all of the following are true:
  /// - The given dimensions exist within the StoredView.
  /// 
  /// If this method fails, the SampledXOffset and SampledYOffset
  /// properties will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - The area specified by SampledHeight and SampledXOffset is
  ///     outside the StoredView, or the area specified by SampledWidth
  ///     and SampledYOffset is outside the StoredView.
  /// 
  /// @param SampledHeight [in] Number of pixels in vertical dimension of sampled view.
  /// @param SampledWidth [in] Number of pixels in horizontal dimension of sampled view.
  /// @param SampledXOffset [in] Number of pixels from top left corner of sampled view. Optional.
  /// @param SampledYOffset [in] Number of pixels from top left corner of sampled view. Optional.
  ///
  HRESULT SetSampledView (
    [in] aafUInt32  SampledHeight,
    [in] aafUInt32  SampledWidth,
    [in] aafInt32  SampledXOffset,
    [in] aafInt32  SampledYOffset);


  //***********************************************************
  //
  // GetSampledView()
  //
  /// Gets the dimensions of sampled view.  Typically this includes
  /// any VITC lines as well as the active picture area, but excludes
  /// leading blank video lines.  The offset is specified relative to
  /// the rectangle specified by Set/GetStoredView().
  ///
  /// Succeeds if all of the following are true:
  /// - pSampledHeight, pSampledWidth, pSampledXOffset and
  ///   pSampledYOffset are valid pointers
  /// 
  /// If any of the input parameters are NULL, the property will not
  /// be returned.
  ///
  /// If this method fails, *pSampledHeight, *pSampledWidth,
  /// *pSampledXOffset, and *pSampledYOffset will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - any of pSampledHeight, pSampledWidth, pSampledXOffset, or
  ///     pSampledYOffset are NULL.
  /// 
  /// @param pSampledHeight [out] Number of pixels in vertical dimension of sampled view.
  /// @param pSampledWidth [out] Number of pixels in horizontal dimension of sampled view.
  /// @param pSampledXOffset [out] Number of pixels from top left corner of sampled view. Optional.
  /// @param pSampledYOffset [out] Number of pixels from top left corner of sampled view. Optional.
  ///
  HRESULT GetSampledView (
    [out] aafUInt32 *  pSampledHeight,
    [out] aafUInt32 *  pSampledWidth,
    [out] aafInt32 *  pSampledXOffset,
    [out] aafInt32 *  pSampledYOffset);


  //***********************************************************
  //
  // SetDisplayView()
  //
  /// Sets the dimension of display view.  Typically this includes
  /// the active picture area, but excludes leading blank video lines
  /// and any VITC lines.  The offset is specified relative to the
  /// rectangle specified by Set/GetStoredView().
  /// 
  /// The following properties are optional:
  ///
  ///     DisplayHeight  - The default value is the storedHeight. Use
  ///                      storedHeight to select the default.
  ///     DisplayWidth   - The default value is the storedWidth. Use
  ///                      storedWidth to select the default.
  ///     DisplayXOffset - The default value is 0.  Use a value of 0 to
  ///                      select the default.
  ///     DisplayYOffset - The default value is 0.  Use a value of 0 to
  ///                      select the default.
  ///
  /// Note that The specified display rectangle may exist outside the
  /// SampledView or even the StoredView.
  ///
  /// If this method fails the DisplayHeight, DisplayWidth, DisplayXOffset and
  /// DisplayYOffset properties will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - The area specified by DisplayHeight and DisplayXOffset is
  ///     outside the StoredView, or the area specified by DisplayWidth
  ///     and DisplayYOffset is outside the StoredView.
  /// 
  /// @param DisplayHeight [in] Number of pixels in vertical dimension of display view. Optional.
  /// @param DisplayWidth [in] Number of pixels in horizontal dimension of display view. Optional.
  /// @param DisplayXOffset [in] Number of pixels from the top-left corner of the display view. Optional.
  /// @param DisplayYOffset [in] Number pixels from the top-left corner of the display view. Optional.
  ///
  HRESULT SetDisplayView (
    [in] aafUInt32  DisplayHeight,
    [in] aafUInt32  DisplayWidth,
    [in] aafInt32  DisplayXOffset,
    [in] aafInt32  DisplayYOffset);


  //***********************************************************
  //
  // GetDisplayView()
  //
  /// Gets the dimension of display view.  Typically this includes
  /// the active picture area, but excludes leading blank video lines
  /// and any VITC lines.  The offset is specified relative to the
  /// rectangle specified by Set/GetStoredView().
  /// 
  /// Note that The specified display rectangle may exist outside the
  /// SampledView or even the StoredView.
  ///
  /// Succeeds if all of the following are true:
  /// - pDisplayHeight, pDisplayWidth, pDisplayXOffset and
  ///   pDisplayYOffset are valid pointers.
  /// 
  /// If this method fails, *pDisplayHeight, *pDisplayWidth,
  /// *pDisplayXOffset, and *pDisplayYOffset will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - any of pDisplayHeight, pDisplayWidth, pDisplayXOffset, or
  ///     pDisplayYOffset are NULL.
  /// 
  /// @param pDisplayHeight [out] Number of pixels in vertical dimension of display view. Optional.
  /// @param pDisplayWidth [out] Number of pixels in horizontal dimension of display view. Optional.
  /// @param pDisplayXOffset [out] Number of pixels from the top-left corner of the display view. Optional.
  /// @param pDisplayYOffset [out] Number pixels from the top-left corner of the display view. Optional.
  ///
  HRESULT GetDisplayView (
    [out] aafUInt32 *  pDisplayHeight,
    [out] aafUInt32 *  pDisplayWidth,
    [out] aafInt32 *  pDisplayXOffset,
    [out] aafInt32 *  pDisplayYOffset);


  //***********************************************************
  //
  // SetFrameLayout()
  //
  /// Sets the frame layout.  The frame layout describes whether all
  /// data for a complete sample is in one frame or is split into more
  /// than/ one field.
  ///
  /// Values are:
  ///
  ///    kNoLayout       - Default; not a valid value.
  ///    kFullFrame      - Each frame contains a full sample in
  ///                      progressive scan lines.
  ///    kSeparateFields - Each sample consists of two fields, which
  ///                      when interlaced produce a full sample.
  ///    kOneField       - Each sample consists of two interlaced
  ///                      fields, but only one field is stored in the
  ///                      data stream.
  ///    kMixedFields    - Similar to FullFrame, except the two fields
  ///                      may have been sampled at different times.
  /// 
  /// Succeeds if all of the following are true:
  /// - frameLayout is a valid value
  /// 
  /// If this method fails, the Frame Layout property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - FrameLayout is not a valid value.
  /// 
  /// @param FrameLayout [in] layout of the frame
  ///
  HRESULT SetFrameLayout (
    [in] aafFrameLayout_t  FrameLayout);


  //***********************************************************
  //
  // GetFrameLayout()
  //
  /// Gets the frame layout.  The frame layout describes whether all
  /// data for a complete sample is in one frame or is split into more
  /// than one field.
  /// 
  /// Values are:
  ///
  ///    kNoLayout       - Default; not a valid value.
  ///    kFullFrame      - Each frame contains a full sample in
  ///                      progressive scan lines.
  ///    kSeparateFields - Each sample consists of two fields, which
  ///                      when interlaced produce a full sample.
  ///    kOneField       - Each sample consists of two interlaced
  ///                      fields, but only one field is stored in the
  ///                      data stream.
  ///    kMixedFields    - Similar to FullFrame, except the two fields
  ///                      may have been sampled at different times.
  /// 
  /// Succeeds if all of the following are true:
  /// - pFrameLayout is a valid pointer
  /// 
  /// If this method fails, *pFrameLayout will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFrameLayout is NULL.
  /// 
  /// @param pFrameLayout [out] layout of the frame
  ///
  HRESULT GetFrameLayout (
    [out] aafFrameLayout_t *  pFrameLayout);


  //***********************************************************
  //
  // SetVideoLineMap()
  //
  /// Sets the VideoLineMap property.  The video line map specifies the
  /// scan line in the analog source that corresponds to the beginning
  /// of each digitized field.  For single-field video, there is 1
  /// value in the array.  For interleaved video, there are 2 values
  /// in the array.
  /// 
  /// Succeeds if all of the following are true:
  /// - pVideoLineMap is a valid pointer
  /// 
  /// If this method fails, the Video Line Map property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pVideoLineMap is NULL.
  /// 
  /// @param numberElements [in] The number of elements in the array
  /// @param pVideoLineMap [in, size_is(numberElements)] Array to hold the Video Line Map information
  ///
  HRESULT SetVideoLineMap (
    [in] aafUInt32  numberElements,
    [in, size_is(numberElements)] aafInt32 *  pVideoLineMap);


  //***********************************************************
  //
  // GetVideoLineMap()
  //
  /// Gets the VideoLineMap property.  The video line map specifies the
  /// scan line in the analog source that corresponds to the beginning of each
  /// digitized field.  For single-field video, there is 1 value in the array.
  /// For interleaved video, there are 2 values in the array.
  ///
  /// The values are written to the array specified by pVideoLineMap,
  /// which is of size numberElements.  The required size may be found
  /// by calling GetVideoLineMapSize().
  /// 
  /// Succeeds if all of the following are true:
  /// - pVideoLineMap is a valid pointer.
  /// - numberElements indicates the array is large enough to hold the
  ///   data.
  /// 
  /// If this method fails, videoLineMap will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumberElements is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - numberElements indicates that the array is too small to hold
  ///     the data.
  /// 
  /// @param numberElements [in] The number of elements in the array
  /// @param pVideoLineMap [out, size_is(numberElements)] Array to hold the Video Line Map information
  ///
  HRESULT GetVideoLineMap (
    [in] aafUInt32  numberElements,
    [out, size_is(numberElements)] aafInt32 *  pVideoLineMap);


  //***********************************************************
  //
  // GetVideoLineMapSize()
  //
  /// Get the number of elements in the VideoLineMap property array.
  /// 
  /// Succeeds if all of the following are true:
  /// - pNumberElements is a valid pointer
  /// 
  /// If this method fails, *pNumberElements will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumberElements is NULL.
  /// 
  /// @param pNumberElements [out] The number of elements in the array
  ///
  HRESULT GetVideoLineMapSize (
    [out] aafUInt32 *  pNumberElements);


  //***********************************************************
  //
  // SetImageAspectRatio()
  //
  /// Sets the Image Aspect Ratio property.  This ratio describes the
  /// ratio between the horizontal size and the vertical size in the
  /// intended final image.
  ///
  /// Succeeds if all of the following are true:
  /// - 
  /// 
  /// If this method fails, the Image Access Ratio property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param ImageAspectRatio [in] Ratio between horizontal and vertical size
  ///
  HRESULT SetImageAspectRatio (
    [in] aafRational_t  ImageAspectRatio);


  //***********************************************************
  //
  // GetImageAspectRatio()
  //
  /// Gets the Image Aspect Ratio property.  This ratio describes the
  /// ratio between the horizontal size and the vertical size in the
  /// intended final image.
  ///
  /// Succeeds if all of the following are true:
  /// - pImageAspectRatio is a valid pointer
  /// 
  /// If this method fails, *pImageAspectRatio will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pImageAspectRatio is NULL.
  /// 
  /// @param pImageAspectRatio [out] Ratio between horizontal and vertical size
  ///
  HRESULT GetImageAspectRatio (
    [out] aafRational_t *  pImageAspectRatio);


  //***********************************************************
  //
  // SetAlphaTransparency()
  //
  /// Sets the AlphaTransparency property.  This property is optional.
  ///
  /// Valid values:
  ///	kMaxValueTransparent - means the maximum Alpha value is
  ///                           transparent
  ///    kMinValueTransparent - means the minimum Alpha value is
  ///                           transparent
  ///
  /// Succeeds if all of the following are true:
  /// - AlphaTransparency is a valid value.
  /// 
  /// If this method fails, the AlphaTransparency property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - AlphaTransparency is not a valid value.
  /// 
  /// @param AlphaTransparency [in] Alpha Transparency value.
  ///
  HRESULT SetAlphaTransparency (
    [in] aafAlphaTransparency_t  AlphaTransparency);


  //***********************************************************
  //
  // GetAlphaTransparency()
  //
  /// Gets the AlphaTransparency property.  This property is optional.
  ///
  /// Valid values:
  ///	kMaxValueTransparent - means the maximum Alpha value is transparent
  ///    kMinValueTransparent - means the minimum Alpha value is transparent
  ///
  /// Succeeds if all of the following are true:
  /// - pAlphaTransparency is a valid pointer
  /// 
  /// If this method fails, pAlphaTransparency not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pAlphaTransparency is NULL.
  /// 
  /// @param pAlphaTransparency [out] Alpha Transparency value.
  ///
  HRESULT GetAlphaTransparency (
    [out] aafAlphaTransparency_t *  pAlphaTransparency);



  //***********************************************************
  //
  // SetImageAlignmentFactor()
  //
  /// Sets the ImageAlignmentFactor property.  Specifies the alignment
  /// when storing the digital essence.  For example, a value of 16
  /// means that the image is stored on 16-byte boundaries.  The
  /// starting point for a field will always be a multiple of 16 bytes.
  /// If the field does not end on a 16-byte boundary, it is padded
  /// out to the next 16-byte boundary.
  ///
  /// Succeeds if all of the following are true:
  /// 
  /// If this method fails, the ImageAlignmentFactor property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param ImageAlignmentFactor [in] Optional.
  ///
  HRESULT SetImageAlignmentFactor (
    [in] aafUInt32  ImageAlignmentFactor);


  //***********************************************************
  //
  // GetImageAlignmentFactor()
  //
  /// Gets the ImageAlignmentFactor property.  Specifies the alignment when
  /// storing the digital essence.  For example, a value of 16 means that the image
  /// is stored on 16-byte boundaries.  The starting point for a field will always
  /// be a multiple of 16 bytes.  If the field does not end on a 16-byte boundary,
  /// it is padded out to the next 16-byte boundary.
  ///
  ///
  /// Succeeds if all of the following are true:
  /// - pImageAlignmentFactor is a valid pointer
  /// 
  /// If this method fails, pImageAlignmentFactor will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pImageAlignmentFactor is NULL.
  /// 
  /// @param pImageAlignmentFactor [out] Optional.
  ///
  HRESULT GetImageAlignmentFactor (
    [out] aafUInt32 *  pImageAlignmentFactor);


  //***********************************************************
  //
  // SetTransferCharacteristic()
  //
  /// Sets the TransferCharacteristic property.
  ///
  /// Succeeds if all of the following are true:
  /// - 
  /// 
  /// If this method fails, the TransferCharacteristic property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param transferCharacteristic [in] Optional
  ///
  HRESULT SetTransferCharacteristic (
    [in] aafUID_constref  transferCharacteristic);


  //***********************************************************
  //
  // GetTransferCharacteristic()
  //
  /// Gets the TransferCharacteristic property.
  ///
  /// Succeeds if all of the following are true:
  /// - pTransferCharacteristic is a valid pointer
  /// 
  /// If this method fails, pTransferCharacteristic will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTransferCharacteristic is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pTransferCharacteristic [out] Optional.
  ///
  HRESULT GetTransferCharacteristic (
    [out] aafUID_t *  pTransferCharacteristic);

  //***********************************************************
  //
  // SetCodingEquations()
  //
  /// Sets the CodingEquations property.
  ///
  /// Succeeds if all of the following are true:
  /// - 
  /// 
  /// If this method fails, the CodingEquations property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param codingEquations [in] Optional
  ///
  HRESULT SetCodingEquations (
    [in] aafUID_constref  codingEquations);


  //***********************************************************
  //
  // GetCodingEquations()
  //
  /// Gets the CodingEquations property.
  ///
  /// Succeeds if all of the following are true:
  /// - pCodingEquations is a valid pointer
  /// 
  /// If this method fails, pCodingEquations will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCodingEquations is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pCodingEquations [out] Optional.
  ///
  HRESULT GetCodingEquations (
    [out] aafUID_t *  pCodingEquations);

  //***********************************************************
  //
  // SetColorPrimaries()
  //
  /// Sets the ColorPrimaries property.
  ///
  /// Succeeds if all of the following are true:
  /// - 
  /// 
  /// If this method fails, the ColorPrimaries property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param colorPrimaries [in] Optional
  ///
  HRESULT SetColorPrimaries (
    [in] aafUID_constref  colorPrimaries);


  //***********************************************************
  //
  // GetColorPrimaries()
  //
  /// Gets the ColorPrimaries property.
  ///
  /// Succeeds if all of the following are true:
  /// - pColorPrimaries is a valid pointer
  /// 
  /// If this method fails, pColorPrimaries will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pColorPrimaries is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pColorPrimaries [out] Optional.
  ///
  HRESULT GetColorPrimaries (
    [out] aafUID_t *  pColorPrimaries);

  //***********************************************************
  //
  // SetFieldStartOffset()
  //
  /// Sets the FieldStartOffset property.
  ///
  /// Succeeds if all of the following are true:
  /// 
  /// If this method fails, the FieldStartOffset property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param fieldStartOffset [in] Optional.
  ///
  HRESULT SetFieldStartOffset (
    [in] aafUInt32  fieldStartOffset);


  //***********************************************************
  //
  // GetFieldStartOffset()
  //
  /// Gets the FieldStartOffset property.
  ///
  /// Succeeds if all of the following are true:
  /// - pFieldStartOffset is a valid pointer
  /// 
  /// If this method fails, pFieldStartOffset will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFieldStartOffset is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pFieldStartOffset [out] Optional.
  ///
  HRESULT GetFieldStartOffset (
    [out] aafUInt32 *  pFieldStartOffset);

  //***********************************************************
  //
  // SetFieldEndOffset()
  //
  /// Sets the FieldEndOffset property.
  ///
  /// Succeeds if all of the following are true:
  /// 
  /// If this method fails, the FieldEndOffset property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param fieldEndOffset [in] Optional.
  ///
  HRESULT SetFieldEndOffset (
    [in] aafUInt32  fieldEndOffset);


  //***********************************************************
  //
  // GetFieldEndOffset()
  //
  /// Gets the FieldEndOffset property.
  ///
  /// Succeeds if all of the following are true:
  /// - pFieldEndOffset is a valid pointer
  /// 
  /// If this method fails, pFieldEndOffset will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFieldEndOffset is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pFieldEndOffset [out] Optional.
  ///
  HRESULT GetFieldEndOffset (
    [out] aafUInt32 *  pFieldEndOffset);

  //***********************************************************
  //
  // SetFieldDominance()
  //
  /// Sets the FieldDominance property.
  ///
  /// Succeeds if all of the following are true:
  /// 
  /// If this method fails, the FieldDominance property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - FieldDominance is not a valid value.
  /// 
  /// @param fieldDominance [in] Optional.
  ///
  HRESULT SetFieldDominance (
    [in] aafFieldNumber_t  fieldDominance);


  //***********************************************************
  //
  // GetFieldDominance()
  //
  /// Gets the FieldDominance property.
  ///
  /// Succeeds if all of the following are true:
  /// - pFieldDominance is a valid pointer
  /// 
  /// If this method fails, pFieldDominance will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFieldDominance is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pFieldDominance [out] Optional.
  ///
  HRESULT GetFieldDominance (
    [out] aafFieldNumber_t *  pFieldDominance);

  //***********************************************************
  //
  // SetDisplayF2Offset()
  //
  /// Sets the DisplayF2Offset property.
  ///
  /// Succeeds if all of the following are true:
  /// 
  /// If this method fails, the DisplayF2Offset property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - displayF2Offset is not a valid value.
  /// 
  /// @param displayF2Offset [in] Optional.
  ///
  HRESULT SetDisplayF2Offset (
    [in] aafInt32  displayF2Offset);


  //***********************************************************
  //
  // GetDisplayF2Offset()
  //
  /// Gets the DisplayF2Offset property.
  ///
  /// Succeeds if all of the following are true:
  /// - pDisplayF2Offset is a valid pointer
  /// 
  /// If this method fails, pDisplayF2Offset will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDisplayF2Offset is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pDisplayF2Offset [out] Optional.
  ///
  HRESULT GetDisplayF2Offset (
    [out] aafInt32 *  pDisplayF2Offset);

  //***********************************************************
  //
  // SetStoredF2Offset()
  //
  /// Sets the StoredF2Offset property.
  ///
  /// Succeeds if all of the following are true:
  /// 
  /// If this method fails, the StoredF2Offset property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - storedF2Offset is not a valid value.
  /// 
  /// @param storedF2Offset [in] Optional.
  ///
  HRESULT SetStoredF2Offset (
    [in] aafInt32  storedF2Offset);


  //***********************************************************
  //
  // GetStoredF2Offset()
  //
  /// Gets the StoredF2Offset property.
  ///
  /// Succeeds if all of the following are true:
  /// - pStoredF2Offset is a valid pointer
  /// 
  /// If this method fails, pStoredF2Offset will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pStoredF2Offset is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pStoredF2Offset [out] Optional.
  ///
  HRESULT GetStoredF2Offset (
    [out] aafInt32 *  pStoredF2Offset);

  //***********************************************************
  //
  // SetActiveFormatDescriptor()
  //
  /// Sets the ActiveFormatDescriptor property.
  ///
  /// Succeeds if all of the following are true:
  /// 
  /// If this method fails, the ActiveFormatDescriptor property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param activeFormatDescriptor [in] Optional.
  ///
  HRESULT SetActiveFormatDescriptor (
    [in] aafUInt8  activeFormatDescriptor);


  //***********************************************************
  //
  // GetActiveFormatDescriptor()
  //
  /// Gets the ActiveFormatDescriptor property.
  ///
  /// Succeeds if all of the following are true:
  /// - pActiveFormatDescriptor is a valid pointer
  /// 
  /// If this method fails, pActiveFormatDescriptor will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pActiveFormatDescriptor is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pActiveFormatDescriptor [out] Optional.
  ///
  HRESULT GetActiveFormatDescriptor (
    [out] aafUInt8 *  pActiveFormatDescriptor);

  //***********************************************************
  //
  // SetSignalStandard()
  //
  /// Sets the SignalStandard property.  This property is optional.
  ///
  /// Succeeds if all of the following are true:
  /// 
  /// If this method fails, the SignalStandard property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_AAFRESULT_INVALID_ENUM_VALUE
  ///   - signalStandard is not a valid value.
  /// 
  /// @param signalStandard [in] Signal standard value.
  ///
  HRESULT SetSignalStandard (
    [in] aafSignalStandard_t  signalStandard);


  //***********************************************************
  //
  // GetSignalStandard()
  //
  /// Gets the SignalStandard property.  This property is optional.
  ///
  /// Succeeds if all of the following are true:
  /// - pSignalStandard is a valid pointer
  /// 
  /// If this method fails, pSignalStandard not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSignalStandard is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pSignalStandard [out] Signal standard value.
  ///
  HRESULT GetSignalStandard (
    [out] aafSignalStandard_t *  pSignalStandard);

}



// ************************
//
// Interface IAAFEndian
//
// ************************
///
/// This interface is used to allow the user to determine the byte
/// order of this object.  Note that the byte order of the object
/// stored in the AAF file may be different from the native byte order
/// of this machine.  Note also that both pieces of information are
/// available here.
///
/// Byte order of newly created AAF files is set upon creation of that
/// file.  It is set to the byte order of the creating machine.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it through
///     this object's primary interface.  Note that IAAFEndian is not a
///     primary interface for a concrete class, so it is not
///     appropriate for the Initialize() method to exist in this
///     interface.  The Initialize() method is available through the
///     concrete object's primary interface.
///
[
    object,
    uuid(6BACC0C1-6091-11D2-841B-00600832ACB8),
    helpstring("IAAFEndian Interface"),
    pointer_default(unique)
]
interface IAAFEndian : IUnknown
{

  //***********************************************************
  //
  // GetStoredByteOrder()
  //
  /// Returns the "Endian-ness" in which the current object was or will
  /// be stored.  If this is a transient object (i.e., one which has
  /// not been persisted) then it will return the native byte order of
  /// the platform on which this is running.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pOrder pointer is valid.
  /// 
  /// If this method fails nothing is written to *pOrder.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pOrder is null.
  /// 
  /// @param pOrder [out] Pointer to place where byte order is to be put
  ///
  HRESULT GetStoredByteOrder (
    [out] eAAFByteOrder_t *  pOrder);


  //***********************************************************
  //
  // GetNativeByteOrder()
  //
  /// Returns the native "Endian-ness" of the platform on which this is
  /// running.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pOrder pointer is valid.
  /// 
  /// If this method fails nothing is written to *pOrder.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pOrder is null.
  /// 
  /// @param pOrder [out] Pointer to place where byte order is to be put
  ///
  HRESULT GetNativeByteOrder (
    [out] eAAFByteOrder_t *  pOrder);
}



// ************************
//
// Interface IAAFEssenceDataEx
//
// ************************

///
///
/// This interface is DEPRECATED, please use IAAFEssenceData2.
///
/// The IAAFEssenceData interface is used to modify AAFEssenceData
/// objects, which contain the actual essence data (ex. WAVE) when
/// it is contained within an AAF file.  Normally the client
/// application would access the essence through the IAAFEssenceAccess
/// interface, which handles the work of finding and (de)compressing
/// the data.  However, in rare cases direct access to the data is
/// required, so this interface is exposed.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
///
/// AAFRESULT_NULL_PARAM
///   - One of the passed in pointers is NULL.
///
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
///
/// Objects that implement IAAFEssenceDataEx also implement the following interfaces:
///  - IAAFObject
[
    object,
    uuid(d919d41f-979b-4aba-9785-8ec319dba448),
    helpstring("IAAFEssenceDataEx Interface"),
    pointer_default(unique)
]
interface IAAFEssenceDataEx : IUnknown
{


  //***********************************************************
  //
  // Initialize()
  //
  /// Associates a weak reference to the given file mob with the
  /// essence data.
  ///
  /// Succeeds if all of the following are true:
  /// - the pFileMob pointer is valid and points to 
  /// a file mob (contains a file descriptor).
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFileMob is null.
  /// 
  /// @param pFileMob [in] reference to a file mob
  ///
  HRESULT Initialize (
    [in] IAAFSourceMob * pFileMob);

  //***********************************************************
  //
  // Write()
  //
  /// Write pre-interleaved data to a essence stream.
  /// 
  /// @param bytes [in] write this many bytes to the data stream
  /// @param buffer [out, size_is(bytes)] here is the buffer
  /// @param bytesWritten [out,ref] 
  ///
  HRESULT Write (
    [in] aafUInt32  bytes,
    [out, size_is(bytes)] aafDataBuffer_t  buffer,
    [out,ref] aafUInt32 *  bytesWritten);


  //***********************************************************
  //
  // Read()
  //
  /// Read pre-interleaved data from a essence stream.
  /// 
  /// @param bytes [in] read this many bytes from the data stream
  /// @param buffer [out, size_is(bytes), length_is(*bytesRead)] here is the buffer
  /// @param bytesRead [out,ref] 
  ///
  HRESULT Read (
    [in] aafUInt32  bytes,
    [out, size_is(bytes), length_is(*bytesRead)] aafDataBuffer_t  buffer,
    [out,ref] aafUInt32 *  bytesRead);


  //***********************************************************
  //
  // SetPosition()
  //
  /// Seek to absolute position within the essence data.
  /// 
  /// @param offset [in] offset from beginning of essence
  ///
  HRESULT SetPosition (
    [in] aafPosition_t  offset);


  //***********************************************************
  //
  // GetPosition()
  //
  /// Get the absolute position within the essence data.
  /// 
  /// @param pOffset [out] offset from beginning of essence
  ///
  HRESULT GetPosition (
    [out] aafPosition_t*  pOffset);


  //***********************************************************
  //
  // GetSize()
  //
  /// Return the total size of the essence data.
  /// 
  /// @param pSize  [out] size of essence data
  ///
  HRESULT GetSize (
    [out] aafLength_t *  pSize );

  //***********************************************************
  //
  // WriteSampleIndex()
  //
  /// Write pre-interleaved data to a sample index stream.
  /// 
  /// @param bytes [in] write this many bytes to the sample index stream
  /// @param buffer [out, size_is(bytes)] here is the buffer
  /// @param bytesWritten [out,ref] 
  ///
  HRESULT WriteSampleIndex (
    [in] aafUInt32  bytes,
    [out, size_is(bytes)] aafDataBuffer_t  buffer,
    [out,ref] aafUInt32 *  bytesWritten);


  //***********************************************************
  //
  // ReadSampleIndex()
  //
  /// Read pre-interleaved data from a sample index stream.
  /// 
  /// @param bytes [in] read this many bytes from the sample index stream
  /// @param buffer [out, size_is(bytes), length_is(*bytesRead)] here is the buffer
  /// @param bytesRead [out,ref] 
  ///
  HRESULT ReadSampleIndex (
    [in] aafUInt32  bytes,
    [out, size_is(bytes), length_is(*bytesRead)] aafDataBuffer_t  buffer,
    [out,ref] aafUInt32 *  bytesRead);


  //***********************************************************
  //
  // SetSampleIndexPosition()
  //
  /// Seek to absolute position within the sample index data.
  /// 
  /// @param offset [in] offset from beginning of sample index
  ///
  HRESULT SetSampleIndexPosition (
    [in] aafPosition_t  offset);


  //***********************************************************
  //
  // GetSampleIndexPosition()
  //
  /// Get the absolute position within the sample index data.
  /// 
  /// @param pOffset [out] offset from beginning of sample index
  ///
  HRESULT GetSampleIndexPosition (
    [out] aafPosition_t*  pOffset);


  //***********************************************************
  //
  // GetSampleIndexSize()
  //
  /// Return the total size of the sample index data.
  /// 
  /// @param pSize  [out] size of sample index data
  ///
  HRESULT GetSampleIndexSize (
    [out] aafLength_t *  pSize );


  //***********************************************************
  //
  // SetFileMob()
  //
  /// Associates a weak reference to the given file mob with the
  /// essence data.
  ///
  /// Succeeds if all of the following are true:
  /// - the pFileMob pointer is valid and points to 
  /// a file mob (contains a file descriptor).
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFileMob is null.
  /// 
  /// @param pFileMob [in] reference to a file mob
  ///
  HRESULT SetFileMob (
    [in] IAAFSourceMob * pFileMob);


  //***********************************************************
  //
  // GetFileMob()
  //
  /// Associates a weak reference to the given file mob with the
  /// essence data.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppFileMob pointer is valid and a weak
  /// reference to the associated file mob can be
  /// resolved.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppFileMob is null.
  /// 
  /// @param ppFileMob [in] reference to a file mob
  ///
  HRESULT GetFileMob (
    [in] IAAFSourceMob ** ppFileMob);


  //***********************************************************
  //
  // GetFileMobID()
  //
  /// Return the mob id used to find the file mob associated with this
  /// essence.  The file mob must exist in the same file as this
  /// essence data.
  /// 
  /// @param pFileMobID [out] the file mob id associated with essence
  ///
  HRESULT GetFileMobID (
    [out] aafMobID_t *  pFileMobID);

}



// ************************
//
// Interface IAAFEssenceData2
//
// ************************

///
/// The IAAFEssenceData2 interface is used to modify AAFEssenceData
/// objects, which contain the actual essence data (ex. WAVE) when
/// it is contained within an AAF file.  Normally the client
/// application would access the essence through the IAAFEssenceAccess
/// interface, which handles the work of finding and (de)compressing
/// the data.  However, in rare cases direct access to the data is
/// required, so this interface is exposed.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
///
/// AAFRESULT_NULL_PARAM
///   - One of the passed in pointers is NULL.
///
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
///
/// Objects that implement IAAFEssenceData2 also implement the following interfaces:
///  - IAAFObject
[
    object,
    uuid(a4b0a376-af63-4620-8ae7-0db819ac4b06),
    helpstring("IAAFEssenceData2 Interface"),
    pointer_default(unique)
]
interface IAAFEssenceData2 : IUnknown
{


  //***********************************************************
  //
  // Initialize()
  //
  /// Associates a weak reference to the given file mob with the
  /// essence data.
  ///
  /// Succeeds if all of the following are true:
  /// - the pFileMob pointer is valid and points to 
  /// a file mob (contains a file descriptor).
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFileMob is null.
  /// 
  /// @param pFileMob [in] reference to a file mob
  ///
  HRESULT Initialize (
    [in] IAAFSourceMob * pFileMob);

  //***********************************************************
  //
  // Write()
  //
  /// Write pre-interleaved data to a essence stream.
  /// 
  /// @param bytes [in] write this many bytes to the data stream
  /// @param buffer [out, size_is(bytes)] here is the buffer
  /// @param bytesWritten [out,ref] 
  ///
  HRESULT Write (
    [in] aafUInt32  bytes,
    [out, size_is(bytes)] aafDataBuffer_t  buffer,
    [out,ref] aafUInt32 *  bytesWritten);


  //***********************************************************
  //
  // Read()
  //
  /// Read pre-interleaved data from a essence stream.
  /// 
  /// @param bytes [in] read this many bytes from the data stream
  /// @param buffer [out, size_is(bytes), length_is(*bytesRead)] here is the buffer
  /// @param bytesRead [out,ref] 
  ///
  HRESULT Read (
    [in] aafUInt32  bytes,
    [out, size_is(bytes), length_is(*bytesRead)] aafDataBuffer_t  buffer,
    [out,ref] aafUInt32 *  bytesRead);


  //***********************************************************
  //
  // SetPosition()
  //
  /// Seek to absolute position within the essence data.
  /// 
  /// @param offset [in] offset from beginning of essence
  ///
  HRESULT SetPosition (
    [in] aafPosition_t  offset);


  //***********************************************************
  //
  // GetPosition()
  //
  /// Get the absolute position within the essence data.
  /// 
  /// @param pOffset [out] offset from beginning of essence
  ///
  HRESULT GetPosition (
    [out] aafPosition_t*  pOffset);


  //***********************************************************
  //
  // GetSize()
  //
  /// Return the total size of the essence data.
  /// 
  /// @param pSize  [out] size of essence data
  ///
  HRESULT GetSize (
    [out] aafLength_t *  pSize );

  //***********************************************************
  //
  // WriteSampleIndex()
  //
  /// Write pre-interleaved data to a sample index stream.
  /// 
  /// @param bytes [in] write this many bytes to the sample index stream
  /// @param buffer [out, size_is(bytes)] here is the buffer
  /// @param bytesWritten [out,ref] 
  ///
  HRESULT WriteSampleIndex (
    [in] aafUInt32  bytes,
    [out, size_is(bytes)] aafDataBuffer_t  buffer,
    [out,ref] aafUInt32 *  bytesWritten);


  //***********************************************************
  //
  // ReadSampleIndex()
  //
  /// Read pre-interleaved data from a sample index stream.
  /// 
  /// @param bytes [in] read this many bytes from the sample index stream
  /// @param buffer [out, size_is(bytes), length_is(*bytesRead)] here is the buffer
  /// @param bytesRead [out,ref] 
  ///
  HRESULT ReadSampleIndex (
    [in] aafUInt32  bytes,
    [out, size_is(bytes), length_is(*bytesRead)] aafDataBuffer_t  buffer,
    [out,ref] aafUInt32 *  bytesRead);


  //***********************************************************
  //
  // SetSampleIndexPosition()
  //
  /// Seek to absolute position within the sample index data.
  /// 
  /// @param offset [in] offset from beginning of sample index
  ///
  HRESULT SetSampleIndexPosition (
    [in] aafPosition_t  offset);


  //***********************************************************
  //
  // GetSampleIndexPosition()
  //
  /// Get the absolute position within the sample index data.
  /// 
  /// @param pOffset [out] offset from beginning of sample index
  ///
  HRESULT GetSampleIndexPosition (
    [out] aafPosition_t*  pOffset);


  //***********************************************************
  //
  // GetSampleIndexSize()
  //
  /// Return the total size of the sample index data.
  /// 
  /// @param pSize  [out] size of sample index data
  ///
  HRESULT GetSampleIndexSize (
    [out] aafLength_t *  pSize );


  //***********************************************************
  //
  // SetFileMob()
  //
  /// Associates a weak reference to the given file mob with the
  /// essence data.
  ///
  /// Succeeds if all of the following are true:
  /// - the pFileMob pointer is valid and points to 
  /// a file mob (contains a file descriptor).
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFileMob is null.
  /// 
  /// @param pFileMob [in] reference to a file mob
  ///
  HRESULT SetFileMob (
    [in] IAAFSourceMob * pFileMob);


  //***********************************************************
  //
  // GetFileMob()
  //
  /// Associates a weak reference to the given file mob with the
  /// essence data.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppFileMob pointer is valid and a weak
  /// reference to the associated file mob can be
  /// resolved.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppFileMob is null.
  /// 
  /// @param ppFileMob [in] reference to a file mob
  ///
  HRESULT GetFileMob (
    [in] IAAFSourceMob ** ppFileMob);


  //***********************************************************
  //
  // GetFileMobID()
  //
  /// Return the mob id used to find the file mob associated with this
  /// essence.  The file mob must exist in the same file as this
  /// essence data.
  /// 
  /// @param pFileMobID [out] the file mob id associated with essence
  ///
  HRESULT GetFileMobID (
    [out] aafMobID_t *  pFileMobID);


  //***********************************************************
  //
  // GetPlainEssenceData()
  //
  /// Creates an object which implements
  // the AAFPlainEssenceData interface and provides access to a file
  // encoding-independent essence data.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pPlainEssenceData is a valid pointer.
  // - reserved is 0.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPlainEssenceData arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - reserved is not 0.
  /// 
  /// @param reserved [in] Reserved for future use
  /// @param pPlainEssenceData [out,retval] file encoding-independent essence data
  ///
  HRESULT GetPlainEssenceData (
    [in] aafUInt32  reserved,
    [out,retval] IAAFPlainEssenceData ** pPlainEssenceData);

}



// ************************
//
// Interface IAAFEssenceMultiAccess
//
// ************************

///
/// AAFEssenceMultiAccess is an interace which provides streaming
/// access over essence data.  This nterfaces deals with essence data
/// which is in an uncompressed form, and handles compression or
/// decompression of the data if required.
///
/// You should call the CreateMultiEssence or OpenMultiEssence calls on
/// AAFMasterMob in order to get an interface pointer to
/// AAFEssenceAccess, as there is no public create or open method in
/// the interface.
///
/// Objects implementing this interface also implement AAFEssenceAccess
/// for operations other than read and write.
///
/// A number of errors can be returned from most method calls,  These
/// are:
///   AAFRESULT_NOMEMORY   -- The system ran out of memory processing
///                           the method. 
///   AAFRESULT_NULL_PARAM -- A NULL parameter was passed in which was
///                           required.
[
    object,
    uuid(D815E2B4-2425-11d3-80AD-006008143E6F),
    helpstring("IAAFEssenceMultiAccess Interface"),
    pointer_default(unique)
]
interface IAAFEssenceMultiAccess : IUnknown
{

  //***********************************************************
  //
  // WriteMultiSamples()
  //
  /// Writes multiple channels worth of sample data to an interleaved
  /// data stream in the natural order for the CODEC.
  /// 
  /// @param arrayElemCount [in] number of elements in the array of transfer operations
  /// @param xferArray [in,size_is(arrayElemCount)] Points to an array of transfer parameters.  All fields in this
  /// array except for bytesXferred must be set up before doing the
  /// transfer.  Some of the fields in the xferArray structure are
  /// status results like bytesXferred and samplesXferred.
  ///
  /// The multiXfer_t structure has the following fields, which
  /// specify one channel of data: 
  ///
  ///   essenceDef    [IN] -- The essence type definition
  ///   physical      [IN] -- The physical input-output channel
  ///   numSamples    [IN] -- The number of samples to transfer
  ///   buflen        [IN] -- The size of the buffer
  ///   buffer        [IN] -- The buffer for this
  /// @param resultArray [out,size_is(arrayElemCount)] Put results into this array.  It has the following fields,
  /// which return result for one channel of data:
  ///
  ///   bytesXfered   [OUT] -- The total number of bytes transferred
  ///   samplesXfered [OUT] -- The total number of samples transferred
  ///
  HRESULT WriteMultiSamples (
    [in] aafUInt16  arrayElemCount,
    [in,size_is(arrayElemCount)] aafmMultiXfer_t *  xferArray,
    [out,size_is(arrayElemCount)] aafmMultiResult_t *  resultArray);


  //***********************************************************
  //
  // ReadMultiSamples()
  //
  /// Reads one or more channels from an interleaved data stream.
  /// Possible Errors:
  ///
  ///   Standard errors (see top of file).
  ///
  ///   AAFRESULT_END_OF_ESSENCE -- Hit the end of the essence (like
  ///                               EOF) while reading.
  /// 
  /// @param elemCount [in] The size of the array for transfer operations.
  /// @param xferArray [in, size_is(elemCount)] Points to an array of transfer parameters.  All fields in this
  /// array except for bytesXferred must be set up before doing the
  /// transfer.  Some of the fields in the xferArray structure are
  /// status results like bytesXferred and samplesXferred.
  ///
  /// The multiXfer_t structure has the following fields, which
  /// specify one channel of data:
  ///
  ///   essenceDef  [IN] -- The essence type definition
  ///   physical    [IN] -- The physical input-output channel
  ///   numSamples  [IN] -- The number of samples to transfer
  ///   buflen      [IN] -- The size of the buffer
  ///   buffer      [IN] -- The buffer for this
  /// @param resultArray [out, size_is(elemCount)] Results go into this array.
  ///
  /// The aafmMultiResult_t structure has the following fields,
  /// which return result for one channel of data: 
  ///
  ///   bytesXfered   [OUT] -- The total number of bytes transferred
  ///   samplesXfered [OUT] -- The total number of samples transferred
  ///
  HRESULT ReadMultiSamples (
    [in] aafUInt16  elemCount,
    [in, size_is(elemCount)] aafmMultiXfer_t *  xferArray,
    [out, size_is(elemCount)] aafmMultiResult_t *  resultArray);
}



// ************************
//
// Interface IAAFEventMobSlot2
//
// ************************

///
/// An EventMobSlot, as all MobSlots, has a concrete segment, which
/// is a concrete Event or a Sequence of ordered Events. If it has a
/// sequence of events, all events shall have the same concrete
/// Event.
///


///
/// Objects that implement IAAFEventMobSlot2 also implement the following interfaces:
///  - IAAFMobSlot
///  - IAAFObject
[
    object,
    uuid(15375122-ce6c-464d-8ac5-228862e61d08),
    helpstring("IAAFEventMobSlot2 Interface"),
    pointer_default(unique)
]
interface IAAFEventMobSlot2 : IUnknown
{

  //***********************************************************
  //
  // GetEditRate()
  //
  /// This method will get the edit rate for this mob slot.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pEditRate pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEditRate arg is NULL.
  /// 
  /// @param pEditRate [out,retval] Edit rate property value
  ///
  HRESULT GetEditRate (
    [out,retval] aafRational_t *  pEditRate);


  //***********************************************************
  //
  // SetEditRate()
  //
  /// This method will get set edit rate for this mob slot.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pEditRate pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEditRate arg is NULL.
  /// 
  /// @param pEditRate [in] Edit rate property value
  ///
  HRESULT SetEditRate (
    [in] aafRational_t *  pEditRate);

  //***********************************************************
  //
  // GetEventSlotOrigin()
  //
  /// This method will return the EventSlotOrigin of this mob slot.
  /// The EventSlotOrigin is an optional property.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pEventSlotOrigin pointer is valid.
  /// - the EventSlotOrigin property is present.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - The EventSlotOrigin property is not present.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEventSlotOrigin arg is NULL.
  /// 
  /// @param pEventSlotOrigin [out,retval] EventSlotOrigin property value
  ///
  HRESULT GetEventSlotOrigin (
    [out,retval] aafPosition_t *  pEventSlotOrigin);


  //***********************************************************
  //
  // SetEventSlotOrigin()
  //
  /// This method will set the EventSlotOrigin of this mob slot.
  /// EventSlotOrigin is an optional property.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.).
  /// 
  /// @param eventSlotOrigin [in] EventSlotOrigin property value
  ///
  HRESULT SetEventSlotOrigin (
    [in] aafPosition_t  eventSlotOrigin);



}



// ************************
//
// Interface IAAFFileDescriptor2
//
// ************************
///
/// The IAAFFileDescriptor2 interface is implemented by objects which
/// describe the format of the content data associated with a File
/// Source mob or the media associated with a Physical Source mob.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it through
///     this object's primary interface.  Note that IAAFFileDescriptor2
///     is a primary interface for an abstract class, so it is not
///     appropriate for the Initialize() method to exist in this
///     interface.  The Initialize() method is available through the
///     concrete object's primary interface.
///


///
/// Objects that implement IAAFFileDescriptor2 also implement the following interfaces:
///  - IAAFEssenceDescriptor
///  - IAAFObject
[
    object,
    uuid(38c1088b-f0f2-47c7-9413-361262ae9f07),
    helpstring("IAAFFileDescriptor2 Interface"),
    pointer_default(unique)
]
interface IAAFFileDescriptor2 : IUnknown
{

  //***********************************************************
  //
  // SetLength()
  //
  /// Sets the length of the essence in samples [not edit units].
  /// 
  /// Always succeeds.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param length [in] length of the essence in samples
  ///
  HRESULT SetLength (
    [in] aafLength_t  length);


  //***********************************************************
  //
  // GetLength()
  //
  /// Gets the length of the essence in samples [not edit units].
  ///
  /// Succeeds if all of the following are true:
  /// - the pLength pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pLength.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLength arg is NULL.
  /// 
  /// @param pLength [out] returns length of the essence in samples
  ///
  HRESULT GetLength (
    [out] aafLength_t *  pLength);


  //***********************************************************
  //
  // SetCodecDef()
  //
  /// Set to the exact codec which was used as a hint.
  /// 
  /// Always succeeds.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param codecDef [in] Which codec was used
  ///
  HRESULT SetCodecDef (
    [in] IAAFCodecDef * codecDef);


  //***********************************************************
  //
  // GetCodecDef()
  //
  /// Get to the exact codec which was used as a hint.
  ///
  /// Succeeds if all of the following are true:
  /// - the pCodecDef pointer is valid.
  /// - the CodecDefinition identifying the codec is
  ///   present in the dictionary.
  /// 
  /// If this method fails nothing will be written to *pCodecDef.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCodecDef arg is NULL.
  ///
  /// AAFRESULT_OBJECT_NOT_FOUND
  ///   - the CodecDefinition identifying the codec is not
  ///     in the dictionary.
  /// 
  /// @param pCodecDef [out] Which codec was used
  ///
  HRESULT GetCodecDef (
    [out] IAAFCodecDef ** pCodecDef);


  //***********************************************************
  //
  // SetSampleRate()
  //
  /// Sets sample rate of the essence as opposed to the edit rate.
  /// 
  /// If this method fails the sample rate property will not be
  /// changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param rate [in] sample rate of the essence
  ///
  HRESULT SetSampleRate (
    [in] aafRational_constref  rate);


  //***********************************************************
  //
  // GetSampleRate()
  //
  /// Gets sample rate of the essence as opposed to the edit rate. and
  /// writes it into the *pRate argument.
  ///
  /// Succeeds if all of the following are true:
  /// - the pRate pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pRate.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pRate arg is NULL.
  /// 
  /// @param pRate [out] sample rate of the essence
  ///
  HRESULT GetSampleRate (
    [out] aafRational_t*  pRate);


  //***********************************************************
  //
  // SetContainerFormat()
  //
  /// Identifies the file format.  The container format is an optional
  /// property.
  /// 
  /// If this method fails the container format property will not be
  /// changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param format [in] file format
  ///
  HRESULT SetContainerFormat (
    [in] IAAFContainerDef * format);


  //***********************************************************
  //
  // GetContainerFormat()
  //
  /// Identifies the file format.
  ///
  /// Succeeds if all of the following are true:
  /// - the pFormat pointer is valid.
  /// - the ContainerDefinition identifying the file format is
  ///   present in the dictionary.
  /// 
  /// If this method fails nothing will be written to *pFormat.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFormat arg is NULL.
  ///
  /// AAFRESULT_OBJECT_NOT_FOUND
  ///   - the ContainerDefinition identifying the file format is not
  ///     in the dictionary.
  /// 
  /// @param pFormat [out] Optional
  ///
  HRESULT GetContainerFormat (
    [out] IAAFContainerDef ** pFormat);


  //***********************************************************
  //
  // SetLinkedSlotID()
  //
  /// Sets the LinkedSlotID property.  
  ///
  ///
  /// This property is optional.
  ///
  /// If this method fails, the LinkedSlotID property will not
  /// be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param LinkedSlotID [in] the linked slot id
  ///
  HRESULT SetLinkedSlotID (
    [in] aafUInt32  LinkedSlotID);


  //***********************************************************
  //
  // GetLinkedSlotID()
  //
  /// Gets the LinkedSlotID property. 
  ///
  ///
  /// Succeeds if all of the following are true:
  /// - pLinkedSlotID is a valid pointer.
  /// 
  /// If this method fails, *pLinkedSlotID will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLinkedSlotID arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the LinkedSlotID property is not present.
  /// 
  /// @param pLinkedSlotID [out] The linked slot id
  ///
  HRESULT GetLinkedSlotID (
    [out] aafUInt32 *  pLinkedSlotID);

}



// ************************
//
// Interface IAAFHeader2
//
// ************************
///
/// The IAAFHeader2 interface provides file-wide information and
/// indexes.  Each AAF file has one and only one instance of an object
/// which supports IAAFHeader2.
///
/// When an IAAFHeader2-supporting object is created, the contained
/// dictionary object is automatically created.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
///
/// Objects that implement IAAFHeader2 also implement the following interfaces:
///  - IAAFObject
[
    object,
    uuid(463C0CA0-926B-4BE4-84C1-4455FF5628EE),
    helpstring("IAAFHeader2 Interface"),
    pointer_default(unique)
]
interface IAAFHeader2 : IUnknown
{

  //***********************************************************
  //
  // LookupMob()
  //
  /// Looks up the Mob that matches the given mob id and puts it into
  /// the ppMob argument.  The returned mob interface is AddRef()ed
  /// before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppMob pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppMob.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppMob is null
  ///
  /// AAFRESULT_MOB_NOT_FOUND
  ///   - the requested mob wasn't found.
  /// 
  /// @param mobID [in, ref] The Mob ID
  /// @param ppMob [out,retval] Matching Mob
  ///
  HRESULT LookupMob (
    [in, ref] aafMobID_constref  mobID,
    [out,retval] IAAFMob ** ppMob);


  //***********************************************************
  //
  // CountMobs()
  //
  /// Writes the number of matches for the given mob kind into the
  /// *pNumMobs argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pNumMobs pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pNumMobs.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumMobs is null.
  /// 
  /// @param mobKind [in] The mob kind to count
  /// @param pResult [out, retval] Total number of mobs of kind mobKind
  ///
  HRESULT CountMobs (
    [in] aafMobKind_t  mobKind,
    [out, retval] aafNumSlots_t *  pResult);


  //***********************************************************
  //
  // GetMobs()
  //
  /// Places an enumerator for mobs that apply to the criteria into the
  /// *ppEnum argument.  If pSearchCriteria is null, all mobs are
  /// returned.   The searchTag field of pSearchCriteria, and exactly
  /// ONE of the fields in the union (tags.mobID, tags.name, etc. )
  /// must be set.  Only one search criterion may be specified.  The
  /// returned enumerator is AddRef()ed before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  /// 
  /// @param pSearchCriteria [in] Search Criteria for enumeration
  /// @param ppEnum [out, retval] Mob Enumeration
  ///
  HRESULT GetMobs (
    [in] aafSearchCrit_t *  pSearchCriteria,
    [out, retval] IEnumAAFMobs ** ppEnum);


  //***********************************************************
  //
  // AddMob()
  //
  /// Appends the given mob to the header.  If the given mob is already
  /// contained this method will do nothing and will return success.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pMob pointer is valid.
  /// - the given mob is not already part of this collection.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMob is null.
  ///
  /// AAFRESULT_DUPLICATE_MOBID
  ///   - the given mob is already contained.
  /// 
  /// @param pMob [in] Mob to add
  ///
  HRESULT AddMob (
    [in] IAAFMob * pMob);


  //***********************************************************
  //
  // RemoveMob()
  //
  /// Removes the given mob from the header.
  ///
  /// Succeeds if all of the following are true:
  /// - the pMob pointer is valid.
  /// - the given mob is currently in the collection.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMob is null.
  ///
  /// AAFRESULT_MOB_NOT_FOUND
  ///   - the given mob is not already contained.
  /// 
  /// @param pMob [in] Mob to remove
  ///
  HRESULT RemoveMob (
    [in] IAAFMob * pMob);


  //***********************************************************
  //
  // CountEssenceData()
  //
  /// Writes the total number of essence data into the *pNumEssenceData
  /// argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pNumEssenceData pointer is valid.
  /// 
  /// If this method fails nothing will be written to
  /// *pNumEssenceData.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumEssenceData is null.
  /// 
  /// @param pResult [out, retval] Total number of essence data
  ///
  HRESULT CountEssenceData (
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // IsEssenceDataPresent()
  //
  /// Returns true if the essence is found.
  ///
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  /// 
  /// @param fileMobID [in, ref] A Unique File Mob ID
  /// @param fmt [in] The Essence File Format
  /// @param pResult [out,retval] True if the essence is found
  ///
  HRESULT IsEssenceDataPresent (
    [in, ref] aafMobID_constref  fileMobID,
    [in] aafFileFormat_t  fmt,
    [out,retval] aafBoolean_t *  pResult);


  //***********************************************************
  //
  // EnumEssenceData()
  //
  /// Places an enumerator for essence that applies to the criteria
  /// into the *ppEnum argument.  The returned enumerator is
  /// AddRef()ed before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pMediaCriteria pointer is valid.
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pMediaCriteria or ppEnum is null.
  /// 
  /// @param ppEnum [out,retval] Essence Enumeration
  ///
  HRESULT EnumEssenceData (
    [out,retval] IEnumAAFEssenceData ** ppEnum);


  //***********************************************************
  //
  // AddEssenceData()
  //
  /// Appends the given essence data object to the header.
  /// 
  /// NOTE! Stub only.   Implementation not yet added.
  ///
  /// Succeeds if all of the following are true:
  /// - the pEssenceData pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_DUPLICATE_MOBID
  ///   - The given mob has already been added.  The validation is done by comparing
  ///     mobIDs, which should be unique.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEssenceData is null.
  /// 
  /// @param pEssenceData [in] Essence data object to append
  ///
  HRESULT AddEssenceData (
    [in] IAAFEssenceData * pEssenceData);

  //***********************************************************
  //
  // RemoveEssenceData()
  //
  /// Removes the given EssenceData from the header.
  ///
  /// Succeeds if all of the following are true:
  /// - the pEssenceData pointer is valid.
  /// - the given EssenceData is currently in the collection.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEssenceData is null.
  ///
  /// AAFRESULT_ESSENCE_NOT_FOUND
  ///   - the given EssenceData is not already contained.
  /// 
  /// @param pEssenceData [in] EssenceData to remove
  ///
  HRESULT RemoveEssenceData (
    [in] IAAFEssenceData * pEssenceData);

  //***********************************************************
  //
  // LookupEssenceData()
  //
  /// Looks up the EssenceData that matches the given mob id and puts it into
  /// the ppEssenceData argument.  The returned EssenceData interface is AddRef()ed
  /// before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEssenceData pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEssenceData.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEssenceData is null
  ///
  /// AAFRESULT_MOB_NOT_FOUND
  ///   - the requested EssenceData wasn't found.
  /// 
  /// @param mobID [in, ref] The Mob ID
  /// @param ppEssenceData [out,retval] Matching EssenceData
  ///
  HRESULT LookupEssenceData (
    [in, ref] aafMobID_constref  mobID,
    [out,retval] IAAFEssenceData ** ppEssenceData);

  //***********************************************************
  //
  // GetDictionary()
  //
  /// Places the dictionary that contains all types of aaf definition
  /// objects into the *ppDictionary argument.  The returned dictionary
  /// is AddRef()ed before it is returned.  Note that the dictionary
  /// is automatically created when the header object is created.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppDictionary pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDictionary is null.
  /// 
  /// @param ppDictionary [out, retval] The AAF Dictionary
  ///
  HRESULT GetDictionary (
    [out, retval] IAAFDictionary ** ppDictionary);


  //***********************************************************
  //
  // GetLastIdentification()
  //
  /// Places the identification of the last entity that modified the
  /// file into the *ppIdentification argument.  The returned
  /// identification is AddRef()ed before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppIdentification pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppIdentification is null.
  /// 
  /// @param ppIdentification [out,retval] Indentification Object
  ///
  HRESULT GetLastIdentification (
    [out,retval] IAAFIdentification ** ppIdentification);


  //***********************************************************
  //
  // LookupIdentification()
  //
  /// Places the Identification that matches the given generation into
  /// the *ppIdentification argument.  The returned identification is
  /// AddRef()ed before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppIdentification pointer is valid.
  /// - the given generation was found.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppIdentification is null.
  ///
  /// AAFRESULT_OBJECT_NOT_FOUND
  ///   - the given generation was not found..
  /// 
  /// @param generation [in, ref] Unique Generation ID
  /// @param ppIdentification [out,retval] Indentification Object
  ///
  HRESULT LookupIdentification (
    [in, ref] aafUID_constref  generation,
    [out,retval] IAAFIdentification ** ppIdentification);


  //***********************************************************
  //
  // CountIdentifications()
  //
  /// Writes the number of identification objects into the *pResult
  /// argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  /// 
  /// @param pResult [out, retval] Total number of identification objects
  ///
  HRESULT CountIdentifications (
    [out, retval] aafUInt32 *  pResult);


  //***********************************************************
  //
  // GetIdentifications()
  //
  /// Places an enumerator for all Identifications criteria into	the
  /// *ppEnum argument.  The returned enumerator is AddRef()ed before
  /// it is returned.
  /// 
  /// NOTE! Stub only.   Implementation not yet added.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  /// 
  /// @param ppEnum [out,retval] Indentification Enumeration
  ///
  HRESULT GetIdentifications (
    [out,retval] IEnumAAFIdentifications ** ppEnum);


  //***********************************************************
  //
  // AppendIdentification()
  //
  /// Appends the given Identification class to the header.  This
  /// method does not attempt to identify duplicate identifications, so
  /// it will succeed even if an identical identification has already
  /// been appended.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pIdent pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pIdent is null.
  /// 
  /// @param pIdent [in] Identification to append
  ///
  HRESULT AppendIdentification (
    [in] IAAFIdentification * pIdent);


  //***********************************************************
  //
  // GetIdentificationAt()
  //
  /// Retrieves the indexed identification from the header.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppIdentification pointer is valid.
  /// - index is less than the value returned by CountIdentifications().
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppIdent is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than or equal to result of
  ///     CountIdentifications().
  /// 
  /// @param index [in] Index of identification to retrieve
  /// @param ppIdentification [out, retval] Retrieved identification
  ///
  HRESULT GetIdentificationAt (
    [in] aafUInt32  index,
    [out, retval] IAAFIdentification ** ppIdentification);


  //***********************************************************
  //
  // GetRefImplVersion()
  //
  /// Return the version of the Reference Implementation currently
  /// running on this machine, which implements these interfaces.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pVersion pointer is valid.
  /// 
  /// If this method fails nothing is written to *pVersion.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pVersion is null.
  /// 
  /// @param pVersion [out, retval] The Reference Implementation Version
  ///
  HRESULT GetRefImplVersion (
    [out, retval] aafProductVersion_t *  pVersion);


  //***********************************************************
  //
  // GetFileRevision()
  //
  /// Return the File Revision property.
  /// 
  /// NOTE! Stub only.   Implementation not yet added.
  ///
  /// Succeeds if all of the following are true:
  /// - the pRevision pointer is valid.
  /// 
  /// If this method fails nothing is written to *pRevision.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pRevision is null.
  /// 
  /// @param pRevision [out, retval] The File Version
  ///
  HRESULT GetFileRevision (
    [out, retval] aafVersionType_t *  pRevision);


  //***********************************************************
  //
  // GetLastModified()
  //
  /// Return the Last Modified property.
  /// 
  /// NOTE! Stub only.   Implementation not yet added.
  ///
  /// Succeeds if all of the following are true:
  /// - the pTimeStamp pointer is valid.
  /// 
  /// If this method fails nothing is written to *pTimeStamp.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTimeStamp is null.
  /// 
  /// @param pTimeStamp [out, retval] The modification date-time stamp
  ///
  HRESULT GetLastModified (
    [out, retval] aafTimeStamp_t *  pTimeStamp);


  //***********************************************************
  //
  // GetContentStorage()
  //
  /// Places the Content Storage object attached to the header into the
  /// *ppStorage argument.
  ///
  /// The returned content storage object is
  /// AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppStorage pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppStorage is null.
  /// 
  /// @param ppStorage [out] Returned Content Storage object
  ///
  HRESULT GetContentStorage (
    [out] IAAFContentStorage ** ppStorage);


  //***********************************************************
  //
  // GetPrimaryMob()
  //
  /// Returns this file's primary mob.
  ///
  /// Succeeds if all of the following are true:
  /// - the pPrimaryMob pointer is valid.
  ///
  /// The returned object is AddRef()ed before it is returned.
  ///
  /// If this method fails no state will be changed.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPrimaryMob arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - property not present.
  /// 
  /// @param pPrimaryMob [out, retval] The primary mob
  ///
  HRESULT GetPrimaryMob (
    [out, retval] IAAFMob ** pPrimaryMob);


  //***********************************************************
  //
  // SetPrimaryMob()
  //
  /// Sets this file's primary mob.
  ///
  /// If this method fails, the property will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPrimaryMob arg is NULL.
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param pPrimaryMob [in] The primary mob
  ///
  HRESULT SetPrimaryMob (
    [in] IAAFMob * pPrimaryMob);


  //***********************************************************
  //
  // GetOperationalPattern()
  //
  /// This method returns ID of the operational pattern this
  /// file complies to.
  ///
  /// Succeeds if all of the following are true:
  /// - the pOperationalPatternID pointer is valid.
  /// - the OperationalPattern property is present
  ///
  /// If this method fails nothing will be written to *pOperationalPatternID.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pOperationalPatternID arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - property not present.
  /// 
  /// @param pOperationalPatternID [out] Operational pattern ID.
  ///
  HRESULT GetOperationalPattern (
    [out] aafUID_t *  pOperationalPatternID);


  //***********************************************************
  //
  // SetOperationalPattern()
  //
  /// Sets operational pattern this file complies to.
  ///
  /// If this method fails, the property will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param operationalPatternID [in] Operational pattern ID.
  ///
  HRESULT SetOperationalPattern (
    [in] aafUID_constref  operationalPatternID);


  //***********************************************************
  //
  // UpdateEssenceContainers()
  //
  /// Ensures that the contents of the EssenceContainers property
  /// is in sync with the file's metadata. If this method succeeds
  /// the property will contain IDs of all ContainerDefinitions referenced
  /// by source mobs in this file.
  /// If the property isn't present it will be created.
  /// This method must be called before any other EssenceContainers
  /// method can be called.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  HRESULT UpdateEssenceContainers ();


  //***********************************************************
  //
  // CountEssenceContainers()
  //
  /// Gets the total number of essence containers present in the file.
  ///
  /// Succeeds if all of the following are true:
  /// - the pCount pointer is valid.
  /// - the EssenceContainers property is present
  ///
  /// If this method fails nothing will be written to *pCount.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCount arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - property not present.
  /// 
  /// @param pCount [out, retval] Number of essence containers
  ///
  HRESULT CountEssenceContainers (
    [out, retval] aafUInt32*  pCount);


  //***********************************************************
  //
  // GetEssenceContainers()
  //
  /// Gets IDs of essence containers present in the file.
  ///
  /// The values are written to the array specified by pEssenceContainerIDs,
  /// which is of size maxEssenceContainersCount. The required size may be found
  /// by calling CountEssenceContainers().
  /// 
  /// Succeeds if all of the following are true:
  /// - pEssenceContainerIDs is a valid pointer.
  /// - maxEssenceContainersCount indicates the array is large enough to hold the
  ///   data.
  /// - the EssenceContainers property is present
  /// 
  /// If this method fails, the property will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEssenceContainerIDs is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - maxEssenceContainersCount indicates that the array is too small to hold
  ///     the data.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - property not present.
  /// 
  /// @param maxEssenceContainersCount [in] The number of elements in the array
  /// @param pEssenceContainerIDs [out, size_is(maxEssenceContainersCount)] Array to hold the essence container IDs
  ///
  HRESULT GetEssenceContainers (
    [in] aafUInt32  maxEssenceContainersCount,
    [out, size_is(maxEssenceContainersCount)] aafUID_t *  pEssenceContainerIDs);


  //***********************************************************
  //
  // IsEssenceContainerPresent()
  //
  /// Returns true if the essence container is present.
  ///
  /// Succeeds if all of the following are true:
  /// - the pIsPresent pointer is valid.
  /// - the EssenceContainers property is present
  ///
  /// If this method fails nothing will be written to *pIsPresent.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pIsPresent arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - property not present.
  /// 
  /// @param essenceContainerID [in, ref] Essence container ID
  /// @param pIsPresent [out,retval] Is this essence container present
  ///
  HRESULT IsEssenceContainerPresent (
    [in, ref] aafUID_constref  essenceContainerID,
    [out,retval] aafBoolean_t*  pIsPresent);


  //***********************************************************
  //
  // CountDescriptiveSchemes()
  //
  /// Gets the total number of descriptive schemes present in the file.
  ///
  /// Succeeds if all of the following are true:
  /// - the pCount pointer is valid.
  /// - the DescriptiveSchemes property is present
  ///
  /// If this method fails nothing will be written to *pCount.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCount arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - property not present.
  /// 
  /// @param pCount [out, retval] Number of descriptive schemes
  ///
  HRESULT CountDescriptiveSchemes (
    [out, retval] aafUInt32*  pCount);


  //***********************************************************
  //
  // GetDescriptiveSchemes()
  //
  /// Gets IDs of descriptive schemes present in the file.
  ///
  /// The values are written to the array specified by pDescriptiveSchemeIDs,
  /// which is of size maxDescriptiveSchemesCount. The required size may be found
  /// by calling CountDescriptiveSchemes().
  /// 
  /// Succeeds if all of the following are true:
  /// - pDescriptiveSchemeIDs is a valid pointer.
  /// - maxDescriptiveSchemesCount indicates the array is large enough to hold the
  ///   data.
  /// - the DescriptiveSchemes property is present
  /// 
  /// If this method fails, the property will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDescriptiveSchemeIDs is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - maxDescriptiveSchemesCount indicates that the array is too small to hold
  ///     the data.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - property not present.
  /// 
  /// @param maxDescriptiveSchemesCount [in] The number of elements in the array
  /// @param pDescriptiveSchemeIDs [out, size_is(maxDescriptiveSchemesCount)] Array to hold the descriptive scheme IDs
  ///
  HRESULT GetDescriptiveSchemes (
    [in] aafUInt32  maxDescriptiveSchemesCount,
    [out, size_is(maxDescriptiveSchemesCount)] aafUID_t *  pDescriptiveSchemeIDs);


  //***********************************************************
  //
  // IsDescriptiveSchemePresent()
  //
  /// Returns true if the descriptive scheme ID is present.
  ///
  ///
  /// Succeeds if all of the following are true:
  /// - the pIsPresent pointer is valid;
  /// - the DescriptiveSchemes property is present
  ///
  /// If this method fails nothing will be written to *pIsPresent.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pIsPresent arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - property not present.
  /// 
  /// @param descriptiveSchemeID [in, ref] Descriptive scheme ID
  /// @param pIsPresent [out,retval] Is this descriptive scheme ID present
  ///
  HRESULT IsDescriptiveSchemePresent (
    [in, ref] aafUID_constref  descriptiveSchemeID,
    [out,retval] aafBoolean_t*  pIsPresent);


  //***********************************************************
  //
  // AddDescriptiveScheme()
  //
  /// Appends the given descriptive scheme ID to the list of
  /// descriptive schemes found in the file.
  ///
  /// Succeeds if all of the following are true:
  /// - the given descriptive scheme ID is not already contained.
  ///
  /// If this method fails, the property will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given descriptive scheme ID is already contained.
  /// 
  /// @param descriptiveSchemeID [in] New descriptive scheme ID.
  ///
  HRESULT AddDescriptiveScheme (
    [in] aafUID_constref  descriptiveSchemeID);


  //***********************************************************
  //
  // RemoveDescriptiveScheme()
  //
  /// Removes the given descriptive scheme ID from
  /// the list of descriptive schemes found in the file.
  ///
  /// Succeeds if all of the following are true:
  /// - the DescriptiveSchemes property is present;
  /// - the given descriptive scheme ID is present in the list
  ///   of descriptive schemes found in the file.
  ///
  /// If this method fails, the property will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - property not present.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given descriptive scheme ID is present in the list
  ///     of descriptive schemes found in the file.
  /// 
  /// @param descriptiveSchemeID [in] Descriptive scheme to remove.
  ///
  HRESULT RemoveDescriptiveScheme (
    [in] aafUID_constref  descriptiveSchemeID);

}



// ************************
//
// Interface IAAFKLVEssenceDataParameters
//
// ************************
///
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.


[
    object,
    uuid(cc2af9ae-edad-4b30-9e3e-5ba692380a84),
    helpstring("IAAFKLVEssenceDataParameters Interface"),
    pointer_default(unique)
]
interface IAAFKLVEssenceDataParameters : IUnknown
{


  //***********************************************************
  //
  // GetEssenceElementKey()
  //
  /// This method returns essence element key associated
  /// with the essence stream.
  ///
  /// Succeeds if all of the following are true:
  /// - pEssenceElementKey is a valid pointer.
  /// - the essence stream supports essence element keys.
  ///
  /// If this method fails nothing will be written to *pEssenceElementKey.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEssenceElementKey arg is NULL.
  ///
  /// AAFRESULT_OPERATION_NOT_PERMITTED
  ///   - the essence stream does not support essence element keys.
  /// 
  /// @param pEssenceElementKey [out] Essence element key.
  ///
  HRESULT GetEssenceElementKey (
    [out] aafUID_t *  pEssenceElementKey);


  //***********************************************************
  //
  // SetEssenceElementKey()
  //
  /// Set the essence element key on the essence stream.
  /// 
  /// Succeeds if all of the following are true:
  /// - the essence stream supports essence element keys.
  /// 
  /// If this method fails, the property will not be changed.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_OPERATION_NOT_PERMITTED
  ///   - the essence stream does not support essence element keys.
  /// 
  /// @param key [in, ref] essence element key
  ///
  HRESULT SetEssenceElementKey (
    [in, ref] aafUID_constref  key);

}



// ************************
//
// Interface IAAFKLVStreamParameters
//
// ************************
///
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
[
    object,
    uuid(379d9d03-4a5f-4399-a105-5ae6e17d9e59),
    helpstring("IAAFKLVStreamParameters Interface"),
    pointer_default(unique)
]
interface IAAFKLVStreamParameters : IUnknown
{


  //***********************************************************
  //
  // GetEssenceElementKey()
  //
  /// This method returns essence element key associated
  /// with the specified stream.
  ///
  /// Succeeds if all of the following are true:
  /// - pStreamPropertyValue is a valid pointer.
  /// - pEssenceElementKey is a valid pointer.
  /// - the specified stream supports essence element keys.
  ///
  /// If this method fails nothing will be written to *pEssenceElementKey.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pStreamPropertyValue or pEssenceElementKey arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - the specified stream does not support essence element keys.
  /// 
  /// @param pStreamPropertyValue [in] stream property value
  /// @param pEssenceElementKey [out] Essence element key.
  ///
  HRESULT GetEssenceElementKey (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [out] aafUID_t *  pEssenceElementKey);


  //***********************************************************
  //
  // SetEssenceElementKey()
  //
  /// Set the essence element key on the specified stream.
  /// 
  /// Succeeds if all of the following are true:
  /// - pStreamPropertyValue is a valid pointer.
  /// - the specified stream supports essence element keys.
  /// 
  /// If this method fails, the property will not be changed.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pStreamPropertyValue arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - the specified stream does not support essence element keys.
  /// 
  /// @param pStreamPropertyValue [in] stream property value
  /// @param key [in, ref] essence element key
  ///
  HRESULT SetEssenceElementKey (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [in, ref] aafUID_constref  key);

}



// ************************
//
// Interface IAAFMasterMob2
//
// ************************
///
/// The IAAFMasterMob interface is implemented by objects which provide
/// access to the File Source Mobs and EssenceData objects.  The Master
/// Mob object is used to provide a level of indirection for accessing
/// Source Mobs from Composition Mobs.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
///
/// Objects that implement IAAFMasterMob2 also implement the following interfaces:
///  - IAAFMob
///  - IAAFMob2
///  - IAAFObject
[
    object,
    uuid(afcffd2c-279b-466f-a496-55cbdcc17531),
    helpstring("IAAFMasterMob2 Interface"),
    pointer_default(unique)
]
interface IAAFMasterMob2 : IUnknown
{



  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty IAAFMasterMob-supporting
  /// object.  This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  /// 
  HRESULT Initialize ();


  //***********************************************************
  //
  // AddMasterSlot()
  //
  /// This function adds a slot to the specified Master Mob that
  /// references the specified a slot in the specified Source Mob. The
  /// new slot in the Master Mob contains a Source Clip that specifies
  /// the Source Mob in its source reference properties.  Typically this
  /// is done automatically by passing the Master Mob handle to
  /// AAFMedia::Create, but this function allows you to add it later.
  ///
  /// Note: If pSlotName is passed in with zero length, then the
  /// slot is not assigned a name.  Slot names are not used by the
  /// SDK, and exist only so the user can name slots.
  /// 
  /// Succeeds if all of the following are true:
  /// (more conditions here)
  /// 
  /// If this method fails no state is changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - One or more of the following parameters are NULL pSourceMob,
  ///     pSlotName, and pDataDef.
  ///
  /// AAFRESULT_INVALID_DATADEF
  ///   - The data kind of the source MOB slot to be added to the Master
  ///     Mob does not match what is specfied in pDataDef.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The specified Source Mob slot was not found.
  ///
  /// AAFRESULT_SLOT_EXISTS
  ///   - The specified Master slot ID already exists.
  /// 
  /// @param pDataDef [in] Data kind of new slot.  Requires a data kind valid for a media
  /// stream. Valid data kinds are:
  /// - Picture
  /// - Sound
  /// @param sourceSlotID [in] Slot ID of the Source Mob slot to be added to the Master Mob
  /// @param pSourceMob [in] Source Mob containing the slot to be added to the Master Mob
  /// @param masterSlotID [in] SlotID assigned to the new Master Mob slot
  /// @param pSlotName [in, string] Name to assign to new slot in Master Mob
  ///
  HRESULT AddMasterSlot (
    [in] IAAFDataDef * pDataDef,
    [in] aafSlotID_t  sourceSlotID,
    [in] IAAFSourceMob * pSourceMob,
    [in] aafSlotID_t  masterSlotID,
    [in, string] aafCharacter_constptr  pSlotName);


  //***********************************************************
  //
  // GetTapeName()
  //
  /// Finds the tape Source Mob associated with a Master Mob slot
  /// and writes the name of the tape, which is stored in the
  /// Mobs Name property, into the pTapeName buffer.  The buffer is
  /// allocated by the caller.  The size of the buffer is given by
  /// bufSize.  If the property name has not yet been set, a
  /// zero-length string will be written (that is, only the trailing
  /// null character).
  /// 
  /// Caller may call GetTapeNameBufLen() to determine the required
  /// buffer size.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pTapeName pointer is valid.
  /// - the specified master slot was found.
  /// - the specified master slot contains a tape mob.
  /// - bufSize indicates the buffer is large enough to hold the name.
  /// 
  /// If this method fails nothing will be written to *pTapeName.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTapeName arg is NULL.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The specified Master Slot was not found.
  ///
  /// AAFRESULT_NOT_TAPEMOB
  ///   - The specified Master Slot does not contain a Tape MOB.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - bufSize indicates the buffer is too small to hold the string.
  /// 
  /// @param masterSlotID [in] SlotID of the Master Mob slot
  /// @param pTapeName [out, size_is(bufSize), string] The returned name
  /// @param bufSize [in] the size of the pTapeName buffer
  ///
  HRESULT GetTapeName (
    [in] aafUInt32  masterSlotID,
    [out, size_is(bufSize), string] aafCharacter *  pTapeName,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetTapeNameBufLen()
  //
  /// Returns the length of buffer required for the GetTapeName()
  /// method.  The value is placed into the location specified by
  /// pLen.  The value will include space required for the trailing
  /// null character.
  ///
  /// Succeeds if all of the following are true:
  /// - the pLen pointer is valid.
  ///
  /// If this method fails nothing will be written to *pLen.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLen arg is NULL.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The specified Master Slot was not found.
  ///
  /// AAFRESULT_NOT_TAPEMOB
  ///   - The specified Master Slot does not contain a Tape MOB.
  /// 
  /// @param masterSlotID [in] SlotID of the Master Mob slot
  /// @param pLen [out] required buffer length
  ///
  HRESULT GetTapeNameBufLen (
    [in] aafUInt32  masterSlotID,
    [out] aafUInt32 *  pLen);


  //***********************************************************
  //
  // GetNumRepresentations()
  //
  /// This function returns the number of media representations
  /// available for the specified SlotID on a specified Master
  /// Mob. This function is meant to work with
  /// GetRepresentationSourceClip, so that you can iterate through
  /// all of the choices yourself.  In most cases, you can use
  /// GetCriteriaSourceClip to handle multiple
  /// representations.  This function and
  /// GetRepresentationSourceClip are lower-level functions.
  ///
  /// Succeeds if all of the following are true:
  /// - the pNumReps pointer is valid.
  ///
  /// If this method fails nothing will be written to *pNumReps.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumReps arg is NULL.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The Master Slot specified by slotID was not found.
  /// 
  /// @param slotID [in] SlotID
  /// @param pNumReps [out, retval] number of representations
  ///
  HRESULT GetNumRepresentations (
    [in] aafSlotID_t  slotID,
    [out, retval] aafNumSlots_t *  pNumReps);


  //***********************************************************
  //
  // GetRepresentation()
  //
  /// This method returns the indexed media representation for the
  /// specified Master Mob, SlotID, and index.  This call is meant to
  /// work with GetNumRepresentations, so that you can iterate through
  /// all of the choices yourself.  This method uses an integer index,
  /// not an iterator.  The function GetRepresentationSourceClip takes
  /// an index between 1 and the number of representations
  /// [inclusive], and returns the indexed Source Mob. You can make
  /// calls to functions such as AAFMedia::GetVideoInfo and
  /// AAFMedia::IsMediaContiguous to determine which media is the best
  /// fit.
  ///
  /// The returned source clip is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppSourceClip pointer is valid.
  ///
  /// If this method fails nothing will be written to *ppSourceClip.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppSourceClip arg is NULL.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The specified Master Slot was not found.
  ///
  /// AAFRESULT_BADINDEX
  ///   - No Source Mob at specified index.
  /// 
  /// @param slotID [in] Slot ID
  /// @param index [in] Index of requested representation
  /// @param ppSourceClip [out] Requested Source Clip
  ///
  HRESULT GetRepresentation (
    [in] aafSlotID_t  slotID,
    [in] aafUInt32  index,
    [out] IAAFSegment ** ppSourceClip);


  //***********************************************************
  //
  // GetCriteriaSegment()
  //
  /// Returns the Segment on the specified slot of a Master Mob
  /// that references the Source Mob that best meets the specified
  /// criteria.  This function will work whether multiple media
  /// representations exist or not.
  ///
  /// The returned segment is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppSegment pointer is valid.
  ///
  /// If this method fails nothing will be written to *ppSegment.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppSegment arg is NULL.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The specified Master Slot was not found.
  /// 
  /// @param slotID [in] Slot ID
  /// @param pCriteria [in] Index of requested representation.  Note: the
  /// aafMediaCriteria_t is defined as the following structure:
  /// typedef struct
  /// {
  ///	aafCriteriaType_t type;
  ///	aafCriteriaProc_t proc;
  /// } aafMediaCriteria_t;
  ///
  /// The type field can have one of the following values:
  /// typedef enum
  /// {
  ///	kAAFAnyRepresentation = 0,
  ///	kAAFFastestRepresentation,
  ///	kAAFBestFidelityRepresentation,
  ///	kAAFSmallestRepresentation,
  ///	kAAFUseRepresentationProc
  /// } aafCriteriaType_t;
  /// @param ppSegment [out] Requested Segment
  ///
  HRESULT GetCriteriaSegment (
    [in] aafSlotID_t  slotID,
    [in] aafMediaCriteria_t *  pCriteria,
    [out] IAAFSegment ** ppSegment);


  //***********************************************************
  //
  // AppendPhysSourceRef()
  //
  /// Connects this Source Mob with the physical Source Mob that
  /// describes the previous generation of essence, appending it to
  /// existing Mob data.  If a physical Source Mob, such as a File
  /// Source Mob or tape Source Mob, references another physical
  /// Source Mob as its ancestor, with no pulldown, then this
  /// function makes the connection between the two.
  ///
  /// Functionally, this is a helper function to create a slot with an
  /// AAFSourceClip referencing a particular piece of media.  This
  /// function takes many parameters because the components of an
  /// aafSourceRef_t have been broken out as separate parameters.
  ///
  /// The ancestor of an AAFSourceMob with an AAFFileDescriptor is often an
  /// AAFTapeDescriptor or NIL.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSourceRefObj pointer is valid.
  /// - the pEssenceKind pointer is valid.
  /// (other conditions here)
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSourceRefObj or pEssenceKind is null.
  ///
  /// (other codes here.)
  /// 
  /// @param editrate [in] Edit rate of slot to contain reference
  /// @param aMobSlot [in] SlotID of slot to contain reference
  /// @param pEssenceKind [in] Data kind of slot to contain reference.  Requires a data kind
  /// valid for a essence stream.  Valid data kinds are:
  /// - Picture
  /// - Sound
  /// @param ref [in] Reference to a Physical Source Mob
  /// @param srcRefLength [in] Length of the Source Clip
  ///
  HRESULT AppendPhysSourceRef (
    [in] aafRational_t  editrate,
    [in] aafSlotID_t  aMobSlot,
    [in] IAAFDataDef * pEssenceKind,
    [in] aafSourceRef_t  ref,
    [in] aafLength_t  srcRefLength);


  //***********************************************************
  //
  // NewPhysSourceRef()
  //
  /// Connects this Source Mob with the physical Source Mob that
  /// describes the previous generation of essence, replacing any
  /// existing Mob data.  If a physical Source Mob, such as a File
  /// Source Mob or tape Source Mob, references another physical
  /// Source Mob as its ancestor, with no pulldown, then this
  /// function makes the connection between the two.
  ///
  /// Functionally, this is a helper function to create a slot with an
  /// AAFSourceClip referencing a particular piece of media.  This
  /// function takes many parameters because the components of an
  /// aafSourceRef_t have been broken out as separate parameters.
  ///
  /// The ancestor of an AAFSourceMob with an AAFFileDescriptor is often an
  /// AAFTapeDescriptor or NIL.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSourceRefObj pointer is valid.
  /// - the pEssenceKind pointer is valid.
  /// (other conditions here)
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSourceRefObj or pEssenceKind is null.
  ///
  /// (other codes here.)
  /// 
  /// @param editrate [in] Edit rate of slot to contain reference
  /// @param aMobSlot [in] SlotID of slot to contain reference
  /// @param pEssenceKind [in] Data kind of slot to contain reference.  Requires a data kind
  /// valid for a essence stream.  Valid data kinds are:
  /// - Picture
  /// - Sound
  /// @param ref [in] Reference to a Physical Source Mob
  /// @param srcRefLength [in] Length of the Source Clip
  ///
  HRESULT NewPhysSourceRef (
    [in] aafRational_t  editrate,
    [in] aafSlotID_t  aMobSlot,
    [in] IAAFDataDef * pEssenceKind,
    [in] aafSourceRef_t  ref,
    [in] aafLength_t  srcRefLength);


  //***********************************************************
  //
  // CreateEssence()
  //
  /// Creates a single channel stream of essence.  Convenience
  /// functions exist to create audio or video essence, and a separate
  /// call (MultiCreate) exists to create interleaved audio and video
  /// data.
  ///
  /// The essence handle from this call can be used with
  /// WriteDataSamples  and possibly WriteDataLines, but NOT with
  /// WriteMultiSamples.
  /// 
  /// If you are creating the essence, and then attaching it to a
  /// master mob, then the "masterMob" field may be left NULL.  For
  /// video, the sampleRate should be the edit rate of the file mob.
  /// For audio, the sample rate should be the actual samples per
  /// second.
  /// 
  /// @param masterSlotID [in] 
  /// @param pMediaKind [in] create essence of this type
  /// @param codecID [in, ref] using this codec
  /// @param editRate [in] with this edit rate
  /// @param samplerate [in] with this sample rate
  /// @param Enable [in] optionally compressing it
  /// @param destination [in] Optionally create the file HERE.
  /// @param fileFormat [in, ref] with this format
  /// @param access [out] Return an essence access on the essence.
  ///
  HRESULT CreateEssence (
    [in] aafSlotID_t  masterSlotID,
    [in] IAAFDataDef * pMediaKind,
    [in, ref] aafUID_constref  codecID,
    [in] aafRational_t  editRate,
    [in] aafRational_t  samplerate,
    [in] aafCompressEnable_t  Enable,
    [in] IAAFLocator * destination,
    [in, ref] aafUID_constref  fileFormat,
    [out] IAAFEssenceAccess ** access);


  //***********************************************************
  //
  // CreateMultiEssence()
  //
  /// Creates a multi-channel interleaved stream of essence.  The
  /// essence handle from this call can be used with WriteDataSamples
  /// or WriteMultiSamples but NOT with or WriteDataLines.
  /// 
  /// If you are creating the essence, and then attaching it to a
  /// master mob, then the "masterMob" field may be left NULL.
  /// 
  /// @param codecID [in, ref] using this codec
  /// @param arrayElemCount [in] this many channels
  /// @param mediaArray [in,ref,size_is(arrayElemCount)] using these definitions
  /// @param Enable [in] optionally compressing it
  /// @param destination [in] Optionally create the file HERE.
  /// @param fileFormat [in, ref] with this format
  /// @param access [out] Return an essence access on the essence.
  ///
  HRESULT CreateMultiEssence (
    [in, ref] aafUID_constref  codecID,
    [in] aafUInt16  arrayElemCount,
    [in,ref,size_is(arrayElemCount)] aafmMultiCreate_t *  mediaArray,
    [in] aafCompressEnable_t  Enable,
    [in] IAAFLocator * destination,
    [in, ref] aafUID_constref  fileFormat,
    [out] IAAFEssenceMultiAccess**  access);


  //***********************************************************
  //
  // OpenEssence()
  //
  /// Opens a single channel of a file mob.  If the essence is
  /// interleaved, then it will be di-interleaved when samples are
  /// read.  This routine follows the locator, and may call the locator
  /// failure callback if the essence can not be found.  If the failure
  /// callback finds the essence, then this routine will return
  /// normally.
  /// 
  /// The essence handle from this call can be used with
  /// ReadDataSamples  and possibly ReadDataLines, but NOT with
  /// ReadMultiSamples.
  /// 
  /// NOTE: If a locator is followed, then essencePtr may reference
  /// ANOTHER file object, which must be closed on file close.
  /// 
  /// @param slotID [in] On this slot
  /// @param mediaCrit [in] using this essence criteria
  /// @param openMode [in] ReadOnly or Append
  /// @param compEnable [in] optionally decompressing
  /// @param access [out] Return an essence access on the essence.
  ///
  HRESULT OpenEssence (
    [in] aafSlotID_t  slotID,
    [in] aafMediaCriteria_t*  mediaCrit,
    [in] aafMediaOpenMode_t  openMode,
    [in] aafCompressEnable_t  compEnable,
    [out] IAAFEssenceAccess ** access);
	

  //***********************************************************
  //
  // OpenMultiEssence()
  //
  /// Opens a all channels associated with a file mob.  This routine
  /// follows the locator, and may call the locator failure callback if
  /// the essence can not be found.  If the failure callback finds the
  /// essence, then this routine will return normally.
  ///
  /// The essence handle from this call can be used with
  /// WriteMultiSamples but NOT with WriteDataSamples.
  /// 
  /// @param slotID [in] On this slot
  /// @param mediaCrit [in] using this essence criteria
  /// @param openMode [in] ReadOnly or Append
  /// @param compEnable [in] optionally decompressing
  /// @param access [out] Return an essence access on the essence.
  ///
  HRESULT OpenMultiEssence (
    [in] aafSlotID_t  slotID,
    [in] aafMediaCriteria_t*  mediaCrit,
    [in] aafMediaOpenMode_t  openMode,
    [in] aafCompressEnable_t  compEnable,
    [out] IAAFEssenceMultiAccess**  access);


  //***********************************************************
  //
  // CountChannels()
  //
  /// Takes an opaque handle, a master mob reference, and a slot ID
  /// so that it may be called before the essence is opened.
  ///
  /// Returns the number of interleaved essence channels of a given
  /// type in the essence stream referenced by the given file mob.
  ///
  /// If the data format is not interleaved, then the answer will
  /// always be zero or one.  This function correctly returns zero for
  /// essence types not handled by a given codec, and handles codecs
  /// which work with multiple essence types.
  /// 
  /// @param slotID [in] On this slot
  /// @param mediaCrit [in] using this essence criteria
  /// @param pMediaKind [in] for this essence type
  /// @param numCh [out] How many channels?
  ///
  HRESULT CountChannels (
    [in] aafSlotID_t  slotID,
    [in] aafMediaCriteria_t*  mediaCrit,
    [in] IAAFDataDef * pMediaKind,
    [out] aafUInt16*  numCh);




  //***********************************************************
  //
  // ExtendEssence()
  //
  /// Extends a single stream of essence that was originally created using
  /// IAAFMasterMob::CreateEssence.  Extended essence is represented by
  /// a Sequence of SourceClip objects.  The first call to ExtendEssence will cause the
  /// TimelineMobSlot's SourceClip object to be replaced by a
  /// Sequence.  The initial SourceClip becomes the first
  /// component of the new Sequence.
  /// 
  /// @param masterSlotID [in] 
  /// @param pMediaKind [in] create essence of this type
  /// @param codecID [in, ref] using this codec
  /// @param editRate [in] with this edit rate
  /// @param samplerate [in] with this sample rate
  /// @param Enable [in] optionally compressing it
  /// @param destination [in] Optionally create the file HERE.
  /// @param fileFormat [in, ref] with this format
  /// @param access [out] Return an essence access on the essence.
  ///
  HRESULT ExtendEssence (
    [in] aafSlotID_t  masterSlotID,
    [in] IAAFDataDef * pMediaKind,
    [in, ref] aafUID_constref  codecID,
    [in] aafRational_t  editRate,
    [in] aafRational_t  samplerate,
    [in] aafCompressEnable_t  Enable,
    [in] IAAFLocator * destination,
    [in, ref] aafUID_constref  fileFormat,
    [out] IAAFEssenceAccess ** access);


  //***********************************************************
  //
  // ExtendMultiEssence()
  //
  /// Extends a multi-channel interleaved stream of essence that was
  /// originally created using IAAFMasterMob::CreateMultiEssence.
  /// Extended essence is represented by a Sequence of SourceClip objects.
  /// The first call to ExtendEssence will cause the TimelineMobSlot's SourceClip
  /// object to be replaced by a Sequence.  The initial SourceClip becomes the first
  /// component of the new Sequence.
  /// 
  /// @param codecID [in, ref] using this codec
  /// @param arrayElemCount [in] this many channels
  /// @param mediaArray [in,ref,size_is(arrayElemCount)] using these definitions
  /// @param Enable [in] optionally compressing it
  /// @param destination [in] Optionally create the file HERE.
  /// @param fileFormat [in, ref] with this format
  /// @param access [out] Return an essence access on the essence.
  ///
  HRESULT ExtendMultiEssence (
    [in, ref] aafUID_constref  codecID,
    [in] aafUInt16  arrayElemCount,
    [in,ref,size_is(arrayElemCount)] aafmMultiCreate_t *  mediaArray,
    [in] aafCompressEnable_t  Enable,
    [in] IAAFLocator * destination,
    [in, ref] aafUID_constref  fileFormat,
    [out] IAAFEssenceMultiAccess**  access);


  //***********************************************************
  //
  // CreateStaticEssence()
  //
  /// Creates and initializes the objects required to represent static essence.
  /// 
  /// @param masterSlotID [in] 
  /// @param pMediaKind [in] create essence of this type
  /// @param codecID [in, ref] using this codec
  /// @param Enable [in] optionally compressing it
  /// @param destination [in] Optionally create the file HERE.
  /// @param fileFormat [in, ref] with this format
  /// @param access [out] Return an essence access on the essence.
  ///
  HRESULT CreateStaticEssence (
    [in] aafSlotID_t  masterSlotID,
    [in] IAAFDataDef * pMediaKind,
    [in, ref] aafUID_constref  codecID,
    [in] aafCompressEnable_t  Enable,
    [in] IAAFLocator * destination,
    [in, ref] aafUID_constref  fileFormat,
    [out] IAAFEssenceAccess ** access);
  /// This function is broadly similar to CreateEssence except that the essence is 
  /// Created in a static slot in the MasterMob
  ///
  /// The essence handle from this call can be used with
  /// WriteDataSamples  and possibly WriteDataLines\, but NOT with
  /// WriteMultiSamples.
  /// 


  //***********************************************************
  //
  // CreateEventEssence()
  //
  /// Creates and initializes the objects required to represent stream of events.
  /// 
  /// @param masterSlotID [in] 
  /// @param pMediaKind [in] create essence of this type
  /// @param codecID [in, ref] using this codec
  /// @param editRate [in] with this edit rate
  /// @param samplerate [in] with this sample rate
  /// @param Enable [in] optionally compressing it
  /// @param destination [in] Optionally create the file HERE.
  /// @param fileFormat [in, ref] with this format
  /// @param access [out] Return an essence access on the essence.
  ///
  HRESULT CreateEventEssence (
    [in] aafSlotID_t  masterSlotID,
    [in] IAAFDataDef * pMediaKind,
    [in, ref] aafUID_constref  codecID,
    [in] aafRational_t  editRate,
    [in] aafRational_t  samplerate,
    [in] aafCompressEnable_t  Enable,
    [in] IAAFLocator * destination,
    [in, ref] aafUID_constref  fileFormat,
    [out] IAAFEssenceAccess ** access);
  /// This function is broadly similar to CreateEssence except that the essence is 
  /// Created in a event slot in the MasterMob
  ///
  /// 
  /// The essence handle from this call can be used with
  /// WriteDataSamples  and possibly WriteDataLines\, but NOT with
  /// WriteMultiSamples.
  /// 

}




// ************************
//
// Interface IAAFMasterMob3
//
// ************************
///
/// The IAAFMasterMob interface is implemented by objects which provide
/// access to the File Source Mobs and EssenceData objects.  The Master
/// Mob object is used to provide a level of indirection for accessing
/// Source Mobs from Composition Mobs.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
///
/// Objects that implement IAAFMasterMob3 also implement the following interfaces:
///  - IAAFMob
///  - IAAFMob2
///  - IAAFObject
[
    object,
    uuid(988af5ac-57d8-47b7-9b0f-239971161939),
    helpstring("IAAFMasterMob3 Interface"),
    pointer_default(unique)
]
interface IAAFMasterMob3 : IUnknown
{



  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty IAAFMasterMob-supporting
  /// object.  This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  /// 
  HRESULT Initialize ();


  //***********************************************************
  //
  // AddMasterSlot()
  //
  /// This function adds a slot to the specified Master Mob that
  /// references the specified a slot in the specified Source Mob. The
  /// new slot in the Master Mob contains a Source Clip that specifies
  /// the Source Mob in its source reference properties.  Typically this
  /// is done automatically by passing the Master Mob handle to
  /// AAFMedia::Create, but this function allows you to add it later.
  ///
  /// Note: If pSlotName is passed in with zero length, then the
  /// slot is not assigned a name.  Slot names are not used by the
  /// SDK, and exist only so the user can name slots.
  /// 
  /// Succeeds if all of the following are true:
  /// (more conditions here)
  /// 
  /// If this method fails no state is changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - One or more of the following parameters are NULL pSourceMob,
  ///     pSlotName, and pDataDef.
  ///
  /// AAFRESULT_INVALID_DATADEF
  ///   - The data kind of the source MOB slot to be added to the Master
  ///     Mob does not match what is specfied in pDataDef.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The specified Source Mob slot was not found.
  ///
  /// AAFRESULT_SLOT_EXISTS
  ///   - The specified Master slot ID already exists.
  /// 
  /// @param pDataDef [in] Data kind of new slot.  Requires a data kind valid for a media
  /// stream. Valid data kinds are:
  /// - Picture
  /// - Sound
  /// @param sourceSlotID [in] Slot ID of the Source Mob slot to be added to the Master Mob
  /// @param pSourceMob [in] Source Mob containing the slot to be added to the Master Mob
  /// @param masterSlotID [in] SlotID assigned to the new Master Mob slot
  /// @param pSlotName [in, string] Name to assign to new slot in Master Mob
  ///
  HRESULT AddMasterSlot (
    [in] IAAFDataDef * pDataDef,
    [in] aafSlotID_t  sourceSlotID,
    [in] IAAFSourceMob * pSourceMob,
    [in] aafSlotID_t  masterSlotID,
    [in, string] aafCharacter_constptr  pSlotName);


  //***********************************************************
  //
  // GetTapeName()
  //
  /// Finds the tape Source Mob associated with a Master Mob slot
  /// and writes the name of the tape, which is stored in the
  /// Mobs Name property, into the pTapeName buffer.  The buffer is
  /// allocated by the caller.  The size of the buffer is given by
  /// bufSize.  If the property name has not yet been set, a
  /// zero-length string will be written (that is, only the trailing
  /// null character).
  /// 
  /// Caller may call GetTapeNameBufLen() to determine the required
  /// buffer size.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pTapeName pointer is valid.
  /// - the specified master slot was found.
  /// - the specified master slot contains a tape mob.
  /// - bufSize indicates the buffer is large enough to hold the name.
  /// 
  /// If this method fails nothing will be written to *pTapeName.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTapeName arg is NULL.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The specified Master Slot was not found.
  ///
  /// AAFRESULT_NOT_TAPEMOB
  ///   - The specified Master Slot does not contain a Tape MOB.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - bufSize indicates the buffer is too small to hold the string.
  /// 
  /// @param masterSlotID [in] SlotID of the Master Mob slot
  /// @param pTapeName [out, size_is(bufSize), string] The returned name
  /// @param bufSize [in] the size of the pTapeName buffer
  ///
  HRESULT GetTapeName (
    [in] aafUInt32  masterSlotID,
    [out, size_is(bufSize), string] aafCharacter *  pTapeName,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetTapeNameBufLen()
  //
  /// Returns the length of buffer required for the GetTapeName()
  /// method.  The value is placed into the location specified by
  /// pLen.  The value will include space required for the trailing
  /// null character.
  ///
  /// Succeeds if all of the following are true:
  /// - the pLen pointer is valid.
  ///
  /// If this method fails nothing will be written to *pLen.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLen arg is NULL.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The specified Master Slot was not found.
  ///
  /// AAFRESULT_NOT_TAPEMOB
  ///   - The specified Master Slot does not contain a Tape MOB.
  /// 
  /// @param masterSlotID [in] SlotID of the Master Mob slot
  /// @param pLen [out] required buffer length
  ///
  HRESULT GetTapeNameBufLen (
    [in] aafUInt32  masterSlotID,
    [out] aafUInt32 *  pLen);


  //***********************************************************
  //
  // GetNumRepresentations()
  //
  /// This function returns the number of media representations
  /// available for the specified SlotID on a specified Master
  /// Mob. This function is meant to work with
  /// GetRepresentationSourceClip, so that you can iterate through
  /// all of the choices yourself.  In most cases, you can use
  /// GetCriteriaSourceClip to handle multiple
  /// representations.  This function and
  /// GetRepresentationSourceClip are lower-level functions.
  ///
  /// Succeeds if all of the following are true:
  /// - the pNumReps pointer is valid.
  ///
  /// If this method fails nothing will be written to *pNumReps.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumReps arg is NULL.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The Master Slot specified by slotID was not found.
  /// 
  /// @param slotID [in] SlotID
  /// @param pNumReps [out, retval] number of representations
  ///
  HRESULT GetNumRepresentations (
    [in] aafSlotID_t  slotID,
    [out, retval] aafNumSlots_t *  pNumReps);


  //***********************************************************
  //
  // GetRepresentation()
  //
  /// This method returns the indexed media representation for the
  /// specified Master Mob, SlotID, and index.  This call is meant to
  /// work with GetNumRepresentations, so that you can iterate through
  /// all of the choices yourself.  This method uses an integer index,
  /// not an iterator.  The function GetRepresentationSourceClip takes
  /// an index between 1 and the number of representations
  /// [inclusive], and returns the indexed Source Mob. You can make
  /// calls to functions such as AAFMedia::GetVideoInfo and
  /// AAFMedia::IsMediaContiguous to determine which media is the best
  /// fit.
  ///
  /// The returned source clip is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppSourceClip pointer is valid.
  ///
  /// If this method fails nothing will be written to *ppSourceClip.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppSourceClip arg is NULL.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The specified Master Slot was not found.
  ///
  /// AAFRESULT_BADINDEX
  ///   - No Source Mob at specified index.
  /// 
  /// @param slotID [in] Slot ID
  /// @param index [in] Index of requested representation
  /// @param ppSourceClip [out] Requested Source Clip
  ///
  HRESULT GetRepresentation (
    [in] aafSlotID_t  slotID,
    [in] aafUInt32  index,
    [out] IAAFSegment ** ppSourceClip);


  //***********************************************************
  //
  // GetCriteriaSegment()
  //
  /// Returns the Segment on the specified slot of a Master Mob
  /// that references the Source Mob that best meets the specified
  /// criteria.  This function will work whether multiple media
  /// representations exist or not.
  ///
  /// The returned segment is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppSegment pointer is valid.
  ///
  /// If this method fails nothing will be written to *ppSegment.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppSegment arg is NULL.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The specified Master Slot was not found.
  /// 
  /// @param slotID [in] Slot ID
  /// @param pCriteria [in] Index of requested representation.  Note: the
  /// aafMediaCriteria_t is defined as the following structure:
  /// typedef struct
  /// {
  ///	aafCriteriaType_t type;
  ///	aafCriteriaProc_t proc;
  /// } aafMediaCriteria_t;
  ///
  /// The type field can have one of the following values:
  /// typedef enum
  /// {
  ///	kAAFAnyRepresentation = 0,
  ///	kAAFFastestRepresentation,
  ///	kAAFBestFidelityRepresentation,
  ///	kAAFSmallestRepresentation,
  ///	kAAFUseRepresentationProc
  /// } aafCriteriaType_t;
  /// @param ppSegment [out] Requested Segment
  ///
  HRESULT GetCriteriaSegment (
    [in] aafSlotID_t  slotID,
    [in] aafMediaCriteria_t *  pCriteria,
    [out] IAAFSegment ** ppSegment);


  //***********************************************************
  //
  // AppendPhysSourceRef()
  //
  /// Connects this Source Mob with the physical Source Mob that
  /// describes the previous generation of essence, appending it to
  /// existing Mob data.  If a physical Source Mob, such as a File
  /// Source Mob or tape Source Mob, references another physical
  /// Source Mob as its ancestor, with no pulldown, then this
  /// function makes the connection between the two.
  ///
  /// Functionally, this is a helper function to create a slot with an
  /// AAFSourceClip referencing a particular piece of media.  This
  /// function takes many parameters because the components of an
  /// aafSourceRef_t have been broken out as separate parameters.
  ///
  /// The ancestor of an AAFSourceMob with an AAFFileDescriptor is often an
  /// AAFTapeDescriptor or NIL.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSourceRefObj pointer is valid.
  /// - the pEssenceKind pointer is valid.
  /// (other conditions here)
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSourceRefObj or pEssenceKind is null.
  ///
  /// (other codes here.)
  /// 
  /// @param editrate [in] Edit rate of slot to contain reference
  /// @param aMobSlot [in] SlotID of slot to contain reference
  /// @param pEssenceKind [in] Data kind of slot to contain reference.  Requires a data kind
  /// valid for a essence stream.  Valid data kinds are:
  /// - Picture
  /// - Sound
  /// @param ref [in] Reference to a Physical Source Mob
  /// @param srcRefLength [in] Length of the Source Clip
  ///
  HRESULT AppendPhysSourceRef (
    [in] aafRational_t  editrate,
    [in] aafSlotID_t  aMobSlot,
    [in] IAAFDataDef * pEssenceKind,
    [in] aafSourceRef_t  ref,
    [in] aafLength_t  srcRefLength);


  //***********************************************************
  //
  // NewPhysSourceRef()
  //
  /// Connects this Source Mob with the physical Source Mob that
  /// describes the previous generation of essence, replacing any
  /// existing Mob data.  If a physical Source Mob, such as a File
  /// Source Mob or tape Source Mob, references another physical
  /// Source Mob as its ancestor, with no pulldown, then this
  /// function makes the connection between the two.
  ///
  /// Functionally, this is a helper function to create a slot with an
  /// AAFSourceClip referencing a particular piece of media.  This
  /// function takes many parameters because the components of an
  /// aafSourceRef_t have been broken out as separate parameters.
  ///
  /// The ancestor of an AAFSourceMob with an AAFFileDescriptor is often an
  /// AAFTapeDescriptor or NIL.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSourceRefObj pointer is valid.
  /// - the pEssenceKind pointer is valid.
  /// (other conditions here)
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSourceRefObj or pEssenceKind is null.
  ///
  /// (other codes here.)
  /// 
  /// @param editrate [in] Edit rate of slot to contain reference
  /// @param aMobSlot [in] SlotID of slot to contain reference
  /// @param pEssenceKind [in] Data kind of slot to contain reference.  Requires a data kind
  /// valid for a essence stream.  Valid data kinds are:
  /// - Picture
  /// - Sound
  /// @param ref [in] Reference to a Physical Source Mob
  /// @param srcRefLength [in] Length of the Source Clip
  ///
  HRESULT NewPhysSourceRef (
    [in] aafRational_t  editrate,
    [in] aafSlotID_t  aMobSlot,
    [in] IAAFDataDef * pEssenceKind,
    [in] aafSourceRef_t  ref,
    [in] aafLength_t  srcRefLength);


  //***********************************************************
  //
  // CreateEssence()
  //
  /// Creates a single channel stream of essence.  Convenience
  /// functions exist to create audio or video essence, and a separate
  /// call (MultiCreate) exists to create interleaved audio and video
  /// data.
  ///
  /// The essence handle from this call can be used with
  /// WriteDataSamples  and possibly WriteDataLines, but NOT with
  /// WriteMultiSamples.
  /// 
  /// If you are creating the essence, and then attaching it to a
  /// master mob, then the "masterMob" field may be left NULL.  For
  /// video, the sampleRate should be the edit rate of the file mob.
  /// For audio, the sample rate should be the actual samples per
  /// second.
  /// 
  /// @param masterSlotID [in] 
  /// @param pMediaKind [in] create essence of this type
  /// @param codecID [in, ref] using this codec
  /// @param editRate [in] with this edit rate
  /// @param samplerate [in] with this sample rate
  /// @param Enable [in] optionally compressing it
  /// @param destination [in] Optionally create the file HERE.
  /// @param fileFormat [in, ref] with this format
  /// @param access [out] Return an essence access on the essence.
  ///
  HRESULT CreateEssence (
    [in] aafSlotID_t  masterSlotID,
    [in] IAAFDataDef * pMediaKind,
    [in, ref] aafUID_constref  codecID,
    [in] aafRational_t  editRate,
    [in] aafRational_t  samplerate,
    [in] aafCompressEnable_t  Enable,
    [in] IAAFLocator * destination,
    [in, ref] aafUID_constref  fileFormat,
    [out] IAAFEssenceAccess ** access);


  //***********************************************************
  //
  // CreateMultiEssence()
  //
  /// Creates a multi-channel interleaved stream of essence.  The
  /// essence handle from this call can be used with WriteDataSamples
  /// or WriteMultiSamples but NOT with or WriteDataLines.
  /// 
  /// If you are creating the essence, and then attaching it to a
  /// master mob, then the "masterMob" field may be left NULL.
  /// 
  /// @param codecID [in, ref] using this codec
  /// @param arrayElemCount [in] this many channels
  /// @param mediaArray [in,ref,size_is(arrayElemCount)] using these definitions
  /// @param Enable [in] optionally compressing it
  /// @param destination [in] Optionally create the file HERE.
  /// @param fileFormat [in, ref] with this format
  /// @param access [out] Return an essence access on the essence.
  ///
  HRESULT CreateMultiEssence (
    [in, ref] aafUID_constref  codecID,
    [in] aafUInt16  arrayElemCount,
    [in,ref,size_is(arrayElemCount)] aafmMultiCreate_t *  mediaArray,
    [in] aafCompressEnable_t  Enable,
    [in] IAAFLocator * destination,
    [in, ref] aafUID_constref  fileFormat,
    [out] IAAFEssenceMultiAccess**  access);


  //***********************************************************
  //
  // OpenEssence()
  //
  /// Opens a single channel of a file mob.  If the essence is
  /// interleaved, then it will be di-interleaved when samples are
  /// read.  This routine follows the locator, and may call the locator
  /// failure callback if the essence can not be found.  If the failure
  /// callback finds the essence, then this routine will return
  /// normally.
  /// 
  /// The essence handle from this call can be used with
  /// ReadDataSamples  and possibly ReadDataLines, but NOT with
  /// ReadMultiSamples.
  /// 
  /// NOTE: If a locator is followed, then essencePtr may reference
  /// ANOTHER file object, which must be closed on file close.
  /// 
  /// @param slotID [in] On this slot
  /// @param mediaCrit [in] using this essence criteria
  /// @param openMode [in] ReadOnly or Append
  /// @param compEnable [in] optionally decompressing
  /// @param access [out] Return an essence access on the essence.
  ///
  HRESULT OpenEssence (
    [in] aafSlotID_t  slotID,
    [in] aafMediaCriteria_t*  mediaCrit,
    [in] aafMediaOpenMode_t  openMode,
    [in] aafCompressEnable_t  compEnable,
    [out] IAAFEssenceAccess ** access);
	

  //***********************************************************
  //
  // OpenMultiEssence()
  //
  /// Opens a all channels associated with a file mob.  This routine
  /// follows the locator, and may call the locator failure callback if
  /// the essence can not be found.  If the failure callback finds the
  /// essence, then this routine will return normally.
  ///
  /// The essence handle from this call can be used with
  /// WriteMultiSamples but NOT with WriteDataSamples.
  /// 
  /// @param slotID [in] On this slot
  /// @param mediaCrit [in] using this essence criteria
  /// @param openMode [in] ReadOnly or Append
  /// @param compEnable [in] optionally decompressing
  /// @param access [out] Return an essence access on the essence.
  ///
  HRESULT OpenMultiEssence (
    [in] aafSlotID_t  slotID,
    [in] aafMediaCriteria_t*  mediaCrit,
    [in] aafMediaOpenMode_t  openMode,
    [in] aafCompressEnable_t  compEnable,
    [out] IAAFEssenceMultiAccess**  access);


  //***********************************************************
  //
  // CountChannels()
  //
  /// Takes an opaque handle, a master mob reference, and a slot ID
  /// so that it may be called before the essence is opened.
  ///
  /// Returns the number of interleaved essence channels of a given
  /// type in the essence stream referenced by the given file mob.
  ///
  /// If the data format is not interleaved, then the answer will
  /// always be zero or one.  This function correctly returns zero for
  /// essence types not handled by a given codec, and handles codecs
  /// which work with multiple essence types.
  /// 
  /// @param slotID [in] On this slot
  /// @param mediaCrit [in] using this essence criteria
  /// @param pMediaKind [in] for this essence type
  /// @param numCh [out] How many channels?
  ///
  HRESULT CountChannels (
    [in] aafSlotID_t  slotID,
    [in] aafMediaCriteria_t*  mediaCrit,
    [in] IAAFDataDef * pMediaKind,
    [out] aafUInt16*  numCh);




  //***********************************************************
  //
  // ExtendEssence()
  //
  /// Extends a single stream of essence that was originally created using
  /// IAAFMasterMob::CreateEssence.  Extended essence is represented by
  /// a Sequence of SourceClip objects.  The first call to ExtendEssence will cause the
  /// TimelineMobSlot's SourceClip object to be replaced by a
  /// Sequence.  The initial SourceClip becomes the first
  /// component of the new Sequence.
  /// 
  /// @param masterSlotID [in] 
  /// @param pMediaKind [in] create essence of this type
  /// @param codecID [in, ref] using this codec
  /// @param editRate [in] with this edit rate
  /// @param samplerate [in] with this sample rate
  /// @param Enable [in] optionally compressing it
  /// @param destination [in] Optionally create the file HERE.
  /// @param fileFormat [in, ref] with this format
  /// @param access [out] Return an essence access on the essence.
  ///
  HRESULT ExtendEssence (
    [in] aafSlotID_t  masterSlotID,
    [in] IAAFDataDef * pMediaKind,
    [in, ref] aafUID_constref  codecID,
    [in] aafRational_t  editRate,
    [in] aafRational_t  samplerate,
    [in] aafCompressEnable_t  Enable,
    [in] IAAFLocator * destination,
    [in, ref] aafUID_constref  fileFormat,
    [out] IAAFEssenceAccess ** access);


  //***********************************************************
  //
  // ExtendMultiEssence()
  //
  /// Extends a multi-channel interleaved stream of essence that was
  /// originally created using IAAFMasterMob::CreateMultiEssence.
  /// Extended essence is represented by a Sequence of SourceClip objects.
  /// The first call to ExtendEssence will cause the TimelineMobSlot's SourceClip
  /// object to be replaced by a Sequence.  The initial SourceClip becomes the first
  /// component of the new Sequence.
  /// 
  /// @param codecID [in, ref] using this codec
  /// @param arrayElemCount [in] this many channels
  /// @param mediaArray [in,ref,size_is(arrayElemCount)] using these definitions
  /// @param Enable [in] optionally compressing it
  /// @param destination [in] Optionally create the file HERE.
  /// @param fileFormat [in, ref] with this format
  /// @param access [out] Return an essence access on the essence.
  ///
  HRESULT ExtendMultiEssence (
    [in, ref] aafUID_constref  codecID,
    [in] aafUInt16  arrayElemCount,
    [in,ref,size_is(arrayElemCount)] aafmMultiCreate_t *  mediaArray,
    [in] aafCompressEnable_t  Enable,
    [in] IAAFLocator * destination,
    [in, ref] aafUID_constref  fileFormat,
    [out] IAAFEssenceMultiAccess**  access);


  //***********************************************************
  //
  // CreateStaticEssence()
  //
  /// Creates and initializes the objects required to represent static essence.
  /// 
  /// @param masterSlotID [in] 
  /// @param pMediaKind [in] create essence of this type
  /// @param codecID [in, ref] using this codec
  /// @param Enable [in] optionally compressing it
  /// @param destination [in] Optionally create the file HERE.
  /// @param fileFormat [in, ref] with this format
  /// @param access [out] Return an essence access on the essence.
  ///
  HRESULT CreateStaticEssence (
    [in] aafSlotID_t  masterSlotID,
    [in] IAAFDataDef * pMediaKind,
    [in, ref] aafUID_constref  codecID,
    [in] aafCompressEnable_t  Enable,
    [in] IAAFLocator * destination,
    [in, ref] aafUID_constref  fileFormat,
    [out] IAAFEssenceAccess ** access);
  /// This function is broadly similar to CreateEssence except that the essence is 
  /// Created in a static slot in the MasterMob
  ///
  /// The essence handle from this call can be used with
  /// WriteDataSamples  and possibly WriteDataLines\, but NOT with
  /// WriteMultiSamples.
  /// 


  //***********************************************************
  //
  // CreateEventEssence()
  //
  /// Creates and initializes the objects required to represent stream of events.
  /// 
  /// @param masterSlotID [in] 
  /// @param pMediaKind [in] create essence of this type
  /// @param codecID [in, ref] using this codec
  /// @param editRate [in] with this edit rate
  /// @param samplerate [in] with this sample rate
  /// @param Enable [in] optionally compressing it
  /// @param destination [in] Optionally create the file HERE.
  /// @param fileFormat [in, ref] with this format
  /// @param access [out] Return an essence access on the essence.
  ///
  HRESULT CreateEventEssence (
    [in] aafSlotID_t  masterSlotID,
    [in] IAAFDataDef * pMediaKind,
    [in, ref] aafUID_constref  codecID,
    [in] aafRational_t  editRate,
    [in] aafRational_t  samplerate,
    [in] aafCompressEnable_t  Enable,
    [in] IAAFLocator * destination,
    [in, ref] aafUID_constref  fileFormat,
    [out] IAAFEssenceAccess ** access);
  /// This function is broadly similar to CreateEssence except that the essence is 
  /// Created in a event slot in the MasterMob
  ///
  /// 
  /// The essence handle from this call can be used with
  /// WriteDataSamples  and possibly WriteDataLines\, but NOT with
  /// WriteMultiSamples.
  /// 


  //***********************************************************
  //
  // AddMasterSlotWithSequence()
  //
  /// This function is similar to AddMasterSlot but creates the structure
  /// MobSlot - Sequence - SourceClip instead of MobSlot - SourceClip.
  /// This arrangement is required for MXF compliance.
  ///
  /// This function adds a slot to the specified Master Mob that
  /// references the specified a slot in the specified Source Mob. The
  /// new slot in the Master Mob has a Sequence containing the Source Clip
  /// that specifies the Source Mob in its source reference properties.
  ///
  /// Note: If pSlotName is passed in with zero length, then the
  /// slot is not assigned a name.  Slot names are not used by the
  /// SDK, and exist only so the user can name slots.
  /// 
  /// Succeeds if all of the following are true:
  /// (more conditions here)
  /// 
  /// If this method fails no state is changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - One or more of the following parameters are NULL pSourceMob,
  ///     pSlotName, and pDataDef.
  ///
  /// AAFRESULT_INVALID_DATADEF
  ///   - The data kind of the source MOB slot to be added to the Master
  ///     Mob does not match what is specfied in pDataDef.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The specified Source Mob slot was not found.
  ///
  /// AAFRESULT_SLOT_EXISTS
  ///   - The specified Master slot ID already exists.
  /// 
  /// @param pDataDef [in] Data kind of new slot.  Requires a data kind valid for a media
  /// stream. Valid data kinds are:
  /// - Picture
  /// - Sound
  /// @param sourceSlotID [in] Slot ID of the Source Mob slot to be added to the Master Mob
  /// @param pSourceMob [in] Source Mob containing the slot to be added to the Master Mob
  /// @param masterSlotID [in] SlotID assigned to the new Master Mob slot
  /// @param pSlotName [in, string] Name to assign to new slot in Master Mob
  ///
  HRESULT AddMasterSlotWithSequence (
    [in] IAAFDataDef * pDataDef,
    [in] aafSlotID_t  sourceSlotID,
    [in] IAAFSourceMob * pSourceMob,
    [in] aafSlotID_t  masterSlotID,
    [in, string] aafCharacter_constptr  pSlotName);

}




// ************************
//
// Interface IAAFMasterMobEx
//
// ************************
///
/// The IAAFMasterMobEx interface extends IAAFMasterMob.  It supports
/// extended essence.  Extended essence is represented by a Sequence of
/// SourceClip objects.  Each SourceClip refers to a SourceMob which
/// describes one chunk of essence.
///
/// Individual chunks of embedded essence are currently limited to 2GB
/// in size.  A Sequence of SourceClips provides the means to overcome
/// this limit.  There is no limit to the number of SourceClip objects
/// in the sequence or the sum total size of all essence in a file,
/// other than those imposed by the underlying persistent object
/// store. It is expected that this will be significantly larger than
/// 2GB of essence data.
///
///
/// Essence can be extended at any time, for any reason.  Typically, it
/// will be extended because a CODEC returned an error indicating a
/// 2GB limit was reached.  To overcome this limit, simply extend the
/// essence.
///
/// IAAFEssenceAccess::ReadSamples knows how to read embedded
/// essence.  This interface is created by IAAFMasterMob::OpenEssence
///
/// This interface returns the same errors as IAAFMasterMob::CreateEssence,
/// and IAAFMasterMob::CreateMultiEssence.
/// 
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// Objects that implement IAAFMasterMobEx also implement the following interfaces:
///  - IAAFMob
///  - IAAFMob2
///  - IAAFObject
[
    object,
    uuid(b1a21370-1a7d-11d2-bf78-00104bc9156d ),
    helpstring("IAAFMasterMobEx Interface"),
    pointer_default(unique)
]
interface IAAFMasterMobEx : IUnknown
{


  //***********************************************************
  //
  // ExtendEssence()
  //
  /// Extends a single stream of essence that was originally created using
  /// IAAFMasterMob::CreateEssence.  Extended essence is represented by
  /// a Sequence of SourceClip objects.  The first call to ExtendEssence will cause the
  /// TimelineMobSlot's SourceClip object to be replaced by a
  /// Sequence.  The initial SourceClip becomes the first
  /// component of the new Sequence.
  /// 
  /// @param masterSlotID [in] 
  /// @param pMediaKind [in] create essence of this type
  /// @param codecID [in, ref] using this codec
  /// @param editRate [in] with this edit rate
  /// @param samplerate [in] with this sample rate
  /// @param Enable [in] optionally compressing it
  /// @param destination [in] Optionally create the file HERE.
  /// @param fileFormat [in, ref] with this format
  /// @param access [out] Return an essence access on the essence.
  ///
  HRESULT ExtendEssence (
    [in] aafSlotID_t  masterSlotID,
    [in] IAAFDataDef * pMediaKind,
    [in, ref] aafUID_constref  codecID,
    [in] aafRational_t  editRate,
    [in] aafRational_t  samplerate,
    [in] aafCompressEnable_t  Enable,
    [in] IAAFLocator * destination,
    [in, ref] aafUID_constref  fileFormat,
    [out] IAAFEssenceAccess ** access);


  //***********************************************************
  //
  // ExtendMultiEssence()
  //
  /// Extends a multi-channel interleaved stream of essence that was
  /// originally created using IAAFMasterMob::CreateMultiEssence.
  /// Extended essence is represented by a Sequence of SourceClip objects.
  /// The first call to ExtendEssence will cause the TimelineMobSlot's SourceClip
  /// object to be replaced by a Sequence.  The initial SourceClip becomes the first
  /// component of the new Sequence.
  /// 
  /// @param codecID [in, ref] using this codec
  /// @param arrayElemCount [in] this many channels
  /// @param mediaArray [in,ref,size_is(arrayElemCount)] using these definitions
  /// @param Enable [in] optionally compressing it
  /// @param destination [in] Optionally create the file HERE.
  /// @param fileFormat [in, ref] with this format
  /// @param access [out] Return an essence access on the essence.
  ///
  HRESULT ExtendMultiEssence (
    [in, ref] aafUID_constref  codecID,
    [in] aafUInt16  arrayElemCount,
    [in,ref,size_is(arrayElemCount)] aafmMultiCreate_t *  mediaArray,
    [in] aafCompressEnable_t  Enable,
    [in] IAAFLocator * destination,
    [in, ref] aafUID_constref  fileFormat,
    [out] IAAFEssenceMultiAccess**  access);

}



// ************************
//
// Interface IAAFMob2
//
// ************************
///
/// The IAAFMob2 interface is implemented by objects that specify a
/// Metadata Object, which can describe a composition, essence, or
/// physical media.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it through
///     this object's primary interface.  Note that IAAFMob2 is a
///     primary interface for an abstract class, so it is not
///     appropriate for the Initialize() method to exist in this
///     interface.  The Initialize() method is available through the
///     concrete object's primary interface.
///
///
/// Objects that implement IAAFMob2 also implement the following interfaces:
///  - IAAFObject
[
    object,
    uuid(a94fdb8b-451f-4d62-ac17-16950344832e),
    helpstring("IAAFMob2 Interface"),
    pointer_default(unique)
]
interface IAAFMob2 : IUnknown
{








  //***********************************************************
  //
  // GetMobID()
  //
  /// This method returns the unique Mob ID associated with this mob.
  ///
  /// Succeeds if all of the following are true:
  /// - the pMobID pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pMobID.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMobID arg is NULL.
  /// 
  /// @param pMobID [out] The unique media object id
  ///
  HRESULT GetMobID (
    [out] aafMobID_t *  pMobID);


  //***********************************************************
  //
  // SetMobID()
  //
  /// When a mob is initially created, the Reference Implementation
  /// internally creates a mobID for the new mob.  This method should
  /// be used to change the mob's identity to an explicit mobID.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param mobID [in, ref] New Mob ID
  ///
  HRESULT SetMobID (
    [in, ref] aafMobID_constref  mobID);


  //***********************************************************
  //
  // SetName()
  //
  /// Sets the Mob Name string property.
  ///
  /// Set the Name property to the value specified in
  /// pName.  A copy is made of the data so the caller
  /// retains ownership of the *pName buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pName pointer is valid.
  /// 
  /// If this method fails the Name property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  /// 
  /// @param pName [in, string] buffer from which Name is to be read
  ///
  HRESULT SetName (
    [in, string] aafCharacter_constptr  pName);


  //***********************************************************
  //
  // GetName()
  //
  /// Gets the Mob Name string property.
  /// 
  /// Writes the Name property, with a trailing null
  /// character, into the pName buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the Name property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetNameBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pName.
  /// 
  /// Succeeds if:
  /// - The pName pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   Name.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold Name.
  /// 
  /// @param pName [out, string, size_is(bufSize)] buffer into which Name is to be written
  /// @param bufSize [in] size of *pName buffer in bytes
  ///
  HRESULT GetName (
    [out, string, size_is(bufSize)] aafCharacter *  pName,
    [in] aafUInt32  bufSize);


  //***********************************************************
  //
  // GetNameBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetName().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  /// 
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  HRESULT GetNameBufLen (
    [out] aafUInt32 *  pBufSize);


  //***********************************************************
  //
  // CountSlots()
  //
  /// This method returns the number of slots contained by this mob.
  ///
  /// Succeeds if all of the following are true:
  /// - the pNumSlots pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pNumSlots.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumSlots arg is NULL.
  /// 
  /// @param pNumSlots [out] Number of slots
  ///
  HRESULT CountSlots (
    [out] aafNumSlots_t *  pNumSlots);


  //***********************************************************
  //
  // AppendSlot()
  //
  /// Appends the given mob slot to the mob.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pSlot pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSlot is null.
  /// 
  /// @param pSlot [in] slot to append
  ///
  HRESULT AppendSlot (
    [in] IAAFMobSlot * pSlot);


  //***********************************************************
  //
  // PrependSlot()
  //
  /// Prepends the given mob slot to the mob.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pSlot pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSlot is null.
  /// 
  /// @param pSlot [in] slot to prepend
  ///
  HRESULT PrependSlot (
    [in] IAAFMobSlot * pSlot);


  //***********************************************************
  //
  // InsertSlotAt()
  //
  /// Inserts the given slot into this mob at the given index.  All
  /// existing slots at the given and higher index will be moved up one
  /// index to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pSlot pointer is valid.
  /// - index is less than or equal to the result obtained by
  ///   CountSlots().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSlot is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than the result obtained from CountSlots().
  /// 
  /// @param index [in] index where slot is to be inserted
  /// @param pSlot [in] slot to insert
  ///
  HRESULT InsertSlotAt (
    [in] aafUInt32  index,
    [in] IAAFMobSlot * pSlot);


  //***********************************************************
  //
  // RemoveSlotAt()
  //
  /// Removes the slot at the given index.  All existing slots at
  /// indices higher than the given index will be moved down one index
  /// to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - index is less than the result obtained by CountSlots().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is not less than the result obtained from
  ///     CountSlots().
  /// 
  /// @param index [in] index of slot to be removed
  ///
  HRESULT RemoveSlotAt (
    [in] aafUInt32  index);


  //***********************************************************
  //
  // GetSlotAt()
  //
  /// Returns the indexed slot in *ppSlot.
  /// 
  /// Succeeds if all of the following are true:
  /// - ppSlot is a valid pointer.
  /// - index is less than the result obtained by CountSlots().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppSlot is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is not less than the result obtained from
  ///     CountSlots().
  /// 
  /// @param index [in] index of slot to be obtained
  /// @param ppSlot [out, retval] the returned slot
  ///
  HRESULT GetSlotAt (
    [in] aafUInt32  index,
    [out, retval] IAAFMobSlot ** ppSlot);


  //***********************************************************
  //
  // GetSlots()
  //
  /// Return an enumeration for all mob slots.  The returned
  /// enumerator is AddRef()ed before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  /// 
  /// @param ppEnum [out] Mob Slot Enumeration
  ///
  HRESULT GetSlots (
    [out] IEnumAAFMobSlots ** ppEnum);


  //***********************************************************
  //
  // GetModTime()
  //
  /// This method will return the modification time for this mob.
  ///
  /// Succeeds if all of the following are true:
  /// - the pLastModified pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pLastModified.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLastModified arg is NULL.
  /// 
  /// @param pLastModified [out] Modified Time
  ///
  HRESULT GetModTime (
    [out] aafTimeStamp_t *  pLastModified);


  //***********************************************************
  //
  // SetModTime()
  //
  /// This method sets the modification time on a mob.  The
  /// modification time is initially set to the time that the mob
  /// was created.  The Reference Implementation does not maintain the
  /// modification time every time that a mob has been updated.
  /// Therefore, this method should be called explicitly to change the
  /// modification time.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param modTime [in, ref] New Modification Time
  ///
  HRESULT SetModTime (
    [in, ref] aafTimeStamp_constref  modTime);


  //***********************************************************
  //
  // GetCreateTime()
  //
  /// This method will return the creation time for this mob.
  ///
  /// Succeeds if all of the following are true:
  /// - the pCreationTime pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pCreationTime.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCreationTime arg is NULL.
  /// 
  /// @param pCreationTime [out] Creation Time
  ///
  HRESULT GetCreateTime (
    [out] aafTimeStamp_t *  pCreationTime);


  //***********************************************************
  //
  // SetCreateTime()
  //
  /// This method sets the creation time on a mob.  The
  /// creation time is initially set to the time that the mob
  /// was created.
  /// Therefore, this method should be called explicitly to change the
  /// creation time.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param createTime [in, ref] New Creation Time
  ///
  HRESULT SetCreateTime (
    [in, ref] aafTimeStamp_constref  createTime);


  //***********************************************************
  //
  // AppendComment()
  //
  /// Creates a user-defined comment and appends it to the specified
  /// Mob.  A Mob comment is implemented as a AAFTaggedValue object of type 
  /// WCharString.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pCategory pointer is valid.
  /// - the pComment pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pCategory or pComment args is NULL.
  /// 
  /// @param pCategory [in,string] Comment heading
  /// @param pComment [in, string] Comment value
  ///
  HRESULT AppendComment (
    [in,string] aafCharacter *  pCategory,
    [in, string] aafCharacter_constptr  pComment);


  //***********************************************************
  //
  // CountComments()
  //
  /// return total number of comments attached to this mob.
  ///
  /// Succeeds if all of the following are true:
  /// - the pNumComments pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pNumComments.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumComments arg is NULL.
  /// 
  /// @param pNumComments [out] Number  of Mob Comments
  ///
  HRESULT CountComments (
    [out] aafUInt32 *  pNumComments);


  //***********************************************************
  //
  // GetComments()
  //
  /// Return the enumeration for all mob comments.  The returned
  /// enumerator is AddRef()ed before it is returned.  Mob comments are 
  /// implemented as AAFTaggedValue of type WCharString.   The enumerator
  /// is implemented as a EnumAAAFTaggedValues.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  /// 
  /// @param ppEnum [out] Mob Comments
  ///
  HRESULT GetComments (
    [out] IEnumAAFTaggedValues ** ppEnum);


  //***********************************************************
  //
  // RemoveComment()
  //
  /// Removes the given comment from this mob.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pComment pointer is valid.
  /// - the given comment is present in the mob.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pComment is null.
  ///
  /// AAFRESULT_OBJECT_NOT_FOUND
  ///   - the given comment is not in this mob.
  /// 
  /// @param pComment [in] Comment to remove
  ///
  HRESULT RemoveComment (
    [in] IAAFTaggedValue * pComment);


  //***********************************************************
  //
  // AppendNewTimelineSlot()
  //
  /// This method creates a new timeline mob slot with the given
  /// property values and appends it to the input mob.
  /// 
  /// The returned mob slot is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSegment pointer is valid.
  /// - the pSlotName pointer is valid.
  /// - the ppNewSlot pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - any of pSegment, pSlotName, or ppNewSlot arguments is null.
  /// 
  /// @param editRate [in] Edit rate property value
  /// @param pSegment [in] Segment to append as slot component
  /// @param slotID [in] new slot ID
  /// @param pSlotName [in, string] new slot name
  /// @param origin [in] The slot origin
  /// @param ppNewSlot [out] Newly created slot
  ///
  HRESULT AppendNewTimelineSlot (
    [in] aafRational_t  editRate,
    [in] IAAFSegment * pSegment,
    [in] aafSlotID_t  slotID,
    [in, string] aafCharacter_constptr  pSlotName,
    [in] aafPosition_t  origin,
    [out] IAAFTimelineMobSlot ** ppNewSlot);


  //***********************************************************
  //
  // GetMobInfo()
  //
  /// This method will get all mob property information is a single call.
  ///
  /// Caller may call GetNameBufLen() to determine the required pName
  /// buffer size.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pLastModified pointer is valid.
  /// - the pCreationTime pointer is valid.
  /// - the pName pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pLastModified,
  /// *pCreationTime, or *pName.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - any of pLastModified, pCreationTime, or pName arguments is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - bufSize indicates the buffer is too small to hold the string.
  /// 
  /// @param pLastModified [out] Modified Time
  /// @param pCreationTime [out] Creation Time
  /// @param pName [out, size_is(bufSize), string] Mob Name
  /// @param bufSize [in] size of the supplied buffer.
  ///
  HRESULT GetMobInfo (
    [out] aafTimeStamp_t *  pLastModified,
    [out] aafTimeStamp_t *  pCreationTime,
    [out, size_is(bufSize), string] aafCharacter *  pName,
    [in] aafInt32  bufSize);


  //***********************************************************
  //
  // OffsetToMobTimecode()
  //
  /// This method will determine the timecode at the given offset into
  /// the given timecode segment, and will return it in *pResult.  If
  /// pTcSeg is NULL, will search for the slot containing a timecode
  /// segment and will use that instead.
  ///
  /// Succeeds if all of the following are true:
  /// - the pTcSeg pointer is valid.
  /// - the pOffset pointer is valid.
  /// - the pResult pointer is valid.
  /// - Timecode track exists.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pOffset or pResult argument is NULL.
  ///
  /// AAFRESULT_TIMECODE_NOT_FOUND
  ///   - timecode track wasn't found.
  /// 
  /// @param pTcSeg [in] Timecode Segment
  /// @param pOffset [in] Offset into segment in edit units for that segment's mob slot
  /// @param pResult [out] The resulting timecode
  ///
  HRESULT OffsetToMobTimecode (
    [in] IAAFSegment * pTcSeg,
    [in] aafPosition_t *  pOffset,
    [out] aafTimecode_t *  pResult);


  //***********************************************************
  //
  // LookupSlot()
  //
  /// The method will find the mob slot for the given slot id.
  ///
  /// The returned mob slot is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppDestSlot pointer is valid.
  /// - the given slot ID is found.
  /// 
  /// If this method fails nothing will be written to *ppDestSlot.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDestSlot arg is NULL.
  /// 
  /// @param slotId [in] The requested slot id
  /// @param ppDestSlot [out] The requested slot
  ///
  HRESULT LookupSlot (
    [in] aafSlotID_t  slotId,
    [out] IAAFMobSlot ** ppDestSlot);


  //***********************************************************
  //
  // ChangeRef()
  //
  /// Finds all Source Clips in the specified Mob that refer to the
  /// specified old Mob, and changes the references to point to the
  /// new Mob.
  ///
  /// This function traverses through the entire structure of the input
  /// Mob looking for Source Clips, and changes the sourceID property
  /// on all Source Clips with oldMobID to newMobID.
  ///
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param oldMobID [in, ref] Old Mob ID reference in source clip
  /// @param newMobID [in, ref] New Mob ID reference in source clip
  ///
  HRESULT ChangeRef (
    [in, ref] aafMobID_constref  oldMobID,
    [in, ref] aafMobID_constref  newMobID);


  //***********************************************************
  //
  // CloneExternal()
  //
  /// Clones the specified Source Mob, and optionally all dependent
  /// Mobs, to an external file, keeping the same MobID.  A pointer
  /// to the newly created destination mob is returned in *ppDestMob.
  /// 
  /// This function clones the specified Source Mob in the source file
  /// into a destination Mob, with the same MobID, in the destination
  /// file.  If resolveDependencies is kFollowDepend, the function
  /// also clones all Mobs referenced by the specified Source Mob.  If
  /// includeMedia is kIncludeMedia, the function also copies the
  /// media data associated with the Source Mob, returns the
  /// destination Mob, and clones all private data.
  ///
  /// If the media data is not in the file, the function does not
  /// attempt to find it in another file and clone it.  Both AAF files
  /// must be open before you call this function and both must have the
  /// same AAF Version number.
  ///
  /// The returned mob is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the pDestFile pointer is valid.
  /// - the ppDestMob pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pDestFile or ppDestMob arguments is NULL.
  /// 
  /// @param resolveDependencies [in] Whether to clone dependent mobs
  /// @param includeMedia [in] Whether to include media data
  /// @param pDestFile [in] Destination AAF File
  /// @param ppDestMob [out] Destination Mob
  ///
  HRESULT CloneExternal (
    [in] aafDepend_t  resolveDependencies,
    [in] aafIncMedia_t  includeMedia,
    [in] IAAFFile * pDestFile,
    [out] IAAFMob ** ppDestMob);


  //***********************************************************
  //
  // Copy()
  //
  /// This function copies the specified Mob into a destination Mob in
  /// the same AAF file. The new Mob is returned through the destMob
  /// parameter. The function gives the destination Mob a new MobID and
  /// the name specified in the destMobName parameter. The function
  /// also copies all private data.
  /// 
  /// The returned mob is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the pDestMobName pointer is valid.
  /// - the ppDestMob pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pDestMobName or pDestMob arguments is NULL.
  /// 
  /// @param pDestMobName [in, string] Optional Input. The name to be assigned to the new copy of the
  /// Mob.  The destMobName argument is optional. Specify a NULL
  /// value if no destination Mob name is desired.
  /// @param ppDestMob [out] Destination Mob
  ///
  HRESULT Copy (
    [in, string] aafCharacter_constptr  pDestMobName,
    [out] IAAFMob ** ppDestMob);
  ///

  //***********************************************************
  //
  // AppendKLVData()
  //
  /// Appends a pre-existing KLV Data object to the specified
  /// Mob.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pKLV pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - the pData arg is NULL.
  /// 
  /// @param pData [in] KLV object
  ///
  HRESULT AppendKLVData (
    [in] IAAFKLVData * pData);


  //***********************************************************
  //
  // CountKLVData()
  //
  /// Return total number of KLV data objects attached to this mob.
  ///
  /// Succeeds if all of the following are true:
  /// - the pNumData pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pNumComments.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumData arg is NULL.
  /// 
  /// @param pNumData [out] Number  of KLV data objects
  ///
  HRESULT CountKLVData (
    [out] aafUInt32 *  pNumData);


  //***********************************************************
  //
  // GetKLVData()
  //
  /// Return the enumeration for all KLV data objects on this mob.  The returned
  /// enumerator is AddRef()ed before it is returned.  The enumerator
  /// is implemented as a EnumAAFKLVData.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  /// 
  /// @param ppEnum [out] KLV data objects
  ///
  HRESULT GetKLVData (
    [out] IEnumAAFKLVData ** ppEnum);


  //***********************************************************
  //
  // RemoveKLVData()
  //
  /// Removes the given KLV data object from this mob.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pData pointer is valid.
  /// - the given KLV data object is present in the mob.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pData is null.
  ///
  /// AAFRESULT_OBJECT_NOT_FOUND
  ///   - the given KLV data object is not in this mob.
  /// 
  /// @param pData [in] KLV data object to remove
  ///
  HRESULT RemoveKLVData (
    [in] IAAFKLVData * pData);


  //***********************************************************
  //
  // AppendAttribute()
  //
  /// Append an attribute name/value pair to the attribute list.
  ///
  /// Creates a new tagged value, initializes it with the specified attribute
  /// name/value pair, and appends it to the attribute list.
  ///
  /// Succeeds if:
  ///   - pName and pValue are valid pointers.
  ///
  /// Return codes:
  ///
  ///   AAFRESULT_SUCCESS
  ///
  ///   AAFRESULT_NULL_PARAM
  ///	     - pName or pValue is null.
  /// 
  /// @param pName [in] The attribute name.
  /// @param pValue [in] The attribute value.
  ///
  HRESULT AppendAttribute (
    [in] aafCharacter_constptr  pName,
    [in] aafCharacter_constptr  pValue);

  //***********************************************************
  //
  // CountAttributes()
  //
  /// Return the number of attributes contained in this mob.
  ///
  /// Succeeds if:
  ///   - pNumAttributes is a valid pointer
  ///
  /// Return codes:
  ///
  ///   AAFRESULT_SUCCESS
  ///
  ///   AAFRESULT_NULL_PARAM
  ///	     - pNumAttributes is null.
  /// 
  /// @param pNumAttributes [out] Pointer to attribute count.
  ///
  HRESULT CountAttributes (
    [out] aafUInt32*  pNumAttributes);
  

  //***********************************************************
  //
  // GetAttributes()
  //
  /// Return an attribute enumerator for this mob.
  ///
  /// Creates an enumerator for this mobs attributes.  The new enumerator is
  /// AddRef()ed before it is returned.
  ///
  /// Succeeds if:
  ///   - pName and pValue are valid pointers.
  ///
  /// Return codes:
  ///
  ///   AAFRESULT_SUCCESS
  ///
  ///   AAFRESULT_NULL_PARAM
  ///	     - pEnum was null.
  /// 
  /// @param ppEnum [out] Pointer to the new enumerator object created by this method.
  ///
  HRESULT GetAttributes (
    [out] IEnumAAFTaggedValues ** ppEnum);


  //***********************************************************
  //
  // RemoveAttribute()
  //
  /// Remove a mob attribute (tagged value).
  ///
  /// Succeeds if:
  ///   - pName and pValue are valid pointers.
  ///
  /// Return codes:
  ///
  ///   AAFRESULT_SUCCESS
  ///
  ///   AAFRESULT_NULL_PARAM
  ///	     - pName or pValue is null.
  /// 
  /// @param pAttribute [in] Pointer to the tagged value attribute.
  ///
  HRESULT RemoveAttribute (
    [in] IAAFTaggedValue * pAttribute);
	
  //***********************************************************
  //
  // SetUsageCode()
  //
  /// Set this mob's usage code. Usage codes are documented in the
  /// AAF Edit Protocol, and related specifications.
  ///
  /// Return codes:
  ///
  ///   AAFRESULT_SUCCESS
  /// 
  /// @param usageCode [in] The usage code value.
  ///
  HRESULT SetUsageCode (
    [in] aafUID_constref  usageCode);

  //***********************************************************
  //
  // GetUsageCode()
  //
  /// Get this mob's usage code. Usage codes are documented in the
  /// AAF Edit Protocol, and related specifications.
  ///
  /// Succeeds if:
  ///   - pUsageCode is a valid pointer
  ///
  /// Return codes:
  ///
  ///   AAFRESULT_PROP_NOT_PRESENT
  ///        - no usage code is present on this mob
  ///
  ///   AAFRESULT_NULL_PARAM
  ///	     - pUsageCode is null
  ///	
  ///   AAFRESULT_SUCCESS
  ///        - succeeded (This is the only code indicating success.)
  /// 
  /// @param pUsageCode [out] Pointer to usage code.
  ///
  HRESULT GetUsageCode (
    [out] aafUID_t*  pUsageCode);


  //***********************************************************
  //
  // AppendNewStaticSlot()
  //
  /// This method creates a new static mob slot with the given
  /// property values and appends it to the input mob.
  /// 
  /// The returned mob slot is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSegment pointer is valid.
  /// - the pSlotName pointer is valid.
  /// - the ppNewSlot pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - any of pSegment, pSlotName, or ppNewSlot arguments is null.
  /// 
  /// @param pSegment [in] Segment to append as slot component
  /// @param slotID [in] new slot ID
  /// @param pSlotName [in, string] new slot name
  /// @param ppNewSlot [out] Newly created slot
  ///
  HRESULT AppendNewStaticSlot (
    [in] IAAFSegment * pSegment,
    [in] aafSlotID_t  slotID,
    [in, string] aafCharacter_constptr  pSlotName,
    [out] IAAFStaticMobSlot ** ppNewSlot);


  //***********************************************************
  //
  // AppendNewEventSlot()
  //
  /// This method creates a new event mob slot with the given
  /// property values and appends it to the input mob.
  /// 
  /// The returned mob slot is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSegment pointer is valid.
  /// - the pSlotName pointer is valid.
  /// - the ppNewSlot pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - any of pSegment, pSlotName, or ppNewSlot arguments is null.
  /// 
  /// @param editRate [in] Edit rate property value
  /// @param pSegment [in] Segment to append as slot component
  /// @param slotID [in] new slot ID
  /// @param pSlotName [in, string] new slot name
  /// @param origin [in] The slot origin
  /// @param ppNewSlot [out] Newly created slot
  ///
  HRESULT AppendNewEventSlot (
    [in] aafRational_t  editRate,
    [in] IAAFSegment * pSegment,
    [in] aafSlotID_t  slotID,
    [in, string] aafCharacter_constptr  pSlotName,
    [in] aafPosition_t  origin,
    [out] IAAFEventMobSlot ** ppNewSlot);
	     

}



// ************************
//
// Interface IAAFProgress
//
// ************************
///
/// This interface is used by the toolkit
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.


[
    object,
    uuid(8E7B0F14-A759-416a-98FD-346242D5081F),
    helpstring("IAAFProgress Interface"),
    pointer_default(unique)
]

interface IAAFProgress : IUnknown
{


  //***********************************************************
  //
  // ProgressCallback()
  //
  /// Called frequently during OM load/save operations.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  HRESULT ProgressCallback ();
}



// ************************
//
// Interface IAAFRGBADescriptor2
//
// ************************


///
/// The IAAFRGBADescriptor2 interface is implemented by objects
/// which describe video content data formatted using RGBA formatting.
///
/// In addition to the parameters inherited from AAFDigitalImageDescriptor,
/// this interface adds Pixel layout (order of R, B, G, alpha)
/// PixelStructure (sizes of the various components), Palette, Palette Layout,
/// and Palette Structure.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it through
///     this object's primary interface.  Note that
///     IAAFDigitalImageDescriptor is a primary interface for an
///     abstract class, so it is not appropriate for the
///     Initialize() method to exist in this interface.  The
///     Initialize() method is available through the concrete
///     object's primary interface.
///
///
/// Objects that implement IAAFRGBADescriptor2 also implement the following interfaces:
///  - IAAFDigitalImageDescriptor
///  - IAAFDigitalImageDescriptor2
///  - IAAFFileDescriptor
///  - IAAFFileDescriptor2
///  - IAAFEssenceDescriptor
///  - IAAFObject
[
    object,
    uuid(205c5aae-727a-46c3-8368-cd8b1d14fbdd),
    helpstring("IAAFRGBADescriptor2 Interface"),
    pointer_default(unique)
]
interface IAAFRGBADescriptor2 : IUnknown
{


  //***********************************************************
  //
  // SetPixelLayout()
  //
  /// Sets the layout and structure of the components in a single pixel.
  /// The layout array is an Array of 8 aafRGBAComponent_t.  The 'Code' field of the struct is
  /// from the set:
  ///   	- kAAFCompNone
  /// 	- kAAFCompAlpha
  /// 	- kAAFCompBlue
  /// 	- kAAFCompFill
  /// 	- kAAFCompGreen
  /// 	- kAAFCompPalette
  /// 	- kAAFCompRed
  ///
  /// The 'Size' field of the struct is the component size in bits.
  /// 
  /// If you set less than 8 entries, the remaining entries will be padded with kAAFCompNone and a size of zero.
  /// If this method fails the PixelLayout property will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param numberElements [in] The number of elements in each array
  /// @param PixelLayoutArray [in] Array of up to 8 aafRGBAComponent_t indicating component order and size.
  ///
  HRESULT SetPixelLayout (
    [in] aafUInt32  numberElements,
    [in] aafRGBAComponent_t*  PixelLayoutArray);

  //***********************************************************
  //
  // CountPixelLayoutElements()
  //
  /// This function returns the number of components in a pixel.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails no state is changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  /// 
  /// @param pResult [out] Number of components
  ///
  HRESULT CountPixelLayoutElements (
    [out] aafUInt32 *  pResult);

  //***********************************************************
  //
  // GetPixelLayout()
  //
  /// Gets the layout and structure of the components in a single pixel.
  /// The layout array is an Array of 8 aafRGBAComponent_t.  The 'Code' field of the struct is
  /// from the set:
  ///   	- kAAFCompNone
  /// 	- kAAFCompAlpha
  /// 	- kAAFCompBlue
  /// 	- kAAFCompFill
  /// 	- kAAFCompGreen
  /// 	- kAAFCompPalette
  /// 	- kAAFCompRed
  ///
  /// The 'Size' field of the struct is the component size in bits.
  /// 
  /// If you Get more entries than were set, the extra entries will be padded with kAAFCompNone and a size of zero.
  ///
  /// If this method fails, PixelLayoutArray will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumberElements or PixelLayoutArray or PixelStructureArray is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - numberElements indicates that the array is too small to hold
  ///     the data.
  /// 
  /// @param numberElements [in] The number of elements in the array
  /// @param PixelLayoutArray [out, size_is(numberElements)] Array to hold up to 8 aafRGBAComponent_t indicating component order and size.
  ///
  HRESULT GetPixelLayout (
    [in] aafUInt32  numberElements,
    [out, size_is(numberElements)] aafRGBAComponent_t*  PixelLayoutArray);

  //***********************************************************
  //
  // SetPalette()
  //
  /// Sets the palette property.  The palette must be in the form specified
  /// by the palette layout and palette structure parameters.
  /// 
  /// Succeeds if all of the following are true:
  /// - pPalette is a valid pointer
  /// 
  /// If this method fails, the palette property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPalette is NULL.
  /// 
  /// @param numberElements [in] The number of bytes in the array
  /// @param pPalette [in, size_is(numberElements)] Array to hold the palette information
  ///
  HRESULT SetPalette (
    [in] aafUInt32  numberElements,
    [in, size_is(numberElements)] aafUInt8*  pPalette);


  //***********************************************************
  //
  // GetPalette()
  //
  /// Sets the palette property.  The palette must be in the form specified
  /// by the palette layout and palette structure parameters.
  /// The values are written to the array specified by pPalette,
  /// which is of size numberElements.  The required size may be found
  /// by calling GetPaletteSize().
  /// 
  /// Succeeds if all of the following are true:
  /// - pPalette is a valid pointer.
  /// - numberElements indicates the array is large enough to hold the
  ///   data.
  /// 
  /// If this method fails, pPalette will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumberElements is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - numberElements indicates that the array is too small to hold
  ///     the data.
  /// 
  /// @param numberRecords [in] The number of bytes in the array
  /// @param pPalette [out, size_is(numberRecords)] Array to hold the palette information
  ///
  HRESULT GetPalette (
    [in] aafUInt32  numberRecords,
    [out, size_is(numberRecords)] aafUInt8*  pPalette);


  //***********************************************************
  //
  // GetPaletteSize()
  //
  /// Get the number of bytes in the VideoLineMap property array.
  /// 
  /// Succeeds if all of the following are true:
  /// - pNumberBytes is a valid pointer
  /// 
  /// If this method fails, *pNumberBytes will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumberBytes is NULL.
  /// 
  /// @param pNumberBytes [out] The number of bytes in the array
  ///
  HRESULT GetPaletteSize (
    [out] aafUInt32 *  pNumberBytes);

  //***********************************************************
  //
  // CountPaletteLayoutElements()
  //
  /// This function returns the number of components in a pixel.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails no state is changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  /// 
  /// @param pResult [out] Number of components
  ///
  HRESULT CountPaletteLayoutElements (
    [out] aafUInt32 *  pResult);

  //***********************************************************
  //
  // SetPaletteLayout()
  //
  /// Sets the layout and structure of the components in a single pixel.
  /// The layout array is an Array of 8 aafRGBAComponent_t.  The 'Code' field of the struct is
  /// from the set:
  ///   	- kAAFCompNone
  /// 	- kAAFCompAlpha
  /// 	- kAAFCompBlue
  /// 	- kAAFCompFill
  /// 	- kAAFCompGreen
  /// 	- kAAFCompPalette
  /// 	- kAAFCompRed
  ///
  /// The 'Size' field of the struct is the component size in bits.
  /// 
  /// If you set less than 8 entries, the remaining entries will be padded with kAAFCompNone and a size of zero.
  /// If this method fails the PaletteLayout property will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param numberElements [in] The number of elements in the array
  /// @param PaletteLayoutArray [in] Array of up to 8 bytes indicating component size, matching layout, and terminated by a zero byte.
  ///
  HRESULT SetPaletteLayout (
    [in] aafUInt32  numberElements,
    [in] aafRGBAComponent_t*  PaletteLayoutArray);

  //***********************************************************
  //
  // GetPaletteLayout()
  //
  /// /// The layout array is an Array of 8 aafRGBAComponent_t.  The 'Code' field of the struct is
  /// from the set:
  ///   	- kAAFCompNone
  /// 	- kAAFCompAlpha
  /// 	- kAAFCompBlue
  /// 	- kAAFCompFill
  /// 	- kAAFCompGreen
  /// 	- kAAFCompPalette
  /// 	- kAAFCompRed
  ///
  /// The 'Size' field of the struct is the component size in bits.
  /// 
  /// If you Get more entries than were set, the extra entries will be padded with kAAFCompNone and a size of zero.
  ///
  /// If this method fails, PaletteLayoutArray will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumberElements or PaletteLayoutArray is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - numberElements indicates that the array is too small to hold
  ///     the data.
  /// 
  /// @param numberElements [in] The number of elements in each array
  /// @param PaletteLayoutArray [out, size_is(numberElements)] Array to hold 8 aafRGBAComponent_t indicating component order and size.
  ///
  HRESULT GetPaletteLayout (
    [in] aafUInt32  numberElements,
    [out, size_is(numberElements)] aafRGBAComponent_t*  PaletteLayoutArray);


  //***********************************************************
  //
  // SetComponentMaxRef()
  //
  /// Sets the ComponentMaxRef property.
  ///
  /// Succeeds if all of the following are true:
  /// 
  /// If this method fails, the ComponentMaxRef property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param componentMaxRef [in] Optional.
  ///
  HRESULT SetComponentMaxRef (
    [in] aafUInt32  componentMaxRef);


  //***********************************************************
  //
  // GetComponentMaxRef()
  //
  /// Gets the ComponentMaxRef property.
  ///
  /// Succeeds if all of the following are true:
  /// - pComponentMaxRef is a valid pointer
  /// - the property is present.
  ///
  /// If this method fails, pComponentMaxRef will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pComponentMaxRef is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pComponentMaxRef [out] Optional.
  ///
  HRESULT GetComponentMaxRef (
    [out] aafUInt32 *  pComponentMaxRef);


  //***********************************************************
  //
  // SetComponentMinRef()
  //
  /// Sets the ComponentMinRef property.
  ///
  /// Succeeds if all of the following are true:
  /// 
  /// If this method fails, the ComponentMinRef property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param componentMinRef [in] Optional.
  ///
  HRESULT SetComponentMinRef (
    [in] aafUInt32  componentMinRef);


  //***********************************************************
  //
  // GetComponentMinRef()
  //
  /// Gets the ComponentMinRef property.
  ///
  /// Succeeds if all of the following are true:
  /// - pComponentMinRef is a valid pointer
  /// - the property is present.
  ///
  /// If this method fails, pComponentMinRef will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pComponentMinRef is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pComponentMinRef [out] Optional.
  ///
  HRESULT GetComponentMinRef (
    [out] aafUInt32 *  pComponentMinRef);


  //***********************************************************
  //
  // SetAlphaMaxRef()
  //
  /// Sets the AlphaMaxRef property.
  ///
  /// Succeeds if all of the following are true:
  /// 
  /// If this method fails, the AlphaMaxRef property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param alphaMaxRef [in] Optional.
  ///
  HRESULT SetAlphaMaxRef (
    [in] aafUInt32  alphaMaxRef);


  //***********************************************************
  //
  // GetAlphaMaxRef()
  //
  /// Gets the AlphaMaxRef property.
  ///
  /// Succeeds if all of the following are true:
  /// - pAlphaMaxRef is a valid pointer
  /// - the property is present.
  ///
  /// If this method fails, pAlphaMaxRef will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pAlphaMaxRef is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pAlphaMaxRef [out] Optional.
  ///
  HRESULT GetAlphaMaxRef (
    [out] aafUInt32 *  pAlphaMaxRef);


  //***********************************************************
  //
  // SetAlphaMinRef()
  //
  /// Sets the AlphaMinRef property.
  ///
  /// Succeeds if all of the following are true:
  /// 
  /// If this method fails, the AlphaMinRef property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param alphaMinRef [in] Optional.
  ///
  HRESULT SetAlphaMinRef (
    [in] aafUInt32  alphaMinRef);


  //***********************************************************
  //
  // GetAlphaMinRef()
  //
  /// Gets the AlphaMinRef property.
  ///
  /// Succeeds if all of the following are true:
  /// - pAlphaMinRef is a valid pointer
  /// - the property is present.
  ///
  /// If this method fails, pAlphaMinRef will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pAlphaMinRef is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pAlphaMinRef [out] Optional.
  ///
  HRESULT GetAlphaMinRef (
    [out] aafUInt32 *  pAlphaMinRef);


  //***********************************************************
  //
  // SetScanningDirection()
  //
  /// Sets the ScanningDirection property.  This property is optional.
  ///
  /// Succeeds if all of the following are true:
  /// - scanningDirection is a value value.
  /// 
  /// If this method fails, the ScanningDirection property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_AAFRESULT_INVALID_ENUM_VALUE
  ///   - scanningDirection is not a valid value.
  /// 
  /// @param scanningDirection [in] Scanning direction value.
  ///
  HRESULT SetScanningDirection (
    [in] aafScanningDirection_t  scanningDirection);


  //***********************************************************
  //
  // GetScanningDirection()
  //
  /// Gets the ScanningDirection property.  This property is optional.
  ///
  /// Succeeds if all of the following are true:
  /// - pScanningDirection is a valid pointer
  /// - the property is present.
  /// 
  /// If this method fails, pScanningDirection not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pScanningDirection is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param pScanningDirection [out] Scanning direction value.
  ///
  HRESULT GetScanningDirection (
    [out] aafScanningDirection_t *  pScanningDirection);


}



// ************************
//
// Interface IAAFSearchSource
//
// ************************
///
/// The IAAFSearchSource interface is used to return source information
/// for some mob slots.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it through
///     this object's primary interface.  Note that IAAFSearchSource is
///     not a primary interface for a concrete class, so it is not
///     appropriate for the Initialize() method to exist in this
///     interface.  The Initialize() method is available through the
///     concrete object's primary interface.
///
[
    object,
    uuid(332CBDD0-5425-11D2-AA7A-10003D000000),
    helpstring("IAAFSearchSource Interface"),
    pointer_default(unique)
]
interface IAAFSearchSource : IUnknown
{

  //***********************************************************
  //
  // SearchSource()
  //
  /// This function returns the source information for a slot in a
  /// Master Mob or Source Mob.  It follows the Source Clip references
  /// in the specified slot until it encounters the kind of Mob
  /// specified in the mobKind parameter.  This function cannot be used
  /// on a Composition Mob and is not intended to be called
  /// iteratively; use the MobOpenSearch, MobGetNextSource,
  /// MobGetThisSource, and MobCloseSearch functions for those
  /// purposes. 
  ///
  /// The returned component and find source info are AddRef()ed
  /// before they are returned.
  ///
  /// Succeeds if all of the following are true:
  /// - ppSourceInfo is non-NULL
  /// - a Mob of the requested kind is found
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppCpnt is null.
  ///
  /// OM_ERR_INVALID_MOBTYPE
  ///	- The enumerator is out of range (bad cast, or writing
  ///      toolkit newer than reader)
  ///
  /// OM_ERR_TRAVERSAL_NOT_POSS
  ///	- Can not find a mob of the given kind.
  /// 
  /// @param slotID [in] Slot ID
  /// @param offset [in] Offset
  /// @param mobKind [in] Mob Kind
  /// @param pMediaCrit [in] Media Criteria
  /// @param pOperationChoice [in] Operation Choice
  /// @param ppSourceInfo [out] Source Information
  ///
  HRESULT SearchSource (
    [in] aafSlotID_t  slotID,
    [in] aafPosition_t  offset,
    [in] aafMobKind_t  mobKind,
    [in] aafMediaCriteria_t *  pMediaCrit,
    [in] aafOperationChoice_t *  pOperationChoice,
    [out] IAAFFindSourceInfo ** ppSourceInfo);
}



// ************************
//
// Interface IAAFSourceReference2
//
// ************************
///
/// The IAAFSourceReference2 interface is implemented by objects that
/// represent the essence or other data described by a MobSlot in a
/// Mob.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// AAFRESULT_NOT_INITIALIZED
///   - This object has not yet had Initialize() called on it through
///     this object's primary interface.  Note that IAAFSourceReference2
///     is a primary interface for an abstract class, so it is not
///     appropriate for the Initialize() method to exist in this
///     interface.  The Initialize() method is available through the
///     concrete object's primary interface.
///
///
/// Objects that implement IAAFSourceReference2 also implement the following interfaces:
///  - IAAFSegment
///  - IAAFComponent
///  - IAAFComponent2
///  - IAAFObject
[
    object,
    uuid(eb3094c4-f60e-4aa3-b500-ba72c4c791b7),
    helpstring("IAAFSourceReference2 Interface"),
    pointer_default(unique)
]
interface IAAFSourceReference2 : IUnknown
{



  //***********************************************************
  //
  // GetSourceID()
  //
  /// Gets the SourceID and places it into the pSourceID argument.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSourceID pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pSourceID.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSourceID arg is NULL.
  /// 
  /// @param pSourceID [retval][out] Place to put source ID
  ///
  HRESULT GetSourceID (
    [retval][out] aafMobID_t *  pSourceID);


  //***********************************************************
  //
  // SetSourceID()
  //
  /// Sets the SourceID using the sourceID argument.
  /// 
  /// Always succeeds.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// @param sourceID [in] Source ID to set
  ///
  HRESULT SetSourceID (
    [in] aafMobID_constref   sourceID);


  //***********************************************************
  //
  // GetSourceMobSlotID()
  //
  /// Gets the Mob Slot ID and places it into the pMobSlotID argument.
  ///
  /// Succeeds if all of the following are true:
  /// - the pMobSlotID pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pMobSlotID.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMobSlotID arg is NULL.
  /// 
  /// @param pMobSlotID [retval][out] Place to put source mob slot ID
  ///
  HRESULT GetSourceMobSlotID (
    [retval][out] aafSlotID_t *  pMobSlotID);


  //***********************************************************
  //
  // SetSourceMobSlotID()
  //
  /// Sets the mob slot ID using the mobSlotID argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - (preconditions here)
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// (other error codes here.)
  /// 
  /// @param mobSlotID [in] Source Mob ID to set
  ///
  HRESULT SetSourceMobSlotID (
    [in] aafSlotID_t   mobSlotID);



  //***********************************************************
  //
  // SetChannelIDs()
  //
  /// Specify the channels in a slot that are referenced. The first channel has
  /// and ID of 1, the N'th channel has an ID of N.  The number of channel IDs
  /// shall equal the number of channels being described the bht MobSlot containing
  /// the SourceReference, e.g. 1 element for a mono audio slot, 6 elements for a 5.1
  /// multi-channel audio slot.
  /// 
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pChannelIDs is null 
  /// 
  /// @param numberElements [in] Number of elements in the pChannelIDs array
  /// @param pChannelIDs [in] Array of channel IDs
  ///
  HRESULT SetChannelIDs (
    [in] aafUInt32  numberElements,
    [in] aafUInt32*  pChannelIDs);


  //***********************************************************
  //
  // GetChannelIDs()
  //
  /// Get the channels in a slot that are referenced.  Refer to
  /// SetChannelIDs for channel IDs description.
  ///
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pChannelIDs is null
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present
  ///
  /// AAFRESULT_SMALLBUF
  ///   - pChannelIDs is too small
  /// 
  /// @param numberElements [in] Number of elements in the pChannelIDs array
  /// @param pChannelIDs [in] Array of channel IDs
  ///
  HRESULT GetChannelIDs (
    [in] aafUInt32  numberElements,
    [in] aafUInt32*  pChannelIDs);

  //***********************************************************
  //
  // GetChannelIDsSize()
  //
  /// Returns the size in bytes of the buffer required to hold the array
  /// returned by GetChannelIDs().
  ///
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSize is null
  /// 
  /// @param pSize [out] required buffer size to hold the ChannelIDs array
  ///
  HRESULT GetChannelIDsSize (
    [out] aafUInt32 *  pSize);

  //***********************************************************
  //
  // SetMonoSourceSlotIDs()
  //
  /// For reference from a multi-channel MobSlot to multiple mono MobSlots.
  /// pMonoSourceSlotIDs identifies the mono slots referenced by this SourceReference
  /// object.
  /// 
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMonoSourceSlotIDs is null 
  /// 
  /// @param numberElements [in] Number of elements in the pMonoSourceSlotIDs array
  /// @param pMonoSourceSlotIDs [in] Array of slot IDs
  ///
  HRESULT SetMonoSourceSlotIDs (
    [in] aafUInt32  numberElements,
    [in] aafUInt32*  pMonoSourceSlotIDs);


  //***********************************************************
  //
  // GetMonoSourceSlotIDs()
  //
  /// Get the mono slot IDs that are referenced by this object.  Refer to
  /// SetMonoSourceSlotIDs for a description of pMonoSourceSlotIDs.
  ///
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMonoSourceSlotIDs is null
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present
  ///
  /// AAFRESULT_SMALLBUF
  ///   - pMonoSourceSlotIDs is too small
  /// 
  /// @param numberElements [in] Number of elements in the pMonoSourceSlotIDs array
  /// @param pMonoSourceSlotIDs [in] Array of channel IDs
  ///
  HRESULT GetMonoSourceSlotIDs (
    [in] aafUInt32  numberElements,
    [in] aafUInt32*  pMonoSourceSlotIDs);

  //***********************************************************
  //
  // GetMonoSourceSlotIDsSize()
  //
  /// Returns the size in bytes of the buffer required to hold the array
  /// returned by GetMonoSourceSlotIDs().
  ///
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSize is null
  /// 
  /// @param pSize [out] required buffer size to hold the MonoSourceSlotIDs array
  ///
  HRESULT GetMonoSourceSlotIDsSize (
    [out] aafUInt32 *  pSize);

}



// ************************
//
// Interface IAAFStreamAccess
//
// ************************
///
/// This interface is used by the toolkit
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.


[
    object,
    uuid(065F5F69-3A64-401e-A1A6-5833268F5236),
    helpstring("IAAFStreamAccess Interface"),
    pointer_default(unique)
]

interface IAAFStreamAccess : IUnknown
{


  //***********************************************************
  //
  // WriteStream()
  //
  /// This method is called back by the AAF toolkit when a previously
  /// defined stream property is actually being written, so that you
  /// may write the data.
  ///  IAAFTypeDef *pTypeDef;
  ///  IAAFTypeDefStream *pTypeDefStream;
  /// 
  ///  propertyValue->GetType(&pTypeDef));
  ///  pTypeDef->QueryInterface(IID_IAAFTypeDefStream,(void **)&pTypeDefStream));
  ///  pTypeDefStream->Write(pStreamPropertyValue, ...);
  ///  
  /// 
  /// @param propertyValue [in] One which will this data be written
  /// @param pUserData [in] A client-supplied pointer used to extract the data
  ///
  HRESULT WriteStream (
    [in] IAAFPropertyValue * propertyValue,
    [in] aafMemPtr_t  pUserData);

}



// ************************
//
// Interface IAAFTimelineMobSlot2
//
// ************************
///
/// The IAAFTimelineMobSlot interface is implemented by objects which
/// contain time-varying timeline essence.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// Types required by this module:
///
/// aafBool
/// aafRational_t
/// aafPosition_t
/// aafTrackID_t
///


///
/// Objects that implement IAAFTimelineMobSlot2 also implement the following interfaces:
///  - IAAFMobSlot
///  - IAAFObject
[
    object,
    uuid(db347978-ba72-4bdf-a188-8172ea5c5f00),
    helpstring("IAAFTimelineMobSlot2 Interface"),
    pointer_default(unique)
]
interface IAAFTimelineMobSlot2 : IUnknown
{

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty
  /// IAAFTimelineMobSlot2-supporting object.  This method must be
  /// called after allocation, and before any other method can be
  /// called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  /// 
  HRESULT Initialize ();


  //***********************************************************
  //
  // GetEditRate()
  //
  /// This method will get the edit rate for this mob slot.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pEditRate pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEditRate arg is NULL.
  /// 
  /// @param pEditRate [out,retval] Edit rate property value
  ///
  HRESULT GetEditRate (
    [out,retval] aafRational_t *  pEditRate);


  //***********************************************************
  //
  // SetEditRate()
  //
  /// This method will get set edit rate for this mob slot.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param editRate [in] Edit rate property value
  ///
  HRESULT SetEditRate (
    [in] aafRational_constref  editRate);


  //***********************************************************
  //
  // GetOrigin()
  //
  /// This method will return the origin of this mob slot.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pOrigin pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pOrigin arg is NULL.
  /// 
  /// @param pOrigin [out,retval] Origin property value
  ///
  HRESULT GetOrigin (
    [out,retval] aafPosition_t *  pOrigin);


  //***********************************************************
  //
  // SetOrigin()
  //
  /// This method will set the origin of this mob slot.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.).
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  /// 
  /// @param origin [in] Origin property value
  ///
  HRESULT SetOrigin (
    [in] aafPosition_t  origin);

  //***********************************************************
  //
  // GetMarkIn()
  //
  /// Gets the MarkIn property of this TimelineMobSlot.
  /// This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the result pointer is valid.
  /// - the property is present.
  /// 
  /// If this method fails nothing will be written to *result.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMarkIn arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param result [out,retval] MarkIn property value
  ///
  HRESULT GetMarkIn (
    [out,retval] aafPosition_t *  result);

  //***********************************************************
  //
  // SetMarkIn()
  //
  /// Sets the MarkIn property of this TimelineMobSlot.
  /// This property is optional.
  ///
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  ///
  /// If this method fails the MarkIn property will not be
  /// changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  /// 
  /// @param value [in] MarkIn property value
  ///
  HRESULT SetMarkIn (
    [in] aafPosition_t  value);

  //***********************************************************
  //
  // GetMarkOut()
  //
  /// Gets the MarkOut property of this TimelineMobSlot.
  /// This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the result pointer is valid.
  /// - the property is present.
  /// 
  /// If this method fails nothing will be written to *result.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMarkIn arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param result [out,retval] MarkOut property value
  ///
  HRESULT GetMarkOut (
    [out,retval] aafPosition_t *  result);

  //***********************************************************
  //
  // SetMarkOut()
  //
  /// Sets the MarkOut property of this TimelineMobSlot.
  /// This property is optional.
  ///
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  ///
  /// If this method fails the MarkOut property will not be
  /// changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  /// 
  /// @param value [in] MarkOut property value
  ///
  HRESULT SetMarkOut (
    [in] aafPosition_t  value);

  //***********************************************************
  //
  // GetUserPos()
  //
  /// Gets the UserPos property of this TimelineMobSlot.
  /// This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the result pointer is valid.
  /// - the property is present.
  /// 
  /// If this method fails nothing will be written to *result.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - result arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  /// 
  /// @param result [out,retval] UserPos property value
  ///
  HRESULT GetUserPos (
    [out,retval] aafPosition_t *  result);

  //***********************************************************
  //
  // SetUserPos()
  //
  /// Sets the UserPos property of this TimelineMobSlot.
  /// This property is optional.
  ///
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  ///
  /// If this method fails the UserPos property will not be
  /// changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  /// 
  /// @param value [in] UserPos property value
  ///
  HRESULT SetUserPos (
    [in] aafPosition_t  value);

}



// ************************
//
// Interface IAAFTypeDefStreamEx
//
// ************************
///
/// This interface is an extension to the previously definined TypeDefStream
/// interface.  Hence the suffix "Ex" to the name. Additional methods are now included.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// Objects that implement IAAFTypeDefStreamEx also implement the following interfaces:
///  - IAAFTypeDef
///  - IAAFMetaDefinition
[
    object,
    uuid(A7A76BEF-E074-4da8-B18D-07E355C60DF4 ),
    helpstring("IAAFTypeDefStreamEx Interface"),
    pointer_default(unique)
]

interface IAAFTypeDefStreamEx : IUnknown
{



  //***********************************************************
  //
  // SetCallback()
  //
  /// Sets a callback interface to be called when a stream is written to or
  /// read from the file.  This allows the stream property to be built bottom up.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pPropertyValue pointer is valid.
  /// - pCallbackIF pointer is valid.
  /// - pUserData pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pPropertyValue or pCallbackIF or pUserData arg is NULL.
  /// 
  /// @param pPropertyValue [in] Issue the callback for this property
  /// @param pCallbackIF [in] Interface of the callback object
  /// @param pUserData [in] Client-specific data passed through to the callback
  ///
  HRESULT SetCallback (
    [in] IAAFPropertyValue * pPropertyValue,
    [in] IAAFStreamAccess*  pCallbackIF,
    [in] aafMemPtr_t  pUserData);

}





// ************************
//
// Interface IAAFTypeDefStream3
//
// ************************
///
/// This interface is used to define Stream types used in AAF
/// persistent objects.  Streams are conceptually similar to
/// variably-sized arrays except that they are intended to be used for
/// very large pieces of data (such as essence).
/// Note: All reads/and writes advance the current position.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// Objects that implement IAAFTypeDefStream3 also implement the following interfaces:
///  - IAAFTypeDef
///  - IAAFMetaDefinition
[
    object,
    uuid(D1E43120-D90A-463f-BC4D-BB1174A8DBD3),
    helpstring("IAAFTypeDefStream3 Interface"),
    pointer_default(unique)
]

interface IAAFTypeDefStream3 : IUnknown
{



  //***********************************************************
  //
  // GetSize()
  //
  /// Returns number of bytes contained in the referenced property
  /// value.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  /// - pSize is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pStreamPropertyValue or pSize arg is NULL.
  /// 
  /// @param pStreamPropertyValue [in] stream property value
  /// @param pSize [out] count of bytes in the specified stream property value
  ///
  HRESULT GetSize (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [out] aafInt64 *  pSize);

  //***********************************************************
  //
  // SetSize()
  //
  /// Set the number of bytes contained in the give stream property value
  /// to newElementCount
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - If pStreamPropertyValue arg is NULL.
  /// 
  /// @param pStreamPropertyValue [in] stream property value
  /// @param newSize [in] new count of bytes in the specified stream property value
  ///
  HRESULT SetSize (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [in] aafInt64  newSize);

  //***********************************************************
  //
  // GetPosition()
  //
  /// Returns the byte position of the current element in the stream. 
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  /// - pPosition is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pStreamPropertyValue or pPosition arg is NULL.
  /// 
  /// @param pStreamPropertyValue [in] stream property value
  /// @param pPosition [out] current byte position in the specified stream property value
  ///
  HRESULT GetPosition (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [out] aafInt64 *  pPosition);

  //***********************************************************
  //
  // SetPosition()
  //
  /// Make the current byte position to the one at newPosition in the stream 
  /// property value. 
  ///
  /// Succeeds if:
  /// - pStreamPropertyValue is a valid pointer.
  /// - the new position is valid
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - If pStreamPropertyValue arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - newPosition is outside the bounds of the stream.
  /// 
  /// @param pStreamPropertyValue [in] stream property value
  /// @param newPosition [in] the new position in the specified stream property value
  ///
  HRESULT SetPosition (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [in] aafInt64  newPosition);


  //***********************************************************
  //
  // Read()
  //
  /// Sequential access.
  /// Copies the data at the position of the stream to the given
  /// buffer.
  ///
  /// Succeeds if all of the following are true:
  /// - the pStreamPropertyValue pointer is valid.
  /// - the pData pointer is valid.
  /// - the indicated bytes exist in the stream.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pStreamPropertyValue or pData arg is NULL.
  /// 
  /// @param pStreamPropertyValue [in] stream property value to read
  /// @param dataSize [in] number of bytes to read
  /// @param pData [out, size_is(dataSize), length_is(*bytesRead)] buffer into which one element from the stream should be written
  /// @param bytesRead [out,ref] number of bytes actually read (will be either dataSize or 0 if there 
  /// is in error)
  ///
  HRESULT Read (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [in] aafUInt32  dataSize,
    [out, size_is(dataSize), length_is(*bytesRead)] aafMemPtr_t  pData,
    [out,ref] aafUInt32 *  bytesRead);

  //***********************************************************
  //
  // Write()
  //
  /// Sequential access.
  /// Copies the data in the given buffer into the stream at the 
  /// current position of the stream..
  ///
  /// Succeeds if all of the following are true:
  /// - the pStreamPropertyValue pointer is valid.
  /// - the pData pointer is valid.
  /// - the indicated bytes could be written to the stream.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pStreamPropertyValue or pData arg is NULL.
  /// 
  /// @param pStreamPropertyValue [in] stream property value to modify
  /// @param dataSize [in] number of bytes to write
  /// @param pData [in, ref, size_is(dataSize)] buffer into which should contain one element to be written to the stream
  ///
  HRESULT Write (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [in] aafUInt32  dataSize,
    [in, ref, size_is(dataSize)] aafMemPtr_t  pData);

  //***********************************************************
  //
  // Append()
  //
  /// Extending the stream.
  /// Copies the data in the given buffer into the stream at the 
  /// end of the stream.
  ///
  /// Succeeds if all of the following are true:
  /// - the pStreamPropertyValue pointer is valid.
  /// - the pData pointer is valid.
  /// - the indicated bytes could be appended to the stream.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pStreamPropertyValue or pData arg is NULL.
  /// 
  /// @param pStreamPropertyValue [in] stream property value to modify
  /// @param dataSize [in] number of bytes to write (must be equal to the element type length)
  /// @param pData [in, ref, size_is(dataSize)] buffer into which should contain one element to be written to the stream
  ///
  HRESULT Append (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [in] aafUInt32  dataSize,
    [in, ref, size_is(dataSize)] aafMemPtr_t  pData);


  //***********************************************************
  //
  // HasStoredByteOrder()
  //
  /// Returns kAAFTrue if the stream has a stored byte order or 
  /// kAAFFalse otherwise.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  /// - pHasByteOrder is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pStreamPropertyValue or pHasByteOrder arg is NULL.
  /// 
  /// @param pStreamPropertyValue [in] stream property value
  /// @param pHasByteOrder [out] kAAFTrue if this stream has a stored byte order
  ///
  HRESULT HasStoredByteOrder (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [out] aafBoolean_t *  pHasByteOrder);

  //***********************************************************
  //
  // GetStoredByteOrder()
  //
  /// Access byte order of the stream.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  /// - pByteOrder is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pStreamPropertyValue or pByteOrder arg is NULL.
  /// 
  /// @param pStreamPropertyValue [in] stream property value
  /// @param pByteOrder [out] Pointer to variable where byte order is to be copied
  ///
  HRESULT GetStoredByteOrder (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [out] eAAFByteOrder_t *  pByteOrder);

  //***********************************************************
  //
  // SetStoredByteOrder()
  //
  /// Sets the byte order to be associated with this stream. Note: the stream
  /// must be empty.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  /// - stream is empty.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - If pStreamPropertyValue arg is NULL.
  /// 
  /// @param pStreamPropertyValue [in] stream property value
  /// @param byteOrder [in] byte order is to be stored with the stream
  ///
  HRESULT SetStoredByteOrder (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [in] eAAFByteOrder_t  byteOrder);

  //***********************************************************
  //
  // ClearStoredByteOrder()
  //
  /// Clears the byte order to be associated with this stream. Note: the stream
  /// must be empty.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  /// - stream is empty.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - If pStreamPropertyValue arg is NULL.
  /// 
  /// @param pStreamPropertyValue [in] stream property value
  ///
  HRESULT ClearStoredByteOrder (
    [in] IAAFPropertyValue * pStreamPropertyValue);

  //***********************************************************
  //
  // ReadElements()
  //
  /// Access in typed chunks of Elements.
  /// Copies the data at the current position of the stream to the given
  /// buffer. Requires that any structures declared within element 
  /// typedef have had their offsets registered with that type.
  ///
  /// Succeeds if all of the following are true:
  /// - the pStreamPropertyValue pointer is valid.
  /// - the pElementType pointer is valid.
  /// - the pData pointer is valid.
  /// - dataSize indicates pData is large enough to hold the data.
  /// - compile-time struct has had its member offests registered.
  /// - the indicated elements exist in this stream type def.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pStreamPropertyValue or pElementType or pBytesRead or pData arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - dataSize indicates pData is too small.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for element typedef.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - there are not dataSize bytes left in the stream.
  /// 
  /// @param pStreamPropertyValue [in] stream property value to read
  /// @param pElementType [in] the type definition of the elements to read
  /// @param dataSize [in] number of bytes to read (must be evenly divisible by the element 
  /// type length)
  /// @param pData [out, size_is(dataSize), length_is(*pBytesRead)] buffer into which elements from the stream should be written
  /// @param pBytesRead [out,ref] number of bytes actually read (will be either dataSize or 0 if 
  /// there is in error)
  ///
  HRESULT ReadElements (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [in] IAAFTypeDef * pElementType,
    [in] aafUInt32  dataSize,
    [out, size_is(dataSize), length_is(*pBytesRead)] aafMemPtr_t  pData,
    [out,ref] aafUInt32 *  pBytesRead);

  //***********************************************************
  //
  // WriteElements()
  //
  /// Access in typed chunks of Elements.
  /// Copies the data in the given buffer into the stream at the  
  /// current position of the stream. Requires that any structures 
  /// declared within element 
  /// typedef have had their offsets registered with that type..
  ///
  /// Succeeds if all of the following are true:
  /// - the pStreamPropertyValue pointer is valid.
  /// - the pElementType pointer is valid.
  /// - the pData pointer is valid.
  /// - dataSize indicates pData is large enough to hold the data.
  /// - compile-time struct has had its member offests registered.
  /// - the indicated elements exist in this stream type def.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pStreamPropertyValue or pElementType or pData arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - dataSize indicates pData is an even multiple of the given 
  ///     element type size.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for the element typedef.
  /// 
  /// @param pStreamPropertyValue [in] stream property value to modify
  /// @param pElementType [in] the type definition of the elements to read
  /// @param dataSize [in] number of bytes to write (must be evenly divisible by the element type 
  /// length)
  /// @param pData [in, ref, size_is(dataSize)] buffer into which elements from the stream should be written
  ///
  HRESULT WriteElements (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [in] IAAFTypeDef * pElementType,
    [in] aafUInt32  dataSize,
    [in, ref, size_is(dataSize)] aafMemPtr_t  pData);


cpp_quote("  /// Extend in chunks of typed Elements") 

  //***********************************************************
  //
  // AppendElements()
  //
  /// Access in typed chunks of Elements.
  /// Copies the data in the given buffer onto the end of the stream. 
  /// Requires that any structures declared within element 
  /// typedef have had their offsets registered with that type..
  ///
  /// Succeeds if all of the following are true:
  /// - the pStreamPropertyValue pointer is valid.
  /// - the pElementType pointer is valid.
  /// - the pData pointer is valid.
  /// - dataSize indicates pData is large enough to hold the data.
  /// - compile-time struct has had its member offests registered.
  /// - the indicated elements exist in this stream type def.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pStreamPropertyValue or pElementType or pData arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - dataSize indicates pData is an even multiple of the given 
  ///     element type size.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for the element typedef.
  /// 
  /// @param pStreamPropertyValue [in] stream property value to modify
  /// @param pElementType [in] the type definition of the elements to read
  /// @param dataSize [in] number of bytes to write (must be evenly divisible by the element type 
  /// length)
  /// @param pData [in, ref, size_is(dataSize)] buffer into which elements from the stream should be written
  ///
  HRESULT AppendElements (
    [in] IAAFPropertyValue * pStreamPropertyValue,
    [in] IAAFTypeDef * pElementType,
    [in] aafUInt32  dataSize,
    [in, ref, size_is(dataSize)] aafMemPtr_t  pData);

  //***********************************************************
  //
  // SetCallback()
  //
  /// Sets a callback interface to be called when a stream is written to or
  /// read from the file.  This allows the stream property to be built bottom up.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pPropertyValue pointer is valid.
  /// - pCallbackIF pointer is valid.
  /// - pUserData pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pPropertyValue or pCallbackIF or pUserData arg is NULL.
  /// 
  /// @param pPropertyValue [in] Issue the callback for this property
  /// @param pCallbackIF [in] Interface of the callback object
  /// @param pUserData [in] Client-specific data passed through to the callback
  ///
  HRESULT SetCallback (
    [in] IAAFPropertyValue * pPropertyValue,
    [in] IAAFStreamAccess*  pCallbackIF,
    [in] aafMemPtr_t  pUserData);

  //***********************************************************
  //
  // GetPlainStreamData()
  //
  /// Creates an object which implements the IAAFPlainStreamData
  // interface and provides access to the file encoding-independent
  // stream data.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pPlainStreamData is a valid pointer.
  // - reserved is 0.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPlainStreamData arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - reserved is not 0.
  /// 
  /// @param reserved [in] Reserved for future use
  /// @param pPlainStreamData [out,retval] file encoding-independent stream data
  ///
  HRESULT GetPlainStreamData (
    [in] aafUInt32  reserved,
    [out,retval] IAAFPlainStreamData ** pPlainStreamData);

}



// ************************
//
// Interface IAAFTypeDefVariableArrayEx
//
// ************************
///
/// This interface is an extension to the previously definined TypeDefVariableArray
/// interface.  Hence the suffix "Ex" to the name. Additional methods are now included.
///
/// In addition to the specific error results listed for each method,
/// all methods in this interface may also return one of the following
/// values:
/// 
/// AAFRESULT_NOMEMORY
///   - insufficient system memory is available to perform the
///     operation.
///
/// Objects that implement IAAFTypeDefVariableArrayEx also implement the following interfaces:
///  - IAAFTypeDef
///  - IAAFMetaDefinition
[
    object,
    uuid(7f73d4b3-6f9a-11d4-8e59-009027dfcc26 ),
    helpstring("IAAFTypeDefVariableArrayEx Interface"),
    pointer_default(unique)
]

interface IAAFTypeDefVariableArrayEx : IUnknown
{



  //***********************************************************
  //
  // PrependElement()
  //
  /// Prepends an element to the end of the array, setting it to the
  /// value given in pMemberPropVal.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pInPropVal pointer is valid.
  /// - pMemberPropVal pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pInPropVal or pMemberPropVal arg is NULL.
  /// 
  /// @param pInPropVal [in] property value corresponding to array to which element is prepended
  /// @param pMemberPropVal [in] value to be prepended to this array
  ///
  HRESULT PrependElement (
    [in] IAAFPropertyValue * pInPropVal,
    [in] IAAFPropertyValue * pMemberPropVal);




  //***********************************************************
  //
  // RemoveElement()
  //
  /// Remove an element from the Array, given an index.
  /// Index is zero-based,
  /// and must be less than the value returned by GetCount().
  /// 
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - the index exists in this array type def.
  /// - The pInPropVal pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pInPropVal arg is NULL.
  ///
  /// AAFRESULT_BADINDEX
  ///   - The given index is out of range for this array type def.
  /// 
  /// @param pInPropVal [in] property value corresponding to array
  /// @param index [in] zero-based index into elements in this array type
  ///
  HRESULT RemoveElement (
    [in] IAAFPropertyValue * pInPropVal,
    [in] aafUInt32  index);




  //***********************************************************
  //
  // InsertElement()
  //
  /// Inserts the value of the single, indicated element of the fixed
  /// array contained in pInPropVal, to the value contained in
  /// pMemberPropVal.  Index is zero-based, and must be less than the
  /// value returned by GetCount().  Property value must be of the
  /// same type as returned by GetType().
  /// 
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - the index exists in this array type def.
  /// - The pInPropVal pointer is valid.
  /// - The ppOutPropVal pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pInPropVal or ppOutPropVal arg is NULL.
  ///
  /// AAFRESULT_BADINDEX
  ///   - The given index is out of range for this array type def.
  /// 
  /// @param pInPropVal [in] property value corresponding to array
  /// @param index [in] zero-based index into elements in this array type
  /// @param pMemberPropVal [in] value to be inserted into this array
  ///
  HRESULT InsertElement (
    [in] IAAFPropertyValue * pInPropVal,
    [in] aafUInt32  index,
    [in] IAAFPropertyValue * pMemberPropVal);




}






  ///***********************************************************
  ///
  /// Global functions for AAF files:
  /// 
  /// In addition to the specific error results listed for each function,
  /// all factory functions may also return one of the following
  /// values:
  /// 
  /// AAFRESULT_NOMEMORY
  ///   - insufficient system memory is available to perform the
  ///     operation.
  ///



cpp_quote("  ///***********************************************************") 
cpp_quote("  /// Functions used to dynamically load and unload the AAF dll") 
cpp_quote("  /// without statically linking to the dll's export library.") 
cpp_quote("  /// To use these functions link to the stub library aaf.lib") 
cpp_quote("  /// (or aafd.lib for the debugging version). ") 
cpp_quote("  /// If the client is statically linking to the AAF dll's export") 
cpp_quote("  /// library then the following functions will always succeed:") 
cpp_quote("  ///***********************************************************") 

  //***********************************************************
  //
  // AAFLoad()
  //
  /// Attempts to load the given implementation of AAF into
  /// the processes address space. Only one implementation
  /// of AAF can be active. Note: once AAFUnload has been
  /// called all subsequent access to AAF interfaces will fail
  ///
  /// To use this function link to the stub library aaf.lib
  /// (or aafd.lib for the debugging version). 
  /// If the client is statically linking to the AAF dll's export
  /// library then the function will always succeed.
  ///
  /// @param dllname [in] Pointer to the name of AAF dll to load.
  /// If this pointer is NULL the function will attempt to load the
  /// default AAF dll. 
  ///
cpp_quote("STDAPI AAFLoad (const char *  dllname);")
cpp_quote("")


  ///***********************************************************
  //
  // AAFUnload()
  //
  /// Attempts to unload the current AAF dll loaded with a
  /// previous call to AAFLoad.
  ///
cpp_quote("STDAPI AAFUnload ();")
cpp_quote("")


cpp_quote("  ///***********************************************************") 
cpp_quote("  /// Factory functions for AAF files:.") 
cpp_quote("  ///***********************************************************") 

  //***********************************************************
  //
  // AAFFileOpenExistingRead()
  //
  /// Creates an object associated with with an existing filesystem
  /// file that contains data which is only to be read.
  /// Does the following:
  ///
  /// - Opens the existing named file in the filesystem for reading.
  /// - Associates an object with that filesystem file.
  /// - Places the object into the Open-read-only state.
  /// - This AAFFile object then can be used as the root of the
  ///   containment tree representing all AAF objects contained within the file.
  ///
  /// Succeeds if:
  /// - The pFileName argument is valid.
  /// - Only valid flags have been specified.
  /// - A valid combination of flags has been specified.
  /// - The named file exists in the filesystem.
  /// - The named filesystem file is readable.
  /// - The named file represents itself as a valid AAF file.  Even if
  ///   this succeeds, it is not guaranteed that the named file is in fact a valid AAF file.
  ///
  /// This function will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - the pFileName pointer arg is NULL.
  ///
  /// AAFRESULT_BAD_FLAGS
  ///   - one or more illegal flags were specified.
  ///
  /// AAFRESULT_BAD_FLAG_COMBINATION
  ///   - illegal combination of otherwise valid flags was specified.
  ///
  /// AAFRESULT_FILE_NOT_FOUND
  ///   - The named file does not exist in the filesystem.
  ///
  /// AAFRESULT_NOT_READABLE
  ///   - The named file cannot be read.
  ///
  /// AAFRESULT_NOT_AAF_FILE
  ///   - The named file does not claim to be a valid AAF file.
  /// 
  /// @param pFileName [in, string] Null-terminated string containing name of filesystem file to be
  /// opened for reading. The file name has no restrictions other than those imposed by
  /// the underlying file system. AAF files that use structured storage encoding typically
  /// use the extension .aaf or .isr. AAF files that use XML encoding typically use the .xml
  /// extension. AAF files that use KLV encoding typically use use the extension .mxf or .klv.
  /// @param modeFlags [in] File open mode flags.  May be any of the following ORed
  /// together.  All other bits must be set to zero.
  ///
  ///  - kAAFFileModeUnbuffered - to indicate buffered mode.  Default
  ///    is buffered.
  /// @param ppFile [out] Pointer to buffer to receive pointer to new file.
  /// 
cpp_quote("STDAPI AAFFileOpenExistingRead (")
cpp_quote("          aafCharacter_constptr  pFileName,")
cpp_quote("          aafUInt32  modeFlags,")
cpp_quote("          IAAFFile ** ppFile);")
cpp_quote("")


  //***********************************************************
  //
  // AAFFileOpenExistingModify()
  //
  /// Creates an object associated with with an existing
  /// filesystem file that contains data which is to be read and
  /// written.  Associates the given identification with it.
  /// Does the following:
  ///
  /// - Opens the existing named file in the filesystem for reading and
  ///   writing.
  /// - Associates an object with that filesystem file.
  /// - Places the object into the Open-read-write  state.
  /// - This AAFFile object then can be used as the root of the
  ///   containment tree representing all AAF objects contained within the file.
  ///
  /// Succeeds if:
  /// - This object is currently Closed.
  /// - The pFileName argument is valid.
  /// - The pIdent argument is valid.
  /// - Only valid flags have been specified.
  /// - A valid combination of flags has been specified.
  /// - The named file exists in the filesystem.
  /// - The named filesystem file is readable.
  /// - The named filesystem file is writable.
  /// - The named file represents itself as a valid AAF file.  Even if
  ///   this succeeds, it is not guaranteed that the named file is in fact a valid AAF file.
  ///
  /// This function will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pFileName or pIdent pointer argument is NULL.
  ///
  /// AAFRESULT_BAD_FLAGS
  ///   - one or more illegal flags were specified.
  ///
  /// AAFRESULT_BAD_FLAG_COMBINATION
  ///   - illegal combination of otherwise valid flags was specified.
  ///
  /// AAFRESULT_FILE_NOT_FOUND
  ///   - The named file does not exist in the filesystem.
  ///
  /// AAFRESULT_NOT_READABLE
  ///   - The named file cannot be read.
  ///
  /// AAFRESULT_NOT_WRITEABLE
  ///   - The named file cannot be written.
  ///
  /// AAFRESULT_NOTAAFFILE
  ///   - The named file is not a valid AAF file.
  /// 
  /// @param pFileName [in, string] Null-terminated string containing name of filesystem file to be
  /// opened for modification. The file name has no restrictions other than those imposed by
  /// the underlying file system. AAF files that use structured storage encoding typically
  /// use the extension .aaf or .isr. AAF files that use XML encoding typically use the .xml
  /// extension. AAF files that use KLV encoding typically use use the extension .mxf or .klv.
  /// @param modeFlags [in] File open mode flags.  May be any of the following ORed together.
  /// All other bits must be set to zero.
  ///
  ///  - kAAFFileModeUnbuffered
  ///    to indicate unbuffered mode. Default is buffered.
  ///  - kAAFFileModeRevertable
  ///    to indicate that Revert is possible on this file (for all changes except those to essence).
  /// @param pIdent [in] Identification of the application which is modifying this file.
  /// @param ppFile [out] Pointer to buffer to receive pointer to new file.
  ///
cpp_quote("STDAPI AAFFileOpenExistingModify (")
cpp_quote("          aafCharacter_constptr  pFileName,")
cpp_quote("          aafUInt32  modeFlags,")
cpp_quote("          aafProductIdentification_t *  pIdent,")
cpp_quote("          IAAFFile ** ppFile);")
cpp_quote("")


  //***********************************************************
  //
  // AAFFileOpenNewModify()
  //
  /// Creates an object associated with with a new
  /// filesystem file that contains data which is to be read and
  /// written.  Associates the given identification with it.
  /// Does the following:
  ///
  /// - Creates a new file in the filesystem with the given name.
  /// - Opens the filesystem file for reading and writing.
  /// - Associates this object with that filesystem file.
  /// - Places this object into the Open state.
  /// - This AAFFile object then can be used as the root of the
  ///   containment tree representing all AAF objects contained within the file.
  ///
  /// Succeeds if:
  /// - The pFileName argument is valid.
  /// - The pIdent argument is valid.
  /// - Only valid flags have been specified.
  /// - A valid combination of flags has been specified.
  /// - The named file does not exists in the filesystem.
  /// - There is sufficient space in the filesystem to create the file.
  ///
  /// This function will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pFileName or pIdent pointer argument is NULL.
  ///
  /// AAFRESULT_BAD_FLAGS
  ///   - one or more illegal flags were specified.
  ///
  /// AAFRESULT_BAD_FLAG_COMBINATION
  ///   - illegal combination of otherwise valid flags was specified.
  ///
  /// AAFRESULT_FILE_EXISTS
  ///   - The named file already exists in the filesystem.
  ///
  /// AAFRESULT_INSUFFICIENT_SPACE
  ///   - There is insufficient space in the filesystem to create this
  ///     file.
  /// 
  /// @param pFileName [in, string] Null-terminated string containing name of filesystem file to be
  /// opened for modification. The file name has no restrictions other than those imposed by
  /// the underlying file system. AAF files that use structured storage encoding typically
  /// use the extension .aaf or .isr. AAF files that use XML encoding typically use the .xml
  /// extension. AAF files that use KLV encoding typically use use the extension .mxf or .klv.
  /// @param modeFlags [in] File open mode flags.  May be any of the following ORed together.
  /// All other bits must be set to zero.
  ///
  ///  - kAAFFileModeUnbuffered
  ///    to indicate unbuffered mode. Default is buffered.
  ///  - kAAFFileModeRevertable
  ///    to indicate that Revert is possible on this file (for all changes except those to essence).
  /// @param pIdent [in] Identification of the application which is creating this file.
  /// @param ppFile [out] Pointer to buffer to receive pointer to new file.
  ///
cpp_quote("STDAPI AAFFileOpenNewModify (")
cpp_quote("          aafCharacter_constptr  pFileName,")
cpp_quote("          aafUInt32  modeFlags,")
cpp_quote("          aafProductIdentification_t *  pIdent,")
cpp_quote("          IAAFFile ** ppFile);")
cpp_quote("")


  //***********************************************************
  //
  // AAFFileOpenNewModifyEx()
  //
  /// Creates an object associated with with a new
  /// filesystem file that contains data which is to be read and
  /// written.  Associates the given identification with it.
  /// Does the following:
  ///
  /// - Creates a new file in the filesystem with the given name.
  /// - Opens the filesystem file for reading and writing.
  /// - Associates this object with that filesystem file.
  /// - Places this object into the Open state.
  /// - This AAFFile object then can be used as the root of the
  ///   containment tree representing all AAF objects contained within the file.
  ///
  /// Succeeds if:
  /// - The pFileName argument is valid.
  /// - The pFileKind argument is valid.
  /// - The pIdent argument is valid.
  /// - Only valid flags have been specified.
  /// - A valid combination of flags has been specified.
  /// - The named file does not exists in the filesystem.
  /// - There is sufficient space in the filesystem to create the file.
  ///
  /// This function will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pFileName or pIdent pointer argument is NULL.
  ///
  /// AAFRESULT_BAD_FLAGS
  ///   - one or more illegal flags were specified.
  ///
  /// AAFRESULT_BAD_FLAG_COMBINATION
  ///   - illegal combination of otherwise valid flags was specified.
  ///
  /// AAFRESULT_FILE_EXISTS
  ///   - The named file already exists in the filesystem.
  ///
  /// AAFRESULT_INSUFFICIENT_SPACE
  ///   - There is insufficient space in the filesystem to create this
  ///     file.
  /// 
  /// @param pFileName [in, string] Null-terminated string containing name of filesystem file to be
  /// opened for modification. The file name has no restrictions other than those imposed by
  /// the underlying file system. AAF files that use structured storage encoding typically
  /// use the extension .aaf or .isr. AAF files that use XML encoding typically use the .xml
  /// extension. AAF files that use KLV encoding typically use use the extension .mxf or .klv.
  /// @param pFileKind [in] kind of file to be created
  /// @param modeFlags [in] File open mode flags
  /// @param pIdent [in] Identification of the application which is creating this file.
  /// @param ppFile [out] Pointer to buffer to receive pointer to new file.
  ///
cpp_quote("STDAPI AAFFileOpenNewModifyEx (")
cpp_quote("          aafCharacter_constptr  pFileName,")
cpp_quote("          aafUID_constptr  pFileKind,")
cpp_quote("          aafUInt32  modeFlags,")
cpp_quote("          aafProductIdentification_t *  pIdent,")
cpp_quote("          IAAFFile ** ppFile);")
cpp_quote("")


  //***********************************************************
  //
  // AAFFileOpenTransient()
  //
  /// Creates an object associated with with a transient file,
  /// meaning that it is not associated with any filesystem file but
  /// may still be used to contain AAF objects as if it was associated
  /// with a filesystem file.  Associates the given identification with
  /// this file.
  ///
  /// Transient files are never considered Revertable.
  ///
  /// Succeeds if:
  /// - This object has already been Initialize()d.
  /// - The pIdent argument is valid.
  /// - This object is currently closed.
  ///
  /// This function will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_ALREADY_OPEN
  ///   - This object is already open.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - the pIdent pointer argument is NULL.
  ///
  /// @param pIdent [in] Identification which is to be associated with this file.
  /// @param ppFile [out] Pointer to buffer to receive pointer to new file.
  /// 
cpp_quote("STDAPI AAFFileOpenTransient (")
cpp_quote("          aafProductIdentification_t *  pIdent,")
cpp_quote("          IAAFFile ** ppFile);")
cpp_quote("")


  //***********************************************************
  //
  // AAFFileIsAAFFile()
  //
  /// Is the named file an AAF file ?
  ///
  /// Note that the function result is returned via the pFileIsAAFFile argument.
  /// If this function succeeds it returns AAFRESULT_SUCCESS even if the named
  /// file is not an AAF file.
  ///
  /// This function will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - at least one of the pointer arguments is NULL.
  ///
  /// AAFRESULT_FILE_NOT_FOUND
  ///   - the file named by pFileName cannot be found.
  /// 
  /// @param pFileName [in, string] Null-terminated string containing name of filesystem file.
  /// @param pAAFFileKind [out] Pointer to an AUID indicating the file kind
  /// @param pFileIsAAFFile [out,retval] Returns AAFTrue if the given file is an AAF file, returns AAFFalse otherwise.
  /// 
cpp_quote("STDAPI AAFFileIsAAFFile (")
cpp_quote("          aafCharacter_constptr  pFileName,")
cpp_quote("          aafUID_t *  pAAFFileKind,")
cpp_quote("          aafBool *  pFileIsAAFFile);")
cpp_quote("")

  //***********************************************************
  //
  // AAFRawStorageIsAAFFile()
  //
  /// Does the storage contain an AAF file ?
  ///
  /// Note that the function result is returned via the pRawStorageIsAAFFile argument.
  /// If this function succeeds it returns AAFRESULT_SUCCESS even if the storage
  /// is not an AAF file.
  ///
  /// This function will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - at least one of the pointer arguments is NULL.
  /// 
  /// @param pRawStorage [in] storage containing the purported file
  /// @param pAAFFileKind [out] Pointer to an AUID indicating the file kind
  /// @param pRawStorageIsAAFFile [out,retval] Returns AAFTrue if the given storage contains an AAF file, returns AAFFalse otherwise.
  /// 
cpp_quote("STDAPI AAFRawStorageIsAAFFile (")
cpp_quote("          IAAFRawStorage *  pRawStorage,")
cpp_quote("          aafUID_t *  pAAFFileKind,")
cpp_quote("          aafBool *  pRawStorageIsAAFFile);")
cpp_quote("")


  //***********************************************************
  //
  // AAFFileIsAAFFileKind()
  //
  /// Is the named file an AAF file ?
  ///
  /// Note that the function result is returned via the pFileIsAAFFile argument.
  /// If this function succeeds it returns AAFRESULT_SUCCESS even if the named
  /// file is not an AAF file of the specified kind.
  ///
  /// This function will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - at least one of the pointer arguments is NULL.
  ///
  /// AAFRESULT_FILEKIND_NOT_REGISTERED
  ///   - the specified file kind is not supported by the toolkit.
  /// 
  /// @param pFileName [in, string] Null-terminated string containing name of filesystem file.
  /// @param pAAFFileKind [in] Pointer to an AUID indicating the file kind to check for
  /// @param pFileIsAAFFile [out,retval] Returns AAFTrue if the given file is an AAF file of the specified kind,
  /// returns AAFFalse otherwise.
  /// 
cpp_quote("STDAPI AAFFileIsAAFFileKind (")
cpp_quote("          aafCharacter_constptr  pFileName,")
cpp_quote("          aafUID_constptr  pAAFFileKind,")
cpp_quote("          aafBool *  pFileIsAAFFile);")
cpp_quote("")


  //***********************************************************
  //
  // AAFRawStorageIsAAFFileKind()
  //
  /// Does the storage contain an AAF file ?
  ///
  /// Note that the function result is returned via the pRawStorageIsAAFFile argument.
  /// If this function succeeds it returns AAFRESULT_SUCCESS even if the storage
  /// is not an AAF file of the specified kind.
  ///
  /// This function will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - at least one of the pointer arguments is NULL.
  ///
  /// AAFRESULT_FILEKIND_NOT_REGISTERED
  ///   - the specified file kind is not supported by the toolkit.
  /// 
  /// @param pRawStorage [in] storage containing the purported file
  /// @param pAAFFileKind [in] Pointer to an AUID indicating the file kind to check for
  /// @param pRawStorageIsAAFFile [out,retval] Returns AAFTrue if the given storage contains an AAF file of the
  /// specified kind, returns AAFFalse otherwise.
  /// 
cpp_quote("STDAPI AAFRawStorageIsAAFFileKind (")
cpp_quote("          IAAFRawStorage *  pRawStorage,")
cpp_quote("          aafUID_constptr  pAAFFileKind,")
cpp_quote("          aafBool *  pRawStorageIsAAFFile);")
cpp_quote("")


  //***********************************************************
  //
  // AAFGetPluginManager()
  //
  /// Returns an interface of the plugin manager, which is used to
  /// select plugins for exporting.
  ///
  /// @param ppPluginManager [out] Pointer to the interface of the plugin manager. 
  ///
cpp_quote("STDAPI AAFGetPluginManager (IAAFPluginManager ** ppPluginManager);")
cpp_quote("")


  //***********************************************************
  //
  // AAFCreateRawStorageMemory()
  //
  /// Create a raw storage providing a built-in implementation of
  /// IAAFRawStorage on memory.
  ///
  /// This is considered a value-added function since clients could
  /// actually create their own.
  ///
  /// Succeeds if:
  /// - The ppNewRawStorage pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppNewRawStorage arg is NULL.
  ///
  /// @param access [in] Governs whether stream may be read from and/or written
  /// to.
  /// @param ppNewRawStorage [out] Newly created storage
  /// 
cpp_quote("STDAPI AAFCreateRawStorageMemory (")
cpp_quote("          aafFileAccess_t  access,")
cpp_quote("          IAAFRawStorage ** ppNewRawStorage);")
cpp_quote("")


  //***********************************************************
  //
  // AAFCreateRawStorageDisk()
  //
  /// Create a raw storage providing a built-in implementation of
  /// IAAFRawStorage on a file on disk.
  ///
  /// Note that it is illegal to specify existence and access as "New"
  /// "Read".
  ///
  /// This is considered a value-added function since clients could
  /// actually create their own.
  ///
  /// Succeeds if:
  /// - The pFilename pointer is valid.
  /// - The ppNewRawStorage pointer is valid.
  /// - If the open mode is one of read, write, or modify.
  /// - If the file existence is one of new or existing.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFilename or ppNewRawStorage arg is NULL.
  ///
  /// AAFRESULT_WRONG_OPENMODE
  /// - If none of read, modify, or write are specified as open
  ///   mode, or if neither new or existing is specified for the
  ///   existence.
  /// 
  /// @param pFilename [in] Name of file to be associated with this storage
  /// @param existence [in] Governs whether storage is on pre-existing data, or is
  ///  newly created.
  /// @param access [in] Governs whether stream may be read from and/or written
  ///  to.
  /// @param ppNewRawStorage [out] Newly created storage
  ///
cpp_quote("STDAPI AAFCreateRawStorageDisk (")
cpp_quote("          aafCharacter_constptr  pFilename,")
cpp_quote("          aafFileExistence_t  existence,")
cpp_quote("          aafFileAccess_t  access,")
cpp_quote("          IAAFRawStorage ** ppNewRawStorage);")
cpp_quote("")


  //***********************************************************
  //
  // AAFCreateRawStorageCachedDisk()
  //
  /// Create a raw storage providing a built-in implementation of
  /// IAAFRawStorage on a file on disk with caching.
  ///
  /// Note that it is illegal to specify existence and access as "New"
  /// "Read".
  ///
  /// This is considered a value-added function since clients could
  /// actually create their own.
  ///
  /// Succeeds if:
  /// - The pFilename pointer is valid.
  /// - The ppNewRawStorage pointer is valid.
  /// - If the open mode is one of read, write, or modify.
  /// - If the file existence is one of new or existing.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFilename or ppNewRawStorage arg is NULL.
  ///
  /// AAFRESULT_WRONG_OPENMODE
  /// - If none of read, modify, or write are specified as open
  ///   mode, or if neither new or existing is specified for the
  ///   existence.
  /// 
  /// @param pFilename [in] Name of file to be associated with this storage
  /// @param existence [in] Governs whether storage is on pre-existing data, or is
  ///  newly created.
  /// @param access [in] Governs whether stream may be read from and/or written
  ///  to.
  /// @param pageCount [in] Count of cache pages
  /// @param pageSize [in] Cache page size in bytes
  /// @param ppNewRawStorage [out] Newly created storage
  ///
cpp_quote("STDAPI AAFCreateRawStorageCachedDisk (")
cpp_quote("          aafCharacter_constptr  pFilename,")
cpp_quote("          aafFileExistence_t  existence,")
cpp_quote("          aafFileAccess_t  access,")
cpp_quote("          aafUInt32  pageCount,")
cpp_quote("          aafUInt32  pageSize,")
cpp_quote("          IAAFRawStorage ** ppNewRawStorage);")
cpp_quote("")

  //***********************************************************
  //
  // AAFCreateRawStorageCached()
  //
  /// Create a new cached raw storage from an
  /// existing raw storage.
  ///
  /// Succeeds if:
  /// - The pRawStorage pointer is valid.
  /// - The ppNewRawStorage pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pRawStorage or ppNewRawStorage arg is NULL.
  ///
  ///   
  /// 
  /// @param pRawStorage [in] Existing raw storage
  /// @param pageCount [in] Count of cache pages
  /// @param pageSize [in] Cache page size in bytes
  /// @param ppNewRawStorage [out] Newly created cached storage
  ///
cpp_quote("STDAPI AAFCreateRawStorageCached (")
cpp_quote("          IAAFRawStorage *  pRawStorage,")
cpp_quote("          aafUInt32  pageCount,")
cpp_quote("          aafUInt32  pageSize,")
cpp_quote("          IAAFRawStorage ** ppNewRawStorage);")
cpp_quote("")

  //***********************************************************
  //
  // AAFCreateRawStorageCached2()
  //
  /// Create a new cached raw storage from an
  /// existing raw storage with control over how the cache pages are allocated.
  ///
  /// Note that pages are allocated as needed so that the toolkit calls
  /// Allocate() a maximum of pageCount times (fewer than pageCount calls
  /// will be made if the data fits entirely within the cache).
  /// 
  /// Succeeds if:
  /// - The pRawStorage pointer is valid.
  /// - The pCachePageAllocator pointer is valid.
  /// - The ppNewRawStorage pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pRawStorage, pCachePageAllocator or ppNewRawStorage arg is NULL.
  ///
  ///
  /// 
  /// @param pRawStorage [in] Existing raw storage
  /// @param pageCount [in] Count of cache pages
  /// @param pageSize [in] Cache page size in bytes
  /// @param pCachePageAllocator [in] Cache page memory allocator
  /// @param ppNewRawStorage [out] Newly created cached storage
  ///
cpp_quote("STDAPI AAFCreateRawStorageCached2 (")
cpp_quote("          IAAFRawStorage *  pRawStorage,")
cpp_quote("          aafUInt32  pageCount,")
cpp_quote("          aafUInt32  pageSize,")
cpp_quote("          IAAFCachePageAllocator*  pCachePageAllocator,")
cpp_quote("          IAAFRawStorage ** ppNewRawStorage);")
cpp_quote("")

  //***********************************************************
  //
  // AAFCreateAAFFileOnRawStorage()
  //
  /// Given an IAAFRawStorage, create an IAAFFile.  If pRawStorage is
  /// actually an IAAFRandomRawStorage, the created file will be an
  /// IAAFRandomFile.
  ///
  /// Note that AAF files based on Binary Structured Storage will
  /// require the underlying IAAFRawStorage to be at least readable,
  /// even in the case of write-only AAF files.
  ///
  /// Note also that only the following combinations of access and
  /// existence are legal:
  ///
  ///          existence   access   Legal?
  ///          ---------   ------   ------
  ///          existing    read     yes
  ///          existing    write    no
  ///          existing    modify   yes
  ///            new       read     no
  ///            new       write    yes
  ///            new       modify   yes
  ///
  /// This method will succeed if the following are true:
  /// - The pRawStorage pointer is valid.
  /// - The ppNewFile pointer is valid.
  /// - The accessibility of the specified raw storage matches that of the desired AAF File; additionally, if the file kind is
  ///   Structured Storage Binary, the raw storage is also required to be at least readable. 
  /// - A legal combination of existence and access flags is given.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pRawStorage or ppNewFile arg is NULL.
  ///
  /// AAFRESULT_NOT_READABLE
  /// - The access parameter specifies readability or if this file is
  ///   Binary Structured Storage, but the specified raw storage is
  ///   not readable.
  ///
  /// AAFRESULT_NOT_WRITEABLE
  /// - The access parameter specifies writeability but the specified
  ///   raw storage is not writeable.
  ///
  /// AAFRESULT_NULL_PARAM
  /// - existence is new, and pFileKind is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  /// - The access or existence parameters are not set to a legal
  ///   combination of values.
  /// 
  /// @param pRawStorage [in] storage to be associated with this file
  /// @param existence [in] Governs whether storage is on pre-existing data, or is
  ///  newly created.
  /// @param access [in] Governs whether stream may be read from and/or written
  ///  to.
  /// @param pFileKind [in] kind of file to be created; only used for new files
  /// @param modeFlags [in] File mode flags
  /// @param pIdent [in] Identification to be associated with this file; only
  ///  used for new files
  /// @param ppNewFile [out] newly-created file
  ///
cpp_quote("STDAPI AAFCreateAAFFileOnRawStorage (")
cpp_quote("          IAAFRawStorage *  pRawStorage,")
cpp_quote("          aafFileExistence_t  existence,")
cpp_quote("          aafFileAccess_t  access,")
cpp_quote("          aafUID_constptr  pFileKind,")
cpp_quote("          aafUInt32  modeFlags,")
cpp_quote("          aafProductIdentification_constptr  pIdent,")
cpp_quote("          IAAFFile ** ppNewFile);")
cpp_quote("")

  //***********************************************************
  //
  // AAFSetProgressCallback()
  //
  /// Sets a progress callback, called back during load and save.
  ///
  /// @param pProgress [in] Pointer to the interface of the progress interface callback. 
  ///
cpp_quote("STDAPI AAFSetProgressCallback (IAAFProgress*  pProgress);")
cpp_quote("")

  //***********************************************************
  //
  // AAFGetFileEncodings()
  //
  /// Returns an enumeration of file encodings supported by this version
  /// of the library.
  ///
  /// This method will succeed if the following are true:
  /// - The ppFileEncodings pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppFileEncodings arg is NULL.
  ///
  /// @param ppFileEncodings [out] Available file encodings. 
  ///
cpp_quote("STDAPI AAFGetFileEncodings (IEnumAAFFileEncodings ** ppFileEncodings);")
cpp_quote("")

  //***********************************************************
  //
  // AAFSetDiagnosticOutput()
  //
  /// Make the specified diagnostic output stream the AAF Toolkit's diagnostic output stream.
  /// By default the diagnostic output goes to stderr. The passed in pointer is AddRefed.
  /// The pointer will be Released the next time AAFSetDiagnosticOutput is called or when
  /// the AAF DLL is unloaded.
  /// 
  ///
  /// This method will succeed if the following are true:
  /// - The pOutput pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pStream arg is NULL.
  ///
  /// @param pOutput [in] New diagnostic output. 
  ///
cpp_quote("STDAPI AAFSetDiagnosticOutput (IAAFDiagnosticOutput*  pOutput);")
cpp_quote("")

  //***********************************************************
  //
  // AAFGetLibraryVersion()
  //
  /// Return the version of the AAF library currently
  /// running on this machine, which implements these interfaces.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pVersion pointer is valid.
  /// 
  /// If this method fails nothing is written to *pVersion.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pVersion is null.
  ///
  /// @param pVersion [out, retval] The library version 
  ///
cpp_quote("STDAPI AAFGetLibraryVersion (aafProductVersion_t *  pVersion);")
cpp_quote("")

  //***********************************************************
  //
  // AAFGetStaticLibraryVersion()
  //
  /// Return the version of the static (aaflib) library
  /// linked against the calling appplication. This version may be the same as
  /// or different from the version of the (dynamically linked) AAF Library
  /// containing the implementation of the various interfaces.  The version
  /// of the AAF Library may be obtained by calling AAFGetLibraryVersion().
  /// 
  /// Succeeds if all of the following are true:
  /// - the pVersion pointer is valid.
  /// 
  /// If this method fails nothing is written to *pVersion.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pVersion is null.
  ///
  /// @param pVersion [out, retval] The static library version 
  ///
cpp_quote("STDAPI AAFGetStaticLibraryVersion (aafProductVersion_t *  pVersion);")
cpp_quote("")

  //***********************************************************
  //
  // AAFGetLibraryPathNameBufLen()
  //
  /// Returns size of buffer (in bytes) required for AAFGetLibraryPathName().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes 
  ///
cpp_quote("STDAPI AAFGetLibraryPathNameBufLen (aafUInt32 *  pBufSize);")
cpp_quote("")

  //***********************************************************
  //
  // AAFGetLibraryPathName()
  //
  /// Get the pathname of the AAF library.
  /// 
  /// Writes the LibraryPathName, with a trailing null
  /// character, into the pLibraryPathName buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.
  /// 
  /// Caller may call AAFGetLibraryPathNameBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pLibraryPathName.
  /// 
  /// Succeeds if:
  /// - The pLibraryPathName pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   LibraryPathName.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLibraryPathName arg is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold LibraryPathName.
  ///
  /// @param pLibraryPathName [out, string, size_is(bufSize)] buffer into which LibraryPathName is to be written
  /// @param bufSize [in] size of *pLibraryPathName buffer in bytes
  /// 
cpp_quote("STDAPI AAFGetLibraryPathName (")
cpp_quote("          aafCharacter *  pLibraryPathName,")
cpp_quote("          aafUInt32  bufSize);")
cpp_quote("")

  //***********************************************************
  //
  // AAFResultToTextBufLen()
  //
  /// Returns the size of the buffer, in bytes, required for the AAFResultToText() function.
  ///
  /// Succeeds if all of the following are true:
  /// - the pResultTextSize pointer is valid.
  /// - the result is an AAFRESULT.
  /// - the result is a recognized AAFRESULT.
  ///
  /// If this method fails nothing will be written to *pResultTextSize.
  ///
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResultTextSize arg is NULL.
  ///
  /// AAFRESULT_RESULT_NOT_AAF
  ///   - result is not an AAFRESULT.
  ///
  /// AAFRESULT_RESULT_NOT_RECOGNIZED
  ///   - result is not a recognized AAFRESULT.
  ///
  /// @param result [in] The result
  /// @param pResultTextSize [out] The size of the required buffer, in bytes.
  /// 
cpp_quote("STDAPI AAFResultToTextBufLen (")
cpp_quote("          AAFRESULT  result,")
cpp_quote("          aafUInt32 *   pResultTextSize);")
cpp_quote("")


  //***********************************************************
  //
  // AAFResultToText()
  //
  /// /// Returns the text representation of an AAFRESULT.
  ///
  /// Succeeds if all of the following are true:
  /// - the pResultText pointer is valid.
  /// - the result is an AAFRESULT.
  /// - the result is a recognized AAFRESULT.
  /// - the buffer is large enough to hold the result text.
  ///
  /// If this method fails nothing will be written to resultText.
  ///
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResultText arg is NULL.
  ///
  /// AAFRESULT_RESULT_NOT_AAF
  ///   - result is not an AAFRESULT.
  ///
  /// AAFRESULT_RESULT_NOT_RECOGNIZED
  ///   - result is not a recognized AAFRESULT.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - pResultText is too small to hold the result text.
  /// 
  /// @param result [in] The result
  /// @param pResultText [out, string, size_is(resultTextSize)] The text representation of the result
  /// @param resultTextSize [in] The size, in bytes, of pResultText
  /// 
cpp_quote("STDAPI AAFResultToText (")
cpp_quote("          AAFRESULT  result,")
cpp_quote("          aafCharacter *  pResultText,")
cpp_quote("          aafUInt32  resultTextSize);")
cpp_quote("")



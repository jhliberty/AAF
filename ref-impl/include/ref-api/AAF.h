//=---------------------------------------------------------------------=
//
// This file was GENERATED for the AAF SDK
//
// $Id: AAF.h,v 1.65 2012/06/26 20:54:40 jptrainor Exp $ $Name: V116 $
//
// The contents of this file are subject to the AAF SDK Public Source
// License Agreement Version 2.0 (the "License"); You may not use this
// file except in compliance with the License.  The License is available
// in AAFSDKPSL.TXT, or you may obtain a copy of the License from the
// Advanced Media Workflow Association, Inc., or its successor.
//
// Software distributed under the License is distributed on an "AS IS"
// basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
// the License for the specific language governing rights and limitations
// under the License.  Refer to Section 3.3 of the License for proper use
// of this Exhibit.
//
// WARNING:  Please contact the Advanced Media Workflow Association,
// Inc., for more information about any additional licenses to
// intellectual property covering the AAF Standard that may be required
// to create and distribute AAF compliant products.
// (http://www.amwa.tv/policies).
//
// Copyright Notices:
// The Original Code of this file is Copyright 1998-2012, licensor of the
// Advanced Media Workflow Association.  All rights reserved.
//
// The Initial Developer of the Original Code of this file and the
// licensor of the Advanced Media Workflow Association is
// Avid Technology.
// All rights reserved.
//
//=---------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// AAF Interfaces.
//=--------------------------------------------------------------------------=
//
#ifndef __AAF_h__
#define __AAF_h__

#ifndef __AAFCOMPlatform_h__
#include "AAFCOMPlatform.h"
#endif

#ifndef __AAFTypes_h__
#include "AAFTypes.h"
#endif

#ifdef __cplusplus
interface IAAFAES3PCMDescriptor;
interface IAAFAIFCDescriptor;
interface IAAFAuxiliaryDescriptor;
interface IAAFBWFImportDescriptor;
interface IAAFCDCIDescriptor;
interface IAAFCachePageAllocator;
interface IAAFClassDef;
interface IAAFCodecDef;
interface IAAFCommentMarker;
interface IAAFComponent;
interface IAAFCompositionMob;
interface IAAFConstantValue;
interface IAAFContainerDef;
interface IAAFContentStorage;
interface IAAFControlPoint;
interface IAAFDataDef;
interface IAAFDataEssenceDescriptor;
interface IAAFDefObject;
interface IAAFDescriptiveClip;
interface IAAFDescriptiveFramework;
interface IAAFDescriptiveMarker;
interface IAAFDescriptiveObject;
interface IAAFDictionary;
interface IAAFDigitalImageDescriptor;
interface IAAFEdgecode;
interface IAAFEssenceAccess;
interface IAAFEssenceData;
interface IAAFEssenceDescriptor;
interface IAAFEssenceFormat;
interface IAAFEssenceGroup;
interface IAAFEvent;
interface IAAFEventMobSlot;
interface IAAFFile;
interface IAAFFileDescriptor;
interface IAAFFileEncoding;
interface IAAFFiller;
interface IAAFFilmDescriptor;
interface IAAFFindSourceInfo;
interface IAAFGPITrigger;
interface IAAFGetFileBits;
interface IAAFHeader;
interface IAAFIdentification;
interface IAAFImportDescriptor;
interface IAAFInterpolationDef;
interface IAAFKLVData;
interface IAAFKLVDataDefinition;
interface IAAFLocator;
interface IAAFMasterMob;
interface IAAFMetaDefinition;
interface IAAFMob;
interface IAAFMobSlot;
interface IAAFMPEGVideoDescriptor;
interface IAAFMultipleDescriptor;
interface IAAFNestedScope;
interface IAAFNetworkLocator;
interface IAAFObject;
interface IAAFOperationDef;
interface IAAFOperationGroup;
interface IAAFPCMDescriptor;
interface IAAFParameter;
interface IAAFParameterDef;
interface IAAFPhysicalDescriptor;
interface IAAFPlainEssenceData;
interface IAAFPlainStreamData;
interface IAAFPluginDef;
interface IAAFPluginManager;
interface IAAFProperty;
interface IAAFPropertyDef;
interface IAAFPropertyValue;
interface IAAFPulldown;
interface IAAFRGBADescriptor;
interface IAAFRandomFile;
interface IAAFRandomRawStorage;
interface IAAFRawStorage;
interface IAAFRIFFChunk;
interface IAAFRecordingDescriptor;
interface IAAFScopeReference;
interface IAAFSegment;
interface IAAFSelector;
interface IAAFSequence;
interface IAAFSetFileBits;
interface IAAFSoundDescriptor;
interface IAAFSourceClip;
interface IAAFSourceMob;
interface IAAFSourceReference;
interface IAAFStaticMobSlot;
interface IAAFTIFFDescriptor;
interface IAAFTaggedValue;
interface IAAFTaggedValueDefinition;
interface IAAFTapeDescriptor;
interface IAAFTextLocator;
interface IAAFTimecode;
interface IAAFTimecodeStream;
interface IAAFTimecodeStream12M;
interface IAAFTimelineMobSlot;
interface IAAFTransition;
interface IAAFTypeDef;
interface IAAFTypeDefCharacter;
interface IAAFTypeDefEnum;
interface IAAFTypeDefExtEnum;
interface IAAFTypeDefFixedArray;
interface IAAFTypeDefIndirect;
interface IAAFTypeDefInt;
interface IAAFTypeDefObjectRef;
interface IAAFTypeDefOpaque;
interface IAAFTypeDefRecord;
interface IAAFTypeDefRename;
interface IAAFTypeDefSet;
interface IAAFTypeDefStream;
interface IAAFTypeDefString;
interface IAAFTypeDefStrongObjRef;
interface IAAFTypeDefVariableArray;
interface IAAFTypeDefWeakObjRef;
interface IAAFVaryingValue;
interface IAAFWAVEDescriptor;
interface IEnumAAFClassDefs;
interface IEnumAAFCodecDefs;
interface IEnumAAFCodecFlavours;
interface IEnumAAFComponents;
interface IEnumAAFContainerDefs;
interface IEnumAAFControlPoints;
interface IEnumAAFDataDefs;
interface IEnumAAFEssenceData;
interface IEnumAAFFileDescriptors;
interface IEnumAAFFileEncodings;
interface IEnumAAFIdentifications;
interface IEnumAAFInterpolationDefs;
interface IEnumAAFKLVData;
interface IEnumAAFKLVDataDefs;
interface IEnumAAFLoadedPlugins;
interface IEnumAAFLocators;
interface IEnumAAFMobSlots;
interface IEnumAAFMobs;
interface IEnumAAFOperationDefs;
interface IEnumAAFParameterDefs;
interface IEnumAAFParameters;
interface IEnumAAFPluginDefs;
interface IEnumAAFPluginLocators;
interface IEnumAAFProperties;
interface IEnumAAFPropertyDefs;
interface IEnumAAFPropertyValues;
interface IEnumAAFRIFFChunks;
interface IEnumAAFSegments;
interface IEnumAAFTaggedValueDefs;
interface IEnumAAFTaggedValues;
interface IEnumAAFTypeDefs;
interface IAAFAES3PCMDescriptor2;
interface IAAFCDCIDescriptor2;
interface IAAFComponent2;
interface IAAFCompositionMob2;
interface IAAFDataDef2;
interface IAAFDataDef3;
interface IAAFDiagnosticOutput;
interface IAAFDictionary2;
interface IAAFDigitalImageDescriptor2;
interface IAAFEndian;
interface IAAFEssenceDataEx;
interface IAAFEssenceData2;
interface IAAFEssenceMultiAccess;
interface IAAFEventMobSlot2;
interface IAAFFileDescriptor2;
interface IAAFHeader2;
interface IAAFKLVEssenceDataParameters;
interface IAAFKLVStreamParameters;
interface IAAFMasterMob2;
interface IAAFMasterMob3;
interface IAAFMasterMobEx;
interface IAAFMob2;
interface IAAFProgress;
interface IAAFRGBADescriptor2;
interface IAAFSearchSource;
interface IAAFSourceReference2;
interface IAAFStreamAccess;
interface IAAFTimelineMobSlot2;
interface IAAFTypeDefStreamEx;
interface IAAFTypeDefStream3;
interface IAAFTypeDefVariableArrayEx;
#else
typedef interface IAAFAES3PCMDescriptor IAAFAES3PCMDescriptor;
typedef interface IAAFAIFCDescriptor IAAFAIFCDescriptor;
typedef interface IAAFAuxiliaryDescriptor IAAFAuxiliaryDescriptor;
typedef interface IAAFBWFImportDescriptor IAAFBWFImportDescriptor;
typedef interface IAAFCDCIDescriptor IAAFCDCIDescriptor;
typedef interface IAAFCachePageAllocator IAAFCachePageAllocator;
typedef interface IAAFClassDef IAAFClassDef;
typedef interface IAAFCodecDef IAAFCodecDef;
typedef interface IAAFCommentMarker IAAFCommentMarker;
typedef interface IAAFComponent IAAFComponent;
typedef interface IAAFCompositionMob IAAFCompositionMob;
typedef interface IAAFConstantValue IAAFConstantValue;
typedef interface IAAFContainerDef IAAFContainerDef;
typedef interface IAAFContentStorage IAAFContentStorage;
typedef interface IAAFControlPoint IAAFControlPoint;
typedef interface IAAFDataDef IAAFDataDef;
typedef interface IAAFDataEssenceDescriptor IAAFDataEssenceDescriptor;
typedef interface IAAFDefObject IAAFDefObject;
typedef interface IAAFDescriptiveClip IAAFDescriptiveClip;
typedef interface IAAFDescriptiveFramework IAAFDescriptiveFramework;
typedef interface IAAFDescriptiveMarker IAAFDescriptiveMarker;
typedef interface IAAFDescriptiveObject IAAFDescriptiveObject;
typedef interface IAAFDictionary IAAFDictionary;
typedef interface IAAFDigitalImageDescriptor IAAFDigitalImageDescriptor;
typedef interface IAAFEdgecode IAAFEdgecode;
typedef interface IAAFEssenceAccess IAAFEssenceAccess;
typedef interface IAAFEssenceData IAAFEssenceData;
typedef interface IAAFEssenceDescriptor IAAFEssenceDescriptor;
typedef interface IAAFEssenceFormat IAAFEssenceFormat;
typedef interface IAAFEssenceGroup IAAFEssenceGroup;
typedef interface IAAFEvent IAAFEvent;
typedef interface IAAFEventMobSlot IAAFEventMobSlot;
typedef interface IAAFFile IAAFFile;
typedef interface IAAFFileDescriptor IAAFFileDescriptor;
typedef interface IAAFFileEncoding IAAFFileEncoding;
typedef interface IAAFFiller IAAFFiller;
typedef interface IAAFFilmDescriptor IAAFFilmDescriptor;
typedef interface IAAFFindSourceInfo IAAFFindSourceInfo;
typedef interface IAAFGPITrigger IAAFGPITrigger;
typedef interface IAAFGetFileBits IAAFGetFileBits;
typedef interface IAAFHeader IAAFHeader;
typedef interface IAAFIdentification IAAFIdentification;
typedef interface IAAFImportDescriptor IAAFImportDescriptor;
typedef interface IAAFInterpolationDef IAAFInterpolationDef;
typedef interface IAAFKLVData IAAFKLVData;
typedef interface IAAFKLVDataDefinition IAAFKLVDataDefinition;
typedef interface IAAFLocator IAAFLocator;
typedef interface IAAFMasterMob IAAFMasterMob;
typedef interface IAAFMetaDefinition IAAFMetaDefinition;
typedef interface IAAFMob IAAFMob;
typedef interface IAAFMobSlot IAAFMobSlot;
typedef interface IAAFMPEGVideoDescriptor IAAFMPEGVideoDescriptor;
typedef interface IAAFMultipleDescriptor IAAFMultipleDescriptor;
typedef interface IAAFNestedScope IAAFNestedScope;
typedef interface IAAFNetworkLocator IAAFNetworkLocator;
typedef interface IAAFObject IAAFObject;
typedef interface IAAFOperationDef IAAFOperationDef;
typedef interface IAAFOperationGroup IAAFOperationGroup;
typedef interface IAAFPCMDescriptor IAAFPCMDescriptor;
typedef interface IAAFParameter IAAFParameter;
typedef interface IAAFParameterDef IAAFParameterDef;
typedef interface IAAFPhysicalDescriptor IAAFPhysicalDescriptor;
typedef interface IAAFPlainEssenceData IAAFPlainEssenceData;
typedef interface IAAFPlainStreamData IAAFPlainStreamData;
typedef interface IAAFPluginDef IAAFPluginDef;
typedef interface IAAFPluginManager IAAFPluginManager;
typedef interface IAAFProperty IAAFProperty;
typedef interface IAAFPropertyDef IAAFPropertyDef;
typedef interface IAAFPropertyValue IAAFPropertyValue;
typedef interface IAAFPulldown IAAFPulldown;
typedef interface IAAFRGBADescriptor IAAFRGBADescriptor;
typedef interface IAAFRandomFile IAAFRandomFile;
typedef interface IAAFRandomRawStorage IAAFRandomRawStorage;
typedef interface IAAFRawStorage IAAFRawStorage;
typedef interface IAAFRIFFChunk IAAFRIFFChunk;
typedef interface IAAFRecordingDescriptor IAAFRecordingDescriptor;
typedef interface IAAFScopeReference IAAFScopeReference;
typedef interface IAAFSegment IAAFSegment;
typedef interface IAAFSelector IAAFSelector;
typedef interface IAAFSequence IAAFSequence;
typedef interface IAAFSetFileBits IAAFSetFileBits;
typedef interface IAAFSoundDescriptor IAAFSoundDescriptor;
typedef interface IAAFSourceClip IAAFSourceClip;
typedef interface IAAFSourceMob IAAFSourceMob;
typedef interface IAAFSourceReference IAAFSourceReference;
typedef interface IAAFStaticMobSlot IAAFStaticMobSlot;
typedef interface IAAFTIFFDescriptor IAAFTIFFDescriptor;
typedef interface IAAFTaggedValue IAAFTaggedValue;
typedef interface IAAFTaggedValueDefinition IAAFTaggedValueDefinition;
typedef interface IAAFTapeDescriptor IAAFTapeDescriptor;
typedef interface IAAFTextLocator IAAFTextLocator;
typedef interface IAAFTimecode IAAFTimecode;
typedef interface IAAFTimecodeStream IAAFTimecodeStream;
typedef interface IAAFTimecodeStream12M IAAFTimecodeStream12M;
typedef interface IAAFTimelineMobSlot IAAFTimelineMobSlot;
typedef interface IAAFTransition IAAFTransition;
typedef interface IAAFTypeDef IAAFTypeDef;
typedef interface IAAFTypeDefCharacter IAAFTypeDefCharacter;
typedef interface IAAFTypeDefEnum IAAFTypeDefEnum;
typedef interface IAAFTypeDefExtEnum IAAFTypeDefExtEnum;
typedef interface IAAFTypeDefFixedArray IAAFTypeDefFixedArray;
typedef interface IAAFTypeDefIndirect IAAFTypeDefIndirect;
typedef interface IAAFTypeDefInt IAAFTypeDefInt;
typedef interface IAAFTypeDefObjectRef IAAFTypeDefObjectRef;
typedef interface IAAFTypeDefOpaque IAAFTypeDefOpaque;
typedef interface IAAFTypeDefRecord IAAFTypeDefRecord;
typedef interface IAAFTypeDefRename IAAFTypeDefRename;
typedef interface IAAFTypeDefSet IAAFTypeDefSet;
typedef interface IAAFTypeDefStream IAAFTypeDefStream;
typedef interface IAAFTypeDefString IAAFTypeDefString;
typedef interface IAAFTypeDefStrongObjRef IAAFTypeDefStrongObjRef;
typedef interface IAAFTypeDefVariableArray IAAFTypeDefVariableArray;
typedef interface IAAFTypeDefWeakObjRef IAAFTypeDefWeakObjRef;
typedef interface IAAFVaryingValue IAAFVaryingValue;
typedef interface IAAFWAVEDescriptor IAAFWAVEDescriptor;
typedef interface IEnumAAFClassDefs IEnumAAFClassDefs;
typedef interface IEnumAAFCodecDefs IEnumAAFCodecDefs;
typedef interface IEnumAAFCodecFlavours IEnumAAFCodecFlavours;
typedef interface IEnumAAFComponents IEnumAAFComponents;
typedef interface IEnumAAFContainerDefs IEnumAAFContainerDefs;
typedef interface IEnumAAFControlPoints IEnumAAFControlPoints;
typedef interface IEnumAAFDataDefs IEnumAAFDataDefs;
typedef interface IEnumAAFEssenceData IEnumAAFEssenceData;
typedef interface IEnumAAFFileDescriptors IEnumAAFFileDescriptors;
typedef interface IEnumAAFFileEncodings IEnumAAFFileEncodings;
typedef interface IEnumAAFIdentifications IEnumAAFIdentifications;
typedef interface IEnumAAFInterpolationDefs IEnumAAFInterpolationDefs;
typedef interface IEnumAAFKLVData IEnumAAFKLVData;
typedef interface IEnumAAFKLVDataDefs IEnumAAFKLVDataDefs;
typedef interface IEnumAAFLoadedPlugins IEnumAAFLoadedPlugins;
typedef interface IEnumAAFLocators IEnumAAFLocators;
typedef interface IEnumAAFMobSlots IEnumAAFMobSlots;
typedef interface IEnumAAFMobs IEnumAAFMobs;
typedef interface IEnumAAFOperationDefs IEnumAAFOperationDefs;
typedef interface IEnumAAFParameterDefs IEnumAAFParameterDefs;
typedef interface IEnumAAFParameters IEnumAAFParameters;
typedef interface IEnumAAFPluginDefs IEnumAAFPluginDefs;
typedef interface IEnumAAFPluginLocators IEnumAAFPluginLocators;
typedef interface IEnumAAFProperties IEnumAAFProperties;
typedef interface IEnumAAFPropertyDefs IEnumAAFPropertyDefs;
typedef interface IEnumAAFPropertyValues IEnumAAFPropertyValues;
typedef interface IEnumAAFRIFFChunks IEnumAAFRIFFChunks;
typedef interface IEnumAAFSegments IEnumAAFSegments;
typedef interface IEnumAAFTaggedValueDefs IEnumAAFTaggedValueDefs;
typedef interface IEnumAAFTaggedValues IEnumAAFTaggedValues;
typedef interface IEnumAAFTypeDefs IEnumAAFTypeDefs;
typedef interface IAAFAES3PCMDescriptor2 IAAFAES3PCMDescriptor2;
typedef interface IAAFCDCIDescriptor2 IAAFCDCIDescriptor2;
typedef interface IAAFComponent2 IAAFComponent2;
typedef interface IAAFCompositionMob2 IAAFCompositionMob2;
typedef interface IAAFDataDef2 IAAFDataDef2;
typedef interface IAAFDataDef3 IAAFDataDef3;
typedef interface IAAFDiagnosticOutput IAAFDiagnosticOutput;
typedef interface IAAFDictionary2 IAAFDictionary2;
typedef interface IAAFDigitalImageDescriptor2 IAAFDigitalImageDescriptor2;
typedef interface IAAFEndian IAAFEndian;
typedef interface IAAFEssenceDataEx IAAFEssenceDataEx;
typedef interface IAAFEssenceData2 IAAFEssenceData2;
typedef interface IAAFEssenceMultiAccess IAAFEssenceMultiAccess;
typedef interface IAAFEventMobSlot2 IAAFEventMobSlot2;
typedef interface IAAFFileDescriptor2 IAAFFileDescriptor2;
typedef interface IAAFHeader2 IAAFHeader2;
typedef interface IAAFKLVEssenceDataParameters IAAFKLVEssenceDataParameters;
typedef interface IAAFKLVStreamParameters IAAFKLVStreamParameters;
typedef interface IAAFMasterMob2 IAAFMasterMob2;
typedef interface IAAFMasterMob3 IAAFMasterMob3;
typedef interface IAAFMasterMobEx IAAFMasterMobEx;
typedef interface IAAFMob2 IAAFMob2;
typedef interface IAAFProgress IAAFProgress;
typedef interface IAAFRGBADescriptor2 IAAFRGBADescriptor2;
typedef interface IAAFSearchSource IAAFSearchSource;
typedef interface IAAFSourceReference2 IAAFSourceReference2;
typedef interface IAAFStreamAccess IAAFStreamAccess;
typedef interface IAAFTimelineMobSlot2 IAAFTimelineMobSlot2;
typedef interface IAAFTypeDefStreamEx IAAFTypeDefStreamEx;
typedef interface IAAFTypeDefStream3 IAAFTypeDefStream3;
typedef interface IAAFTypeDefVariableArrayEx IAAFTypeDefVariableArrayEx;
#endif

// IAAFAES3PCMDescriptor

// ************************
//
// Interface IAAFAES3PCMDescriptor
//
// ************************



#ifndef __IAAFAES3PCMDescriptor_INTERFACE_DEFINED__
#define __IAAFAES3PCMDescriptor_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFAES3PCMDescriptor;

#undef  INTERFACE
#define INTERFACE   IAAFAES3PCMDescriptor

DECLARE_INTERFACE_(IAAFAES3PCMDescriptor, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFAES3PCMDescriptor methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, IAAFAES3PCMDescriptor-supporting
  /// object. This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  STDMETHOD(Initialize) (THIS) PURE;


















  END_INTERFACE
};
#endif // __IAAFAES3PCMDescriptor_INTERFACE_DEFINED__


// IAAFAIFCDescriptor

// ************************
//
// Interface IAAFAIFCDescriptor
//
// ************************





#ifndef __IAAFAIFCDescriptor_INTERFACE_DEFINED__
#define __IAAFAIFCDescriptor_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFAIFCDescriptor;

#undef  INTERFACE
#define INTERFACE   IAAFAIFCDescriptor

DECLARE_INTERFACE_(IAAFAIFCDescriptor, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFAIFCDescriptor methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty
  /// IAAFAIFCDescriptor-supporting object.  This method must be
  /// called after allocation, and before any other method can be
  /// called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  STDMETHOD(Initialize) (THIS) PURE;


  //***********************************************************
  //
  // GetSummary()
  //
  /// Gets a copy of the AIFC file information without the media.
  /// 
  /// Succeeds if all of the following are true:
  /// - pSummary is a valid pointer.
  /// - The size of the buffer is large enough to hold the AIFC file information.
  /// 
  /// If this method fails pSummary will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSummary arg is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - The buffer is too small to hold the AIFC file information.
  ///
  ///
  /// @param size [in] Size of preallocated buffer
  /// @param pSummary [out, size_is(size)] Preallocated buffer to hold the AIFC file information
  ///
  STDMETHOD(GetSummary) (THIS_
    aafUInt32  size,
    aafDataValue_t  pSummary) PURE;

  //***********************************************************
  //
  // GetSummaryBufferSize()
  //
  /// Returns the size of the buffer required for the GetSummary()
  /// method.  The value is placed into the location specified by pSize.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSize pointer is valid.
  ///
  /// If this method fails nothing will be written to *pSize.
  ///
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSize arg is NULL.
  ///
  ///
  /// @param pSize [out] required buffer size
  ///
  STDMETHOD(GetSummaryBufferSize) (THIS_
    aafUInt32 *  pSize) PURE;

  //***********************************************************
  //
  // SetSummary()
  //
  /// Sets the AIFC file information.
  /// 
  /// Succeeds if all of the following are true:
  /// - pSummary is a valid pointer
  /// 
  /// If this method fails the summary property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSummary arg is NULL.
  ///
  ///
  /// @param size [in] Size of preallocated buffer
  /// @param pSummary [in, size_is(size)] buffer containing value
  ///
  STDMETHOD(SetSummary) (THIS_
    aafUInt32  size,
    aafDataValue_t  pSummary) PURE;



  END_INTERFACE
};
#endif // __IAAFAIFCDescriptor_INTERFACE_DEFINED__



// IAAFAuxiliaryDescriptor

// ************************
//
// Interface IAAFAuxiliaryDescriptor
//
// ************************






#ifndef __IAAFAuxiliaryDescriptor_INTERFACE_DEFINED__
#define __IAAFAuxiliaryDescriptor_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFAuxiliaryDescriptor;


#undef  INTERFACE
#define INTERFACE   IAAFAuxiliaryDescriptor

DECLARE_INTERFACE_(IAAFAuxiliaryDescriptor, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFAuxiliaryDescriptor methods *** */


  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated,
  /// IAAFAuxiliaryDescriptor object.  This method must be called
  /// after allocation, and before any other method can be called.
  ///
  /// Return codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  STDMETHOD(Initialize) (THIS) PURE;

  //***********************************************************
  //
  // SetMimeType()
  //
  /// Sets The registered mime type of the data per RFC 2046 and RFC 2048.
  ///
  /// Set the MimeType property to the value specified in
  /// pMimeType.  A copy is made of the data so the caller
  /// retains ownership of the *pMimeType buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pMimeType pointer is valid.
  /// 
  /// If this method fails the MimeType property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMimeType arg is NULL.
  ///
  /// @param pMimeType [in, string] buffer from which MimeType is to be read
  ///
  STDMETHOD(SetMimeType) (THIS_
    aafCharacter_constptr  pMimeType) PURE;


  //***********************************************************
  //
  // GetMimeType()
  //
  /// Gets The registered mime type of the data per RFC 2046 and RFC 2048.
  /// 
  /// Writes the MimeType property, with a trailing null
  /// character, into the pMimeType buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the MimeType property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetMimeTypeBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pMimeType.
  /// 
  /// Succeeds if:
  /// - The pMimeType pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   MimeType.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMimeType arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold MimeType.
  ///
  /// @param pMimeType [out, string, size_is(bufSize)] buffer into which MimeType is to be written
  /// @param bufSize [in] size of *pMimeType buffer in bytes
  ///
  STDMETHOD(GetMimeType) (THIS_
    aafCharacter *  pMimeType,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetMimeTypeBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetMimeType().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetMimeTypeBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;

  //***********************************************************
  //
  // SetCharSet()
  //
  /// Sets The registered character set per RFC 2048.
  ///
  /// Set the CharSet property to the value specified in
  /// pCharSet.  A copy is made of the data so the caller
  /// retains ownership of the *pCharSet buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pCharSet pointer is valid.
  /// 
  /// If this method fails the CharSet property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCharSet arg is NULL.
  ///
  /// @param pCharSet [in, string] buffer from which CharSet is to be read
  ///
  STDMETHOD(SetCharSet) (THIS_
    aafCharacter_constptr  pCharSet) PURE;


  //***********************************************************
  //
  // GetCharSet()
  //
  /// Gets The registered character set per RFC 2048.
  /// 
  /// Writes the CharSet property, with a trailing null
  /// character, into the pCharSet buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the CharSet property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetCharSetBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pCharSet.
  /// 
  /// Succeeds if:
  /// - The pCharSet pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   CharSet.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCharSet arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold CharSet.
  ///
  /// @param pCharSet [out, string, size_is(bufSize)] buffer into which CharSet is to be written
  /// @param bufSize [in] size of *pCharSet buffer in bytes
  ///
  STDMETHOD(GetCharSet) (THIS_
    aafCharacter *  pCharSet,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetCharSetBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetCharSet().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetCharSetBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;


  END_INTERFACE
};
#endif // __IAAFAuxiliaryDescriptor_INTERFACE_DEFINED__



// IAAFBWFImportDescriptor

// ************************
//
// Interface IAAFBWFImportDescriptor
//
// ************************




#ifndef __IAAFBWFImportDescriptor_INTERFACE_DEFINED__
#define __IAAFBWFImportDescriptor_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFBWFImportDescriptor;


#undef  INTERFACE
#define INTERFACE   IAAFBWFImportDescriptor

DECLARE_INTERFACE_(IAAFBWFImportDescriptor, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFBWFImportDescriptor methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty
  /// IAAFBWFImportDescriptor-supporting object.  This method must be
  /// called after allocation, and before any other method can be
  /// called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  STDMETHOD(Initialize) (THIS) PURE;


  //***********************************************************
  //
  // SetFileSecurityReport()
  //
  /// Sets the fileSecurityReport property. This is an optional property.
  /// 
  /// If this method fails, the FileSecurityReport property will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  ///
  /// @param fileSecurityReport [in] value to assign to the FileSecurityReport property
  ///
  STDMETHOD(SetFileSecurityReport) (THIS_
    aafUInt32  fileSecurityReport) PURE;


  //***********************************************************
  //
  // GetFileSecurityReport()
  //
  /// Gets the FileSecurityReport property.
  ///
  /// Succeeds if all of the following are true:
  /// - pFileSecurityReport is a valid pointer
  /// - the property is present.
  ///
  /// If this method fails, pFileSecurityReport will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFileSecurityReport is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pFileSecurityReport [out] value of the FileSecurityReport property
  ///
  STDMETHOD(GetFileSecurityReport) (THIS_
    aafUInt32 *  pFileSecurityReport) PURE;


  //***********************************************************
  //
  // SetFileSecurityWave()
  //
  /// Sets the FileSecurityWave property. This is an optional property.
  /// 
  /// If this method fails, the FileSecurityWave property will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  ///
  /// @param fileSecurityWave [in] value to assign to the FileSecurityWave property
  ///
  STDMETHOD(SetFileSecurityWave) (THIS_
    aafUInt32  fileSecurityWave) PURE;


  //***********************************************************
  //
  // GetFileSecurityWave()
  //
  /// Gets the FileSecurityWave property.
  ///
  /// Succeeds if all of the following are true:
  /// - pFileSecurityWave is a valid pointer
  /// - the property is present.
  ///
  /// If this method fails, pFileSecurityWave will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFileSecurityWave is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pFileSecurityWave [out] value of the FileSecurityWave property
  ///
  STDMETHOD(GetFileSecurityWave) (THIS_
    aafUInt32 *  pFileSecurityWave) PURE;


  //***********************************************************
  //
  // CountUnknownBWFChunks()
  //
  /// Return total number of RIFFChunk objects attached to this component.
  ///
  /// Succeeds if all of the following are true:
  /// - the pNumData pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pNumComments.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumData arg is NULL.
  ///
  /// @param pNumData [out] Number  of RIFFChunk objects
  ///
  STDMETHOD(CountUnknownBWFChunks) (THIS_
    aafUInt32 *  pNumData) PURE;

  //***********************************************************
  //
  // AppendUnknownBWFChunk()
  //
  /// Appends a pre-existing RIFFChunk object to end of this
  /// BWFImportDescriptor's list of UnknownBWFChunks.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pData pointer is valid.
  /// - the pData pointer indicates an object which is not already
  ///   owned by any object
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - the pData arg is NULL.
  ///
  /// AAFRESULT_OBJECT_ALREADY_ATTACHED
  ///   - the object pointed to by pData is already owned by this
  ///      or another object.
  ///
  /// @param pData [in] RIFFChunk object to append
  ///
  STDMETHOD(AppendUnknownBWFChunk) (THIS_
    IAAFRIFFChunk * pData) PURE;
  

  //***********************************************************
  //
  // PrependUnknownBWFChunk()
  //
  /// Prepends a pre-existing RIFFChunk object to the
  /// beginning of this BWFImportDescriptor's list of UnknownBWFChunks.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pData pointer is valid.
  /// - the pData pointer indicates an object which is not already
  ///   owned by any object
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pData is null.
  ///
  /// AAFRESULT_OBJECT_ALREADY_ATTACHED
  ///   - the object pointed to by pData is already owned by this
  ///      or another object.
  ///
  /// @param pData [in] RIFFChunk object to prepend
  ///
  STDMETHOD(PrependUnknownBWFChunk) (THIS_
    IAAFRIFFChunk * pData) PURE;



  //***********************************************************
  //
  // InsertUnknownBWFChunkAt()
  //
  /// Inserts the given RIFFChunk at the given index in this 
  /// BWFImportDescriptor's list of UnknownBWFChunks.  Chunks already
  /// existing at the given and higher indices will be moved to the
  /// next higher index to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pData pointer is valid.
  /// - the pData pointer indicates an object which is not already
  ///   owned by any object
  /// - index is less than or equal to the value returned by
  ///   CountUnknownBWFChunks().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pData is null.
  ///
  /// AAFRESULT_OBJECT_ALREADY_ATTACHED
  ///   - the object pointed to by pData is already owned by this
  ///      or another object.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than the value returned by
  ///     CountUnknownBWFChunks().
  ///
  /// @param index [in] index at which chunk is to be inserted
  /// @param pData [in] RIFFChunk to append
  ///
  STDMETHOD(InsertUnknownBWFChunkAt) (THIS_
    aafUInt32  index,
    IAAFRIFFChunk * pData) PURE;


  //***********************************************************
  //
  // GetUnknownBWFChunkAt()
  //
  /// Retrieves the RIFFChunk at the given index in this BWFImportDescriptor's
  /// list of UnknownBWFChunks.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pData pointer is valid.
  /// - index is less than the value returned by CountUnknownBWFChunks().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppData is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than or equal to the value returned by
  ///     CountUnknownBWFChunks().
  ///
  /// @param index [in] index of chunk to retrieve
  /// @param ppData [out, retval] returned RIFFChunk
  ///
  STDMETHOD(GetUnknownBWFChunkAt) (THIS_
    aafUInt32  index,
    IAAFRIFFChunk ** ppData) PURE;


  //***********************************************************
  //
  // RemoveUnknownBWFChunkAt()
  //
  /// Removes the RIFFChunk at the given index in this BWFImportDescriptor's
  /// list of UnknownBWFChunks.  Chunks already
  /// existing at indices higher than the given index will be moved to
  /// the next lower index to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - index is less than the value returned by CountUnknownBWFChunks().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than or equal to the value returned by
  ///     CountUnknownBWFChunks().
  ///
  /// @param index [in] index of chunk to remove
  ///
  STDMETHOD(RemoveUnknownBWFChunkAt) (THIS_
    aafUInt32  index) PURE;


  //***********************************************************
  //
  // GetUnknownBWFChunks()
  //
  /// Return the enumeration for all RIFFChunk objects on this component.  The returned
  /// enumerator is AddRef()ed before it is returned.  The enumerator
  /// is implemented as an EnumAAFRIFFChunks.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// @param ppEnum [out] RIFFChunk objects
  ///
  STDMETHOD(GetUnknownBWFChunks) (THIS_
    IEnumAAFRIFFChunks ** ppEnum) PURE;


  //***********************************************************
  //
  // SetCodingHistory()
  //
  /// Sets the CodingHistory string property.
  ///
  /// Set the CodingHistory property to the value specified in
  /// pCodingHistory.  A copy is made of the data so the caller
  /// retains ownership of the *pCodingHistory buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pCodingHistory pointer is valid.
  /// 
  /// If this method fails the CodingHistory property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCodingHistory arg is NULL.
  ///
  /// @param pCodingHistory [in, string] buffer from which CodingHistory is to be read
  ///
  STDMETHOD(SetCodingHistory) (THIS_
    aafCharacter_constptr  pCodingHistory) PURE;


  //***********************************************************
  //
  // GetCodingHistory()
  //
  /// Gets the CodingHistory string property.
  /// 
  /// Writes the CodingHistory property, with a trailing null
  /// character, into the pCodingHistory buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the CodingHistory property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetCodingHistoryBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pCodingHistory.
  /// 
  /// Succeeds if:
  /// - The pCodingHistory pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   CodingHistory.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCodingHistory arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold CodingHistory.
  ///
  /// @param pCodingHistory [out, string, size_is(bufSize)] buffer into which CodingHistory is to be written
  /// @param bufSize [in] size of *pCodingHistory buffer in bytes
  ///
  STDMETHOD(GetCodingHistory) (THIS_
    aafCharacter *  pCodingHistory,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetCodingHistoryBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetCodingHistory().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetCodingHistoryBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;
     
  //***********************************************************
  //
  // SetBasicData()
  //
  /// Sets the BasicData string property.
  ///
  /// Set the BasicData property to the value specified in
  /// pBasicData.  A copy is made of the data so the caller
  /// retains ownership of the *pBasicData buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pBasicData pointer is valid.
  /// 
  /// If this method fails the BasicData property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBasicData arg is NULL.
  ///
  /// @param pBasicData [in, string] buffer from which BasicData is to be read
  ///
  STDMETHOD(SetBasicData) (THIS_
    aafCharacter_constptr  pBasicData) PURE;


  //***********************************************************
  //
  // GetBasicData()
  //
  /// Gets the BasicData string property.
  /// 
  /// Writes the BasicData property, with a trailing null
  /// character, into the pBasicData buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the BasicData property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetBasicDataBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pBasicData.
  /// 
  /// Succeeds if:
  /// - The pBasicData pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   BasicData.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBasicData arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold BasicData.
  ///
  /// @param pBasicData [out, string, size_is(bufSize)] buffer into which BasicData is to be written
  /// @param bufSize [in] size of *pBasicData buffer in bytes
  ///
  STDMETHOD(GetBasicData) (THIS_
    aafCharacter *  pBasicData,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetBasicDataBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetBasicData().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetBasicDataBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;

  //***********************************************************
  //
  // SetStartOfModulation()
  //
  /// Sets the StartOfModulation string property.
  ///
  /// Set the StartOfModulation property to the value specified in
  /// pStartOfModulation.  A copy is made of the data so the caller
  /// retains ownership of the *pStartOfModulation buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pStartOfModulation pointer is valid.
  /// 
  /// If this method fails the StartOfModulation property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pStartOfModulation arg is NULL.
  ///
  /// @param pStartOfModulation [in, string] buffer from which StartOfModulation is to be read
  ///
  STDMETHOD(SetStartOfModulation) (THIS_
    aafCharacter_constptr  pStartOfModulation) PURE;


  //***********************************************************
  //
  // GetStartOfModulation()
  //
  /// Gets the StartOfModulation string property.
  /// 
  /// Writes the StartOfModulation property, with a trailing null
  /// character, into the pStartOfModulation buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the StartOfModulation property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetStartOfModulationBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pStartOfModulation.
  /// 
  /// Succeeds if:
  /// - The pStartOfModulation pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   StartOfModulation.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pStartOfModulation arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold StartOfModulation.
  ///
  /// @param pStartOfModulation [out, string, size_is(bufSize)] buffer into which StartOfModulation is to be written
  /// @param bufSize [in] size of *pStartOfModulation buffer in bytes
  ///
  STDMETHOD(GetStartOfModulation) (THIS_
    aafCharacter *  pStartOfModulation,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetStartOfModulationBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetStartOfModulation().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetStartOfModulationBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;
     
  //***********************************************************
  //
  // SetQualityEvent()
  //
  /// Sets the QualityEvent string property.
  ///
  /// Set the QualityEvent property to the value specified in
  /// pQualityEvent.  A copy is made of the data so the caller
  /// retains ownership of the *pQualityEvent buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pQualityEvent pointer is valid.
  /// 
  /// If this method fails the QualityEvent property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pQualityEvent arg is NULL.
  ///
  /// @param pQualityEvent [in, string] buffer from which QualityEvent is to be read
  ///
  STDMETHOD(SetQualityEvent) (THIS_
    aafCharacter_constptr  pQualityEvent) PURE;


  //***********************************************************
  //
  // GetQualityEvent()
  //
  /// Gets the QualityEvent string property.
  /// 
  /// Writes the QualityEvent property, with a trailing null
  /// character, into the pQualityEvent buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the QualityEvent property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetQualityEventBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pQualityEvent.
  /// 
  /// Succeeds if:
  /// - The pQualityEvent pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   QualityEvent.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pQualityEvent arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold QualityEvent.
  ///
  /// @param pQualityEvent [out, string, size_is(bufSize)] buffer into which QualityEvent is to be written
  /// @param bufSize [in] size of *pQualityEvent buffer in bytes
  ///
  STDMETHOD(GetQualityEvent) (THIS_
    aafCharacter *  pQualityEvent,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetQualityEventBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetQualityEvent().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetQualityEventBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;

  //***********************************************************
  //
  // SetEndOfModulation()
  //
  /// Sets the EndOfModulation string property.
  ///
  /// Set the EndOfModulation property to the value specified in
  /// pEndOfModulation.  A copy is made of the data so the caller
  /// retains ownership of the *pEndOfModulation buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pEndOfModulation pointer is valid.
  /// 
  /// If this method fails the EndOfModulation property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEndOfModulation arg is NULL.
  ///
  /// @param pEndOfModulation [in, string] buffer from which EndOfModulation is to be read
  ///
  STDMETHOD(SetEndOfModulation) (THIS_
    aafCharacter_constptr  pEndOfModulation) PURE;


  //***********************************************************
  //
  // GetEndOfModulation()
  //
  /// Gets the EndOfModulation string property.
  /// 
  /// Writes the EndOfModulation property, with a trailing null
  /// character, into the pEndOfModulation buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the EndOfModulation property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetEndOfModulationBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pEndOfModulation.
  /// 
  /// Succeeds if:
  /// - The pEndOfModulation pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   EndOfModulation.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEndOfModulation arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold EndOfModulation.
  ///
  /// @param pEndOfModulation [out, string, size_is(bufSize)] buffer into which EndOfModulation is to be written
  /// @param bufSize [in] size of *pEndOfModulation buffer in bytes
  ///
  STDMETHOD(GetEndOfModulation) (THIS_
    aafCharacter *  pEndOfModulation,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetEndOfModulationBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetEndOfModulation().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetEndOfModulationBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;
     
  //***********************************************************
  //
  // SetQualityParameter()
  //
  /// Sets the QualityParameter string property.
  ///
  /// Set the QualityParameter property to the value specified in
  /// pQualityParameter.  A copy is made of the data so the caller
  /// retains ownership of the *pQualityParameter buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pQualityParameter pointer is valid.
  /// 
  /// If this method fails the QualityParameter property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pQualityParameter arg is NULL.
  ///
  /// @param pQualityParameter [in, string] buffer from which QualityParameter is to be read
  ///
  STDMETHOD(SetQualityParameter) (THIS_
    aafCharacter_constptr  pQualityParameter) PURE;


  //***********************************************************
  //
  // GetQualityParameter()
  //
  /// Gets the QualityParameter string property.
  /// 
  /// Writes the QualityParameter property, with a trailing null
  /// character, into the pQualityParameter buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the QualityParameter property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetQualityParameterBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pQualityParameter.
  /// 
  /// Succeeds if:
  /// - The pQualityParameter pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   QualityParameter.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pQualityParameter arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold QualityParameter.
  ///
  /// @param pQualityParameter [out, string, size_is(bufSize)] buffer into which QualityParameter is to be written
  /// @param bufSize [in] size of *pQualityParameter buffer in bytes
  ///
  STDMETHOD(GetQualityParameter) (THIS_
    aafCharacter *  pQualityParameter,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetQualityParameterBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetQualityParameter().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetQualityParameterBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;
     
  //***********************************************************
  //
  // SetOperatorComment()
  //
  /// Sets the OperatorComment string property.
  ///
  /// Set the OperatorComment property to the value specified in
  /// pOperatorComment.  A copy is made of the data so the caller
  /// retains ownership of the *pOperatorComment buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pOperatorComment pointer is valid.
  /// 
  /// If this method fails the OperatorComment property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pOperatorComment arg is NULL.
  ///
  /// @param pOperatorComment [in, string] buffer from which OperatorComment is to be read
  ///
  STDMETHOD(SetOperatorComment) (THIS_
    aafCharacter_constptr  pOperatorComment) PURE;


  //***********************************************************
  //
  // GetOperatorComment()
  //
  /// Gets the OperatorComment string property.
  /// 
  /// Writes the OperatorComment property, with a trailing null
  /// character, into the pOperatorComment buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the OperatorComment property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetOperatorCommentBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pOperatorComment.
  /// 
  /// Succeeds if:
  /// - The pOperatorComment pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   OperatorComment.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pOperatorComment arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold OperatorComment.
  ///
  /// @param pOperatorComment [out, string, size_is(bufSize)] buffer into which OperatorComment is to be written
  /// @param bufSize [in] size of *pOperatorComment buffer in bytes
  ///
  STDMETHOD(GetOperatorComment) (THIS_
    aafCharacter *  pOperatorComment,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetOperatorCommentBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetOperatorComment().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetOperatorCommentBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;
     
  //***********************************************************
  //
  // SetCueSheet()
  //
  /// Sets the CueSheet string property.
  ///
  /// Set the CueSheet property to the value specified in
  /// pCueSheet.  A copy is made of the data so the caller
  /// retains ownership of the *pCueSheet buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pCueSheet pointer is valid.
  /// 
  /// If this method fails the CueSheet property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCueSheet arg is NULL.
  ///
  /// @param pCueSheet [in, string] buffer from which CueSheet is to be read
  ///
  STDMETHOD(SetCueSheet) (THIS_
    aafCharacter_constptr  pCueSheet) PURE;


  //***********************************************************
  //
  // GetCueSheet()
  //
  /// Gets the CueSheet string property.
  /// 
  /// Writes the CueSheet property, with a trailing null
  /// character, into the pCueSheet buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the CueSheet property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetCueSheetBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pCueSheet.
  /// 
  /// Succeeds if:
  /// - The pCueSheet pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   CueSheet.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCueSheet arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold CueSheet.
  ///
  /// @param pCueSheet [out, string, size_is(bufSize)] buffer into which CueSheet is to be written
  /// @param bufSize [in] size of *pCueSheet buffer in bytes
  ///
  STDMETHOD(GetCueSheet) (THIS_
    aafCharacter *  pCueSheet,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetCueSheetBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetCueSheet().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetCueSheetBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;


  END_INTERFACE
};
#endif // __IAAFBWFImportDescriptor_INTERFACE_DEFINED__



// IAAFCDCIDescriptor

// ************************
//
// Interface IAAFCDCIDescriptor
//
// ************************



#ifndef __IAAFCDCIDescriptor_INTERFACE_DEFINED__
#define __IAAFCDCIDescriptor_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFCDCIDescriptor;


#undef  INTERFACE
#define INTERFACE   IAAFCDCIDescriptor

DECLARE_INTERFACE_(IAAFCDCIDescriptor, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFCDCIDescriptor methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty
  /// IAAFCDCIDescriptor-supporting object.  This method must be called
  /// after allocation, and before any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  STDMETHOD(Initialize) (THIS) PURE;


  //***********************************************************
  //
  // SetComponentWidth()
  //
  /// Sets the ComponentWidth property.  Specifies the number of bits
  /// used to store each component.  Typical values can be 8, 10,
  /// 12, 14, or 16, but others are permitted by the reference
  /// implementation.  Each component in a sample is packed
  /// contiguously; the sample is filled with the number of bits
  /// specified by the optional PaddingBits property.  If  the
  /// PaddingBits property is omitted, samples are packed
  /// contiguously.
  ///
  /// If this method fails, the ComponentWidth property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param ComponentWidth [in] Number of bits.
  ///
  STDMETHOD(SetComponentWidth) (THIS_
    aafInt32  ComponentWidth) PURE;


  //***********************************************************
  //
  // GetComponentWidth()
  //
  /// Gets the ComponentWidth property.  Specifies the number of bits
  /// used to store each component.  Typical values can be 8, 10,
  /// 12, 14, or 16, but others are permitted by the reference
  /// implementation.  Each component in a sample is packed
  /// contiguously; the sample is filled with the number of bits
  /// specified by the optional PaddingBits property.  If the
  /// PaddingBits property is omitted, samples are packed
  /// contiguously.
  ///
  /// Succeeds if all of the following are true:
  /// - pComponentWidth is a valid pointer.
  /// 
  /// If this method fails, *pComponentWidth will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pComponentWidth arg is NULL.
  ///
  /// @param pComponentWidth [out] Address to store the number of bits.
  ///
  STDMETHOD(GetComponentWidth) (THIS_
    aafInt32 *  pComponentWidth) PURE;


  //***********************************************************
  //
  // SetHorizontalSubsampling()
  //
  /// Sets the HorizontalSubsampling property.  Specifies the ratio of
  /// luminance sampling to chrominance sampling in the horizontal direction.
  /// For 4:2:2 video, the value is 2, which means that there are twice as
  /// many luminance values as there are color-difference values.
  /// Another typical value is 1; however other values are permitted by
  /// the reference implementation.
  ///
  /// If this method fails, the HorizontalSubsampling property will
  /// not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param HorizontalSubsampling [in] Integer value.
  ///
  STDMETHOD(SetHorizontalSubsampling) (THIS_
    aafUInt32  HorizontalSubsampling) PURE;


  //***********************************************************
  //
  // GetHorizontalSubsampling()
  //
  /// Gets the HorizontalSubsampling property.  Specifies the ratio of
  /// luminance sampling to chrominance sampling in the horizontal
  /// direction.  For 4:2:2 video, the value is 2, which means that
  /// there are twice as many luminance values as there are
  /// color-difference values.  Another typical value is 1; however
  /// other values are permitted by the reference implementation.
  ///
  /// Succeeds if all of the following are true:
  /// - pHorizontalSubsampling is a valid pointer.
  /// 
  /// If this method fails, *pHorizontalSubsampling will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pHorizontalSubsampling arg is NULL.
  ///
  /// @param pHorizontalSubsampling [out] Address to store the integer value.
  ///
  STDMETHOD(GetHorizontalSubsampling) (THIS_
    aafUInt32 *  pHorizontalSubsampling) PURE;


  //***********************************************************
  //
  // SetVerticalSubsampling()
  //
  /// Sets the VerticalSubsampling property.  Specifies the ratio of
  /// luminance sampling to chrominance sampling in the vertical direction.
  /// For 4:2:2 video, the value is 2, which means that there are twice as
  /// many luminance values as there are color-difference values.
  /// Another typical value is 1; however other values are permitted by
  /// the reference implementation.
  ///
  /// If this method fails, the VerticalSubsampling property will
  /// not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param VerticalSubsampling [in] Integer value.
  ///
  STDMETHOD(SetVerticalSubsampling) (THIS_
    aafUInt32  VerticalSubsampling) PURE;


  //***********************************************************
  //
  // GetVerticalSubsampling()
  //
  /// Gets the VerticalSubsampling property.  Specifies the ratio of
  /// luminance sampling to chrominance sampling in the vertical
  /// direction.  For 4:2:2 video, the value is 2, which means that
  /// there are twice as many luminance values as there are
  /// color-difference values.  Another typical value is 1; however
  /// other values are permitted by the reference implementation.
  ///
  /// Succeeds if all of the following are true:
  /// - pVerticalSubsampling is a valid pointer.
  /// 
  /// If this method fails, *pVerticalSubsampling will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pVerticalSubsampling arg is NULL.
  ///
  /// @param pVerticalSubsampling [out] Address to store the integer value.
  ///
  STDMETHOD(GetVerticalSubsampling) (THIS_
    aafUInt32 *  pVerticalSubsampling) PURE;


  //***********************************************************
  //
  // SetColorSiting()
  //
  /// Sets the ColorSiting property.  Specifies how to compute subsampled
  /// chrominance values.
  ///
  /// Valid values are:
  ///
  ///     kCoSiting  - To calculate subsampled pixels, take the preceding's pixels
  ///                  color value, discard the other color values and cosite the
  ///                  color with the first luminance value.
  ///
  ///     kAveraging - To calculate subsampled pixels, take the average of the two
  ///                  adjacent pixels' color values and site the color in the center
  ///                  of the luminance pixels.
  ///
  ///     kThreeTap  - To calculate subsampled pixels, take 25 percent of the the previous
  ///                  pixel's color value, 50 percent of the first value and 25 percent
  ///                  of the second value.  For the first value in a row, use 75 percent
  ///                  of that value since there is no previous value.  The kThreeTap value
  ///                  is only meaningful when the HorizontalSubsampling propert has a value
  ///                  of 2.
  ///
  /// This property is optional.  The default value is kCoSiting.
  ///
  /// Succeeds if all of the following are true:
  /// - ColorSiting is valid
  ///
  /// If this method fails, the ColorSiting property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param ColorSiting [in] Color siting value.
  ///
  STDMETHOD(SetColorSiting) (THIS_
    aafColorSiting_t  ColorSiting) PURE;


  //***********************************************************
  //
  // GetColorSiting()
  //
  /// Gets the ColorSiting property.  Specifies how to compute
  /// subsampled chrominance values.
  ///
  /// Valid values are:
  ///
  ///     kCoSiting  - To calculate subsampled pixels, take the
  ///                  preceding's pixels color value, discard the
  ///                  other color values and cosite the color with the
  ///                  first luminance value.
  ///
  ///     kAveraging - To calculate subsampled pixels, take the
  ///                  average of the two adjacent pixels' color values
  ///                  and site the color in the center of the
  ///                  luminance pixels.
  ///
  ///     kThreeTap  - To calculate subsampled pixels, take 25 percent
  ///                  of the the previous pixel's color value, 50
  ///                  percent of the first value and 25 percent of the
  ///                  second value.  For the first value in a row,
  ///                  use 75 percent of that value since there is no
  ///                  previous value.  The kThreeTap value is only
  ///                  meaningful when the HorizontalSubsampling
  ///                  propert has a value of 2.
  ///
  /// Succeeds if all of the following are true:
  /// - pColorSiting is a valid pointer.
  ///
  /// If this method fails, *pColorSiting will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pColorSiting arg is NULL.
  ///
  /// @param pColorSiting [out] Address to store the color siting value.
  ///
  STDMETHOD(GetColorSiting) (THIS_
    aafColorSiting_t *  pColorSiting) PURE;


  //***********************************************************
  //
  // SetBlackReferenceLevel()
  //
  /// Sets the BlackReferenceLevel property.  Specifies the digital luminance
  /// component component value associated with black.
  ///
  /// For CCIR-601/2, the value is 16 for 8-bit video and 64 for
  /// 10-bit video.  For YUV, the value is 0.  These are typical
  /// values; other values will not be disallowed by the reference
  /// implementation.
  ///
  /// The same value is used in CDCI and RGBA when standard colorspace
  /// conversion is used.
  ///
  /// This property is optional.  The default value is 0.
  ///
  /// If this method fails, the BlackReferenceLevel property will not
  /// be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param BlackReferenceLevel [in] Integer value.
  ///
  STDMETHOD(SetBlackReferenceLevel) (THIS_
    aafUInt32  BlackReferenceLevel) PURE;


  //***********************************************************
  //
  // GetBlackReferenceLevel()
  //
  /// Gets the BlackReferenceLevel property.  Specifies the digital
  /// luminance component value associated with black.
  ///
  /// For CCIR-601/2, the value is 16 for 8-bit video and 64 for
  /// 10-bit video.  For YUV, the value is 0.  These are typical
  /// values; other values will not be disallowed by the reference
  /// implementation.
  ///
  /// The same value is used in CDCI and RGBA when standard colorspace
  /// conversion is used.
  ///
  /// Succeeds if all of the following are true:
  /// - pBlackReferenceLevel is a valid pointer.
  /// 
  /// If this method fails, *pBlackReferenceLevel will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBlackReferenceLevel arg is NULL.
  ///
  /// @param pBlackReferenceLevel [out] Address to store the integer value.
  ///
  STDMETHOD(GetBlackReferenceLevel) (THIS_
    aafUInt32 *  pBlackReferenceLevel) PURE;


  //***********************************************************
  //
  // SetWhiteReferenceLevel()
  //
  /// Sets the WhiteReferenceLevel property.  Specifies the digital
  /// luminance component component value associated with white.
  ///
  /// For CCIR-601/2, the value is 235 for 8-bit video and 940 for
  /// 10-bit video.  For YUV, the value is 255 for 8-bit video and
  /// 1023 for 10-bit video.  These are typical values; other values
  /// will not be disallowed by the reference implementation.
  ///
  /// This property is optional.  The default value is the maximum
  /// unsigned interger value for component size.
  ///
  /// If this method fails, the WhiteReferenceLevel property will not
  /// be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param WhiteReferenceLevel [in] Integer value.
  ///
  STDMETHOD(SetWhiteReferenceLevel) (THIS_
    aafUInt32  WhiteReferenceLevel) PURE;


  //***********************************************************
  //
  // GetWhiteReferenceLevel()
  //
  /// Gets the WhiteReferenceLevel property.  Specifies the digital
  /// luminance component component value associated with white.
  ///
  /// For CCIR-601/2, the value is 235 for 8-bit video and 940 for
  /// 10-bit video.  For YUV, the value is 255 for 8-bit video and
  /// 1023 for 10-bit video.  These are typical values; other values
  /// will not be disallowed by the reference implementation.
  ///
  /// Succeeds if all of the following are true:
  /// - pWhiteReferenceLevel is a valid pointer.
  /// 
  /// If this method fails, *pWhiteReferenceLevel will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pWhiteReferenceLevel arg is NULL.
  ///
  /// @param pWhiteReferenceLevel [out] Address to store the integer value.
  ///
  STDMETHOD(GetWhiteReferenceLevel) (THIS_
    aafUInt32 *  pWhiteReferenceLevel) PURE;


  //***********************************************************
  //
  // SetColorRange()
  //
  /// Sets the ColorRange property.  Specifies the range of allowable
  /// digital chrominance component values.  Chrominance values are
  /// unsigned and the range is centered on 128 for 8-bit video and 512
  /// for 10-bit video.  This value is used for both chrominance
  /// components.
  ///
  /// For CCIR-601/2, the range is 225 for 8-bit video and 897 for
  /// 10-bit video.  For YUV, the range is 255 for 8-bit video and
  /// 1023 for 10-bit video.  These are typical values; other values will
  /// not be disallowed by the reference implementation.
  ///
  /// This property is optional.  The default value is the maximum
  /// unsigned integer value for component size.
  ///
  /// Succeeds if all of the following are true:
  /// 
  /// If this method fails, the ColorRange property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param ColorRange [in] Integer value.
  ///
  STDMETHOD(SetColorRange) (THIS_
    aafUInt32  ColorRange) PURE;


  //***********************************************************
  //
  // GetColorRange()
  //
  /// Gets the ColorRange property.  Specifies the range of allowable
  /// digital chrominance component values.  Chrominance values are
  /// unsigned and the range is centered on 128 for 8-bit video and 512
  /// for 10-bit video.  This value is used for both chrominance
  /// components.
  ///
  /// For CCIR-601/2, the range is 225 for 8-bit video and 897 for
  /// 10-bit video.  For YUV, the range is 255 for 8-bit video and
  /// 1023 for 10-bit video.  These are typical values; other values will
  /// not be disallowed by the reference implementation.
  ///
  /// Succeeds if all of the following are true:
  /// - pColorRange is a valid pointer.
  /// 
  /// If this method fails, *pColorRange will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pColorRange arg is NULL.
  ///
  /// @param pColorRange [out] Address to store the integer value.
  ///
  STDMETHOD(GetColorRange) (THIS_
    aafUInt32 *  pColorRange) PURE;


  //***********************************************************
  //
  // SetPaddingBits()
  //
  /// Sets the PaddingBits property.  Specifies the number of bits
  /// padded to each pixel.
  ///
  /// This property is optional.  The default value is 0.
  ///
  /// If this method fails, the PaddingBits property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param PaddingBits [in] Number of bits.
  ///
  STDMETHOD(SetPaddingBits) (THIS_
    aafInt16  PaddingBits) PURE;


  //***********************************************************
  //
  // GetPaddingBits()
  //
  /// Gets the PaddingBits property.  Specifies the number of bits
  /// padded to each pixel.
  ///
  ///
  /// Succeeds if all of the following are true:
  /// - pPaddingBits is a valid pointer.
  /// 
  /// If this method fails, pPaddingBits will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPaddingBits arg is NULL.
  ///
  /// @param pPaddingBits [out] Address to store the number of bits.
  ///
  STDMETHOD(GetPaddingBits) (THIS_
    aafInt16 *  pPaddingBits) PURE;







  END_INTERFACE
};
#endif // __IAAFCDCIDescriptor_INTERFACE_DEFINED__


// IAAFCachePageAllocator

// ************************
//
// Interface IAAFCachePageAllocator
//
// ************************



#ifndef __IAAFCachePageAllocator_INTERFACE_DEFINED__
#define __IAAFCachePageAllocator_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFCachePageAllocator;

#undef  INTERFACE
#define INTERFACE   IAAFCachePageAllocator

DECLARE_INTERFACE_(IAAFCachePageAllocator, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFCachePageAllocator methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Initialize.
  ///
  /// @param pageCount [in] Maximum number of pages to allocate
  /// @param pageSize [in] Size in bytes of each page
  ///
  STDMETHOD(Initialize) (THIS_
    aafUInt32  pageCount,
    aafUInt32  pageSize) PURE;

  //***********************************************************
  //
  // Allocate()
  //
  /// Allocate a cache page.
  ///
  /// @param pPage [out] Pointer to the newly allocated page
  ///
  STDMETHOD(Allocate) (THIS_
    aafMemPtr_t *  pPage) PURE;

  //***********************************************************
  //
  // Deallocate()
  //
  /// Dellocate a cache page.
  ///
  /// @param page [in] Pointer to the page to deallocate
  ///
  STDMETHOD(Deallocate) (THIS_
    aafMemPtr_t  page) PURE;


  END_INTERFACE
};
#endif // __IAAFCachePageAllocator_INTERFACE_DEFINED__



// IAAFClassDef

// ************************
//
// Interface IAAFClassDef
//
// ************************











#ifndef __IAAFClassDef_INTERFACE_DEFINED__
#define __IAAFClassDef_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFClassDef;

#undef  INTERFACE
#define INTERFACE   IAAFClassDef

DECLARE_INTERFACE_(IAAFClassDef, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFClassDef methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes this class definition object to inherit from the
  /// given parent class.  If isConcrete is set to AAFTrue, objects of
  /// this class can be instantiated; otherwise, it will be illegal to
  /// instantiate such objects.
  /// 
  /// Succeeds if:
  /// - The pID pointer is valid.
  /// - The pParentClass pointer is valid.
  /// - The pTypeName pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pID, pParentClass, or pTypeName arg is NULL.
  ///
  /// @param classID [in, ref] auid to be used to identify this type
  /// @param pParentClass [in] existing class from which this one inherits
  /// @param pClassName [in, string] friendly name of this type definition
  /// @param isConcrete [in] can objects of this class be instantiated
  ///
  STDMETHOD(Initialize) (THIS_
    aafUID_constref  classID,
    IAAFClassDef * pParentClass,
    aafCharacter_constptr  pClassName,
    aafBoolean_t  isConcrete) PURE;


  //***********************************************************
  //
  // GetPropertyDefs()
  //
  /// Returns an enumerator over all of the aaf property definitions
  /// attached to the current class.
  /// 
  /// Succeeds if:
  /// - The ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  ///
  /// @param ppEnum [out, retval] Property Definition enumeration
  ///
  STDMETHOD(GetPropertyDefs) (THIS_
    IEnumAAFPropertyDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountPropertyDefs()
  //
  /// Returns number of property definitions in this class.
  /// 
  /// Succeeds if:
  /// - The pCount pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCount arg is NULL.
  ///
  /// @param pCount [out] number of properties contained in this class definition
  ///
  STDMETHOD(CountPropertyDefs) (THIS_
    aafUInt32 *  pCount) PURE;


  //***********************************************************
  //
  // RegisterNewPropertyDef()
  //
  /// Creates a new property definition and registers it in this class
  /// definition.  If ppPropDef is non-NULL, will return the new
  /// property definition in ppPropDef.
  /// 
  /// Note that it is illegal to add mandatory properties to an
  /// existing (registered) class.  This method will allow adding
  /// either optional or mandatory properties to a class, but they must
  /// be added to a class which has not yet been registered in the
  /// dictionary.  If this class has already been registered, it is
  /// possible to add optional properties, but not through this
  /// method.  Optional properties added to an existing (registered)
  /// class may be added through the RegisterOptionalPropertyDef()
  /// method.
  /// 
  /// Succeeds if:
  /// - The pID pointer is valid.
  /// - The pName pointer is valid.
  /// - The pTypeDef pointer is valid.
  /// - This class has not already been registered in the dictionary.
  /// - The auid specified by pID has not already been registered.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pName or pTypeDef arg is NULL.
  ///
  /// AAFRESULT_OBJECT_ALREADY_ATTACHED
  ///   - This class has already been registered.
  ///
  /// AAFRESULT_ALREADY_UNIQUELY_INDENTIFED
  ///   - This class already has a unique indentifier property.
  ///
  /// AAFRESULT_BAD_PARAM
  ///   - The given ID has already been registered.
  ///
  /// @param id [in, ref] auid to be used to identify this property
  /// @param pName [in, string] name of the new property
  /// @param pTypeDef [in] type of the new property
  /// @param isOptional [in] true if new property is to be optional
  /// @param isUniqueIdentifier [in] true if new property is to be the unique identifier of the class
  /// @param ppPropDef [out] return pointer to newly created property def
  ///
  STDMETHOD(RegisterNewPropertyDef) (THIS_
    aafUID_constref  id,
    aafCharacter_constptr  pName,
    IAAFTypeDef * pTypeDef,
    aafBoolean_t  isOptional,
    aafBoolean_t  isUniqueIdentifier,
    IAAFPropertyDef ** ppPropDef) PURE;


  //***********************************************************
  //
  // RegisterOptionalPropertyDef()
  //
  /// Creates a new property definition and registers it in this class
  /// definition.  If ppPropDef is non-NULL, will return the new
  /// property definition in ppPropDef.
  ///
  /// Note that it is illegal to add mandatory properties to an already
  /// existing (registered) class.  It is assumed that this property is
  /// being added to a class which is already registered.  If so, it
  /// must be optional and this method will declare it so.  If it is
  /// wished to add a mandatory property, that may be done through the
  /// RegisterNewPropertyDef() method, but that must be called on a class
  /// which is not yet registered.
  /// 
  /// Succeeds if:
  /// - The pID pointer is valid.
  /// - The pName pointer is valid.
  /// - The pTypeDef pointer is valid.
  /// - The auid specified by pID has not already been registered.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pName or pTypeDef arg is NULL.
  ///
  /// AAFRESULT_BAD_PARAM
  ///   - The given ID has already been registered.
  ///
  /// @param id [in, ref] auid to be used to identify this property
  /// @param pName [in, string] name of the new property
  /// @param pTypeDef [in] type of the new property
  /// @param ppPropDef [out] return pointer to newly created property def
  ///
  STDMETHOD(RegisterOptionalPropertyDef) (THIS_
    aafUID_constref  id,
    aafCharacter_constptr  pName,
    IAAFTypeDef * pTypeDef,
    IAAFPropertyDef ** ppPropDef) PURE;


  //***********************************************************
  //
  // LookupPropertyDef()
  //
  /// Looks up the property definition corresponding to the named auid
  /// and returns a pointer to that property definition in ppPropDef.
  /// 
  /// Succeeds if:
  /// - The pPropID pointer is valid.
  /// - The ppPropDef pointer is valid.
  /// - the auid specified by pID has been registered as a property
  ///   definition for this class definition.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppPropDef arg is NULL.
  ///
  /// AAFRESULT_BAD_PARAM
  ///   - The given ID has not been registered as a property
  ///     definition.
  ///
  /// @param propID [in, ref] auid reprepresenting property to look up
  /// @param ppPropDef [out] resulting property definition
  ///
  STDMETHOD(LookupPropertyDef) (THIS_
    aafUID_constref  propID,
    IAAFPropertyDef ** ppPropDef) PURE;


  //***********************************************************
  //
  // GetName()
  //
  /// Gets Accesses a human-readable name for the class.  This name is not
  /// meant to be a way for programs to refer to the class, as it is
  /// of undetermined length, and is not checked to guarantee
  /// uniqueness.
  /// 
  /// Writes the Name property, with a trailing null
  /// character, into the pName buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the Name property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetNameBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pName.
  /// 
  /// Succeeds if:
  /// - The pName pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   Name.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold Name.
  ///
  /// @param pName [out, string, size_is(bufSize)] buffer into which Name is to be written
  /// @param bufSize [in] size of *pName buffer in bytes
  ///
  STDMETHOD(GetName) (THIS_
    aafCharacter *  pName,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetNameBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetName().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetNameBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;


  //***********************************************************
  //
  // GetParent()
  //
  /// Gets the Parent class for this object.  If there is no parent,
  /// returns the result AAFRESULT_NO_PARENT.  The only class which has no parent will
  /// be AAFObject.
  /// 
  /// Succeeds if:
  /// - The ppClassDef pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pClassDef arg is NULL.
  ///
  /// @param ppClassDef [out, retval] parent class definition
  ///
  STDMETHOD(GetParent) (THIS_
    IAAFClassDef ** ppClassDef) PURE;


  //***********************************************************
  //
  // IsConcrete()
  //
  /// Returns true if this class can be instantiated; returns false
  /// otherwise. 
  /// 
  /// Succeeds if:
  /// - The ppClassDef pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult arg is NULL.
  ///
  /// @param pResult [out, retval] Can this class be instantiated
  ///
  STDMETHOD(IsConcrete) (THIS_
    aafBoolean_t*  pResult) PURE;


  //***********************************************************
  //
  // IsRoot()
  //
  /// Returns true if this class is the base of the inheritance
  /// hierarchy; returns false otherwise.
  /// 
  /// Succeeds if:
  /// - The ppClassDef pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - isRoot arg is NULL.
  ///
  /// @param isRoot [out, retval] Is this a root (base) class
  ///
  STDMETHOD(IsRoot) (THIS_
    aafBoolean_t*  isRoot) PURE;


  //***********************************************************
  //
  // IsUniquelyIdentified()
  //
  /// Returns true if this class is uniquely identified.
  /// 
  /// Succeeds if:
  /// - The pIsUniquelyIdentified pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pIsUniquelyIdentified arg is NULL.
  ///
  /// @param pIsUniquelyIdentified [out, retval] Is this a UniquelyIdentified class
  ///
  STDMETHOD(IsUniquelyIdentified) (THIS_
    aafBoolean_t*  pIsUniquelyIdentified) PURE;


  //***********************************************************
  //
  // GetUniqueIdentifier()
  //
  /// Returns the property definition corresponding to this class'
  /// unique identifier.
  /// 
  /// Succeeds if:
  /// - The ppUniqueIdentifier pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppUniqueIdentifier arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - If this class definition does not have a unique identifier
  ///     property definition.
  ///
  /// @param ppUniqueIdentifier [out, retval] The unique identifier
  ///
  STDMETHOD(GetUniqueIdentifier) (THIS_
    IAAFPropertyDef ** ppUniqueIdentifier) PURE;


  //***********************************************************
  //
  // CreateInstance()
  //
  /// Creates an object of this class, and returns it by reference in
  /// the location specified by the ppObject argument.
  /// 
  /// Succeeds if:
  /// - The ppObject pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppObject arg is NULL. 
  /// 
  /// @param riid Reference to the identifier of the interface
  /// @param ppvObject Address of output variable that receives the
  ///                  interface pointer requested in riid
  ///
  STDMETHOD(CreateInstance)(THIS_
    REFIID riid,
    IUnknown ** ppvObject) PURE;


  END_INTERFACE
};
#endif // __IAAFClassDef_INTERFACE_DEFINED__



// IAAFCodecDef

// ************************
//
// Interface IAAFCodecDef
//
// ************************






#ifndef __IAAFCodecDef_INTERFACE_DEFINED__
#define __IAAFCodecDef_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFCodecDef;

#undef  INTERFACE
#define INTERFACE   IAAFCodecDef

DECLARE_INTERFACE_(IAAFCodecDef, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFCodecDef methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Init all fields of a definition object.
  ///
  /// @param id [in, ref] AUID for new DefObject
  /// @param pName [in, string] Name for new DefObject
  /// @param pDescription [in, string] Description for new DefObject
  ///
  STDMETHOD(Initialize) (THIS_
    aafUID_constref  id,
    aafCharacter_constptr  pName,
    aafCharacter_constptr  pDescription) PURE;


  //***********************************************************
  //
  // IsEssenceKindSupported()
  //
  /// Returns AAFTrue if the given codec support transfers to essence
  /// of the given essence kind.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pEssenceKind pointer is valid.
  /// - the pIsSupported pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pIsSupported.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEssenceKind or pIsSupported is null.
  ///
  /// @param pEssenceKind [in] The essence kind
  /// @param pIsSupported [out,retval] Is this type supported
  ///
  STDMETHOD(IsEssenceKindSupported) (THIS_
    IAAFDataDef * pEssenceKind,
    aafBoolean_t*  pIsSupported) PURE;

 
  //***********************************************************
  //
  // AddEssenceKind()
  //
  /// Appends the given essence kind to those supported by the codec.
  /// This is dependant upon the format, not an incomplete implementation.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEssenceKind is null.
  ///
  /// AAFRESULT_DUPLICATE_ESSENCE_KIND
  ///   - the given essenceKind is already contained.
  ///
  /// @param pEssenceKind [in] The essence kind
  ///
  STDMETHOD(AddEssenceKind) (THIS_
    IAAFDataDef * pEssenceKind) PURE;


  //***********************************************************
  //
  // RemoveEssenceKind()
  //
  /// Removes the given essence kind from the list of those supported
  /// by the codec.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEssenceKind is null.
  ///
  /// AAFRESULT_OBJECT_NOT_FOUND
  ///   - the given essenceKind is not already contained.
  ///
  /// @param pEssenceKind [in] The essence kind to remove
  ///
  STDMETHOD(RemoveEssenceKind) (THIS_
    IAAFDataDef * pEssenceKind) PURE;


  //***********************************************************
  //
  // CountEssenceKinds()
  //
  /// Places the number of supported essence kinds into *pResult.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is NULL.
  ///
  /// @param pResult [out, retval] The number of essence kinds
  ///
  STDMETHOD(CountEssenceKinds) (THIS_
    aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // GetEssenceKinds()
  //
  /// Places an IEnumAAFDataDefs enumerator for the essence kinds
  /// contained in the sequence into the *ppEnum argument.
  /// 
  /// The returned enumerator is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// E_FAIL
  ///   - Failed to create the enumerator.
  ///
  /// @param ppEnum [out, retval] Essence Kind Enumeration
  ///
  STDMETHOD(GetEssenceKinds) (THIS_
    IEnumAAFDataDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // AreThereFlavours()
  //
  /// Find out whether its worth iterating over flavours.  Flavours are
  /// used when a single codec can support multiple formats.  An
  /// example would be a codec which would accept a "resolution ID"
  /// for a particular manufacturer and set up all of the parameters.
  /// When a new resolution ID is released, then a new codec plugin
  /// would give users the ability to use the new resolutions without
  /// upgrading the application.
  ///
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - if Result is null.
  ///
  /// @param pResult [out,retval] True if there are flavours of this codec
  ///
  STDMETHOD(AreThereFlavours) (THIS_
    aafBoolean_t *  pResult) PURE;


  //***********************************************************
  //
  // GetFileDescriptorClass()
  //
  /// Places the file descriptor class object associated with this
  /// codec into the *ppClass argument.  If none exists yet, NULL is
  /// placed into the*ppClass argument.
  ///
  /// The returned class object, if it exists, is
  /// AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppClass pointer is valid.
  /// - A valid file descriptor class exists.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppClass is null.
  ///
  /// @param ppClass [out] Returned file descriptor class object
  ///
  STDMETHOD(GetFileDescriptorClass) (THIS_
    IAAFClassDef ** ppClass) PURE;


  //***********************************************************
  //
  // SetFileDescriptorClass()
  //
  /// Sets the file descriptor class associated with this codec to be
  /// the given one. 
  ///
  /// Succeeds if all of the following are true:
  /// - the pClass pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pClass is null.
  ///
  /// @param pClass [in] File descriptor class object
  ///
  STDMETHOD(SetFileDescriptorClass) (THIS_
    IAAFClassDef * pClass) PURE;


  //***********************************************************
  //
  // EnumCodecFlavours()
  //
  /// Places an enumerator for codec flavour into the *ppEnum argument.
  /// The returned enumerator is AddRef()ed before it is returned.
  /// 
  /// Flavours are used when a single codec can support multiple
  /// formats.  An example would be a codec which would accept a
  /// "resolution ID" for a particular manufacturer and set up all of
  /// the parameters.  When a new resolution ID is released, then a
  /// new codec plugin would give users the ability to use the new
  /// resolutions without upgrading the application.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - if ppEnum is null.
  ///
  /// @param ppEnum [out,retval] Codec flavour Enumeration
  ///
  STDMETHOD(EnumCodecFlavours) (THIS_
    IEnumAAFCodecFlavours ** ppEnum) PURE;
  

  END_INTERFACE
};
#endif // __IAAFCodecDef_INTERFACE_DEFINED__



// IAAFCommentMarker

// ************************
//
// Interface IAAFCommentMarker
//
// ************************







#ifndef __IAAFCommentMarker_INTERFACE_DEFINED__
#define __IAAFCommentMarker_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFCommentMarker;

#undef  INTERFACE
#define INTERFACE   IAAFCommentMarker

DECLARE_INTERFACE_(IAAFCommentMarker, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFCommentMarker methods *** */


  //***********************************************************
  //
  // GetAnnotation()
  //
  /// This method will get the annotation for this comment marker and place an
  /// interface for it into the **ppResult argument. 
  ///
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult arg is NULL.
  ///
  /// @param ppResult [out,retval] Annotation property value
  ///
  STDMETHOD(GetAnnotation) (THIS_
    IAAFSourceReference ** ppResult) PURE;

  //***********************************************************
  //
  // SetAnnotation()
  //
  /// This method will set the Annotation for this comment marker.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param pAnnotation [in] Annotation property value
  ///
  STDMETHOD(SetAnnotation) (THIS_
    IAAFSourceReference * pAnnotation) PURE;


  END_INTERFACE
};
#endif // __IAAFCommentMarker_INTERFACE_DEFINED__



// IAAFComponent

// ************************
//
// Interface IAAFComponent
//
// ************************







#ifndef __IAAFComponent_INTERFACE_DEFINED__
#define __IAAFComponent_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFComponent;

#undef  INTERFACE
#define INTERFACE   IAAFComponent

DECLARE_INTERFACE_(IAAFComponent, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFComponent methods *** */
  //***********************************************************
  //
  // SetLength()
  //
  /// Sets the length property value on this component object.
  /// 
  /// Succeeds if all of the following are true:
  /// - the optional length property is present for this object.
  ///
  /// This method deals with an optional property, which will only be
  /// present for time-varying media.
  /// 
  /// If this method fails the length property will not be
  /// changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_BAD_PROP
  ///   - the optional length property is not present for this object.
  ///
  /// @param length [in] The duration in edit units of this component
  ///
  STDMETHOD(SetLength) (THIS_
    aafLength_constref  length) PURE;


  //***********************************************************
  //
  // GetLength()
  //
  /// Gets the duration in edit units of this component.
  ///	
  /// Succeeds if all of the following are true:
  /// - the pLength pointer is valid.
  /// - the optional length property is present for this object.
  ///
  /// This method deals with an optional property, which will only be
  /// present for time-varying media.
  /// 
  /// If this method fails nothing will be written to *pLength.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLength arg is NULL.
  ///
  /// AAFRESULT_BAD_PROP
  ///   - the optional length property is not present for this object.
  ///
  /// @param pLength [retval][out] Length of this component
  ///
  STDMETHOD(GetLength) (THIS_
    aafLength_t *  pLength) PURE;
	

  //***********************************************************
  //
  // SetDataDef()
  //
  /// Sets the data definition property AUID on this component.
  /// 
  /// If this method fails the Data Definition property will not be
  /// changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDataDef arg is NULL.
  ///
  /// @param pDataDef [in] DataDef of this object
  ///
  STDMETHOD(SetDataDef) (THIS_
    IAAFDataDef * pDataDef) PURE;


  //***********************************************************
  //
  // GetDataDef()
  //
  /// Returns data definition object.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppDatadef pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppDatadef.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDatadef arg is NULL.
  ///
  /// @param ppDatadef [out, retval] DataDef of this object
  ///
  STDMETHOD(GetDataDef) (THIS_
    IAAFDataDef ** ppDatadef) PURE;

  //***********************************************************
  //
  // AppendKLVData()
  //
  /// Appends a pre-existing KLV Data object to the specified
  /// component.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pKLV pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - the pData arg is NULL.
  ///
  /// @param pData [in] KLV object
  ///
  STDMETHOD(AppendKLVData) (THIS_
    IAAFKLVData * pData) PURE;


  //***********************************************************
  //
  // CountKLVData()
  //
  /// Return total number of KLV data objects attached to this component.
  ///
  /// Succeeds if all of the following are true:
  /// - the pNumData pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pNumComments.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumData arg is NULL.
  ///
  /// @param pNumData [out] Number  of KLV data objects
  ///
  STDMETHOD(CountKLVData) (THIS_
    aafUInt32 *  pNumData) PURE;


  //***********************************************************
  //
  // GetKLVData()
  //
  /// Return the enumeration for all KLV data objects on this component.  The returned
  /// enumerator is AddRef()ed before it is returned.  The enumerator
  /// is implemented as a EnumAAFKLVData.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// @param ppEnum [out] KLV data objects
  ///
  STDMETHOD(GetKLVData) (THIS_
    IEnumAAFKLVData ** ppEnum) PURE;


  //***********************************************************
  //
  // RemoveKLVData()
  //
  /// Removes the given KLV data object from this component.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pData pointer is valid.
  /// - the given KLV data object is present in the component.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pData is null.
  ///
  /// AAFRESULT_OBJECT_NOT_FOUND
  ///   - the given KLV data object is not in this component.
  ///
  /// @param pData [in] KLV data object to remove
  ///
  STDMETHOD(RemoveKLVData) (THIS_
    IAAFKLVData * pData) PURE;












  END_INTERFACE
};
#endif // __IAAFComponent_INTERFACE_DEFINED__



// IAAFCompositionMob

// ************************
//
// Interface IAAFCompositionMob
//
// ************************



#ifndef __IAAFCompositionMob_INTERFACE_DEFINED__
#define __IAAFCompositionMob_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFCompositionMob;

#undef  INTERFACE
#define INTERFACE   IAAFCompositionMob

DECLARE_INTERFACE_(IAAFCompositionMob, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFCompositionMob methods *** */
  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes this object with the given name.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has not yet been initialized.
  /// - the pName pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName argument is NULL.
  ///
  /// @param pName [in, string] Mob name [optional]
  ///
  STDMETHOD(Initialize) (THIS_
    aafCharacter_constptr  pName) PURE;


  //***********************************************************
  //
  // GetDefaultFade()
  //
  /// Get the default fade for this composition.  If there is no
  /// default fade, this function returns with no error, but the VALID
  /// field of the structure is false.  This allows you to pass this
  /// struct to SourceClip::GetFade() in all cases.
  ///
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the pResult pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult argument is NULL.
  ///
  /// @param pResult [out] a default fade struct
  ///
  STDMETHOD(GetDefaultFade) (THIS_
    aafDefaultFade_t *  pResult) PURE;
	

  //***********************************************************
  //
  // SetDefaultFade()
  //
  /// Adds the default crossfade properties to the Mob.
  ///
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_BAD_TYPE
  ///   - invalid fadeType.
  ///
  /// AAFRESULT_BAD_LENGTH
  ///   - invalid fadeLength.
  ///
  /// @param fadeLength [in] Default fade length
  /// @param fadeType [in] default fade type
  /// @param fadeEditUnit [in] default fade edit unit
  ///
  STDMETHOD(SetDefaultFade) (THIS_
    aafLength_t  fadeLength,
    aafFadeType_t  fadeType,
    aafRational_t  fadeEditUnit) PURE;






  END_INTERFACE
};
#endif // __IAAFCompositionMob_INTERFACE_DEFINED__


// IAAFConstantValue

// ************************
//
// Interface IAAFConstantValue
//
// ************************







#ifndef __IAAFConstantValue_INTERFACE_DEFINED__
#define __IAAFConstantValue_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFConstantValue;

#undef  INTERFACE
#define INTERFACE   IAAFConstantValue

DECLARE_INTERFACE_(IAAFConstantValue, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFConstantValue methods *** */


  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a new constant value object to be identified with the
  /// given the given type, and with the given human-legible name.
  ///
  /// This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  /// - pParameterDef and pValue are a valid pointers.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - This object has already had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pParameterDef or pValue arg is NULL.
  /// 
  ///
  /// @param pParameterDef [in] Parameter definition for this object (this determines the type of the constant value)
  /// @param valueSize [in] Size of preallocated buffer
  /// @param pValue [in, size_is(valueSize)] buffer containing value
  ///
  STDMETHOD(Initialize) (THIS_
    IAAFParameterDef * pParameterDef,
    aafUInt32  valueSize,
    aafDataBuffer_t  pValue) PURE;


  //***********************************************************
  //
  // GetValue()
  //
  /// Writes the value into the pValue buffer.  The buffer is allocated
  /// by the caller, and the size of the buffer is given by
  /// valueSize.
  /// 
  /// Caller may call GetValueBufLen() to determine the
  /// required buffer size.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pValue pointer is valid.
  /// - valueSize indicates the buffer is large enough to hold the
  ///   name.
  /// 
  /// If this method fails nothing will be written to *pValue.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pValue arg is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - valueSize indicates the buffer is too small to hold the
  ///     value.
  ///
  /// @param valueSize [in] Size of preallocated buffer
  /// @param pValue [out, size_is(valueSize),length_is(*bytesRead)] Preallocated buffer to hold value
  /// @param bytesRead [out] Number of actual bytes read
  ///
  STDMETHOD(GetValue) (THIS_
    aafUInt32  valueSize,
    aafDataBuffer_t  pValue,
    aafUInt32*  bytesRead) PURE;


  //***********************************************************
  //
  // GetValueBufLen()
  //
  /// Returns the length of buffer required for the GetValue()
  /// method.  The value is placed into the location specified by
  /// pLen.
  ///
  /// Succeeds if all of the following are true:
  /// - the pLen pointer is valid.
  ///
  /// If this method fails nothing will be written to *pLen.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLen arg is NULL.
  ///
  /// @param pLen [out] Pointer to an variable used to return the length
  ///
  STDMETHOD(GetValueBufLen) (THIS_
    aafUInt32 *  pLen) PURE;

  //***********************************************************
  //
  // GetTypeDefinition()
  //
  /// Places the type definition of the dataval inside this parameter into the
  /// *ppTypeDef argument.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTypeDef is null.
  ///
  /// @param ppTypeDef [out,retval] Type Definition of the dataval inside of this object
  ///
  STDMETHOD(GetTypeDefinition) (THIS_
    IAAFTypeDef ** ppTypeDef) PURE;

  //***********************************************************
  //
  // SetValue()
  //
  /// The data value is set from a buffer of size valueSize and type.
  ///
  /// Succeeds if all of the following are true:
  /// - pTypeDef is valid and registered with the object's dictionary.
  /// - the pValue pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTypeDef is null.
  ///
  /// @param valueSize [in] Size of preallocated buffer
  /// @param pValue [in, size_is(valueSize)] buffer containing value
  ///
  STDMETHOD(SetValue) (THIS_
    aafUInt32  valueSize,
    aafDataBuffer_t  pValue) PURE;


  END_INTERFACE
};
#endif // __IAAFConstantValue_INTERFACE_DEFINED__



// IAAFContainerDef

// ************************
//
// Interface IAAFContainerDef
//
// ************************



#ifndef __IAAFContainerDef_INTERFACE_DEFINED__
#define __IAAFContainerDef_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFContainerDef;

#undef  INTERFACE
#define INTERFACE   IAAFContainerDef

DECLARE_INTERFACE_(IAAFContainerDef, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFContainerDef methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Init all fields of a definition object.
  ///
  /// @param id [in, ref] AUID for new DefObject
  /// @param pName [in, string] Name for new DefObject
  /// @param pDescription [in, string] Description for new DefObject
  ///
  STDMETHOD(Initialize) (THIS_
    aafUID_constref  id,
    aafCharacter_constptr  pName,
    aafCharacter_constptr  pDescription) PURE;


  //***********************************************************
  //
  // EssenceIsIdentified()
  //
  /// Tells whether the given plugin is capable of supporting
  /// authentication.  The methods for authenticating a plugin are
  /// still <tbd>.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pEssenceIsIdentified pointer is valid.
  /// 
  /// If this method fails nothing will be written to
  /// *pEssenceIsIdentified.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEssenceIsIdentified arg is NULL.
  ///
  /// @param pEssenceIsIdentified [out] The EssenceIsIdentified
  ///
  STDMETHOD(EssenceIsIdentified) (THIS_
    aafBoolean_t *  pEssenceIsIdentified) PURE;


  //***********************************************************
  //
  // SetEssenceIsIdentified()
  //
  /// Tells whether the given plugin is capable of supporting
  /// authentication.  The methods for authenticating a plugin are
  /// still <tbd>.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param EssenceIsIdentified [in] The EssenceIsIdentified flag
  ///
  STDMETHOD(SetEssenceIsIdentified) (THIS_
    aafBoolean_t  EssenceIsIdentified) PURE;

  END_INTERFACE
};
#endif // __IAAFContainerDef_INTERFACE_DEFINED__



// IAAFContentStorage

// ************************
//
// Interface IAAFContentStorage
//
// ************************


#ifndef __IAAFContentStorage_INTERFACE_DEFINED__
#define __IAAFContentStorage_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFContentStorage;




#undef  INTERFACE
#define INTERFACE   IAAFContentStorage

DECLARE_INTERFACE_(IAAFContentStorage, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFContentStorage methods *** */


  //***********************************************************
  //
  // LookupMob()
  //
  /// Looks up the Mob that matches the given mob id and puts it into
  /// the ppMob argument.  The returned mob interface is AddRef()ed
  /// before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppMob pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppMob.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppMob is null
  ///
  /// AAFRESULT_MOB_NOT_FOUND
  ///   - the requested mob wasn't found.
  ///
  /// @param mobID [in, ref] The Mob ID
  /// @param ppMob [out,retval] Matching Mob
  ///
  STDMETHOD(LookupMob) (THIS_
    aafMobID_constref  mobID,
    IAAFMob ** ppMob) PURE;


  //***********************************************************
  //
  // CountMobs()
  //
  /// Writes the number of matches for the given mob kind into the
  /// *pNumMobs argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pNumMobs pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pNumMobs.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumMobs is null.
  ///
  /// @param mobKind [in] The mob kind to count
  /// @param pResult [out, retval] Total number of mobs of kind mobKind
  ///
  STDMETHOD(CountMobs) (THIS_
    aafMobKind_t  mobKind,
    aafNumSlots_t *  pResult) PURE;


  //***********************************************************
  //
  // GetMobs()
  //
  /// Places an enumerator for mobs that apply to the criteria into the
  /// *ppEnum argument.  If pSearchCriteria is null, all mobs are
  /// returned.   The searchTag field of pSearchCriteria, and exactly
  /// ONE of the fields in the union (tags.mobID, tags.name, etc. )
  /// must be set.  Only one search criterion may be specified.  The
  /// returned enumerator is AddRef()ed before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// @param pSearchCriteria [in] Search Criteria for enumeration
  /// @param ppEnum [out, retval] Mob Enumeration
  ///
  STDMETHOD(GetMobs) (THIS_
    aafSearchCrit_t *  pSearchCriteria,
    IEnumAAFMobs ** ppEnum) PURE;


  //***********************************************************
  //
  // AddMob()
  //
  /// Appends the given mob to the header.  If the given mob is already
  /// contained this method will do nothing and will return success.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pMob pointer is valid.
  /// - the given mob is not already part of this collection.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMob is null.
  ///
  /// AAFRESULT_DUPLICATE_MOBID
  ///   - the given mob is already contained.
  ///
  /// @param pMob [in] Mob to add
  ///
  STDMETHOD(AddMob) (THIS_
    IAAFMob * pMob) PURE;


  //***********************************************************
  //
  // RemoveMob()
  //
  /// Removes the given mob from the header.
  ///
  /// Succeeds if all of the following are true:
  /// - the pMob pointer is valid.
  /// - the given mob is currently in the collection.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMob is null.
  ///
  /// AAFRESULT_MOB_NOT_FOUND
  ///   - the given mob is not already contained.
  ///
  /// @param pMob [in] Mob to remove
  ///
  STDMETHOD(RemoveMob) (THIS_
    IAAFMob * pMob) PURE;


  //***********************************************************
  //
  // CountEssenceData()
  //
  /// Writes the total number of essence data into the *pNumEssenceData
  /// argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pNumEssenceData pointer is valid.
  /// 
  /// If this method fails nothing will be written to
  /// *pNumEssenceData.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumEssenceData is null.
  ///
  /// @param pResult [out, retval] Total number of essence data
  ///
  STDMETHOD(CountEssenceData) (THIS_
    aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // IsEssenceDataPresent()
  //
  /// Returns true if essence is found.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  ///
  /// @param fileMobID [in, ref] A Unique File Mob ID
  /// @param fmt [in] The Essence File Format
  /// @param pResult [out,retval] True if the essence is found
  ///
  STDMETHOD(IsEssenceDataPresent) (THIS_
    aafMobID_constref  fileMobID,
    aafFileFormat_t  fmt,
    aafBoolean_t *  pResult) PURE;


  //***********************************************************
  //
  // EnumEssenceData()
  //
  /// Places an enumerator for essence that applies to the criteria
  /// into the *ppEnum argument.  The returned enumerator is
  /// AddRef()ed before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pMediaCriteria pointer is valid.
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pMediaCriteria or ppEnum is null.
  ///
  /// @param ppEnum [out,retval] Essence Enumeration
  ///
  STDMETHOD(EnumEssenceData) (THIS_
    IEnumAAFEssenceData ** ppEnum) PURE;


  //***********************************************************
  //
  // AddEssenceData()
  //
  /// Appends the given essence data object to the header.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pEssenceData pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_DUPLICATE_MOBID
  ///   - The given mob has already been added.  The validation is done by comparing
  ///     mobIDs, which should be unique.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEssenceData is null.
  ///
  /// @param pEssenceData [in] Essence data object to append
  ///
  STDMETHOD(AddEssenceData) (THIS_
    IAAFEssenceData * pEssenceData) PURE;

  //***********************************************************
  //
  // RemoveEssenceData()
  //
  /// Removes the given EssenceData from the header.
  ///
  /// Succeeds if all of the following are true:
  /// - the pEssenceData pointer is valid.
  /// - the given EssenceData is currently in the collection.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEssenceData is null.
  ///
  /// AAFRESULT_ESSENCE_NOT_FOUND
  ///   - the given EssenceData is not already contained.
  ///
  /// @param pEssenceData [in] EssenceData to remove
  ///
  STDMETHOD(RemoveEssenceData) (THIS_
    IAAFEssenceData * pEssenceData) PURE;

  //***********************************************************
  //
  // LookupEssenceData()
  //
  /// Looks up the EssenceData that matches the given mob id and puts it into
  /// the ppEssenceData argument.  The returned EssenceData interface is AddRef()ed
  /// before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEssenceData pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEssenceData.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEssenceData is null
  ///
  /// AAFRESULT_MOB_NOT_FOUND
  ///   - the requested EssenceData wasn't found.
  ///
  /// @param mobID [in, ref] The Mob ID
  /// @param ppEssenceData [out,retval] Matching EssenceData
  ///
  STDMETHOD(LookupEssenceData) (THIS_
    aafMobID_constref  mobID,
    IAAFEssenceData ** ppEssenceData) PURE;


  END_INTERFACE
};
#endif // __IAAFContentStorage_INTERFACE_DEFINED__



// IAAFControlPoint

// ************************
//
// Interface IAAFControlPoint
//
// ************************








#ifndef __IAAFControlPoint_INTERFACE_DEFINED__
#define __IAAFControlPoint_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFControlPoint;

#undef  INTERFACE
#define INTERFACE   IAAFControlPoint

DECLARE_INTERFACE_(IAAFControlPoint, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFControlPoint methods *** */


  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a new control point object to be 
  ///
  /// This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  /// - pVaryingValue is a valid pointer.
  /// - time is a valid rational.
  /// - pValue is a valid pointer
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - This object has already had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName or pValue arg is NULL.
  /// 
  ///
  /// @param pVaryingValue [in] A varying value (this determines the type of this control point through the parameter definition)
  /// @param time [in] Control Point time
  /// @param valueSize [in] Size of preallocated buffer
  /// @param pValue [in, size_is(valueSize)] buffer containing value
  ///
  STDMETHOD(Initialize) (THIS_
    IAAFVaryingValue * pVaryingValue,
    aafRational_constref  time,
    aafUInt32  valueSize,
    aafDataBuffer_t  pValue) PURE;

  //***********************************************************
  //
  // GetTime()
  //
  /// Returns the position of the control point within an operation group, expressed as a rational
  /// running from 0 to 1.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pTime pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pTime.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - This property does not exist in the file.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTime arg is NULL.
  ///
  /// @param pTime [out,retval] Pointer to an aafRational_t
  ///
  STDMETHOD(GetTime) (THIS_
    aafRational_t *  pTime) PURE;

  //***********************************************************
  //
  // GetEditHint()
  //
  /// Returns the edit hint of the control point, which describes how to alter the
  /// position if the AAFOperationGroup is made longer or shorter.
  ///
  /// Succeeds if all of the following are true:
  /// - the pEditHint pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pEditHint.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - This property does not exist in the file.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEditHint arg is NULL.
  ///
  /// @param pEditHint [out,retval] Pointer to an aafEditHint_t
  ///
  STDMETHOD(GetEditHint) (THIS_
    aafEditHint_t *  pEditHint) PURE;

  //***********************************************************
  //
  // GetValueBufLen()
  //
  /// Returns the length of buffer required for the GetValue() method.
  /// The value is placed into the location specified by pLen.
  ///
  /// Succeeds if all of the following are true:
  /// - the pLen pointer is valid.
  ///
  /// If this method fails nothing will be written to *pLen.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLen arg is NULL.
  ///
  /// @param pLen [out] Pointer to an variable used to return the length
  ///
  STDMETHOD(GetValueBufLen) (THIS_
    aafUInt32 *  pLen) PURE;

  //***********************************************************
  //
  // GetValue()
  //
  /// Writes the value into the pValue buffer.  The buffer is allocated by the caller,
  /// and the size of the buffer is given by valueSize.
  /// 
  /// Caller may call GetValueBufLen() to determine the
  /// required buffer size.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pValue pointer is valid.
  /// - valueSize indicates the buffer is large enough to hold the name.
  /// 
  /// If this method fails nothing will be written to *pValue.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pValue arg is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - valueSize indicates the buffer is too small to hold the value.
  ///
  /// @param valueSize [in] Size of preallocated buffer
  /// @param pValue [out, size_is(valueSize),length_is(*bytesRead)] Preallocated buffer to hold value
  /// @param bytesRead [out] Number of actual bytes read
  ///
  STDMETHOD(GetValue) (THIS_
    aafUInt32  valueSize,
    aafDataBuffer_t  pValue,
    aafUInt32*  bytesRead) PURE;

  //***********************************************************
  //
  // SetTime()
  //
  /// Sets the position of the control point within an operation group, expressed as a rational
  /// running from 0 to 1.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param pTime [in] Control Point time
  ///
  STDMETHOD(SetTime) (THIS_
    aafRational_t  pTime) PURE;

  //***********************************************************
  //
  // SetEditHint()
  //
  /// Sets the control point Edit hint value, which describes how to alter the
  /// position if the AAFOperationGroup is made longer or shorter.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param editHint [in] Control Point Edit hint
  ///
  STDMETHOD(SetEditHint) (THIS_
    aafEditHint_t  editHint) PURE;

  //***********************************************************
  //
  // GetTypeDefinition()
  //
  /// Places the type definition of the dataval inside this parameter into the
  /// *ppTypeDef argument.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTypeDef is null.
  ///
  /// @param ppTypeDef [out,retval] Type Definition of the dataval inside of this object
  ///
  STDMETHOD(GetTypeDefinition) (THIS_
    IAAFTypeDef ** ppTypeDef) PURE;

  //***********************************************************
  //
  // SetValue()
  //
  /// The data value is set from a buffer of size valueSize and type.
  ///
  /// Succeeds if all of the following are true:
  /// - pTypeDef is valid and registered with the object's dictionary.
  /// - the pValue pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTypeDef is null.
  ///
  /// @param valueSize [in] Size of preallocated buffer
  /// @param pValue [in, size_is(valueSize)] buffer containing value
  ///
  STDMETHOD(SetValue) (THIS_
    aafUInt32  valueSize,
    aafDataBuffer_t  pValue) PURE;


  END_INTERFACE
};
#endif // __IAAFControlPoint_INTERFACE_DEFINED__




// IAAFDataDef

// ************************
//
// Interface IAAFDataDef
//
// ************************




#ifndef __IAAFDataDef_INTERFACE_DEFINED__
#define __IAAFDataDef_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFDataDef;

#undef  INTERFACE
#define INTERFACE   IAAFDataDef

DECLARE_INTERFACE_(IAAFDataDef, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFDataDef methods *** */
  //***********************************************************
  //
  // Initialize()
  //
  /// Init all fields of a definition object.
  ///
  /// @param id [in, ref] AUID for new DefObject
  /// @param pName [in, string] Name for new DefObject
  /// @param pDescription [in, string] Description for new DefObject
  ///
  STDMETHOD(Initialize) (THIS_
    aafUID_constref  id,
    aafCharacter_constptr  pName,
    aafCharacter_constptr  pDescription) PURE;


  //***********************************************************
  //
  // IsPictureKind()
  //
  /// Sets return value to TRUE if DataDef is a picture.
  ///
  /// @param bIsPictureKind [retval,out] pointer to the return value
  ///
  STDMETHOD(IsPictureKind) (THIS_
    aafBoolean_t *  bIsPictureKind) PURE;


  //***********************************************************
  //
  // IsMatteKind()
  //
  /// Sets return value to TRUE if DataDef is a matte.
  ///
  /// @param bIsMatteKind [retval,out] pointer to the return value
  ///
  STDMETHOD(IsMatteKind) (THIS_
    aafBoolean_t *  bIsMatteKind) PURE;


  //***********************************************************
  //
  // IsPictureWithMatteKind()
  //
  /// Sets return value to TRUE if DataDef is a picture with matte.
  ///
  /// @param bIsPictureWithMatteKind [retval,out] pointer to the return value
  ///
  STDMETHOD(IsPictureWithMatteKind) (THIS_
    aafBoolean_t *  bIsPictureWithMatteKind) PURE;


  //***********************************************************
  //
  // IsSoundKind()
  //
  /// Sets return value to TRUE if DataDef is a sound.
  ///
  /// @param bIsSoundKind [retval,out] pointer to the return value
  ///
  STDMETHOD(IsSoundKind) (THIS_
    aafBoolean_t *  bIsSoundKind) PURE;


  //***********************************************************
  //
  // DoesDataDefConvertTo()
  //
  /// Sets return value to TRUE if the DataDef of the given object
  /// can be converted to the DataDef specified in the IN 
  /// parameter with the DataDefName string.
  ///
  /// @param id [in] data def to compare against
  /// @param bDoesConvertTo [retval, out] pointer to result
  ///
  STDMETHOD(DoesDataDefConvertTo) (THIS_
    IAAFDataDef * id,
    aafBoolean_t *  bDoesConvertTo) PURE;
		   

  //***********************************************************
  //
  // IsDataDefOf()
  //
  /// Sets the value to TRUE if the DataDef of the given object
  /// matches the DataDef specified in the IN parameter with the
  /// DataDefName string.
  ///
  /// @param pDataDef [in] data def to compare against
  /// @param bIsDataDefOf [retval, out] pointer to result
  ///
  STDMETHOD(IsDataDefOf) (THIS_
    IAAFDataDef * pDataDef,
    aafBoolean_t *  bIsDataDefOf) PURE;


  //***********************************************************
  //
  // DoesDataDefConvertFrom()
  //
  /// Sets return value to TRUE if the DataDef of the given object
  /// can be converted from the DataDef specified in the IN 
  /// parameter specified with the DataDefName string.
  ///
  /// @param pDataDef [in] data def to compare against
  /// @param bDoesConvertFrom [retval, out] pointer to result
  ///
  STDMETHOD(DoesDataDefConvertFrom) (THIS_
    IAAFDataDef * pDataDef,
    aafBoolean_t *  bDoesConvertFrom) PURE;








  END_INTERFACE
};
#endif // __IAAFDataDef_INTERFACE_DEFINED__


// IAAFDataEssenceDescriptor

// ************************
//
// Interface IAAFDataEssenceDescriptor
//
// ************************




#ifndef __IAAFDataEssenceDescriptor_INTERFACE_DEFINED__
#define __IAAFDataEssenceDescriptor_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFDataEssenceDescriptor;


#undef  INTERFACE
#define INTERFACE   IAAFDataEssenceDescriptor

DECLARE_INTERFACE_(IAAFDataEssenceDescriptor, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFDataEssenceDescriptor methods *** */



  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty IAAFDataEssenceDescriptor-supporting
  /// object.  This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  STDMETHOD(Initialize) (THIS) PURE;

  //***********************************************************
  //
  // SetDataEssenceCoding()
  //
  /// Sets the DataEssenceCoding property
  /// This property is optional.  
  /// 
  /// If this method fails the Data Definition property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param dataEssenceCoding [in] Optional.
  ///
  STDMETHOD(SetDataEssenceCoding) (THIS_
    aafUID_constref  dataEssenceCoding) PURE;


  //***********************************************************
  //
  // GetDataEssenceCoding()
  //
  /// Gets the DataEssenceCoding property
  /// information of the video essence data.  This property is
  /// optional.
  ///
  /// Succeeds if all of the following are true:
  /// - the pDataEssenceCoding pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pDataEssenceCoding.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDataEssenceCoding arg is NULL.
  ///
  /// @param pDataEssenceCoding [out] Optional.
  ///
  STDMETHOD(GetDataEssenceCoding) (THIS_
    aafUID_t *  pDataEssenceCoding) PURE;


  END_INTERFACE
};
#endif // __IAAFDataEssenceDescriptor_INTERFACE_DEFINED__



// IAAFDefObject

// ************************
//
// Interface IAAFDefObject
//
// ************************




#ifndef __IAAFDefObject_INTERFACE_DEFINED__
#define __IAAFDefObject_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFDefObject;

#undef  INTERFACE
#define INTERFACE   IAAFDefObject

DECLARE_INTERFACE_(IAAFDefObject, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFDefObject methods *** */

  //***********************************************************
  //
  // SetName()
  //
  /// Sets the Name of this definition.
  ///
  /// Set the Name property to the value specified in
  /// pName.  A copy is made of the data so the caller
  /// retains ownership of the *pName buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pName pointer is valid.
  /// 
  /// If this method fails the Name property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  ///
  /// @param pName [in, string] buffer from which Name is to be read
  ///
  STDMETHOD(SetName) (THIS_
    aafCharacter_constptr  pName) PURE;


  //***********************************************************
  //
  // GetName()
  //
  /// Gets the Name of this definition.
  /// 
  /// Writes the Name property, with a trailing null
  /// character, into the pName buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the Name property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetNameBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pName.
  /// 
  /// Succeeds if:
  /// - The pName pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   Name.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold Name.
  ///
  /// @param pName [out, string, size_is(bufSize)] buffer into which Name is to be written
  /// @param bufSize [in] size of *pName buffer in bytes
  ///
  STDMETHOD(GetName) (THIS_
    aafCharacter *  pName,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetNameBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetName().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetNameBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;


  //***********************************************************
  //
  // SetDescription()
  //
  /// Sets the Description of this definition.
  ///
  /// Set the Description property to the value specified in
  /// pDescription.  A copy is made of the data so the caller
  /// retains ownership of the *pDescription buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pDescription pointer is valid.
  /// 
  /// If this method fails the Description property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDescription arg is NULL.
  ///
  /// @param pDescription [in, string] buffer from which Description is to be read
  ///
  STDMETHOD(SetDescription) (THIS_
    aafCharacter_constptr  pDescription) PURE;


  //***********************************************************
  //
  // GetDescription()
  //
  /// Gets the Description of this definition.
  /// 
  /// Writes the Description property, with a trailing null
  /// character, into the pDescription buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the Description property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetDescriptionBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pDescription.
  /// 
  /// Succeeds if:
  /// - The pDescription pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   Description.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDescription arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold Description.
  ///
  /// @param pDescription [out, string, size_is(bufSize)] buffer into which Description is to be written
  /// @param bufSize [in] size of *pDescription buffer in bytes
  ///
  STDMETHOD(GetDescription) (THIS_
    aafCharacter *  pDescription,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetDescriptionBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetDescription().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetDescriptionBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;


  //***********************************************************
  //
  // Initialize()
  //
  /// Init all fields of a definition object.
  ///
  /// @param id [in, ref] AUID for new DefObject
  /// @param pName [in, string] Name for new DefObject
  ///
  STDMETHOD(Initialize) (THIS_
    aafUID_constref  id,
    aafCharacter_constptr  pName) PURE;


  //***********************************************************
  //
  // GetAUID()
  //
  /// Gets the AUID for this object.
  ///
  /// @param pAuid [retval,out] Pointer to an AUID reference
  ///
  STDMETHOD(GetAUID) (THIS_
    aafUID_t *  pAuid) PURE;


  END_INTERFACE
};
#endif // __IAAFDefObject_INTERFACE_DEFINED__



// IAAFDescriptiveClip

// ************************
//
// Interface IAAFDescriptiveClip
//
// ************************




#ifndef __IAAFDescriptiveClip_INTERFACE_DEFINED__
#define __IAAFDescriptiveClip_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFDescriptiveClip;


#undef  INTERFACE
#define INTERFACE   IAAFDescriptiveClip

DECLARE_INTERFACE_(IAAFDescriptiveClip, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFDescriptiveClip methods *** */


  //***********************************************************
  //
  // Initialize()
  //
  /// This method initializes a source clip object with
  /// the given properties.  Only required properties are set.
  /// Optional properties are added with separate functions.
  ///
  /// Succeds if:
  /// - This object has not already been Initialize()d.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDataDef argument is NULL.
  ///
  /// @param pDataDef [in] Data Definition object
  /// @param length [in] Length property value
  /// @param sourceRef [in] Source Reference
  ///
  STDMETHOD(Initialize) (THIS_
    IAAFDataDef * pDataDef,
    aafLength_constref  length,
    aafSourceRef_t  sourceRef) PURE;


  //***********************************************************
  //
  // CountDescribedSlotIDs()
  //
  /// Gets the total number of described slot IDs present in
  /// the list of described slot IDs referenced by this DescriptiveClip.
  ///
  /// Succeeds if all of the following are true:
  /// - the pCount pointer is valid;
  /// - the DescribedSlotIDs property is present.
  ///
  /// If this method fails nothing will be written to *pCount.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCount arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the DescribedSlotIDs property is not present.
  ///
  /// @param pCount [out, retval] Number of described slot IDs
  ///
  STDMETHOD(CountDescribedSlotIDs) (THIS_
    aafUInt32*  pCount) PURE;


  //***********************************************************
  //
  // GetDescribedSlotIDs()
  //
  /// Gets all the described slot IDs in the list of
  /// described slot IDs referenced by this DescriptiveClip.
  ///
  /// The values are written to the array specified by pDescribedSlotIDs,
  /// which is of size maxDescribedSlotIDCount. The required size may be found
  /// by calling CountDescribedSlotIDs().
  /// 
  /// Succeeds if all of the following are true:
  /// - pDescribedSlotIDs is a valid pointer;
  /// - maxDescribedSlotIDCount indicates the array is large enough to hold the
  ///   data;
  /// - the DescribedSlotIDs property is present.
  /// 
  /// If this method fails, the property will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDescribedSlotIDs is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - maxDescribedSlotIDCount indicates that the array is too small to hold
  ///     all the referenced described slot IDs.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the DescribedSlotIDs property is not present.
  ///
  /// @param maxDescribedSlotIDCount [in] The size of the given pDescribedSlotIDs buffer
  /// @param pDescribedSlotIDs [out, size_is(maxDescribedSlotIDCount)] Array to hold the described slot IDs
  ///
  STDMETHOD(GetDescribedSlotIDs) (THIS_
    aafUInt32  maxDescribedSlotIDCount,
    aafUInt32 *  pDescribedSlotIDs) PURE;


  //***********************************************************
  //
  // IsDescribedSlotIDPresent()
  //
  /// Determines if the given described slot ID is present in
  /// the list of described slot IDs referenced by this DescriptiveClip.
  ///
  ///
  /// Succeeds if all of the following are true:
  /// - the pIsPresent pointer is valid;
  /// - the DescribedSlotIDs property is present.
  ///
  /// If this method fails nothing will be written to *pIsPresent.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pIsPresent arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the DescribedSlotIDs property is not present.
  ///
  /// @param DescribedSlotID [in] described slot ID whose presence is to be queried
  /// @param pIsPresent [out,retval] True if DescribedSlotID is present
  ///
  STDMETHOD(IsDescribedSlotIDPresent) (THIS_
    aafUInt32  DescribedSlotID,
    aafBoolean_t*  pIsPresent) PURE;


  //***********************************************************
  //
  // AddDescribedSlotID()
  //
  /// Appends the given described slot ID to the list of
  /// described slot IDs referenced by this DescriptiveClip.
  ///
  /// Succeeds if all of the following are true:
  /// - the given described slot ID is not already contained in the list
  ///   of described slot IDs referenced by this DescriptiveClip.
  ///
  /// If this method fails, the property will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given described slot ID is already contained in the list
  ///     of described slot IDs referenced by this DescriptiveClip.
  ///
  /// @param DescribedSlotID [in] described slot ID to add.
  ///
  STDMETHOD(AddDescribedSlotID) (THIS_
    aafUInt32  DescribedSlotID) PURE;


  //***********************************************************
  //
  // RemoveDescribedSlotID()
  //
  /// Removes the given described slot ID from
  /// the list of described slot IDs referenced by this DescriptiveClip.
  ///
  /// If the removed ID was the last ID in the list, the list is removed
  /// from this DescriptiveClip (the property is removed).
  ///
  /// Succeeds if all of the following are true:
  /// - the DescribedSlotIDs property is present;
  /// - the given described slot ID is present in the list
  ///   of described slot IDs referenced by this DescriptiveClip.
  ///
  /// If this method fails, the property will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - property not present.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given described slot ID is not present in the list
  ///     of described slot IDs referenced by this DescriptiveClip.
  ///
  /// @param DescribedSlotID [in] described slot ID to remove.
  ///
  STDMETHOD(RemoveDescribedSlotID) (THIS_
    aafUInt32  DescribedSlotID) PURE;



  END_INTERFACE
};
#endif // __IAAFDescriptiveClip_INTERFACE_DEFINED__



// IAAFDescriptiveFramework

// ************************
//
// Interface IAAFDescriptiveFramework
//
// ************************





#ifndef __IAAFDescriptiveFramework_INTERFACE_DEFINED__
#define __IAAFDescriptiveFramework_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFDescriptiveFramework;

#undef  INTERFACE
#define INTERFACE   IAAFDescriptiveFramework

DECLARE_INTERFACE_(IAAFDescriptiveFramework, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFDescriptiveFramework methods *** */



  END_INTERFACE
};
#endif // __IAAFDescriptiveFramework_INTERFACE_DEFINED__



// IAAFDescriptiveMarker

// ************************
//
// Interface IAAFDescriptiveMarker
//
// ************************







#ifndef __IAAFDescriptiveMarker_INTERFACE_DEFINED__
#define __IAAFDescriptiveMarker_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFDescriptiveMarker;


#undef  INTERFACE
#define INTERFACE   IAAFDescriptiveMarker

DECLARE_INTERFACE_(IAAFDescriptiveMarker, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFDescriptiveMarker methods *** */


  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated,
  /// IAAFDescriptiveFrame object.  This method must be called
  /// after allocation, and before any other method can be called.
  ///
  /// Return codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  STDMETHOD(Initialize) (THIS) PURE;


  //***********************************************************
  //
  // SetDescribedSlotIDs()
  //
  /// Specifies the slot IDs in the Mob to which the DescriptiveFramework refers.
  /// 
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMonoSourceSlotIDs is null 
  ///
  /// This interface is not currently implemented.
  ///
  /// @param numberElements [in] Number of elements in the pDescribedSlotIDs array
  /// @param pDescribedSlotIDs [in] Array of slot IDs
  ///
  STDMETHOD(SetDescribedSlotIDs) (THIS_
    aafUInt32  numberElements,
    aafUInt32*  pDescribedSlotIDs) PURE;


  //***********************************************************
  //
  // GetDescribedSlotIDs()
  //
  /// Get the described slot IDs that are referenced by this object.  Refer to
  /// SetDescribedSlotIDs for a description of pDescribedSlotIDs.
  ///
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDescribedSlotIDs is null
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present
  ///
  /// AAFRESULT_SMALLBUF
  ///   - pDescribedSlotIDs is too small
  ///
  /// This interface is not currently implemented.
  ///
  /// @param numberElements [in] Number of elements in the pDescribedSlotIDs array
  /// @param pDescribedSlotIDs [in] Array of channel IDs
  ///
  STDMETHOD(GetDescribedSlotIDs) (THIS_
    aafUInt32  numberElements,
    aafUInt32*  pDescribedSlotIDs) PURE;

  //***********************************************************
  //
  // GetDescribedSlotIDsSize()
  //
  /// Get the number of slot IDs stored by this DescriptiveMarker.
  ///
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDescribedSlotIDs is null 
  ///
  /// @param numberElements [out] Number of elements in the pDescribedSlotIDs array
  ///
  STDMETHOD(GetDescribedSlotIDsSize) (THIS_
    aafUInt32 *  numberElements) PURE;

  //***********************************************************
  //
  // SetDescriptiveFramework()
  //
  /// Sets the DescriptiveFramework that describes this DescriptiveMarker.
  ///
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///	- succeeded
  ///
  /// AAFRESULT_NULL_PARAM
  ///	- pDescriptorFramework is null
  ///
  /// @param pDescriptiveFramework [in] DescriptorFramework object to set
  ///
  STDMETHOD(SetDescriptiveFramework) (THIS_
    IAAFDescriptiveFramework * pDescriptiveFramework) PURE;

  //***********************************************************
  //
  // GetDescriptiveFramework()
  //
  /// Gets the DescriptiveFramework that describes this DescriptiveMarker.
  ///
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///	- succeeded
  ///
  /// AAFRESULT_NULL_PARAM
  ///	- ppDescriptorFramework is null
  ///
  /// @param ppDescriptiveFramework [out,retval] DescriptorFramework object to return
  ///
  STDMETHOD(GetDescriptiveFramework) (THIS_
    IAAFDescriptiveFramework ** ppDescriptiveFramework) PURE;


  END_INTERFACE
};
#endif // __IAAFDescriptiveMarker_INTERFACE_DEFINED__



// IAAFDescriptiveObject

// ************************
//
// Interface IAAFDescriptiveObject
//
// ************************





#ifndef __IAAFDescriptiveObject_INTERFACE_DEFINED__
#define __IAAFDescriptiveObject_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFDescriptiveObject;


#undef  INTERFACE
#define INTERFACE   IAAFDescriptiveObject

DECLARE_INTERFACE_(IAAFDescriptiveObject, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFDescriptiveObject methods *** */



  END_INTERFACE
};
#endif // __IAAFDescriptiveObject_INTERFACE_DEFINED__



// IAAFDictionary

// ************************
//
// Interface IAAFDictionary
//
// ************************
























#ifndef __IAAFDictionary_INTERFACE_DEFINED__
#define __IAAFDictionary_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFDictionary;


#undef  INTERFACE
#define INTERFACE   IAAFDictionary

DECLARE_INTERFACE_(IAAFDictionary, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFDictionary methods *** */

  //***********************************************************
  //
  // CreateInstance()
  //
  /// Creates a single uninitialized AAF object of the class associated 
  /// with a specified stored object id. 
  ///
  /// @param id Class identifier (AUID) of the stored object. This is the
  ///           corresponding SMPTE identifier (as a GUID) for all predefined
  ///           built-in classes.
  /// @param riid Reference to the identifier of the interface
  /// @param ppvObject Address of output variable that receives the
  ///                  interface pointer requested in riid
  ///
  STDMETHOD(CreateInstance)(THIS_
    aafUID_constref id,
    REFIID riid,
    IUnknown ** ppvObject) PURE;


  //***********************************************************
  //
  // CreateMetaInstance()
  //
  /// Creates a single uninitialized AAF meta class or type associated 
  /// with a specified stored object id. 
  /// 
  /// @param id Identifier (id) of a  class or type definition. This is the
  ///           corresponding SMPTE identifier (as a GUID) for all predefined
  ///           built-in definitions.
  /// @param riid Reference to the identifier of the interface
  /// @param ppMetaDefinition Address of output variable that receives the
  ///                         interface pointer requested in riid
  ///
  STDMETHOD(CreateMetaInstance)(THIS_
    aafUID_constref id,
    REFIID riid,
    IUnknown ** ppMetaDefinition) PURE;



  //***********************************************************
  //
  // RegisterClassDef()
  //
  /// Add the class definition object to the dictionary.
  /// 
  /// Succeeds if:
  /// - The pClassDef pointer is valid.
  /// - the ID contained in the class def is not already been
  ///   registered.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pClassDef arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The class def ID has already been registered.
  ///
  /// @param pClassDef [in] Class Definition
  ///
  STDMETHOD(RegisterClassDef) (THIS_
    IAAFClassDef * pClassDef) PURE;


  //***********************************************************
  //
  // LookupClassDef()
  //
  /// Return the class definition with the given id.
  /// 
  /// Succeeds if:
  /// - The pClassID pointer is valid.
  /// - The ppClassDef pointer is valid.
  /// - the ID is a recognized id for a class definition.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pClassID or ppClassDef arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given ID is not recognized as a class definition ID.
  ///
  /// @param classId [in, ref] Class Unique ID
  /// @param ppClassDef [out,retval] Class Definition
  ///
  STDMETHOD(LookupClassDef) (THIS_
    aafUID_constref  classId,
    IAAFClassDef ** ppClassDef) PURE;


  //***********************************************************
  //
  // GetClassDefs()
  //
  /// Return an enumerator for all class definitions.
  ///
  /// Succeeds if:
  /// - The ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  ///
  /// @param ppEnum [out,retval] Class Definition Enumeration
  ///
  STDMETHOD(GetClassDefs) (THIS_
    IEnumAAFClassDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountClassDefs()
  //
  /// Writes the number of class definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  ///
  /// @param pResult [out, retval] Total number of class definition objects
  ///
  STDMETHOD(CountClassDefs) (THIS_
    aafUInt32 *  pResult) PURE;

  //***********************************************************
  //
  // CreateForwardClassReference()
  //
  /// Return the class definition with the given id.
  /// 
  /// Succeeds if:
  /// - The classId does not represent an existing forward class reference
  ///   or a class definition that has already been successfully registered.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given ID is not recognized as a class definition ID.
  ///
  /// @param classId [in, ref] Class Unique ID
  ///
  STDMETHOD(CreateForwardClassReference) (THIS_
    aafUID_constref  classId) PURE;

  //***********************************************************
  //
  // HasForwardClassReference()
  //
  /// Return kAAFTrue if the given class identification is a forward reference.
  /// 
  /// Succeeds if:
  /// - The pClassID pointer is valid.
  /// - The ppClassDef pointer is valid.
  /// - the ID is a recognized id for a class definition.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pClassID or ppClassDef arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given ID is not recognized as a class definition ID.
  ///
  /// @param classId [in, ref] Class Unique ID
  /// @param pResult [out,retval] true if forward class reference; false if not a forward class reference
  ///
  STDMETHOD(HasForwardClassReference) (THIS_
    aafUID_constref  classId,
    aafBoolean_t *  pResult) PURE;

  //***********************************************************
  //
  // RegisterTypeDef()
  //
  /// Add the type definition object to the dictionary.
  /// 
  /// Succeeds if:
  /// - The pTypeDef pointer is valid.
  /// - the ID is not already been registered.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pClassDef arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given type has already been registered.
  ///
  /// @param pTypeDef [in] Type Definition Object
  ///
  STDMETHOD(RegisterTypeDef) (THIS_
    IAAFTypeDef * pTypeDef) PURE;


  //***********************************************************
  //
  // LookupTypeDef()
  //
  /// Return the type definition object with the given id.
  /// 
  /// Succeeds if:
  /// - The pTypeID pointer is valid.
  /// - The ppTypeDef pointer is valid.
  /// - the ID is a recognized id for a type definition.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pTypeID or ppTypeDef arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given ID is not recognized as a type definition ID.
  ///
  /// @param typeId [in, ref] Type Unique ID
  /// @param ppTypeDef [out,retval] Type Definition Object
  ///
  STDMETHOD(LookupTypeDef) (THIS_
    aafUID_constref  typeId,
    IAAFTypeDef ** ppTypeDef) PURE;


  //***********************************************************
  //
  // GetTypeDefs()
  //
  /// Return an enumerator for all type definitions.
  ///
  /// Succeeds if:
  /// - The ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  ///
  /// @param ppEnum [out,retval] Type Def Enumeration
  ///
  STDMETHOD(GetTypeDefs) (THIS_
    IEnumAAFTypeDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountTypeDefs()
  //
  /// Writes the number of type definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  ///
  /// @param pResult [out, retval] Total number of type definition objects
  ///
  STDMETHOD(CountTypeDefs) (THIS_
    aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // RegisterOpaqueTypeDef()
  //
  /// Add the opaquetype definition object to the dictionary.
  /// 
  /// Succeeds if:
  /// - The pTypeDef pointer is valid.
  /// - the definition is not already been registered with RegisterTypeDef.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTypeDef arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given type has already been registered.
  ///
  /// @param pTypeDef [in] Type Definition Object
  ///
  STDMETHOD(RegisterOpaqueTypeDef) (THIS_
    IAAFTypeDef * pTypeDef) PURE;


  //***********************************************************
  //
  // LookupOpaqueTypeDef()
  //
  /// Return the opaque type definition object with the given id.
  /// 
  /// Succeeds if:
  /// - The pTypeID pointer is valid.
  /// - The ppTypeDef pointer is valid.
  /// - the ID is a recognized id for an opaque type definition.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either typeId or ppTypeDef arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given ID is not recognized as a type definition ID.
  ///
  /// @param typeId [in, ref] Type Unique ID
  /// @param ppTypeDef [out,retval] Type Definition Object
  ///
  STDMETHOD(LookupOpaqueTypeDef) (THIS_
    aafUID_constref  typeId,
    IAAFTypeDef ** ppTypeDef) PURE;


  //***********************************************************
  //
  // GetOpaqueTypeDefs()
  //
  /// Return an enumerator for all registered opaque type definitions.
  ///
  /// Succeeds if:
  /// - The ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  ///
  /// @param ppEnum [out,retval] Type Def Enumeration
  ///
  STDMETHOD(GetOpaqueTypeDefs) (THIS_
    IEnumAAFTypeDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountOpaqueTypeDefs()
  //
  /// Writes the number of opaque type definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  ///
  /// @param pResult [out, retval] Total number of opaque type definition objects
  ///
  STDMETHOD(CountOpaqueTypeDefs) (THIS_
    aafUInt32 *  pResult) PURE;

  //***********************************************************
  //
  // RegisterKLVDataKey()
  //
  /// Add the definition for the given KLV key to the runtime dictionary.
  /// The pTypeDef will often be kAAFTypeID_UInt8Array,
  /// but may be something else.
  /// 
  /// Succeeds if:
  /// - The pTypeDef pointer is valid.
  /// - the definition is not already been registered with RegisterTypeDef.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTypeDef arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given type has already been registered.
  ///
  /// @param pUID [in] Key to define
  /// @param pTypeDef [in] Type Definition Object
  ///
  STDMETHOD(RegisterKLVDataKey) (THIS_
    aafUID_t  pUID,
    IAAFTypeDef * pTypeDef) PURE;

  //***********************************************************
  //
  // RegisterDataDef()
  //
  /// Add the data definition object to the header's list of definitions.
  ///
  /// @param pDataDef [in] Data Definition Object
  ///
  STDMETHOD(RegisterDataDef) (THIS_
    IAAFDataDef * pDataDef) PURE;


  //***********************************************************
  //
  // LookupDataDef()
  //
  /// Return the data definition object with the given id.
  ///
  /// @param dataDefinitionId [in, ref] Data Definition Unique ID
  /// @param ppDataDef [out,retval] Data Definition Object
  ///
  STDMETHOD(LookupDataDef) (THIS_
    aafUID_constref  dataDefinitionId,
    IAAFDataDef ** ppDataDef) PURE;


  //***********************************************************
  //
  // GetDataDefs()
  //
  /// Return an enumerator for aff data definitions.
  ///
  /// @param ppEnum [out,retval] Definition Enumeration
  ///
  STDMETHOD(GetDataDefs) (THIS_
    IEnumAAFDataDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountDataDefs()
  //
  /// Writes the number of data definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  ///
  /// @param pResult [out, retval] Total number of data definition objects
  ///
  STDMETHOD(CountDataDefs) (THIS_
    aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // RegisterOperationDef()
  //
  /// Add the operation definition object to the header's list of definitions.
  ///
  /// @param pOperationDef [in] Operation Definition Object
  ///
  STDMETHOD(RegisterOperationDef) (THIS_
    IAAFOperationDef * pOperationDef) PURE;


  //***********************************************************
  //
  // LookupOperationDef()
  //
  /// Return the operation definition object with the given id.
  ///
  /// @param operationId [in, ref] Operation Def Unique ID
  /// @param ppOperationDef [out,retval] Operation definition object
  ///
  STDMETHOD(LookupOperationDef) (THIS_
    aafUID_constref  operationId,
    IAAFOperationDef ** ppOperationDef) PURE;


  //***********************************************************
  //
  // GetOperationDefs()
  //
  /// Return an enumerator for all operation definitions.
  ///
  /// @param ppEnum [out,retval] Definition Enumeration
  ///
  STDMETHOD(GetOperationDefs) (THIS_
    IEnumAAFOperationDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountOperationDefs()
  //
  /// Writes the number of operation definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  ///
  /// @param pResult [out, retval] Total number of operation definition objects
  ///
  STDMETHOD(CountOperationDefs) (THIS_
    aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // RegisterParameterDef()
  //
  /// Add the parameter definition object to the header's list of definitions.
  ///
  /// @param pParmDef [in] Parameter Definition Object
  ///
  STDMETHOD(RegisterParameterDef) (THIS_
    IAAFParameterDef * pParmDef) PURE;


  //***********************************************************
  //
  // LookupParameterDef()
  //
  /// Return the parameter definition object with the given id.
  ///
  /// @param parameterId [in, ref] Parameter Unique ID
  /// @param ppParmDef [out,retval] Parameter definition object
  ///
  STDMETHOD(LookupParameterDef) (THIS_
    aafUID_constref  parameterId,
    IAAFParameterDef ** ppParmDef) PURE;


  //***********************************************************
  //
  // GetParameterDefs()
  //
  /// Return an enumerator for all parameter definitions.
  ///
  /// @param ppEnum [out,retval] Definition Enumeration
  ///
  STDMETHOD(GetParameterDefs) (THIS_
    IEnumAAFParameterDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountParameterDefs()
  //
  /// Writes the number of parameter definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  ///
  /// @param pResult [out, retval] Total number of parameter definition objects
  ///
  STDMETHOD(CountParameterDefs) (THIS_
    aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // RegisterCodecDef()
  //
  /// Add the codec definition object to the header's list of definitions.
  ///
  /// @param pParmDef [in] Codec Definition Object
  ///
  STDMETHOD(RegisterCodecDef) (THIS_
    IAAFCodecDef * pParmDef) PURE;


  //***********************************************************
  //
  // LookupCodecDef()
  //
  /// Return the codec definition object with the given id.
  ///
  /// @param parameterId [in, ref] Parameter Unique ID
  /// @param ppParmDef [out,retval] Codec definition object
  ///
  STDMETHOD(LookupCodecDef) (THIS_
    aafUID_constref  parameterId,
    IAAFCodecDef ** ppParmDef) PURE;


  //***********************************************************
  //
  // GetCodecDefs()
  //
  /// Return an enumerator for all codec definitions.
  ///
  /// @param ppEnum [out,retval] Definition Enumeration
  ///
  STDMETHOD(GetCodecDefs) (THIS_
    IEnumAAFCodecDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountCodecDefs()
  //
  /// Writes the number of codec definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  ///
  /// @param pResult [out, retval] Total number of codec definition objects
  ///
  STDMETHOD(CountCodecDefs) (THIS_
    aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // RegisterContainerDef()
  //
  /// Add the container definition object to the header's list of definitions.
  ///
  /// @param pParmDef [in] Container Definition Object
  ///
  STDMETHOD(RegisterContainerDef) (THIS_
    IAAFContainerDef * pParmDef) PURE;


  //***********************************************************
  //
  // LookupContainerDef()
  //
  /// Return the container definition object with the given id.
  ///
  /// @param parameterId [in, ref] Parameter Unique ID
  /// @param ppParmDef [out,retval] Container definition object
  ///
  STDMETHOD(LookupContainerDef) (THIS_
    aafUID_constref  parameterId,
    IAAFContainerDef ** ppParmDef) PURE;


  //***********************************************************
  //
  // GetContainerDefs()
  //
  /// Return an enumerator for all container definitions.
  ///
  /// @param ppEnum [out,retval] Definition Enumeration
  ///
  STDMETHOD(GetContainerDefs) (THIS_
    IEnumAAFContainerDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountContainerDefs()
  //
  /// Writes the number of container definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  ///
  /// @param pResult [out, retval] Total number of container definition objects
  ///
  STDMETHOD(CountContainerDefs) (THIS_
    aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // RegisterInterpolationDef()
  //
  /// Add the Interpolation definition object to the header's list of definitions.
  ///
  /// @param pInterpolationDef [in] Interpolation Definition Object
  ///
  STDMETHOD(RegisterInterpolationDef) (THIS_
    IAAFInterpolationDef * pInterpolationDef) PURE;


  //***********************************************************
  //
  // LookupInterpolationDef()
  //
  /// Return the Interpolation definition object with the given id.
  ///
  /// @param parameterId [in, ref] Parameter Unique ID
  /// @param ppInterpolationDef [out,retval] Interpolation definition object
  ///
  STDMETHOD(LookupInterpolationDef) (THIS_
    aafUID_constref  parameterId,
    IAAFInterpolationDef ** ppInterpolationDef) PURE;


  //***********************************************************
  //
  // GetInterpolationDefs()
  //
  /// Return an enumerator for aff Interpolation definitions.
  ///
  /// @param ppEnum [out,retval] Definition Enumeration
  ///
  STDMETHOD(GetInterpolationDefs) (THIS_
    IEnumAAFInterpolationDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountInterpolationDefs()
  //
  /// Writes the number of interpolation definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  ///
  /// @param pResult [out, retval] Total number of interpolation definition objects
  ///
  STDMETHOD(CountInterpolationDefs) (THIS_
    aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // RegisterPluginDef()
  //
  /// Add the plugin definition object to the header's list of definitions.
  ///
  /// @param pPlugDef [in] plugin definition Object
  ///
  STDMETHOD(RegisterPluginDef) (THIS_
    IAAFPluginDef * pPlugDef) PURE;


  //***********************************************************
  //
  // LookupPluginDef()
  //
  /// Return the plugin descriptor object with the given id.
  ///
  /// @param parameterId [in, ref] Parameter Unique ID
  /// @param ppPlugDef [out,retval] plugin descriptor object
  ///
  STDMETHOD(LookupPluginDef) (THIS_
    aafUID_constref  parameterId,
    IAAFPluginDef ** ppPlugDef) PURE;


  //***********************************************************
  //
  // GetPluginDefs()
  //
  /// Return an enumerator for all plugin descriptors.
  ///
  /// @param ppEnum [out,retval] Definition Enumeration
  ///
  STDMETHOD(GetPluginDefs) (THIS_
    IEnumAAFPluginDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountPluginDefs()
  //
  /// Writes the number of plugin definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  ///
  /// @param pResult [out, retval] Total number of plugin definition objects
  ///
  STDMETHOD(CountPluginDefs) (THIS_
    aafUInt32 *  pResult) PURE;

























  END_INTERFACE
};
#endif // __IAAFDictionary_INTERFACE_DEFINED__


// IAAFDigitalImageDescriptor

// ************************
//
// Interface IAAFDigitalImageDescriptor
//
// ************************



#ifndef __IAAFDigitalImageDescriptor_INTERFACE_DEFINED__
#define __IAAFDigitalImageDescriptor_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFDigitalImageDescriptor;


#undef  INTERFACE
#define INTERFACE   IAAFDigitalImageDescriptor

DECLARE_INTERFACE_(IAAFDigitalImageDescriptor, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFDigitalImageDescriptor methods *** */

  //***********************************************************
  //
  // SetCompression()
  //
  /// Sets the kind of compression and format of compression
  /// information of the video essence data.  This property is
  /// optional.  If there is no compression, the property is omitted.
  /// 
  /// If this method fails the Data Definition property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param compression [in] Optional.
  ///
  STDMETHOD(SetCompression) (THIS_
    aafUID_constref  compression) PURE;


  //***********************************************************
  //
  // GetCompression()
  //
  /// Gets the kind of compression and format of compression
  /// information of the video essence data.  This property is
  /// optional.
  ///
  /// Succeeds if all of the following are true:
  /// - the pCompression pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pCompression.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pComporession arg is NULL.
  ///
  /// @param pCompression [out] Optional.
  ///
  STDMETHOD(GetCompression) (THIS_
    aafUID_t *  pCompression) PURE;


  //***********************************************************
  //
  // SetStoredView()
  //
  /// Sets the dimension of the stored view.  Typically this includes
  /// leading blank video lines, any VITC lines, as well as the active
  /// picture area.
  /// 
  /// If this method fails the Stored Height and Stored Width
  /// properties will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param StoredHeight [in] Number of pixels in vertical dimension of stored view.
  /// @param StoredWidth [in] Number of pixels in horizontal dimension of stored view.
  ///
  STDMETHOD(SetStoredView) (THIS_
    aafUInt32  StoredHeight,
    aafUInt32  StoredWidth) PURE;


  //***********************************************************
  //
  // GetStoredView()
  //
  /// Gets the dimension of the stored view.  Typically this includes
  /// leading blank video lines, any VITC lines, as well as the active
  /// picture area.
  /// 
  /// Succeeds if all of the following are true:
  /// - pStoredHieght and pStoredWidth are valid pointers.
  /// 
  /// If this method fails, the *pStoredHieght and *pStoredWidth will
  /// not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pStoredHeight or pStoredWidth is NULL.
  ///
  /// @param pStoredHeight [out] Number of pixels in vertical dimension of stored view.
  /// @param pStoredWidth [out] Number of pixels in horizontal dimension of stored view.
  ///
  STDMETHOD(GetStoredView) (THIS_
    aafUInt32 *  pStoredHeight,
    aafUInt32 *  pStoredWidth) PURE;


  //***********************************************************
  //
  // SetSampledView()
  //
  /// Sets the dimensions of sampled view.  Typically this includes
  /// any VITC lines as well as the active picture area, but excludes
  /// leading blank video lines.  The offset is specified relative to
  /// the rectangle specified by Set/GetStoredView().
  ///
  /// The following properties are optional:
  ///
  ///     SampledXOffset - The default value is 0.  Use a value of 0 to
  ///                      select the default.
  ///     SampledYOffset - The default value is 0.  Use a value of 0 to
  ///                      select the default.
  ///
  /// Succeeds if all of the following are true:
  /// - The given dimensions exist within the StoredView.
  /// 
  /// If this method fails, the SampledXOffset and SampledYOffset
  /// properties will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - The area specified by SampledHeight and SampledXOffset is
  ///     outside the StoredView, or the area specified by SampledWidth
  ///     and SampledYOffset is outside the StoredView.
  ///
  /// @param SampledHeight [in] Number of pixels in vertical dimension of sampled view.
  /// @param SampledWidth [in] Number of pixels in horizontal dimension of sampled view.
  /// @param SampledXOffset [in] Number of pixels from top left corner of sampled view. Optional.
  /// @param SampledYOffset [in] Number of pixels from top left corner of sampled view. Optional.
  ///
  STDMETHOD(SetSampledView) (THIS_
    aafUInt32  SampledHeight,
    aafUInt32  SampledWidth,
    aafInt32  SampledXOffset,
    aafInt32  SampledYOffset) PURE;


  //***********************************************************
  //
  // GetSampledView()
  //
  /// Gets the dimensions of sampled view.  Typically this includes
  /// any VITC lines as well as the active picture area, but excludes
  /// leading blank video lines.  The offset is specified relative to
  /// the rectangle specified by Set/GetStoredView().
  ///
  /// Succeeds if all of the following are true:
  /// - pSampledHeight, pSampledWidth, pSampledXOffset and
  ///   pSampledYOffset are valid pointers
  /// 
  /// If any of the input parameters are NULL, the property will not
  /// be returned.
  ///
  /// If this method fails, *pSampledHeight, *pSampledWidth,
  /// *pSampledXOffset, and *pSampledYOffset will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - any of pSampledHeight, pSampledWidth, pSampledXOffset, or
  ///     pSampledYOffset are NULL.
  ///
  /// @param pSampledHeight [out] Number of pixels in vertical dimension of sampled view.
  /// @param pSampledWidth [out] Number of pixels in horizontal dimension of sampled view.
  /// @param pSampledXOffset [out] Number of pixels from top left corner of sampled view. Optional.
  /// @param pSampledYOffset [out] Number of pixels from top left corner of sampled view. Optional.
  ///
  STDMETHOD(GetSampledView) (THIS_
    aafUInt32 *  pSampledHeight,
    aafUInt32 *  pSampledWidth,
    aafInt32 *  pSampledXOffset,
    aafInt32 *  pSampledYOffset) PURE;


  //***********************************************************
  //
  // SetDisplayView()
  //
  /// Sets the dimension of display view.  Typically this includes
  /// the active picture area, but excludes leading blank video lines
  /// and any VITC lines.  The offset is specified relative to the
  /// rectangle specified by Set/GetStoredView().
  /// 
  /// The following properties are optional:
  ///
  ///     DisplayHeight  - The default value is the storedHeight. Use
  ///                      storedHeight to select the default.
  ///     DisplayWidth   - The default value is the storedWidth. Use
  ///                      storedWidth to select the default.
  ///     DisplayXOffset - The default value is 0.  Use a value of 0 to
  ///                      select the default.
  ///     DisplayYOffset - The default value is 0.  Use a value of 0 to
  ///                      select the default.
  ///
  /// Note that The specified display rectangle may exist outside the
  /// SampledView or even the StoredView.
  ///
  /// If this method fails the DisplayHeight, DisplayWidth, DisplayXOffset and
  /// DisplayYOffset properties will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - The area specified by DisplayHeight and DisplayXOffset is
  ///     outside the StoredView, or the area specified by DisplayWidth
  ///     and DisplayYOffset is outside the StoredView.
  ///
  /// @param DisplayHeight [in] Number of pixels in vertical dimension of display view. Optional.
  /// @param DisplayWidth [in] Number of pixels in horizontal dimension of display view. Optional.
  /// @param DisplayXOffset [in] Number of pixels from the top-left corner of the display view. Optional.
  /// @param DisplayYOffset [in] Number pixels from the top-left corner of the display view. Optional.
  ///
  STDMETHOD(SetDisplayView) (THIS_
    aafUInt32  DisplayHeight,
    aafUInt32  DisplayWidth,
    aafInt32  DisplayXOffset,
    aafInt32  DisplayYOffset) PURE;


  //***********************************************************
  //
  // GetDisplayView()
  //
  /// Gets the dimension of display view.  Typically this includes
  /// the active picture area, but excludes leading blank video lines
  /// and any VITC lines.  The offset is specified relative to the
  /// rectangle specified by Set/GetStoredView().
  /// 
  /// Note that The specified display rectangle may exist outside the
  /// SampledView or even the StoredView.
  ///
  /// Succeeds if all of the following are true:
  /// - pDisplayHeight, pDisplayWidth, pDisplayXOffset and
  ///   pDisplayYOffset are valid pointers.
  /// 
  /// If this method fails, *pDisplayHeight, *pDisplayWidth,
  /// *pDisplayXOffset, and *pDisplayYOffset will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - any of pDisplayHeight, pDisplayWidth, pDisplayXOffset, or
  ///     pDisplayYOffset are NULL.
  ///
  /// @param pDisplayHeight [out] Number of pixels in vertical dimension of display view. Optional.
  /// @param pDisplayWidth [out] Number of pixels in horizontal dimension of display view. Optional.
  /// @param pDisplayXOffset [out] Number of pixels from the top-left corner of the display view. Optional.
  /// @param pDisplayYOffset [out] Number pixels from the top-left corner of the display view. Optional.
  ///
  STDMETHOD(GetDisplayView) (THIS_
    aafUInt32 *  pDisplayHeight,
    aafUInt32 *  pDisplayWidth,
    aafInt32 *  pDisplayXOffset,
    aafInt32 *  pDisplayYOffset) PURE;


  //***********************************************************
  //
  // SetFrameLayout()
  //
  /// Sets the frame layout.  The frame layout describes whether all
  /// data for a complete sample is in one frame or is split into more
  /// than/ one field.
  ///
  /// Values are:
  ///
  ///    kNoLayout       - Default; not a valid value.
  ///    kFullFrame      - Each frame contains a full sample in
  ///                      progressive scan lines.
  ///    kSeparateFields - Each sample consists of two fields, which
  ///                      when interlaced produce a full sample.
  ///    kOneField       - Each sample consists of two interlaced
  ///                      fields, but only one field is stored in the
  ///                      data stream.
  ///    kMixedFields    - Similar to FullFrame, except the two fields
  ///                      may have been sampled at different times.
  /// 
  /// Succeeds if all of the following are true:
  /// - frameLayout is a valid value
  /// 
  /// If this method fails, the Frame Layout property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - FrameLayout is not a valid value.
  ///
  /// @param FrameLayout [in] layout of the frame
  ///
  STDMETHOD(SetFrameLayout) (THIS_
    aafFrameLayout_t  FrameLayout) PURE;


  //***********************************************************
  //
  // GetFrameLayout()
  //
  /// Gets the frame layout.  The frame layout describes whether all
  /// data for a complete sample is in one frame or is split into more
  /// than one field.
  /// 
  /// Values are:
  ///
  ///    kNoLayout       - Default; not a valid value.
  ///    kFullFrame      - Each frame contains a full sample in
  ///                      progressive scan lines.
  ///    kSeparateFields - Each sample consists of two fields, which
  ///                      when interlaced produce a full sample.
  ///    kOneField       - Each sample consists of two interlaced
  ///                      fields, but only one field is stored in the
  ///                      data stream.
  ///    kMixedFields    - Similar to FullFrame, except the two fields
  ///                      may have been sampled at different times.
  /// 
  /// Succeeds if all of the following are true:
  /// - pFrameLayout is a valid pointer
  /// 
  /// If this method fails, *pFrameLayout will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFrameLayout is NULL.
  ///
  /// @param pFrameLayout [out] layout of the frame
  ///
  STDMETHOD(GetFrameLayout) (THIS_
    aafFrameLayout_t *  pFrameLayout) PURE;


  //***********************************************************
  //
  // SetVideoLineMap()
  //
  /// Sets the VideoLineMap property.  The video line map specifies the
  /// scan line in the analog source that corresponds to the beginning
  /// of each digitized field.  For single-field video, there is 1
  /// value in the array.  For interleaved video, there are 2 values
  /// in the array.
  /// 
  /// Succeeds if all of the following are true:
  /// - pVideoLineMap is a valid pointer
  /// 
  /// If this method fails, the Video Line Map property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pVideoLineMap is NULL.
  ///
  /// @param numberElements [in] The number of elements in the array
  /// @param pVideoLineMap [in, size_is(numberElements)] Array to hold the Video Line Map information
  ///
  STDMETHOD(SetVideoLineMap) (THIS_
    aafUInt32  numberElements,
    aafInt32 *  pVideoLineMap) PURE;


  //***********************************************************
  //
  // GetVideoLineMap()
  //
  /// Gets the VideoLineMap property.  The video line map specifies the
  /// scan line in the analog source that corresponds to the beginning of each
  /// digitized field.  For single-field video, there is 1 value in the array.
  /// For interleaved video, there are 2 values in the array.
  ///
  /// The values are written to the array specified by pVideoLineMap,
  /// which is of size numberElements.  The required size may be found
  /// by calling GetVideoLineMapSize().
  /// 
  /// Succeeds if all of the following are true:
  /// - pVideoLineMap is a valid pointer.
  /// - numberElements indicates the array is large enough to hold the
  ///   data.
  /// 
  /// If this method fails, videoLineMap will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumberElements is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - numberElements indicates that the array is too small to hold
  ///     the data.
  ///
  /// @param numberElements [in] The number of elements in the array
  /// @param pVideoLineMap [out, size_is(numberElements)] Array to hold the Video Line Map information
  ///
  STDMETHOD(GetVideoLineMap) (THIS_
    aafUInt32  numberElements,
    aafInt32 *  pVideoLineMap) PURE;


  //***********************************************************
  //
  // GetVideoLineMapSize()
  //
  /// Get the number of elements in the VideoLineMap property array.
  /// 
  /// Succeeds if all of the following are true:
  /// - pNumberElements is a valid pointer
  /// 
  /// If this method fails, *pNumberElements will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumberElements is NULL.
  ///
  /// @param pNumberElements [out] The number of elements in the array
  ///
  STDMETHOD(GetVideoLineMapSize) (THIS_
    aafUInt32 *  pNumberElements) PURE;


  //***********************************************************
  //
  // SetImageAspectRatio()
  //
  /// Sets the Image Aspect Ratio property.  This ratio describes the
  /// ratio between the horizontal size and the vertical size in the
  /// intended final image.
  ///
  /// Succeeds if all of the following are true:
  /// - 
  /// 
  /// If this method fails, the Image Access Ratio property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param ImageAspectRatio [in] Ratio between horizontal and vertical size
  ///
  STDMETHOD(SetImageAspectRatio) (THIS_
    aafRational_t  ImageAspectRatio) PURE;


  //***********************************************************
  //
  // GetImageAspectRatio()
  //
  /// Gets the Image Aspect Ratio property.  This ratio describes the
  /// ratio between the horizontal size and the vertical size in the
  /// intended final image.
  ///
  /// Succeeds if all of the following are true:
  /// - pImageAspectRatio is a valid pointer
  /// 
  /// If this method fails, *pImageAspectRatio will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pImageAspectRatio is NULL.
  ///
  /// @param pImageAspectRatio [out] Ratio between horizontal and vertical size
  ///
  STDMETHOD(GetImageAspectRatio) (THIS_
    aafRational_t *  pImageAspectRatio) PURE;


  //***********************************************************
  //
  // SetAlphaTransparency()
  //
  /// Sets the AlphaTransparency property.  This property is optional.
  ///
  /// Valid values:
  ///	kMaxValueTransparent - means the maximum Alpha value is
  ///                           transparent
  ///    kMinValueTransparent - means the minimum Alpha value is
  ///                           transparent
  ///
  /// Succeeds if all of the following are true:
  /// - AlphaTransparency is a valid value.
  /// 
  /// If this method fails, the AlphaTransparency property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - AlphaTransparency is not a valid value.
  ///
  /// @param AlphaTransparency [in] Alpha Transparency value.
  ///
  STDMETHOD(SetAlphaTransparency) (THIS_
    aafAlphaTransparency_t  AlphaTransparency) PURE;


  //***********************************************************
  //
  // GetAlphaTransparency()
  //
  /// Gets the AlphaTransparency property.  This property is optional.
  ///
  /// Valid values:
  ///	kMaxValueTransparent - means the maximum Alpha value is transparent
  ///    kMinValueTransparent - means the minimum Alpha value is transparent
  ///
  /// Succeeds if all of the following are true:
  /// - pAlphaTransparency is a valid pointer
  /// 
  /// If this method fails, pAlphaTransparency not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pAlphaTransparency is NULL.
  ///
  /// @param pAlphaTransparency [out] Alpha Transparency value.
  ///
  STDMETHOD(GetAlphaTransparency) (THIS_
    aafAlphaTransparency_t *  pAlphaTransparency) PURE;


  //***********************************************************
  //
  // SetGamma()
  //
  /// Sets the TransferCharacteristic property.
  ///
  /// Succeeds if all of the following are true:
  /// - 
  /// 
  /// If this method fails, the Gamma property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param Gamma [in] Optional
  ///
  STDMETHOD(SetGamma) (THIS_
    aafUID_t  Gamma) PURE;


  //***********************************************************
  //
  // GetGamma()
  //
  /// Gets the TransferCharacteristic property.
  ///
  /// Succeeds if all of the following are true:
  /// - pGamma is a valid pointer
  /// 
  /// If this method fails, pGamma will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pGamma is NULL.
  ///
  /// @param pGamma [out] Optional.
  ///
  STDMETHOD(GetGamma) (THIS_
    aafUID_t *  pGamma) PURE;


  //***********************************************************
  //
  // SetImageAlignmentFactor()
  //
  /// Sets the ImageAlignmentFactor property.  Specifies the alignment
  /// when storing the digital essence.  For example, a value of 16
  /// means that the image is stored on 16-byte boundaries.  The
  /// starting point for a field will always be a multiple of 16 bytes.
  /// If the field does not end on a 16-byte boundary, it is padded
  /// out to the next 16-byte boundary.
  ///
  /// Succeeds if all of the following are true:
  /// 
  /// If this method fails, the ImageAlignmentFactor property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param ImageAlignmentFactor [in] Optional.
  ///
  STDMETHOD(SetImageAlignmentFactor) (THIS_
    aafUInt32  ImageAlignmentFactor) PURE;


  //***********************************************************
  //
  // GetImageAlignmentFactor()
  //
  /// Gets the ImageAlignmentFactor property.  Specifies the alignment when
  /// storing the digital essence.  For example, a value of 16 means that the image
  /// is stored on 16-byte boundaries.  The starting point for a field will always
  /// be a multiple of 16 bytes.  If the field does not end on a 16-byte boundary,
  /// it is padded out to the next 16-byte boundary.
  ///
  ///
  /// Succeeds if all of the following are true:
  /// - pImageAlignmentFactor is a valid pointer
  /// 
  /// If this method fails, pImageAlignmentFactor will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pImageAlignmentFactor is NULL.
  ///
  /// @param pImageAlignmentFactor [out] Optional.
  ///
  STDMETHOD(GetImageAlignmentFactor) (THIS_
    aafUInt32 *  pImageAlignmentFactor) PURE;























  END_INTERFACE
};
#endif // __IAAFDigitalImageDescriptor_INTERFACE_DEFINED__


// IAAFEdgecode

// ************************
//
// Interface IAAFEdgecode
//
// ************************
 



#ifndef __IAAFEdgecode_INTERFACE_DEFINED__
#define __IAAFEdgecode_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFEdgecode;

#undef  INTERFACE
#define INTERFACE   IAAFEdgecode

DECLARE_INTERFACE_(IAAFEdgecode, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFEdgecode methods *** */


  //***********************************************************
  //
  // Initialize()
  //
  /// This function creates a new edgecode clip with the
  /// given property values.  The edgecode value is represented with an
  /// aafEdgecode_t struct consisting of startFrame, filmKind, and
  /// codeFormat.
  ///
  /// @param length   [in] Length Property Value
  /// @param edgecode [in] Edgecode Value
  ///
  STDMETHOD(Initialize) (THIS_
    aafLength_t    length  ,
    aafEdgecode_t  edgecode) PURE;

  //***********************************************************
  //
  // GetEdgecode()
  //
  /// This set of functions returns the required property values
  /// for the object identified by XXX.
  ///
  /// @param edgecode [out] Edgecode
  ///
  STDMETHOD(GetEdgecode) (THIS_
    aafEdgecode_t *  edgecode) PURE;


  END_INTERFACE
};
#endif // __IAAFEdgecode_INTERFACE_DEFINED__



// IAAFEssenceAccess

// ************************
//
// Interface IAAFEssenceAccess
//
// ************************









#ifndef __IAAFEssenceAccess_INTERFACE_DEFINED__
#define __IAAFEssenceAccess_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFEssenceAccess;

#undef  INTERFACE
#define INTERFACE   IAAFEssenceAccess

DECLARE_INTERFACE_(IAAFEssenceAccess, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFEssenceAccess methods *** */


  //***********************************************************
  //
  // SetEssenceCodecFlavour()
  //
  /// Sets which flavour of the codec ID is to be used.
  ///
  /// An example of a flavour would be a number of standard starting
  /// JPEG tables.
  ///
  /// @param flavour [in, ref] The particular flavour
  ///
  STDMETHOD(SetEssenceCodecFlavour) (THIS_
    aafUID_constref  flavour) PURE;


  //***********************************************************
  //
  // WriteSamples()
  //
  /// Writes data to the given essence stream.
  ///
  /// A single video frame is ONE sample.
  ///
  /// Buflen must be large enough to hold the total sample size.
  ///
  /// Possible Errors:
  ///   AAFRESULT_SINGLE_CHANNEL_OP -- Tried to write to an interleaved
  ///                                  stream.
  ///   AAFRESULT_BADDATAADDRESS    -- The buffer must not be a NULL
  ///                                  pointer.
  ///
  /// @param nSamples [in] write this many samples
  /// @param buflen [in] from a buffer of this size
  /// @param buffer [in,size_is(buflen)] from a buffer
  /// @param samplesWritten [out, ref] The number of samples actually written
  /// @param bytesWritten [out, ref] The number of bytes actually written
  ///
  STDMETHOD(WriteSamples) (THIS_
    aafUInt32  nSamples,
    aafUInt32  buflen,
    aafDataBuffer_t  buffer,
    aafUInt32 *  samplesWritten,
    aafUInt32 *  bytesWritten) PURE;


  //***********************************************************
  //
  // GetLargestSampleSize()
  //
  /// Returns the size in bytes of the largest sample for a given
  /// essence type.
  ///
  /// For uncompressed data, or the output of the software codec, the
  /// sample size will propably be a constant.
  ///
  /// The essence type parameter exists to support codecs with multiple
  /// interleaved essence types.
  ///
  /// @param pDataDef [in] for this essence type
  /// @param maxSize [out] the largest sample size
  ///
  STDMETHOD(GetLargestSampleSize) (THIS_
    IAAFDataDef * pDataDef,
    aafLength_t*  maxSize) PURE;


  //***********************************************************
  //
  // GetIndexedSampleSize()
  //
  /// Returns the size in bytes of the given sample for a given essence
  /// type.
  ///
  /// For uncompressed data, or the output of the software codec, the
  /// sample size will propably be a constant.
  ///
  /// The essence type parameter exists to support codecs with multiple
  /// interleaved essence types.
  /// 
  /// Possible Errors:
  ///   AAFRESULT_NULL_PARAM      -- A return parameter was NULL.
  ///   AAFRESULT_BADSAMPLEOFFSET -- The supplied sample offset is out
  ///                                of range.
  ///
  /// @param pDataDef [in] and this essence type
  /// @param frameNum [in] for this [0-based] sample frame number
  /// @param frameSize [out] How big is the sample frame?
  ///
  STDMETHOD(GetIndexedSampleSize) (THIS_
    IAAFDataDef * pDataDef,
    aafPosition_t  frameNum,
    aafLength_t*  frameSize) PURE;


  //***********************************************************
  //
  // SetTransformParameters()
  //
  /// Sets a series of format objects which will be used to describe
  /// the in-memory format.
  ///
  /// This is the format expected on writes and produced on reads.
  ///
  /// On writes, the data will be written in this format, except
  /// where a software codec may be used.  On reads, the data will be
  /// translated to this format.
  ///
  /// The order of the parameters does matter, as transformations will
  /// be applied in that order to get from the on-disk format to the
  /// in-memory format.
  ///
  /// @param op [in] A set of transforms to apply to the essence if required
  ///
  STDMETHOD(SetTransformParameters) (THIS_
    IAAFEssenceFormat * op) PURE;
	 

  //***********************************************************
  //
  // CountSamples()
  //
  /// Returns the number of samples of the given essence type on the
  /// given essence stream.
  /// 
  /// A video sample is one frame.
  ///
  /// @param pDataDef [in] For this essence dataDef
  /// @param result [out] find out how many samples are present
  ///
  STDMETHOD(CountSamples) (THIS_
    IAAFDataDef * pDataDef,
    aafLength_t *  result) PURE;


  //***********************************************************
  //
  // ReadSamples()
  //
  /// Read a given number of samples from an opened essence stream.
  ///
  /// This call will only return a single channel of essence from an
  /// interleaved stream.
  ///
  /// A video sample is a frame.
  ///
  /// Buflen is in bytes, and should be large enough to hold the
  /// samples after the requested transforms have been applied.
  ///
  /// Possible Errors:
  ///   AAFRESULT_END_OF_DATA -- Hit the end of the essence (like
  ///                            EOF) while reading.
  ///   AAFRESULT_SMALLBUF    -- Buffer too small for samples.
  ///
  /// @param nSamples [in] Read this many samples
  /// @param buflen [in] into a buffer of this size
  /// @param buffer [out, size_is(buflen),length_is(*bytesRead)] The transfer buffer
  /// @param samplesRead [out, ref] The number of samples actually read
  /// @param bytesRead [out, ref] The number of bytes actually read
  ///
  STDMETHOD(ReadSamples) (THIS_
    aafUInt32  nSamples,
    aafUInt32  buflen,
    aafDataBuffer_t  buffer,
    aafUInt32 *  samplesRead,
    aafUInt32 *  bytesRead) PURE;


  //***********************************************************
  //
  // Seek()
  //
  /// The seek function for essence.
  ///
  /// Useful only on reading, you can't seek aound while writing
  /// essence.
  ///
  /// An audio frame is one sample across all channels.
  ///
  /// Possible Errors:
  ///   AAFRESULT_BADSAMPLEOFFSET -- Hit the end of the essence
  ///                                (like EOF) while reading.
  ///
  /// @param sampleFrameNum [in] A 0-based offset in units of the sample rate to seek to.
  ///
  STDMETHOD(Seek) (THIS_
    aafPosition_t  sampleFrameNum) PURE;


  //***********************************************************
  //
  // GetFileFormat()
  //
  /// Given an AAFEssenceFormat, read the essence parameters inside
  /// and set the values from the file format.
  ///
  /// @param opsTemplate [in] An AAFEssenceFormat with parameter codes set but no values
  /// @param opsResult [out] Another AAFEssenceFormat with values set
  ///
  STDMETHOD(GetFileFormat) (THIS_
    IAAFEssenceFormat * opsTemplate,
    IAAFEssenceFormat ** opsResult) PURE;


  //***********************************************************
  //
  // GetFileFormatParameterList()
  //
  /// Returns an AAFEssenceFormat containing a list of all parameters
  /// supported by the current codec.
  ///
  /// @param ops [out] An ampty AAFEssenceFormat object
  ///
  STDMETHOD(GetFileFormatParameterList) (THIS_
    IAAFEssenceFormat ** ops) PURE;


  //***********************************************************
  //
  // GetEmptyFileFormat()
  //
  /// Returns an empty AAFEssenceFormat object.  This is the factory
  /// method for AAFEssenceFormat.
  ///
  /// @param ops [out] An ampty AAFEssenceFormat object
  ///
  STDMETHOD(GetEmptyFileFormat) (THIS_
    IAAFEssenceFormat ** ops) PURE;


  //***********************************************************
  //
  // PutFileFormat()
  //
  /// Given an AAFEssenceFormat, read the essence parameters inside
  /// and change the file format.
  ///
  /// @param ops [in] An AAFEssenceFormat with one or more parameter/value pairs
  ///
  STDMETHOD(PutFileFormat) (THIS_
    IAAFEssenceFormat * ops) PURE;


  //***********************************************************
  //
  // GetCodecName()
  //
  /// Returns the full name of the given codec expanded for human
  /// consumption.
  ///
  /// No other call uses this name, so it may be fully
  /// descriptive, esp. of limitations.
  ///
  /// The name will be truncated to fit within "buflen" bytes.
  ///
  /// Possible Errors:
  ///   AAFRESULT_CODEC_INVALID - The given codec ID is not loaded.
  ///   AAFRESULT_SMALLBUF      - The buffer is not large enough to
  ///                             hold the data.
  ///
  /// @param namelen [in] The size of the name buffer to be filled
  /// @param name [out,size_is(namelen)] The buffer to fill
  ///
  STDMETHOD(GetCodecName) (THIS_
    aafUInt32  namelen,
    aafCharacter *  name) PURE;


  //***********************************************************
  //
  // GetCodecID()
  //
  /// Returns the codec ID being used to handle the specified essence.
  ///
  /// This will be required in order to send private data to the
  /// codec.
  ///
  /// The name will be truncated to fit within "buflen" bytes.
  ///
  /// @param codecID [out] Returns the current codec ID
  ///
  STDMETHOD(GetCodecID) (THIS_
    aafCodecID_t *  codecID) PURE;


  //***********************************************************
  //
  // CompleteWrite()
  //
  /// Handle any format related writing at the end and adjust mob
  /// lengths.  Must be called before releasing a write essence
  /// access.
  ///
  /// Possible Errors:
  ///   AAFRESULT_STREAM_FULL
  ///   - The essence can not be written because of a fault such as a
  ///     disk full error in the underlying operating system.
  STDMETHOD(CompleteWrite) (THIS) PURE;






  END_INTERFACE
};
#endif // __IAAFEssenceAccess_INTERFACE_DEFINED__


// IAAFEssenceData

// ************************
//
// Interface IAAFEssenceData
//
// ************************






#ifndef __IAAFEssenceData_INTERFACE_DEFINED__
#define __IAAFEssenceData_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFEssenceData;

#undef  INTERFACE
#define INTERFACE   IAAFEssenceData

DECLARE_INTERFACE_(IAAFEssenceData, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFEssenceData methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Associates a weak reference to the given file mob with the
  /// essence data.
  ///
  /// Succeeds if all of the following are true:
  /// - the pFileMob pointer is valid and points to 
  /// a file mob (contains a file descriptor).
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFileMob is null.
  ///
  /// @param pFileMob [in] reference to a file mob
  ///
  STDMETHOD(Initialize) (THIS_
    IAAFSourceMob * pFileMob) PURE;

  //***********************************************************
  //
  // Write()
  //
  /// Write pre-interleaved data to a essence stream.
  ///
  /// @param bytes [in] write this many bytes
  /// @param buffer [out, size_is(bytes)] here is the buffer
  /// @param bytesWritten [out,ref] 
  ///
  STDMETHOD(Write) (THIS_
    aafUInt32  bytes,
    aafDataBuffer_t  buffer,
    aafUInt32 *  bytesWritten) PURE;


  //***********************************************************
  //
  // Read()
  //
  /// Read pre-interleaved data from a essence stream.
  ///
  /// @param bytes [in] read this many bytes
  /// @param buffer [out, size_is(bytes), length_is(*bytesRead)] here is the buffer
  /// @param bytesRead [out,ref] 
  ///
  STDMETHOD(Read) (THIS_
    aafUInt32  bytes,
    aafDataBuffer_t  buffer,
    aafUInt32 *  bytesRead) PURE;


  //***********************************************************
  //
  // SetPosition()
  //
  /// Seek to absolute position within the essence data.
  ///
  /// @param offset [in] offset from beginning of essence
  ///
  STDMETHOD(SetPosition) (THIS_
    aafPosition_t  offset) PURE;


  //***********************************************************
  //
  // GetPosition()
  //
  /// Get the absolute position within the essence data.
  ///
  /// @param pOffset [out] offset from beginning of essence
  ///
  STDMETHOD(GetPosition) (THIS_
    aafPosition_t*  pOffset) PURE;


  //***********************************************************
  //
  // GetSize()
  //
  /// Return the total size of the essence data.
  ///
  /// @param pSize  [out] size of essence data
  ///
  STDMETHOD(GetSize) (THIS_
    aafLength_t *  pSize ) PURE;


  //***********************************************************
  //
  // SetFileMob()
  //
  /// Associates a weak reference to the given file mob with the
  /// essence data.
  ///
  /// Succeeds if all of the following are true:
  /// - the pFileMob pointer is valid and points to 
  /// a file mob (contains a file descriptor).
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFileMob is null.
  ///
  /// @param pFileMob [in] reference to a file mob
  ///
  STDMETHOD(SetFileMob) (THIS_
    IAAFSourceMob * pFileMob) PURE;


  //***********************************************************
  //
  // GetFileMob()
  //
  /// Associates a weak reference to the given file mob with the
  /// essence data.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppFileMob pointer is valid and a weak
  /// reference to the associated file mob can be
  /// resolved.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppFileMob is null.
  ///
  /// @param ppFileMob [in] reference to a file mob
  ///
  STDMETHOD(GetFileMob) (THIS_
    IAAFSourceMob ** ppFileMob) PURE;


  //***********************************************************
  //
  // GetFileMobID()
  //
  /// Return the mob id used to find the file mob associated with this
  /// essence.  The file mob must exist in the same file as this
  /// essence data.
  ///
  /// @param pFileMobID [out] the file mob id associated with essence
  ///
  STDMETHOD(GetFileMobID) (THIS_
    aafMobID_t *  pFileMobID) PURE;








  END_INTERFACE
};
#endif // __IAAFEssenceData_INTERFACE_DEFINED__


// IAAFEssenceDescriptor

// ************************
//
// Interface IAAFEssenceDescriptor
//
// ************************





#ifndef __IAAFEssenceDescriptor_INTERFACE_DEFINED__
#define __IAAFEssenceDescriptor_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFEssenceDescriptor;

#undef  INTERFACE
#define INTERFACE   IAAFEssenceDescriptor

DECLARE_INTERFACE_(IAAFEssenceDescriptor, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFEssenceDescriptor methods *** */

  //***********************************************************
  //
  // CountLocators()
  //
  /// Return the number of locators attached to this essence
  /// descriptor.  The number of locators may be zero if the essence is
  /// in the current file.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pCount pointer is valid.
  /// 
  /// If this method fails nothing is written to *pCount.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCount is null.
  ///
  /// @param pResult [out] Returns the number of locators
  ///
  STDMETHOD(CountLocators) (THIS_
    aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // AppendLocator()
  //
  /// Append another locator to this essence descriptor.  Use this
  /// function to add a locator to be scanned last when searching for
  /// the essence (a secondary location for the essence).
  /// 
  /// Succeeds if all of the following are true:
  /// - the pLocator pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLocator is null.
  ///
  /// @param pLocator [in] Locator to append
  ///
  STDMETHOD(AppendLocator) (THIS_
    IAAFLocator * pLocator) PURE;


  //***********************************************************
  //
  // PrependLocator()
  //
  /// Prepend another locator to this essence descriptor.  Use this
  /// function to add a locator to be scanned first when searching for
  /// the essence (a new primary location for the essence).
  /// 
  /// Succeeds if all of the following are true:
  /// - the pLocator pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLocator is null.
  ///
  /// @param pLocator [in] Locator to append
  ///
  STDMETHOD(PrependLocator) (THIS_
    IAAFLocator * pLocator) PURE;


  //***********************************************************
  //
  // InsertLocatorAt()
  //
  /// Inserts the given locator at the given index.  Locators already
  /// existing at the given and higher indices will be moved to the
  /// next higher index to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pLocator pointer is valid.
  /// - index is less than or equal to the value returned by
  ///   CountLocators().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLocator is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than the value returned by
  ///     CountLocators().
  ///
  /// @param index [in] index at which locator is to be inserted
  /// @param pLocator [in] Locator to append
  ///
  STDMETHOD(InsertLocatorAt) (THIS_
    aafUInt32  index,
    IAAFLocator * pLocator) PURE;


  //***********************************************************
  //
  // GetLocatorAt()
  //
  /// Retrieves the locator at the given index.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pLocator pointer is valid.
  /// - index is less than the value returned by CountLocators().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLocator is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than or equal to the value returned by
  ///     CountLocators().
  ///
  /// @param index [in] index of locator to retrieve
  /// @param ppLocator [out, retval] returned locator
  ///
  STDMETHOD(GetLocatorAt) (THIS_
    aafUInt32  index,
    IAAFLocator ** ppLocator) PURE;


  //***********************************************************
  //
  // RemoveLocatorAt()
  //
  /// Removes the locator at the given index.  Locators already
  /// existing at indices higher than the given index will be moved to
  /// the next lower index to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - index is less than the value returned by CountLocators().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than or equal to the value returned by
  ///     CountLocators().
  ///
  /// @param index [in] index of locator to remove
  ///
  STDMETHOD(RemoveLocatorAt) (THIS_
    aafUInt32  index) PURE;


  //***********************************************************
  //
  // GetLocators()
  //
  /// Returns an enumerator to the locators.  The number of locators
  /// may be zero if the essence is in the current file.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// @param ppEnum [out] An enumerator to the locators on this essence descriptor
  ///
  STDMETHOD(GetLocators) (THIS_
    IEnumAAFLocators ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IAAFEssenceDescriptor_INTERFACE_DEFINED__



// IAAFEssenceFormat

// ************************
//
// Interface IAAFEssenceFormat
//
// ************************



#ifndef __IAAFEssenceFormat_INTERFACE_DEFINED__
#define __IAAFEssenceFormat_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFEssenceFormat;

#undef  INTERFACE
#define INTERFACE   IAAFEssenceFormat

DECLARE_INTERFACE_(IAAFEssenceFormat, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFEssenceFormat methods *** */

  //***********************************************************
  //
  // AddFormatSpecifier()
  //
  /// Appends a format specifier to the AAFEssenceFormat.  If an
  /// essenceFormatCode has already been added, then this call
  /// replaces the value, otherwise the value is appended.
  ///
  /// The value data is passed in as a void * through the "value"
  /// argument.  The size of the value must be passed through the
  /// valueSize argument.
  ///
  /// @param essenceFormatCode [in] From aaddefuids.h
  /// @param valueSize [in] Size of preallocated buffer
  /// @param value [in, size_is(valueSize)] Value data
  ///
  STDMETHOD(AddFormatSpecifier) (THIS_
    aafUID_constref  essenceFormatCode,
    aafInt32  valueSize,
    aafDataBuffer_t  value) PURE;


  //***********************************************************
  //
  // GetFormatSpecifier()
  //
  /// The data value is returned in a preallocated buffer of size
  /// valueSize.
  ///
  /// The actual number of bytes read is returned in bytesRead.  If the
  /// buffer is not big enough to return the entire  value, an error
  /// is returned.
  ///
  /// @param essenceFormatCode [in] From aaddefuids.h
  /// @param valueSize [in] Size of preallocated buffer
  /// @param value [out, size_is(valueSize),length_is(*bytesRead)] Preallocated buffer to hold value
  /// @param bytesRead [out] Number of actual bytes read
  ///
  STDMETHOD(GetFormatSpecifier) (THIS_
    aafUID_constref  essenceFormatCode,
    aafInt32  valueSize,
    aafDataBuffer_t  value,
    aafInt32*  bytesRead) PURE;


  //***********************************************************
  //
  // NumFormatSpecifiers()
  //
  /// The data value is returned in a preallocated buffer of size
  /// valueSize.
  ///
  /// @param numSpecifiers [out] The number of specifiers present.
  ///
  STDMETHOD(NumFormatSpecifiers) (THIS_
    aafInt32*  numSpecifiers) PURE;


  //***********************************************************
  //
  // GetIndexedFormatSpecifier()
  //
  /// The data value is returned in a preallocated buffer of size
  /// valueSize.
  ///
  /// @param index [in] 0-based index
  /// @param essenceFormatCode [out] From aaddefuids.h
  /// @param valueSize [in] Size of preallocated buffer
  /// @param value [out, size_is(valueSize),length_is(*bytesRead)] Preallocated buffer to hold value
  /// @param bytesRead [out] Number of actual bytes read
  ///
  STDMETHOD(GetIndexedFormatSpecifier) (THIS_
    aafInt32  index,
    aafUID_t*  essenceFormatCode,
    aafInt32  valueSize,
    aafDataBuffer_t  value,
    aafInt32*  bytesRead) PURE;

  END_INTERFACE
};
#endif // __IAAFEssenceFormat_INTERFACE_DEFINED__



// IAAFEssenceGroup

// ************************
//
// Interface IAAFEssenceGroup
//
// ************************





#ifndef __IAAFEssenceGroup_INTERFACE_DEFINED__
#define __IAAFEssenceGroup_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFEssenceGroup;

#undef  INTERFACE
#define INTERFACE   IAAFEssenceGroup

DECLARE_INTERFACE_(IAAFEssenceGroup, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFEssenceGroup methods *** */

  //***********************************************************
  //
  // SetStillFrame()
  //
  /// This method sets the still frame property on a essence group to
  /// be the source clip passed as the stillFrame argument.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pStillFrame is null.
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param pStillFrame [in] Still Frame source clip 
  ///
  STDMETHOD(SetStillFrame) (THIS_
    IAAFSourceClip * pStillFrame) PURE;
    

  //***********************************************************
  //
  // GetStillFrame()
  //
  /// Gets the still frame property on a essence group.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppStillFrame is null.
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param ppStillFrame [out] Still Frame source clip 
  ///
  STDMETHOD(GetStillFrame) (THIS_
    IAAFSourceClip ** ppStillFrame) PURE;


  //***********************************************************
  //
  // AppendChoice()
  //
  /// Append another choice to this AAFEssenceGroup.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pChoice pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pChoice is null.
  ///
  /// @param pChoice [in] Source clip to add as a choice 
  ///
  STDMETHOD(AppendChoice) (THIS_
    IAAFSegment * pChoice) PURE;


  //***********************************************************
  //
  // PrependChoice()
  //
  /// Prepend another choice to this AAFEssenceGroup.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pChoice pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pChoice is null.
  ///
  /// @param pChoice [in] Source clip to add as a choice
  ///
  STDMETHOD(PrependChoice) (THIS_
    IAAFSegment * pChoice) PURE;


  //***********************************************************
  //
  // InsertChoiceAt()
  //
  /// Insert another choice to this AAFEssenceGroup at the given
  /// index.  Choices already existing at the given and higher indices
  /// will be moved up by one index to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pChoice pointer is valid.
  /// - index is less than or equal to the value returned by
  ///   CountChoices().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pChoice is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than the value returned by
  ///     CountChoices().
  ///
  /// @param index [in] place to insert new choice
  /// @param pChoice [in] Source clip to add as a choice
  ///
  STDMETHOD(InsertChoiceAt) (THIS_
    aafUInt32  index,
    IAAFSegment * pChoice) PURE;


  //***********************************************************
  //
  // CountChoices()
  //
  /// Returns the number of choices attached to this AAFEssenceGroup.,
  /// excepting the still frame.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pCount pointer is valid.
  /// 
  /// If this method fails nothing is written to *pCount.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCount is null.
  ///
  /// @param pCount [out] The number of representations contained within.
  ///
  STDMETHOD(CountChoices) (THIS_
    aafUInt32*   pCount) PURE;


  //***********************************************************
  //
  // GetChoiceAt()
  //
  /// Given an index, returns the corresponding source clip choice.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppChoice pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppChoice.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_MISSING_INDEX
  ///   - The given index value is not present.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppChoice arg is NULL.
  ///
  /// @param index [in] The 0-based index into the array
  /// @param ppChoice [out] The representation at that index
  ///
  STDMETHOD(GetChoiceAt) (THIS_
    aafUInt32  index,
    IAAFSegment  ** ppChoice) PURE;


  //***********************************************************
  //
  // RemoveChoiceAt()
  //
  /// Removes the choice at the given index.  Items already existing at
  /// higher indices will be moved down by one index to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppChoice pointer is valid.
  /// - index is less than the value returned by CountChoices().
  /// 
  /// If this method fails no state will be changed.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppChoice arg is NULL.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than or equal to the value returned by
  ///     CountChoices().
  ///
  /// @param index [in] The 0-based index into the array
  ///
  STDMETHOD(RemoveChoiceAt) (THIS_
    aafUInt32  index) PURE;

  END_INTERFACE
};
#endif // __IAAFEssenceGroup_INTERFACE_DEFINED__



// IAAFEvent

// ************************
//
// Interface IAAFEvent
//
// ************************





#ifndef __IAAFEvent_INTERFACE_DEFINED__
#define __IAAFEvent_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFEvent;

#undef  INTERFACE
#define INTERFACE   IAAFEvent

DECLARE_INTERFACE_(IAAFEvent, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFEvent methods *** */


  //***********************************************************
  //
  // GetPosition()
  //
  /// This method will return the Position of this event.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pPosition pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPosition arg is NULL.
  ///
  /// @param pPosition [out,retval] Position property value
  ///
  STDMETHOD(GetPosition) (THIS_
    aafPosition_t *  pPosition) PURE;

  //***********************************************************
  //
  // SetPosition()
  //
  /// This method will set the Position of this event.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.).
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param Position [in] Position property value
  ///
  STDMETHOD(SetPosition) (THIS_
    aafPosition_t  Position) PURE;


  //***********************************************************
  //
  // SetComment()
  //
  /// Sets specifies the purpose of the event.
  ///
  /// Set the Comment property to the value specified in
  /// pComment.  A copy is made of the data so the caller
  /// retains ownership of the *pComment buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pComment pointer is valid.
  /// 
  /// If this method fails the Comment property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pComment arg is NULL.
  ///
  /// @param pComment [in, string] buffer from which Comment is to be read
  ///
  STDMETHOD(SetComment) (THIS_
    aafCharacter_constptr  pComment) PURE;


  //***********************************************************
  //
  // GetComment()
  //
  /// Gets specifies the purpose of the event.
  /// 
  /// Writes the Comment property, with a trailing null
  /// character, into the pComment buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the Comment property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetCommentBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pComment.
  /// 
  /// Succeeds if:
  /// - The pComment pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   Comment.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pComment arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold Comment.
  ///
  /// @param pComment [out, string, size_is(bufSize)] buffer into which Comment is to be written
  /// @param bufSize [in] size of *pComment buffer in bytes
  ///
  STDMETHOD(GetComment) (THIS_
    aafCharacter *  pComment,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetCommentBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetComment().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetCommentBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;


  END_INTERFACE
};
#endif // __IAAFEvent_INTERFACE_DEFINED__



// IAAFEventMobSlot

// ************************
//
// Interface IAAFEventMobSlot
//
// ************************




#ifndef __IAAFEventMobSlot_INTERFACE_DEFINED__
#define __IAAFEventMobSlot_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFEventMobSlot;

#undef  INTERFACE
#define INTERFACE   IAAFEventMobSlot

DECLARE_INTERFACE_(IAAFEventMobSlot, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFEventMobSlot methods *** */
  //***********************************************************
  //
  // GetEditRate()
  //
  /// This method will get the edit rate for this mob slot.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pEditRate pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEditRate arg is NULL.
  ///
  /// @param pEditRate [out,retval] Edit rate property value
  ///
  STDMETHOD(GetEditRate) (THIS_
    aafRational_t *  pEditRate) PURE;


  //***********************************************************
  //
  // SetEditRate()
  //
  /// This method will get set edit rate for this mob slot.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pEditRate pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEditRate arg is NULL.
  ///
  /// @param pEditRate [in] Edit rate property value
  ///
  STDMETHOD(SetEditRate) (THIS_
    aafRational_t *  pEditRate) PURE;









  END_INTERFACE
};
#endif // __IAAFEventMobSlot_INTERFACE_DEFINED__


// IAAFFile

// ************************
//
// Interface IAAFFile
//
// ************************




#ifndef __IAAFFile_INTERFACE_DEFINED__
#define __IAAFFile_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFFile;

#undef  INTERFACE
#define INTERFACE   IAAFFile

DECLARE_INTERFACE_(IAAFFile, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFFile methods *** */

  //***********************************************************
  //
  // Open()
  //
  /// Associates this IAAFFile-supporting object with the storage to
  /// which it is to be associated.  It will then be possible to access
  /// objects within this file.
  ///
  /// This method will succeed only if all of the following are true:
  /// - This object has not already been opened.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_OPEN
  ///   - This object has already been Open()ed.
  STDMETHOD(Open) (THIS) PURE;


  //***********************************************************
  //
  // SaveCopyAs()
  //
  /// Copies the contents of this file to *pDestFile.  Requires that
  /// *pDestFile be open, writeable or modifiable, and not yet
  /// contain any objects.
  ///
  /// NOTE! Stub only.   Implementation not yet added.
  ///
  /// Succeeds if:
  /// - This object is currently open.
  /// - The named filesystem file is writable.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_OPEN
  ///   - This object is not open.
  ///
  /// AAFRESULT_NOT_WRITEABLE
  ///   - The named file cannot be written.
  ///
  /// @param pDestFile [in] File to recieve contents
  ///
  STDMETHOD(SaveCopyAs) (THIS_
    IAAFFile * pDestFile) PURE;


  //***********************************************************
  //
  // GetHeader()
  //
  /// Returns the IAAFHeader-supporting object associated with this
  /// file.  If this object has never been associated with a file, a
  /// new empty IAAFHeader-supporting object will be created and
  /// returned.  The returned header is AddRef()ed before it is
  /// returned.  Note that the header is automatically created when the
  /// file object is created.
  ///
  /// Succeeds if:
  /// - This object has already been Initialize()d.
  /// - This file object is open.
  /// - the given header pointer is valid.
  /// - this object contains a header.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NOT_OPEN
  ///   - This object is not open.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - the header pointer arg is NULL.
  ///
  /// AAFRESULT_NO_HEADER
  ///   - this object contains no header.
  ///
  /// @param ppHeader [out, retval] Set to header of the current file
  ///
  STDMETHOD(GetHeader) (THIS_
    IAAFHeader ** ppHeader) PURE;


  //***********************************************************
  //
  // GetRevision()
  //
  /// Get the revision of the current AAF file, and returns it in pRev.
  ///
  /// Succeeds if:
  /// - This object has already been Initialize()d.
  /// - the given revision pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - the revision pointer arg is NULL.
  ///
  /// AAFRESULT_NOT_OPEN
  ///   - This object is not open.
  ///
  /// @param pRev [out, retval] Revision of the current file
  ///
  STDMETHOD(GetRevision) (THIS_
    aafFileRev_t *  pRev) PURE;


  //***********************************************************
  //
  // Save()
  //
  /// If this IAAFFile-supporting object is open, all unsaved changes
  /// made to the contents of this object are saved.
  ///
  /// This method will succeed only if all of the following are true:
  /// - This object is currently open.
  /// - Sufficient space remains in the storage for the data to be
  ///   written.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_OPEN
  ///   - This object is not open.
  ///
  /// AAFRESULT_WRONG_OPENMODE
  ///   - This object is not open for writing or modification.
  ///
  /// AAFRESULT_INSUFFICIENT_SPACE
  ///   - There is insufficient space in the storage to save the
  ///     contents of this object.
  STDMETHOD(Save) (THIS) PURE;


  //***********************************************************
  //
  // Close()
  //
  /// Dissociates this IAAFFile-supporting object from its
  /// currently-associated storage.  Any AAF objects which were
  /// contained within this object will then no longer be available to
  /// the client.
  ///
  /// If the client is maintaining any references to any objects which
  /// are contained in this object, those objects will be marked as
  /// dissociated, and methods on them will fail.
  ///
  /// Any unsaved changes will be written to the file before the Close
  /// operation is complete.
  ///
  /// This method will succeed only if all of the following are true:
  /// - This object is currently open.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_OPEN
  ///   - This object is not already open.
  STDMETHOD(Close) (THIS) PURE;

  //***********************************************************
  //
  // GetDictionary()
  //
  /// Places the dictionary that contains all types of aaf definition
  /// objects into the *ppDictionary argument.  The returned dictionary
  /// is AddRef()ed before it is returned.  Note that the dictionary
  /// is automatically created when the header object is created.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppDictionary pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDictionary is null.
  ///
  /// @param ppDictionary [out, retval] The AAF Dictionary
  ///
  STDMETHOD(GetDictionary) (THIS_
    IAAFDictionary ** ppDictionary) PURE;


  END_INTERFACE
};
#endif // __IAAFFile_INTERFACE_DEFINED__



// IAAFFileDescriptor

// ************************
//
// Interface IAAFFileDescriptor
//
// ************************



#ifndef __IAAFFileDescriptor_INTERFACE_DEFINED__
#define __IAAFFileDescriptor_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFFileDescriptor;

#undef  INTERFACE
#define INTERFACE   IAAFFileDescriptor

DECLARE_INTERFACE_(IAAFFileDescriptor, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFFileDescriptor methods *** */
  //***********************************************************
  //
  // SetLength()
  //
  /// Sets the length of the essence in samples [not edit units].
  /// 
  /// Always succeeds.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param length [in] length of the essence in samples
  ///
  STDMETHOD(SetLength) (THIS_
    aafLength_t  length) PURE;


  //***********************************************************
  //
  // GetLength()
  //
  /// Gets the length of the essence in samples [not edit units].
  ///
  /// Succeeds if all of the following are true:
  /// - the pLength pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pLength.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLength arg is NULL.
  ///
  /// @param pLength [out] returns length of the essence in samples
  ///
  STDMETHOD(GetLength) (THIS_
    aafLength_t *  pLength) PURE;


  //***********************************************************
  //
  // SetCodecDef()
  //
  /// Set to the exact codec which was used as a hint.
  /// 
  /// Always succeeds.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param codecDef [in] Which codec was used
  ///
  STDMETHOD(SetCodecDef) (THIS_
    IAAFCodecDef * codecDef) PURE;


  //***********************************************************
  //
  // GetCodecDef()
  //
  /// Get to the exact codec which was used as a hint.
  ///
  /// Succeeds if all of the following are true:
  /// - the pCodecDef pointer is valid.
  /// - the CodecDefinition identifying the codec is
  ///   present in the dictionary.
  /// 
  /// If this method fails nothing will be written to *pCodecDef.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCodecDef arg is NULL.
  ///
  /// AAFRESULT_OBJECT_NOT_FOUND
  ///   - the CodecDefinition identifying the codec is not
  ///     in the dictionary.
  ///
  /// @param pCodecDef [out] Which codec was used
  ///
  STDMETHOD(GetCodecDef) (THIS_
    IAAFCodecDef ** pCodecDef) PURE;


  //***********************************************************
  //
  // SetSampleRate()
  //
  /// Sets sample rate of the essence as opposed to the edit rate.
  /// 
  /// If this method fails the sample rate property will not be
  /// changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param rate [in] sample rate of the essence
  ///
  STDMETHOD(SetSampleRate) (THIS_
    aafRational_constref  rate) PURE;


  //***********************************************************
  //
  // GetSampleRate()
  //
  /// Gets sample rate of the essence as opposed to the edit rate. and
  /// writes it into the *pRate argument.
  ///
  /// Succeeds if all of the following are true:
  /// - the pRate pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pRate.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pRate arg is NULL.
  ///
  /// @param pRate [out] sample rate of the essence
  ///
  STDMETHOD(GetSampleRate) (THIS_
    aafRational_t*  pRate) PURE;


  //***********************************************************
  //
  // SetContainerFormat()
  //
  /// Identifies the file format.  The container format is an optional
  /// property.
  /// 
  /// If this method fails the container format property will not be
  /// changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param format [in] file format
  ///
  STDMETHOD(SetContainerFormat) (THIS_
    IAAFContainerDef * format) PURE;


  //***********************************************************
  //
  // GetContainerFormat()
  //
  /// Identifies the file format.
  ///
  /// Succeeds if all of the following are true:
  /// - the pFormat pointer is valid.
  /// - the ContainerDefinition identifying the file format is
  ///   present in the dictionary.
  /// 
  /// If this method fails nothing will be written to *pFormat.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFormat arg is NULL.
  ///
  /// AAFRESULT_OBJECT_NOT_FOUND
  ///   - the ContainerDefinition identifying the file format is not
  ///     in the dictionary.
  ///
  /// @param pFormat [out] Optional
  ///
  STDMETHOD(GetContainerFormat) (THIS_
    IAAFContainerDef ** pFormat) PURE;






  END_INTERFACE
};
#endif // __IAAFFileDescriptor_INTERFACE_DEFINED__


// IAAFFileEncoding

// ************************
//
// Interface IAAFFileEncoding
//
// ************************



#ifndef __IAAFFileEncoding_INTERFACE_DEFINED__
#define __IAAFFileEncoding_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFFileEncoding;

#undef  INTERFACE
#define INTERFACE   IAAFFileEncoding

DECLARE_INTERFACE_(IAAFFileEncoding, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFFileEncoding methods *** */

  //***********************************************************
  //
  // GetName()
  //
  /// Gets the name of this file encoding.
  /// 
  /// Writes the Name property, with a trailing null
  /// character, into the pName buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the Name property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetNameBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pName.
  /// 
  /// Succeeds if:
  /// - The pName pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   Name.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold Name.
  ///
  /// @param pName [out, string, size_is(bufSize)] buffer into which Name is to be written
  /// @param bufSize [in] size of *pName buffer in bytes
  ///
  STDMETHOD(GetName) (THIS_
    aafCharacter *  pName,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetNameBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetName().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetNameBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;


  //***********************************************************
  //
  // GetDescription()
  //
  /// Gets the description of this file encoding.
  /// 
  /// Writes the Description property, with a trailing null
  /// character, into the pDescription buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the Description property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetDescriptionBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pDescription.
  /// 
  /// Succeeds if:
  /// - The pDescription pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   Description.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDescription arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold Description.
  ///
  /// @param pDescription [out, string, size_is(bufSize)] buffer into which Description is to be written
  /// @param bufSize [in] size of *pDescription buffer in bytes
  ///
  STDMETHOD(GetDescription) (THIS_
    aafCharacter *  pDescription,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetDescriptionBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetDescription().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetDescriptionBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;



  //***********************************************************
  //
  // GetFileKind()
  //
  /// This method returns the unique ID associated with this file encoding.
  ///
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pFileKind pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pFileKind.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFileKind argument is NULL.
  ///
  /// @param pFileKind [out] The unique file encoding ID
  ///
  STDMETHOD(GetFileKind) (THIS_
    aafUID_t *  pFileKind) PURE;


  END_INTERFACE
};
#endif // __IAAFFileEncoding_INTERFACE_DEFINED__



// IAAFFiller

// ************************
//
// Interface IAAFFiller
//
// ************************




#ifndef __IAAFFiller_INTERFACE_DEFINED__
#define __IAAFFiller_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFFiller;


#undef  INTERFACE
#define INTERFACE   IAAFFiller

DECLARE_INTERFACE_(IAAFFiller, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFFiller methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// This function will create a new filler object with the given
  /// property values.  Length is specified in units of the edit rate
  /// of the containing timeline mob slot.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has not yet been initialized.
  /// - the length is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDataDef is null.
  ///
  /// AAFRESULT_BAD_LENGTH
  ///   - length is negative.
  ///
  /// @param pDataDef [in] Data Definition Object
  /// @param length [in] Length Property Value
  ///
  STDMETHOD(Initialize) (THIS_
    IAAFDataDef * pDataDef,
    aafLength_t  length) PURE;

  END_INTERFACE
};
#endif // __IAAFFiller_INTERFACE_DEFINED__



// IAAFFilmDescriptor

// ************************
//
// Interface IAAFFilmDescriptor
//
// ************************




#ifndef __IAAFFilmDescriptor_INTERFACE_DEFINED__
#define __IAAFFilmDescriptor_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFFilmDescriptor;

#undef  INTERFACE
#define INTERFACE   IAAFFilmDescriptor

DECLARE_INTERFACE_(IAAFFilmDescriptor, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFFilmDescriptor methods *** */

  //***********************************************************
  //
  // SetFilmManufacturer()
  //
  /// Sets the Film Manufacturer string property.
  ///
  /// Set the FilmManufacturer property to the value specified in
  /// pFilmManufacturer.  A copy is made of the data so the caller
  /// retains ownership of the *pFilmManufacturer buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pFilmManufacturer pointer is valid.
  /// 
  /// If this method fails the FilmManufacturer property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFilmManufacturer arg is NULL.
  ///
  /// @param pFilmManufacturer [in, string] buffer from which FilmManufacturer is to be read
  ///
  STDMETHOD(SetFilmManufacturer) (THIS_
    aafCharacter_constptr  pFilmManufacturer) PURE;


  //***********************************************************
  //
  // GetFilmManufacturer()
  //
  /// Gets the Film Manufacturer string property.
  /// 
  /// Writes the FilmManufacturer property, with a trailing null
  /// character, into the pFilmManufacturer buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the FilmManufacturer property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetFilmManufacturerBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pFilmManufacturer.
  /// 
  /// Succeeds if:
  /// - The pFilmManufacturer pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   FilmManufacturer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFilmManufacturer arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold FilmManufacturer.
  ///
  /// @param pFilmManufacturer [out, string, size_is(bufSize)] buffer into which FilmManufacturer is to be written
  /// @param bufSize [in] size of *pFilmManufacturer buffer in bytes
  ///
  STDMETHOD(GetFilmManufacturer) (THIS_
    aafCharacter *  pFilmManufacturer,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetFilmManufacturerBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetFilmManufacturer().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetFilmManufacturerBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;


  //***********************************************************
  //
  // SetFilmModel()
  //
  /// Sets the Film Model string property.
  ///
  /// Set the FilmModel property to the value specified in
  /// pFilmModel.  A copy is made of the data so the caller
  /// retains ownership of the *pFilmModel buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pFilmModel pointer is valid.
  /// 
  /// If this method fails the FilmModel property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFilmModel arg is NULL.
  ///
  /// @param pFilmModel [in, string] buffer from which FilmModel is to be read
  ///
  STDMETHOD(SetFilmModel) (THIS_
    aafCharacter_constptr  pFilmModel) PURE;


  //***********************************************************
  //
  // GetFilmModel()
  //
  /// Gets the Film Model string property.
  /// 
  /// Writes the FilmModel property, with a trailing null
  /// character, into the pFilmModel buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the FilmModel property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetFilmModelBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pFilmModel.
  /// 
  /// Succeeds if:
  /// - The pFilmModel pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   FilmModel.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFilmModel arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold FilmModel.
  ///
  /// @param pFilmModel [out, string, size_is(bufSize)] buffer into which FilmModel is to be written
  /// @param bufSize [in] size of *pFilmModel buffer in bytes
  ///
  STDMETHOD(GetFilmModel) (THIS_
    aafCharacter *  pFilmModel,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetFilmModelBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetFilmModel().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetFilmModelBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;


  //***********************************************************
  //
  // GetFilmFormat()
  //
  /// Gets the film format.
  ///
  /// Valid values include:
  ///  - kFt35MM
  ///  - kFt16MM
  ///  - kFt8MM
  ///  - kFt65MM
  /// 
  /// This method succeeds if all of the following are true:
  /// - the pFilmFormat pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFilmFormat arg is NULL.
  ///
  /// @param pFilmFormat [out] pointer to the filmFormat
  ///
  STDMETHOD(GetFilmFormat) (THIS_
    aafFilmType_t*  pFilmFormat) PURE;


  //***********************************************************
  //
  // GetFrameRate()
  //
  /// Get the frame rate of the film.
  /// 
  /// This method succeeds if all of the following are true:
  /// - the pRate pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pRate parameter is NULL.
  ///
  /// @param pRate [out] Frame Rate
  ///
  STDMETHOD(GetFrameRate) (THIS_
    aafUInt32*  pRate) PURE;


  //***********************************************************
  //
  // GetPerfPerFrame()
  //
  /// Get the number of perforations per frame.
  /// 
  /// This method succeeds if all of the following are true:
  /// - the pPerfPerFrame pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPerfPerFrame parameter is NULL.
  ///
  /// @param pPerfPerFrame [out] Perforations per frame
  ///
  STDMETHOD(GetPerfPerFrame) (THIS_
    aafUInt8*  pPerfPerFrame) PURE;


  //***********************************************************
  //
  // GetFilmAspectRatio()
  //
  /// Get the image aspect ratio.
  /// 
  /// This method succeeds if all of the following are true:
  /// - the pAspectRatio pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pAspectRatio arg is NULL.
  ///
  /// @param pAspectRatio [out] Film Aspect Ratio
  ///
  STDMETHOD(GetFilmAspectRatio) (THIS_
    aafRational_t*  pAspectRatio) PURE;


  //***********************************************************
  //
  // SetFilmFormat()
  //
  /// Sets the film format of the film.
  /// Valid values include:
  ///  - kFt35MM
  ///  - kFt16MM
  ///  - kFt8MM
  ///  - kFt65MM
  /// 
  /// This method succeeds if all of the following are true:
  /// - formFactor represents a valid format.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_BAD_TYPE
  ///	- filmFormat is invalid.
  ///
  /// @param filmFormat [in] Film Format
  ///
  STDMETHOD(SetFilmFormat) (THIS_
    aafFilmType_t  filmFormat) PURE;


  //***********************************************************
  //
  // SetFrameRate()
  //
  /// Set the frame rate of the film.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param rate [in] Frame Rate
  ///
  STDMETHOD(SetFrameRate) (THIS_
    aafUInt32  rate) PURE;


  //***********************************************************
  //
  // SetPerfPerFrame()
  //
  /// Set the number of perforations per frame.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param perfPerFrame [in] Perforations per frame
  ///
  STDMETHOD(SetPerfPerFrame) (THIS_
    aafUInt8  perfPerFrame) PURE;


  //***********************************************************
  //
  // SetFilmAspectRatio()
  //
  /// Set the image aspect ratio.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param aspectRatio [in] Film Aspect Ratio
  ///
  STDMETHOD(SetFilmAspectRatio) (THIS_
    aafRational_t  aspectRatio) PURE;

  END_INTERFACE
};
#endif // __IAAFFilmDescriptor_INTERFACE_DEFINED__



// IAAFFindSourceInfo

// ************************
//
// Interface IAAFFindSourceInfo
//
// ************************





#ifndef __IAAFFindSourceInfo_INTERFACE_DEFINED__
#define __IAAFFindSourceInfo_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFFindSourceInfo;

#undef  INTERFACE
#define INTERFACE   IAAFFindSourceInfo

DECLARE_INTERFACE_(IAAFFindSourceInfo, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFFindSourceInfo methods *** */


  //***********************************************************
  //
  // GetMob()
  //
  /// This function returns the mob found by the function
  /// which generated this IAAFFindSourceInfo as a result.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppMob pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppMob.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULLOBJECT
  ///   - There is no valid mob referenced
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppMob arg is NULL.
  ///
  /// @param ppMob [out] The final media object referenced
  ///
  STDMETHOD(GetMob) (THIS_
    IAAFMob ** ppMob) PURE;

  //***********************************************************
  //
  // GetSourceReference()
  //
  /// This function returns the source reference found by the function
  /// which generated this IAAFFindSourceInfo as a result.
  ///
  /// Note: the 3 properties that make up the "source
  /// reference" are sourceID, sourceTrackID, and startTime.
  ///
  /// Succeeds if all of the following are true:
  /// - This object has already been Initialize()d.
  /// - the pSourceRef pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pSourceRef.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSourceRef arg is NULL.
  ///
  /// @param pSourceRef [out] Source Reference
  ///
  STDMETHOD(GetSourceReference) (THIS_
    aafSourceRef_t *  pSourceRef) PURE;

  //***********************************************************
  //
  // GetLength()
  //
  /// Gets the length of this component.
  /// This function returns the duration in edit units of the result.
  ///	
  /// Succeeds if all of the following are true:
  /// - the pLength pointer is valid.
  /// - the optional length property is present for this object.
  ///
  /// This method deals with an optional property, which will only be
  /// present for time-varying media.
  /// 
  /// If this method fails nothing will be written to *pLength.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLength arg is NULL.
  ///
  /// AAFRESULT_BAD_PROP
  ///   - the optional length property is not present for this object.
  ///
  /// @param pLength [retval][out] Length of this component
  ///
  STDMETHOD(GetLength) (THIS_
    aafLength_t *  pLength) PURE;

  //***********************************************************
  //
  // GetEditRate()
  //
  /// This method will get the edit rate for this result.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pEditRate pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEditRate arg is NULL.
  ///
  /// @param pEditRate [out,retval] Edit rate property value
  ///
  STDMETHOD(GetEditRate) (THIS_
    aafRational_t *  pEditRate) PURE;


  END_INTERFACE
};
#endif // __IAAFFindSourceInfo_INTERFACE_DEFINED__



// IAAFGPITrigger

// ************************
//
// Interface IAAFGPITrigger
//
// ************************





#ifndef __IAAFGPITrigger_INTERFACE_DEFINED__
#define __IAAFGPITrigger_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFGPITrigger;

#undef  INTERFACE
#define INTERFACE   IAAFGPITrigger

DECLARE_INTERFACE_(IAAFGPITrigger, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFGPITrigger methods *** */


  //***********************************************************
  //
  // GetActiveState()
  //
  /// Sets *pActiveState to AAFTrue it the event is on otherwise
  /// sets it to AAFFalse.
  ///
  /// Succeeds if:
  /// - The pActiveState pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - The pActiveState pointer is NULL.
  ///
  /// @param pActiveState [out, retval] pointer to the result
  ///
  STDMETHOD(GetActiveState) (THIS_
    aafBoolean_t *  pActiveState) PURE;


  //***********************************************************
  //
  // SetActiveState()
  //
  /// Set to AAFTrue to turn the trigger on or AAFFalse
  /// to turn the trigger off.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param ActiveState [in] the active state of the trigger
  ///
  STDMETHOD(SetActiveState) (THIS_
    aafBoolean_t  ActiveState) PURE;


  END_INTERFACE
};
#endif // __IAAFGPITrigger_INTERFACE_DEFINED__



// IAAFGetFileBits

// ************************
//
// Interface IAAFGetFileBits
//
// ************************



#ifndef __IAAFGetFileBits_INTERFACE_DEFINED__
#define __IAAFGetFileBits_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFGetFileBits;

#undef  INTERFACE
#define INTERFACE   IAAFGetFileBits

DECLARE_INTERFACE_(IAAFGetFileBits, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFGetFileBits methods *** */

  //***********************************************************
  //
  // ReadAt()
  //
  /// Attempts to read bufsize bytes from this stream at the given byte
  /// offset.  Places the data into buf.  Any attempt to read beyond
  /// the size of this file, as reported by GetSize(), will be
  /// considered an error.
  ///
  /// A value of zero for position indicates the beginning of the
  /// stream.
  ///
  /// Succeeds if:
  /// - The pNumBytes pointer is valid.
  /// - position + buSize is not larger than the size of this file, as
  ///   reported by GetSize().
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - buf arg is NULL.
  ///
  /// AAFRESULT_OFFSET_SIZE
  ///   - position + size is larger than the size of this file.
  ///
  /// @param buf [out, size_is(bufSize)] Buffer into which data is read
  /// @param bufSize [in] Size of buf in bytes
  /// @param position [in] The position in bytes at which to read
  ///
  STDMETHOD(ReadAt) (THIS_
    aafMemPtr_t  buf,
    aafUInt32  bufSize,
    aafUInt64  position) PURE;


  //***********************************************************
  //
  // GetSize()
  //
  /// Returns the size of this file, in bytes, in *pSize.
  ///
  /// Succeeds if:
  /// - The pSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSize arg is NULL.
  ///
  /// @param pSize [out] The size of this file in bytes
  ///
  STDMETHOD(GetSize) (THIS_
    aafUInt64 *  pSize) PURE;

  END_INTERFACE
};
#endif // __IAAFGetFileBits_INTERFACE_DEFINED__



// IAAFHeader

// ************************
//
// Interface IAAFHeader
//
// ************************










#ifndef __IAAFHeader_INTERFACE_DEFINED__
#define __IAAFHeader_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFHeader;

#undef  INTERFACE
#define INTERFACE   IAAFHeader

DECLARE_INTERFACE_(IAAFHeader, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFHeader methods *** */
  //***********************************************************
  //
  // LookupMob()
  //
  /// Looks up the Mob that matches the given mob id and puts it into
  /// the ppMob argument.  The returned mob interface is AddRef()ed
  /// before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppMob pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppMob.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppMob is null
  ///
  /// AAFRESULT_MOB_NOT_FOUND
  ///   - the requested mob wasn't found.
  ///
  /// @param mobID [in, ref] The Mob ID
  /// @param ppMob [out,retval] Matching Mob
  ///
  STDMETHOD(LookupMob) (THIS_
    aafMobID_constref  mobID,
    IAAFMob ** ppMob) PURE;


  //***********************************************************
  //
  // CountMobs()
  //
  /// Writes the number of matches for the given mob kind into the
  /// *pNumMobs argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pNumMobs pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pNumMobs.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumMobs is null.
  ///
  /// @param mobKind [in] The mob kind to count
  /// @param pResult [out, retval] Total number of mobs of kind mobKind
  ///
  STDMETHOD(CountMobs) (THIS_
    aafMobKind_t  mobKind,
    aafNumSlots_t *  pResult) PURE;


  //***********************************************************
  //
  // GetMobs()
  //
  /// Places an enumerator for mobs that apply to the criteria into the
  /// *ppEnum argument.  If pSearchCriteria is null, all mobs are
  /// returned.   The searchTag field of pSearchCriteria, and exactly
  /// ONE of the fields in the union (tags.mobID, tags.name, etc. )
  /// must be set.  Only one search criterion may be specified.  The
  /// returned enumerator is AddRef()ed before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// @param pSearchCriteria [in] Search Criteria for enumeration
  /// @param ppEnum [out, retval] Mob Enumeration
  ///
  STDMETHOD(GetMobs) (THIS_
    aafSearchCrit_t *  pSearchCriteria,
    IEnumAAFMobs ** ppEnum) PURE;


  //***********************************************************
  //
  // AddMob()
  //
  /// Appends the given mob to the header.  If the given mob is already
  /// contained this method will do nothing and will return success.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pMob pointer is valid.
  /// - the given mob is not already part of this collection.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMob is null.
  ///
  /// AAFRESULT_DUPLICATE_MOBID
  ///   - the given mob is already contained.
  ///
  /// @param pMob [in] Mob to add
  ///
  STDMETHOD(AddMob) (THIS_
    IAAFMob * pMob) PURE;


  //***********************************************************
  //
  // RemoveMob()
  //
  /// Removes the given mob from the header.
  ///
  /// Succeeds if all of the following are true:
  /// - the pMob pointer is valid.
  /// - the given mob is currently in the collection.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMob is null.
  ///
  /// AAFRESULT_MOB_NOT_FOUND
  ///   - the given mob is not already contained.
  ///
  /// @param pMob [in] Mob to remove
  ///
  STDMETHOD(RemoveMob) (THIS_
    IAAFMob * pMob) PURE;


  //***********************************************************
  //
  // CountEssenceData()
  //
  /// Writes the total number of essence data into the *pNumEssenceData
  /// argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pNumEssenceData pointer is valid.
  /// 
  /// If this method fails nothing will be written to
  /// *pNumEssenceData.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumEssenceData is null.
  ///
  /// @param pResult [out, retval] Total number of essence data
  ///
  STDMETHOD(CountEssenceData) (THIS_
    aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // IsEssenceDataPresent()
  //
  /// Returns true if the essence is found.
  ///
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  ///
  /// @param fileMobID [in, ref] A Unique File Mob ID
  /// @param fmt [in] The Essence File Format
  /// @param pResult [out,retval] True if the essence is found
  ///
  STDMETHOD(IsEssenceDataPresent) (THIS_
    aafMobID_constref  fileMobID,
    aafFileFormat_t  fmt,
    aafBoolean_t *  pResult) PURE;


  //***********************************************************
  //
  // EnumEssenceData()
  //
  /// Places an enumerator for essence that applies to the criteria
  /// into the *ppEnum argument.  The returned enumerator is
  /// AddRef()ed before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pMediaCriteria pointer is valid.
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pMediaCriteria or ppEnum is null.
  ///
  /// @param ppEnum [out,retval] Essence Enumeration
  ///
  STDMETHOD(EnumEssenceData) (THIS_
    IEnumAAFEssenceData ** ppEnum) PURE;


  //***********************************************************
  //
  // AddEssenceData()
  //
  /// Appends the given essence data object to the header.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pEssenceData pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_DUPLICATE_MOBID
  ///   - The given mob has already been added.  The validation is done by comparing
  ///     mobIDs, which should be unique.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEssenceData is null.
  ///
  /// @param pEssenceData [in] Essence data object to append
  ///
  STDMETHOD(AddEssenceData) (THIS_
    IAAFEssenceData * pEssenceData) PURE;

  //***********************************************************
  //
  // RemoveEssenceData()
  //
  /// Removes the given EssenceData from the header.
  ///
  /// Succeeds if all of the following are true:
  /// - the pEssenceData pointer is valid.
  /// - the given EssenceData is currently in the collection.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEssenceData is null.
  ///
  /// AAFRESULT_ESSENCE_NOT_FOUND
  ///   - the given EssenceData is not already contained.
  ///
  /// @param pEssenceData [in] EssenceData to remove
  ///
  STDMETHOD(RemoveEssenceData) (THIS_
    IAAFEssenceData * pEssenceData) PURE;

  //***********************************************************
  //
  // LookupEssenceData()
  //
  /// Looks up the EssenceData that matches the given mob id and puts it into
  /// the ppEssenceData argument.  The returned EssenceData interface is AddRef()ed
  /// before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEssenceData pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEssenceData.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEssenceData is null
  ///
  /// AAFRESULT_MOB_NOT_FOUND
  ///   - the requested EssenceData wasn't found.
  ///
  /// @param mobID [in, ref] The Mob ID
  /// @param ppEssenceData [out,retval] Matching EssenceData
  ///
  STDMETHOD(LookupEssenceData) (THIS_
    aafMobID_constref  mobID,
    IAAFEssenceData ** ppEssenceData) PURE;

  //***********************************************************
  //
  // GetDictionary()
  //
  /// Places the dictionary that contains all types of aaf definition
  /// objects into the *ppDictionary argument.  The returned dictionary
  /// is AddRef()ed before it is returned.  Note that the dictionary
  /// is automatically created when the header object is created.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppDictionary pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDictionary is null.
  ///
  /// @param ppDictionary [out, retval] The AAF Dictionary
  ///
  STDMETHOD(GetDictionary) (THIS_
    IAAFDictionary ** ppDictionary) PURE;


  //***********************************************************
  //
  // GetLastIdentification()
  //
  /// Places the identification of the last entity that modified the
  /// file into the *ppIdentification argument.  The returned
  /// identification is AddRef()ed before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppIdentification pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppIdentification is null.
  ///
  /// @param ppIdentification [out,retval] Indentification Object
  ///
  STDMETHOD(GetLastIdentification) (THIS_
    IAAFIdentification ** ppIdentification) PURE;


  //***********************************************************
  //
  // LookupIdentification()
  //
  /// Places the Identification that matches the given generation into
  /// the *ppIdentification argument.  The returned identification is
  /// AddRef()ed before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppIdentification pointer is valid.
  /// - the given generation was found.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppIdentification is null.
  ///
  /// AAFRESULT_OBJECT_NOT_FOUND
  ///   - the given generation was not found..
  ///
  /// @param generation [in, ref] Unique Generation ID
  /// @param ppIdentification [out,retval] Indentification Object
  ///
  STDMETHOD(LookupIdentification) (THIS_
    aafUID_constref  generation,
    IAAFIdentification ** ppIdentification) PURE;


  //***********************************************************
  //
  // CountIdentifications()
  //
  /// Writes the number of identification objects into the *pResult
  /// argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  ///
  /// @param pResult [out, retval] Total number of identification objects
  ///
  STDMETHOD(CountIdentifications) (THIS_
    aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // GetIdentifications()
  //
  /// Places an enumerator for all Identifications criteria into the
  /// *ppEnum argument.  The returned enumerator is AddRef()ed before
  /// it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// @param ppEnum [out,retval] Indentification Enumeration
  ///
  STDMETHOD(GetIdentifications) (THIS_
    IEnumAAFIdentifications ** ppEnum) PURE;


  //***********************************************************
  //
  // AppendIdentification()
  //
  /// Appends the given Identification class to the header.  This
  /// method does not attempt to identify duplicate identifications, so
  /// it will succeed even if an identical identification has already
  /// been appended.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pIdent pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pIdent is null.
  ///
  /// @param pIdent [in] Identification to append
  ///
  STDMETHOD(AppendIdentification) (THIS_
    IAAFIdentification * pIdent) PURE;


  //***********************************************************
  //
  // GetIdentificationAt()
  //
  /// Retrieves the indexed identification from the header.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppIdentification pointer is valid.
  /// - index is less than the value returned by CountIdentifications().
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppIdent is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than or equal to result of
  ///     CountIdentifications().
  ///
  /// @param index [in] Index of identification to retrieve
  /// @param ppIdentification [out, retval] Retrieved identification
  ///
  STDMETHOD(GetIdentificationAt) (THIS_
    aafUInt32  index,
    IAAFIdentification ** ppIdentification) PURE;


  //***********************************************************
  //
  // GetRefImplVersion()
  //
  /// Return the version of the Reference Implementation currently
  /// running on this machine, which implements these interfaces.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pVersion pointer is valid.
  /// 
  /// If this method fails nothing is written to *pVersion.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pVersion is null.
  ///
  /// @param pVersion [out, retval] The Reference Implementation Version
  ///
  STDMETHOD(GetRefImplVersion) (THIS_
    aafProductVersion_t *  pVersion) PURE;


  //***********************************************************
  //
  // GetFileRevision()
  //
  /// Return the File Revision property.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pRevision pointer is valid.
  /// 
  /// If this method fails nothing is written to *pRevision.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pRevision is null.
  ///
  /// @param pRevision [out, retval] The File Version
  ///
  STDMETHOD(GetFileRevision) (THIS_
    aafVersionType_t *  pRevision) PURE;


  //***********************************************************
  //
  // GetLastModified()
  //
  /// Return the Last Modified property.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pTimeStamp pointer is valid.
  /// 
  /// If this method fails nothing is written to *pTimeStamp.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTimeStamp is null.
  ///
  /// @param pTimeStamp [out, retval] The modification date-time stamp
  ///
  STDMETHOD(GetLastModified) (THIS_
    aafTimeStamp_t *  pTimeStamp) PURE;


  //***********************************************************
  //
  // GetContentStorage()
  //
  /// Places the Content Storage object attached to the header into the
  /// *ppStorage argument.
  ///
  /// The returned content storage object is
  /// AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppStorage pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppStorage is null.
  ///
  /// @param ppStorage [out] Returned Content Storage object
  ///
  STDMETHOD(GetContentStorage) (THIS_
    IAAFContentStorage ** ppStorage) PURE;




















  END_INTERFACE
};
#endif // __IAAFHeader_INTERFACE_DEFINED__


// IAAFIdentification

// ************************
//
// Interface IAAFIdentification
//
// ************************



#ifndef __IAAFIdentification_INTERFACE_DEFINED__
#define __IAAFIdentification_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFIdentification;

#undef  INTERFACE
#define INTERFACE   IAAFIdentification

DECLARE_INTERFACE_(IAAFIdentification, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFIdentification methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated IAAFIdentification-supporting
  /// object.  This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// This method fills in the mandatory properties of the object.  The
  /// values of the following required properties are set based on the
  /// information given in arguments to this method:
  /// - companyName
  /// - productname
  /// - productVersionString
  /// - productID
  /// 
  /// The following mandatory properties will be filled in
  /// automatically by the reference implementation:
  /// - date
  /// - generationAUID
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  /// - companyName is a valid pointer
  /// - productName is a valid pointer
  /// - productVersionString is a valid pointer
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - companyName, productName, or productVersionString is NULL.
  ///
  /// @param companyName [in] company name string
  /// @param productName [in] product name string
  /// @param productVersionString [in] product version string
  /// @param productID [in] product identification
  ///
  STDMETHOD(Initialize) (THIS_
    aafCharacter_constptr  companyName,
    aafCharacter_constptr  productName,
    aafCharacter_constptr  productVersionString,
    aafUID_constref  productID) PURE;


  //***********************************************************
  //
  // GetCompanyName()
  //
  /// Gets the Company Name string property.
  /// 
  /// Writes the CompanyName property, with a trailing null
  /// character, into the pCompanyName buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the CompanyName property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetCompanyNameBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pCompanyName.
  /// 
  /// Succeeds if:
  /// - The pCompanyName pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   CompanyName.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCompanyName arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold CompanyName.
  ///
  /// @param pCompanyName [out, string, size_is(bufSize)] buffer into which CompanyName is to be written
  /// @param bufSize [in] size of *pCompanyName buffer in bytes
  ///
  STDMETHOD(GetCompanyName) (THIS_
    aafCharacter *  pCompanyName,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetCompanyNameBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetCompanyName().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetCompanyNameBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;


  //***********************************************************
  //
  // GetProductName()
  //
  /// Gets the Product Name string property.
  /// 
  /// Writes the ProductName property, with a trailing null
  /// character, into the pProductName buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the ProductName property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetProductNameBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pProductName.
  /// 
  /// Succeeds if:
  /// - The pProductName pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   ProductName.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pProductName arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold ProductName.
  ///
  /// @param pProductName [out, string, size_is(bufSize)] buffer into which ProductName is to be written
  /// @param bufSize [in] size of *pProductName buffer in bytes
  ///
  STDMETHOD(GetProductName) (THIS_
    aafCharacter *  pProductName,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetProductNameBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetProductName().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetProductNameBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;


  //***********************************************************
  //
  // GetProductVersionString()
  //
  /// Gets the Product Version string property.
  /// 
  /// Writes the ProductVersionString property, with a trailing null
  /// character, into the pProductVersionString buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the ProductVersionString property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetProductVersionStringBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pProductVersionString.
  /// 
  /// Succeeds if:
  /// - The pProductVersionString pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   ProductVersionString.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pProductVersionString arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold ProductVersionString.
  ///
  /// @param pProductVersionString [out, string, size_is(bufSize)] buffer into which ProductVersionString is to be written
  /// @param bufSize [in] size of *pProductVersionString buffer in bytes
  ///
  STDMETHOD(GetProductVersionString) (THIS_
    aafCharacter *  pProductVersionString,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetProductVersionStringBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetProductVersionString().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetProductVersionStringBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;


  //***********************************************************
  //
  // GetProductVersion()
  //
  /// Gets the Product Version property associated with this
  /// identification object and places it into *pVersion.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pVersion pointer is valid.
  /// 
  /// If this method fails, nothing will be written to *pVersion.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pVersion arg is NULL.
  ///
  /// @param pVersion [out] The Product Version
  ///
  STDMETHOD(GetProductVersion) (THIS_
    aafProductVersion_t *  pVersion) PURE;


  //***********************************************************
  //
  // SetProductVersion()
  //
  /// Set the Product Version property to the value specified in
  /// pVersion.  A copy is made of the data so the caller retains
  /// ownership of the *pVersion struct and is responsible for
  /// de-allocating it.
  /// 
  /// If this method fails the Product Version property will not be
  /// changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param version [in] The Product Version
  ///
  STDMETHOD(SetProductVersion) (THIS_
    aafProductVersion_constref  version) PURE;


  //***********************************************************
  //
  // GetProductID()
  //
  /// Obtains the Product ID, which is the identification number
  /// assigned to the application and vendor of the application which
  /// attached this object to the AAF file.  This ID is written into
  /// the caller-allocated aafUID_t specified by the pProductID
  /// argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pProductID pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pProductID.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pProductID arg is NULL.
  ///
  /// @param pProductID [out] The Product ID
  ///
  STDMETHOD(GetProductID) (THIS_
    aafUID_t *  pProductID) PURE;


  //***********************************************************
  //
  // GetDate()
  //
  /// Writes the Date-time Stamp property into the caller-allocated
  /// aafTimeStamp_t specified by the pTimeStamp argument.  The
  /// date-time stamp recorded in this object corresponds to the time
  /// that this file was created or modified upon the occasion that
  /// this object was added to the file.
  ///
  /// Note: This is a read-only property.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pTimeStamp pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pTimeStamp.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTimeStamp arg is NULL.
  ///
  /// @param pTimestamp [out] The date-time stamp
  ///
  STDMETHOD(GetDate) (THIS_
    aafTimeStamp_t *  pTimestamp) PURE;


  //***********************************************************
  //
  // GetRefImplVersion()
  //
  /// Obtains the version of the Reference Implementation which
  /// created this identification object and writes it into the
  /// caller-allocated aafProductVersion_t specified by the pVersion
  /// argument.
  ///
  /// Note: This is a read-only property.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pVersion pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pVersion.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pVersion arg is NULL.
  ///
  /// @param pVersion [out] The Reference Implementation Version
  ///
  STDMETHOD(GetRefImplVersion) (THIS_
    aafProductVersion_t *  pVersion) PURE;


  //***********************************************************
  //
  // GetPlatform()
  //
  /// Gets the Platform string property.
  ///
  /// This information is provided only to allow diagnostic printing of
  /// platform information to be read by humans.  The format of the
  /// strings is not guaranteed to remain the same for a given
  /// platform.  Having said that, the possible values currently
  /// returned are:
  /// - "Win32" for Intel/Win32 platforms
  /// - "MacOS" for MacOS platforms
  /// - "Unknown" for unknown platforms
  /// 
  /// Writes the Platform property, with a trailing null
  /// character, into the pPlatform buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the Platform property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetPlatformBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pPlatform.
  /// 
  /// Succeeds if:
  /// - The pPlatform pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   Platform.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPlatform arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold Platform.
  ///
  /// @param pPlatform [out, string, size_is(bufSize)] buffer into which Platform is to be written
  /// @param bufSize [in] size of *pPlatform buffer in bytes
  ///
  STDMETHOD(GetPlatform) (THIS_
    aafCharacter *  pPlatform,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetPlatformBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetPlatform().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetPlatformBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;


  //***********************************************************
  //
  // GetGenerationID()
  //
  /// Obtains the generation of this AAF file, which was generated at
  /// the time this identification object was created.  If a file was
  /// opened for modification by many applications in its lifetime,
  /// then there will be multiple Identification objects.  This is
  /// written into the caller-allocated aafUID_t specified by the
  /// pGeneration argument.
  /// 
  /// Note: This is a read-only property.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pGeneration pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pGeneration.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pGeneration arg is NULL.
  ///
  /// @param pGeneration [out] The unique generation
  ///
  STDMETHOD(GetGenerationID) (THIS_
    aafUID_t *  pGeneration) PURE;

  END_INTERFACE
};
#endif // __IAAFIdentification_INTERFACE_DEFINED__



// IAAFImportDescriptor

// ************************
//
// Interface IAAFImportDescriptor
//
// ************************




#ifndef __IAAFImportDescriptor_INTERFACE_DEFINED__
#define __IAAFImportDescriptor_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFImportDescriptor;

#undef  INTERFACE
#define INTERFACE   IAAFImportDescriptor

DECLARE_INTERFACE_(IAAFImportDescriptor, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFImportDescriptor methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty
  /// IAAFImportDescriptor-supporting object.  This method must be called
  /// after allocation, and before any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  STDMETHOD(Initialize) (THIS) PURE;


  END_INTERFACE
};
#endif // __IAAFImportDescriptor_INTERFACE_DEFINED__



// IAAFInterpolationDef

// ************************
//
// Interface IAAFInterpolationDef
//
// ************************




#ifndef __IAAFInterpolationDef_INTERFACE_DEFINED__
#define __IAAFInterpolationDef_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFInterpolationDef;

#undef  INTERFACE
#define INTERFACE   IAAFInterpolationDef

DECLARE_INTERFACE_(IAAFInterpolationDef, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFInterpolationDef methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Init all fields of a definition object.
  ///
  /// @param id [in, ref] AUID for new DefObject
  /// @param pName [in, string] Name for new DefObject
  /// @param pDescription [in, string] Description for new DefObject
  ///
  STDMETHOD(Initialize) (THIS_
    aafUID_constref  id,
    aafCharacter_constptr  pName,
    aafCharacter_constptr  pDescription) PURE;



  END_INTERFACE
};
#endif // __IAAFInterpolationDef_INTERFACE_DEFINED__



// IAAFKLVData

// ************************
//
// Interface IAAFKLVData
//
// ************************




#ifndef __IAAFKLVData_INTERFACE_DEFINED__
#define __IAAFKLVData_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFKLVData;

#undef  INTERFACE
#define INTERFACE   IAAFKLVData

DECLARE_INTERFACE_(IAAFKLVData, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFKLVData methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a new KLVData object to be interpreted using the
  /// given given key.  The key must have been registered using dictionary->RegisterKLVDataKey()
  /// in order to use the byte swapping functionality of the type model.
  ///
  /// This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  /// - pName is a valid pointer.
  /// - pTypeDef is a valid pointer and registered
  /// - pValue is a valid pointer
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - This object has already had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTypeDef or pValue arg is NULL.
  ///
  /// AAFRESULT_NOT_VALID_KEY
  ///   - The  given key must not resolve to a builtin type.  For most purposes, use
  ///     IAAFTypeDefRename to rename an existing type.
  ///
  /// 
  ///
  /// @param key [in] Key of the following value data
  /// @param length [in] Length of preallocated buffer
  /// @param pValue [in, size_is(length)] buffer containing value
  ///
  STDMETHOD(Initialize) (THIS_
    aafUID_t  key,
    aafUInt32  length,
    aafDataBuffer_t  pValue) PURE;

  //***********************************************************
  //
  // GetKey()
  //
  /// Returns the type definition for this invocation.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pKey pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pKey.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - This property does not exist in the file.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pKey arg is NULL.
  ///
  /// @param pKey [out] The key of this object
  ///
  STDMETHOD(GetKey) (THIS_
    aafUID_t*  pKey) PURE;


  //***********************************************************
  //
  // GetValue()
  //
  /// Writes the value into the pValue buffer.  The buffer is allocated
  /// by the caller, and the size of the buffer is given by
  /// valueSize.
  /// 
  /// Caller may call GetValueBufLen() to determine the
  /// required buffer size.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pValue pointer is valid.
  /// - valueSize indicates the buffer is large enough to hold the name.
  /// 
  /// If this method fails nothing will be written to *pValue.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pValue arg is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - valueSize indicates the buffer is too small to hold the value.
  ///
  /// @param valueSize [in] Size of preallocated buffer
  /// @param pValue [out, size_is(valueSize), length_is(*bytesRead)] Preallocated buffer to hold value
  /// @param bytesRead [out] Number of actual bytes read
  ///
  STDMETHOD(GetValue) (THIS_
    aafUInt32  valueSize,
    aafDataBuffer_t  pValue,
    aafUInt32 *  bytesRead) PURE;


  //***********************************************************
  //
  // GetValueBufLen()
  //
  /// Returns the length of buffer required for the GetValue() method.
  /// The value is placed into the location specified by pLen.
  ///
  /// Succeeds if all of the following are true:
  /// - the pLen pointer is valid.
  ///
  /// If this method fails nothing will be written to *pLen.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLen arg is NULL.
  ///
  /// @param pLen [out] Pointer to an variable used to return the length
  ///
  STDMETHOD(GetValueBufLen) (THIS_
    aafUInt32 *  pLen) PURE;

  //***********************************************************
  //
  // SetValue()
  //
  /// The data value is set from a buffer of size valueSize and type.
  ///
  /// Succeeds if all of the following are true:
  /// - the pValue pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pValue is null.
  ///
  /// @param valueSize [in] Size of preallocated buffer
  /// @param pValue [in, size_is(valueSize)] buffer containing value
  ///
  STDMETHOD(SetValue) (THIS_
    aafUInt32  valueSize,
    aafDataBuffer_t  pValue) PURE;


  END_INTERFACE
};
#endif // __IAAFKLVData_INTERFACE_DEFINED__



// IAAFKLVDataDefinition

// ************************
//
// Interface IAAFKLVDataDefinition
//
// ************************







#ifndef __IAAFKLVDataDefinition_INTERFACE_DEFINED__
#define __IAAFKLVDataDefinition_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFKLVDataDefinition;

#undef  INTERFACE
#define INTERFACE   IAAFKLVDataDefinition

DECLARE_INTERFACE_(IAAFKLVDataDefinition, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFKLVDataDefinition methods *** */


  //***********************************************************
  //
  // Initialize()
  //
  /// Init all fields of a definition object.
  ///
  /// @param id [in, ref] AUID for new DefObject
  /// @param pName [in, string] Name for new DefObject
  /// @param pDescription [in, string] Description for new DefObject
  ///
  STDMETHOD(Initialize) (THIS_
    aafUID_constref  id,
    aafCharacter_constptr  pName,
    aafCharacter_constptr  pDescription) PURE;

  //***********************************************************
  //
  // AddParentProperty()
  //
  /// Add a property definition to the KLV data definition.
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pParentProperty is null.
  ///
  /// @param pParentProperty [in] Property definition to add.
  ///
  STDMETHOD(AddParentProperty) (THIS_
    IAAFPropertyDef * pParentProperty) PURE;

  //***********************************************************
  //
  // GetParentProperties()
  //
  /// Writes an enumerator for the property definitions into *ppEnum.
  /// A reference is added to the new enumerator before it is returned.
  ///
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// @param ppEnum [out] Property definition enumerator.
  ///
  STDMETHOD(GetParentProperties) (THIS_
    IEnumAAFPropertyDefs ** ppEnum) PURE;

  //***********************************************************
  //
  // CountParentProperties()
  //
  /// Writes the total number of property definitions into *pNumProperties if,
  /// and only if, the method succeeds.
  ///
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// @param pNumProperties [out] Number of property definitions.
  ///
  STDMETHOD(CountParentProperties) (THIS_
    aafUInt32*  pNumProperties) PURE;

  //***********************************************************
  //
  // RemoveParentProperty()
  //
  /// Removes the given property definition.
  ///
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - The property definition is not in this tagged value definition.
  ///
  /// @param pParentProperty [in] Property to remove.
  ///
  STDMETHOD(RemoveParentProperty) (THIS_
    IAAFPropertyDef * pParentProperty) PURE;

  //***********************************************************
  //
  // GetKLVDataType()
  //
  /// Writes the data definition object attached to this KLV data
  /// definition into the *ppTypeDef argument if, and only if, the call succeeds.
  /// If none exists, NULL is written to the *ppTypeDef argument.
  ///
  /// The returned data definition object, if it exists, is
  /// AddRef()ed before it is returned.
  ///
  /// Return codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTypeDef is null.
  ///
  /// @param ppTypeDef [out] Returned data definition object
  ///
  STDMETHOD(GetKLVDataType) (THIS_
    IAAFTypeDef ** ppTypeDef) PURE;


  //***********************************************************
  //
  // SetKLVDataType()
  //
  /// Sets the date type of this KLV data definition to be the given one.
  ///
  /// Return codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTypeDef is null.
  ///
  /// @param pTypeDef [in] Data definition object
  ///
  STDMETHOD(SetKLVDataType) (THIS_
    IAAFTypeDef * pTypeDef) PURE;


  END_INTERFACE
};
#endif // __IAAFKLVDataDefinition_INTERFACE_DEFINED__



// IAAFLocator

// ************************
//
// Interface IAAFLocator
//
// ************************



#ifndef __IAAFLocator_INTERFACE_DEFINED__
#define __IAAFLocator_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFLocator;

#undef  INTERFACE
#define INTERFACE   IAAFLocator

DECLARE_INTERFACE_(IAAFLocator, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFLocator methods *** */

  //***********************************************************
  //
  // SetPath()
  //
  /// Sets the Path string property.
  ///
  /// Set the Path property to the value specified in
  /// pPath.  A copy is made of the data so the caller
  /// retains ownership of the *pPath buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pPath pointer is valid.
  /// 
  /// If this method fails the Path property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPath arg is NULL.
  ///
  /// @param pPath [in, string] buffer from which Path is to be read
  ///
  STDMETHOD(SetPath) (THIS_
    aafCharacter_constptr  pPath) PURE;


  //***********************************************************
  //
  // GetPath()
  //
  /// Gets the Path string property.
  /// 
  /// Writes the Path property, with a trailing null
  /// character, into the pPath buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the Path property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetPathBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pPath.
  /// 
  /// Succeeds if:
  /// - The pPath pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   Path.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPath arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold Path.
  ///
  /// @param pPath [out, string, size_is(bufSize)] buffer into which Path is to be written
  /// @param bufSize [in] size of *pPath buffer in bytes
  ///
  STDMETHOD(GetPath) (THIS_
    aafCharacter *  pPath,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetPathBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetPath().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetPathBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;

  END_INTERFACE
};
#endif // __IAAFLocator_INTERFACE_DEFINED__



// IAAFMasterMob

// ************************
//
// Interface IAAFMasterMob
//
// ************************









#ifndef __IAAFMasterMob_INTERFACE_DEFINED__
#define __IAAFMasterMob_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFMasterMob;

#undef  INTERFACE
#define INTERFACE   IAAFMasterMob

DECLARE_INTERFACE_(IAAFMasterMob, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFMasterMob methods *** */
  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty IAAFMasterMob-supporting
  /// object.  This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  STDMETHOD(Initialize) (THIS) PURE;


  //***********************************************************
  //
  // AddMasterSlot()
  //
  /// This function adds a slot to the specified Master Mob that
  /// references the specified a slot in the specified Source Mob. The
  /// new slot in the Master Mob contains a Source Clip that specifies
  /// the Source Mob in its source reference properties.  Typically this
  /// is done automatically by passing the Master Mob handle to
  /// AAFMedia::Create, but this function allows you to add it later.
  ///
  /// Note: If pSlotName is passed in with zero length, then the
  /// slot is not assigned a name.  Slot names are not used by the
  /// SDK, and exist only so the user can name slots.
  /// 
  /// Succeeds if all of the following are true:
  /// (more conditions here)
  /// 
  /// If this method fails no state is changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - One or more of the following parameters are NULL pSourceMob,
  ///     pSlotName, and pDataDef.
  ///
  /// AAFRESULT_INVALID_DATADEF
  ///   - The data kind of the source MOB slot to be added to the Master
  ///     Mob does not match what is specfied in pDataDef.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The specified Source Mob slot was not found.
  ///
  /// AAFRESULT_SLOT_EXISTS
  ///   - The specified Master slot ID already exists.
  ///
  /// @param pDataDef [in] Data kind of new slot.  Requires a data kind valid for a media
  /// stream. Valid data kinds are:
  /// - Picture
  /// - Sound
  /// @param sourceSlotID [in] Slot ID of the Source Mob slot to be added to the Master Mob
  /// @param pSourceMob [in] Source Mob containing the slot to be added to the Master Mob
  /// @param masterSlotID [in] SlotID assigned to the new Master Mob slot
  /// @param pSlotName [in, string] Name to assign to new slot in Master Mob
  ///
  STDMETHOD(AddMasterSlot) (THIS_
    IAAFDataDef * pDataDef,
    aafSlotID_t  sourceSlotID,
    IAAFSourceMob * pSourceMob,
    aafSlotID_t  masterSlotID,
    aafCharacter_constptr  pSlotName) PURE;


  //***********************************************************
  //
  // GetTapeName()
  //
  /// Finds the tape Source Mob associated with a Master Mob slot
  /// and writes the name of the tape, which is stored in the
  /// Mobs Name property, into the pTapeName buffer.  The buffer is
  /// allocated by the caller.  The size of the buffer is given by
  /// bufSize.  If the property name has not yet been set, a
  /// zero-length string will be written (that is, only the trailing
  /// null character).
  /// 
  /// Caller may call GetTapeNameBufLen() to determine the required
  /// buffer size.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pTapeName pointer is valid.
  /// - the specified master slot was found.
  /// - the specified master slot contains a tape mob.
  /// - bufSize indicates the buffer is large enough to hold the name.
  /// 
  /// If this method fails nothing will be written to *pTapeName.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTapeName arg is NULL.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The specified Master Slot was not found.
  ///
  /// AAFRESULT_NOT_TAPEMOB
  ///   - The specified Master Slot does not contain a Tape MOB.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - bufSize indicates the buffer is too small to hold the string.
  ///
  /// @param masterSlotID [in] SlotID of the Master Mob slot
  /// @param pTapeName [out, size_is(bufSize), string] The returned name
  /// @param bufSize [in] the size of the pTapeName buffer
  ///
  STDMETHOD(GetTapeName) (THIS_
    aafUInt32  masterSlotID,
    aafCharacter *  pTapeName,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetTapeNameBufLen()
  //
  /// Returns the length of buffer required for the GetTapeName()
  /// method.  The value is placed into the location specified by
  /// pLen.  The value will include space required for the trailing
  /// null character.
  ///
  /// Succeeds if all of the following are true:
  /// - the pLen pointer is valid.
  ///
  /// If this method fails nothing will be written to *pLen.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLen arg is NULL.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The specified Master Slot was not found.
  ///
  /// AAFRESULT_NOT_TAPEMOB
  ///   - The specified Master Slot does not contain a Tape MOB.
  ///
  /// @param masterSlotID [in] SlotID of the Master Mob slot
  /// @param pLen [out] required buffer length
  ///
  STDMETHOD(GetTapeNameBufLen) (THIS_
    aafUInt32  masterSlotID,
    aafUInt32 *  pLen) PURE;


  //***********************************************************
  //
  // GetNumRepresentations()
  //
  /// This function returns the number of media representations
  /// available for the specified SlotID on a specified Master
  /// Mob. This function is meant to work with
  /// GetRepresentationSourceClip, so that you can iterate through
  /// all of the choices yourself.  In most cases, you can use
  /// GetCriteriaSourceClip to handle multiple
  /// representations.  This function and
  /// GetRepresentationSourceClip are lower-level functions.
  ///
  /// Succeeds if all of the following are true:
  /// - the pNumReps pointer is valid.
  ///
  /// If this method fails nothing will be written to *pNumReps.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumReps arg is NULL.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The Master Slot specified by slotID was not found.
  ///
  /// @param slotID [in] SlotID
  /// @param pNumReps [out, retval] number of representations
  ///
  STDMETHOD(GetNumRepresentations) (THIS_
    aafSlotID_t  slotID,
    aafNumSlots_t *  pNumReps) PURE;


  //***********************************************************
  //
  // GetRepresentation()
  //
  /// This method returns the indexed media representation for the
  /// specified Master Mob, SlotID, and index.  This call is meant to
  /// work with GetNumRepresentations, so that you can iterate through
  /// all of the choices yourself.  This method uses an integer index,
  /// not an iterator.  The function GetRepresentationSourceClip takes
  /// an index between 1 and the number of representations
  /// [inclusive], and returns the indexed Source Mob. You can make
  /// calls to functions such as AAFMedia::GetVideoInfo and
  /// AAFMedia::IsMediaContiguous to determine which media is the best
  /// fit.
  ///
  /// The returned source clip is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppSourceClip pointer is valid.
  ///
  /// If this method fails nothing will be written to *ppSourceClip.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppSourceClip arg is NULL.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The specified Master Slot was not found.
  ///
  /// AAFRESULT_BADINDEX
  ///   - No Source Mob at specified index.
  ///
  /// @param slotID [in] Slot ID
  /// @param index [in] Index of requested representation
  /// @param ppSourceClip [out] Requested Source Clip
  ///
  STDMETHOD(GetRepresentation) (THIS_
    aafSlotID_t  slotID,
    aafUInt32  index,
    IAAFSegment ** ppSourceClip) PURE;


  //***********************************************************
  //
  // GetCriteriaSegment()
  //
  /// Returns the Segment on the specified slot of a Master Mob
  /// that references the Source Mob that best meets the specified
  /// criteria.  This function will work whether multiple media
  /// representations exist or not.
  ///
  /// The returned segment is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppSegment pointer is valid.
  ///
  /// If this method fails nothing will be written to *ppSegment.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppSegment arg is NULL.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The specified Master Slot was not found.
  ///
  /// @param slotID [in] Slot ID
  /// @param pCriteria [in] Index of requested representation.  Note: the
  /// aafMediaCriteria_t is defined as the following structure:
  /// typedef struct
  /// {
  ///	aafCriteriaType_t type;
  ///	aafCriteriaProc_t proc;
  /// } aafMediaCriteria_t;
  ///
  /// The type field can have one of the following values:
  /// typedef enum
  /// {
  ///	kAAFAnyRepresentation = 0,
  ///	kAAFFastestRepresentation,
  ///	kAAFBestFidelityRepresentation,
  ///	kAAFSmallestRepresentation,
  ///	kAAFUseRepresentationProc
  /// } aafCriteriaType_t;
  /// @param ppSegment [out] Requested Segment
  ///
  STDMETHOD(GetCriteriaSegment) (THIS_
    aafSlotID_t  slotID,
    aafMediaCriteria_t *  pCriteria,
    IAAFSegment ** ppSegment) PURE;


  //***********************************************************
  //
  // AppendPhysSourceRef()
  //
  /// Connects this Source Mob with the physical Source Mob that
  /// describes the previous generation of essence, appending it to
  /// existing Mob data.  If a physical Source Mob, such as a File
  /// Source Mob or tape Source Mob, references another physical
  /// Source Mob as its ancestor, with no pulldown, then this
  /// function makes the connection between the two.
  ///
  /// Functionally, this is a helper function to create a slot with an
  /// AAFSourceClip referencing a particular piece of media.  This
  /// function takes many parameters because the components of an
  /// aafSourceRef_t have been broken out as separate parameters.
  ///
  /// The ancestor of an AAFSourceMob with an AAFFileDescriptor is often an
  /// AAFTapeDescriptor or NIL.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSourceRefObj pointer is valid.
  /// - the pEssenceKind pointer is valid.
  /// (other conditions here)
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSourceRefObj or pEssenceKind is null.
  ///
  /// (other codes here.)
  ///
  /// @param editrate [in] Edit rate of slot to contain reference
  /// @param aMobSlot [in] SlotID of slot to contain reference
  /// @param pEssenceKind [in] Data kind of slot to contain reference.  Requires a data kind
  /// valid for a essence stream.  Valid data kinds are:
  /// - Picture
  /// - Sound
  /// @param ref [in] Reference to a Physical Source Mob
  /// @param srcRefLength [in] Length of the Source Clip
  ///
  STDMETHOD(AppendPhysSourceRef) (THIS_
    aafRational_t  editrate,
    aafSlotID_t  aMobSlot,
    IAAFDataDef * pEssenceKind,
    aafSourceRef_t  ref,
    aafLength_t  srcRefLength) PURE;


  //***********************************************************
  //
  // NewPhysSourceRef()
  //
  /// Connects this Source Mob with the physical Source Mob that
  /// describes the previous generation of essence, replacing any
  /// existing Mob data.  If a physical Source Mob, such as a File
  /// Source Mob or tape Source Mob, references another physical
  /// Source Mob as its ancestor, with no pulldown, then this
  /// function makes the connection between the two.
  ///
  /// Functionally, this is a helper function to create a slot with an
  /// AAFSourceClip referencing a particular piece of media.  This
  /// function takes many parameters because the components of an
  /// aafSourceRef_t have been broken out as separate parameters.
  ///
  /// The ancestor of an AAFSourceMob with an AAFFileDescriptor is often an
  /// AAFTapeDescriptor or NIL.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSourceRefObj pointer is valid.
  /// - the pEssenceKind pointer is valid.
  /// (other conditions here)
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSourceRefObj or pEssenceKind is null.
  ///
  /// (other codes here.)
  ///
  /// @param editrate [in] Edit rate of slot to contain reference
  /// @param aMobSlot [in] SlotID of slot to contain reference
  /// @param pEssenceKind [in] Data kind of slot to contain reference.  Requires a data kind
  /// valid for a essence stream.  Valid data kinds are:
  /// - Picture
  /// - Sound
  /// @param ref [in] Reference to a Physical Source Mob
  /// @param srcRefLength [in] Length of the Source Clip
  ///
  STDMETHOD(NewPhysSourceRef) (THIS_
    aafRational_t  editrate,
    aafSlotID_t  aMobSlot,
    IAAFDataDef * pEssenceKind,
    aafSourceRef_t  ref,
    aafLength_t  srcRefLength) PURE;


  //***********************************************************
  //
  // CreateEssence()
  //
  /// Creates a single channel stream of essence.  Convenience
  /// functions exist to create audio or video essence, and a separate
  /// call (MultiCreate) exists to create interleaved audio and video
  /// data.
  ///
  /// The essence handle from this call can be used with
  /// WriteDataSamples  and possibly WriteDataLines, but NOT with
  /// WriteMultiSamples.
  /// 
  /// If you are creating the essence, and then attaching it to a
  /// master mob, then the "masterMob" field may be left NULL.  For
  /// video, the sampleRate should be the edit rate of the file mob.
  /// For audio, the sample rate should be the actual samples per
  /// second.
  ///
  /// @param masterSlotID [in] 
  /// @param pMediaKind [in] create essence of this type
  /// @param codecID [in, ref] using this codec
  /// @param editRate [in] with this edit rate
  /// @param samplerate [in] with this sample rate
  /// @param Enable [in] optionally compressing it
  /// @param destination [in] Optionally create the file HERE.
  /// @param fileFormat objPass with this format
  /// @param access objOut Return an essence access on the essence.
  ///
  STDMETHOD(CreateEssence) (THIS_
    aafSlotID_t  masterSlotID,
    IAAFDataDef * pMediaKind,
    aafUID_constref  codecID,
    aafRational_t  editRate,
    aafRational_t  samplerate,
    aafCompressEnable_t  Enable,
    IAAFLocator * destination,
    aafUID_constref  fileFormat,
    IAAFEssenceAccess ** access) PURE;


  //***********************************************************
  //
  // CreateMultiEssence()
  //
  /// Creates a multi-channel interleaved stream of essence.  The
  /// essence handle from this call can be used with WriteDataSamples
  /// or WriteMultiSamples but NOT with or WriteDataLines.
  /// 
  /// If you are creating the essence, and then attaching it to a
  /// master mob, then the "masterMob" field may be left NULL.
  ///
  /// @param codecID [in, ref] using this codec
  /// @param arrayElemCount [in] this many channels
  /// @param mediaArray [in,ref,size_is(arrayElemCount)] using these definitions
  /// @param Enable [in] optionally compressing it
  /// @param destination [in] Optionally create the file HERE.
  /// @param fileFormat [in, ref] with this format
  /// @param access [out] Return an essence access on the essence.
  ///
  STDMETHOD(CreateMultiEssence) (THIS_
    aafUID_constref  codecID,
    aafUInt16  arrayElemCount,
    aafmMultiCreate_t *  mediaArray,
    aafCompressEnable_t  Enable,
    IAAFLocator * destination,
    aafUID_constref  fileFormat,
    IAAFEssenceMultiAccess**  access) PURE;


  //***********************************************************
  //
  // OpenEssence()
  //
  /// Opens a single channel of a file mob.  If the essence is
  /// interleaved, then it will be di-interleaved when samples are
  /// read.  This routine follows the locator, and may call the locator
  /// failure callback if the essence can not be found.  If the failure
  /// callback finds the essence, then this routine will return
  /// normally.
  /// 
  /// The essence handle from this call can be used with
  /// ReadDataSamples  and possibly ReadDataLines, but NOT with
  /// ReadMultiSamples.
  /// 
  /// NOTE: If a locator is followed, then essencePtr may reference
  /// ANOTHER file object, which must be closed on file close.
  ///
  /// @param slotID [in] On this slot
  /// @param mediaCrit [in] using this essence criteria
  /// @param openMode [in] ReadOnly or Append
  /// @param compEnable [in] optionally decompressing
  /// @param access [out] Return an essence access on the essence.
  ///
  STDMETHOD(OpenEssence) (THIS_
    aafSlotID_t  slotID,
    aafMediaCriteria_t*  mediaCrit,
    aafMediaOpenMode_t  openMode,
    aafCompressEnable_t  compEnable,
    IAAFEssenceAccess ** access) PURE;
	

  //***********************************************************
  //
  // OpenMultiEssence()
  //
  /// Opens a all channels associated with a file mob.  This routine
  /// follows the locator, and may call the locator failure callback if
  /// the essence can not be found.  If the failure callback finds the
  /// essence, then this routine will return normally.
  ///
  /// The essence handle from this call can be used with
  /// WriteMultiSamples but NOT with WriteDataSamples.
  ///
  /// @param slotID [in] On this slot
  /// @param mediaCrit [in] using this essence criteria
  /// @param openMode [in] ReadOnly or Append
  /// @param compEnable [in] optionally decompressing
  /// @param access [out] Return an essence access on the essence.
  ///
  STDMETHOD(OpenMultiEssence) (THIS_
    aafSlotID_t  slotID,
    aafMediaCriteria_t*  mediaCrit,
    aafMediaOpenMode_t  openMode,
    aafCompressEnable_t  compEnable,
    IAAFEssenceMultiAccess**  access) PURE;


  //***********************************************************
  //
  // CountChannels()
  //
  /// Takes an opaque handle, a master mob reference, and a slot ID
  /// so that it may be called before the essence is opened.
  ///
  /// Returns the number of interleaved essence channels of a given
  /// type in the essence stream referenced by the given file mob.
  ///
  /// If the data format is not interleaved, then the answer will
  /// always be zero or one.  This function correctly returns zero for
  /// essence types not handled by a given codec, and handles codecs
  /// which work with multiple essence types.
  ///
  /// @param slotID [in] On this slot
  /// @param mediaCrit [in] using this essence criteria
  /// @param pMediaKind [in] for this essence type
  /// @param numCh [out] How many channels?
  ///
  STDMETHOD(CountChannels) (THIS_
    aafSlotID_t  slotID,
    aafMediaCriteria_t*  mediaCrit,
    IAAFDataDef * pMediaKind,
    aafUInt16*  numCh) PURE;













  END_INTERFACE
};
#endif // __IAAFMasterMob_INTERFACE_DEFINED__


// IAAFMetaDefinition

// ************************
//
// Interface IAAFMetaDefinition
//
// ************************





#ifndef __IAAFMetaDefinition_INTERFACE_DEFINED__
#define __IAAFMetaDefinition_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFMetaDefinition;

#undef  INTERFACE
#define INTERFACE   IAAFMetaDefinition

DECLARE_INTERFACE_(IAAFMetaDefinition, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFMetaDefinition methods *** */


  //***********************************************************
  //
  // Initialize()
  //
  /// Init all fields of a meta definition object.
  ///
  /// @param id [in, ref] AUID for new DefObject
  /// @param pName [in, string] Name for new Meta Definition
  /// @param pDescription [in, string] the Description of this meta definition
  ///
  STDMETHOD(Initialize) (THIS_
    aafUID_constref  id,
    aafCharacter_constptr  pName,
    aafCharacter_constptr  pDescription) PURE;


  //***********************************************************
  //
  // GetAUID()
  //
  /// Gets the AUID for this object.
  ///
  /// @param pAuid [retval,out] Pointer to an AUID reference
  ///
  STDMETHOD(GetAUID) (THIS_
    aafUID_t *  pAuid) PURE;

  //***********************************************************
  //
  // SetName()
  //
  /// Sets the Name of this definition.
  ///
  /// Set the Name property to the value specified in
  /// pName.  A copy is made of the data so the caller
  /// retains ownership of the *pName buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pName pointer is valid.
  /// 
  /// If this method fails the Name property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  ///
  /// @param pName [in, string] buffer from which Name is to be read
  ///
  STDMETHOD(SetName) (THIS_
    aafCharacter_constptr  pName) PURE;


  //***********************************************************
  //
  // GetName()
  //
  /// Gets the Name of this definition.
  /// 
  /// Writes the Name property, with a trailing null
  /// character, into the pName buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the Name property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetNameBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pName.
  /// 
  /// Succeeds if:
  /// - The pName pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   Name.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold Name.
  ///
  /// @param pName [out, string, size_is(bufSize)] buffer into which Name is to be written
  /// @param bufSize [in] size of *pName buffer in bytes
  ///
  STDMETHOD(GetName) (THIS_
    aafCharacter *  pName,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetNameBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetName().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetNameBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;

  //***********************************************************
  //
  // SetDescription()
  //
  /// Sets the Description of this definition.
  ///
  /// Set the Description property to the value specified in
  /// pDescription.  A copy is made of the data so the caller
  /// retains ownership of the *pDescription buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pDescription pointer is valid.
  /// 
  /// If this method fails the Description property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDescription arg is NULL.
  ///
  /// @param pDescription [in, string] buffer from which Description is to be read
  ///
  STDMETHOD(SetDescription) (THIS_
    aafCharacter_constptr  pDescription) PURE;


  //***********************************************************
  //
  // GetDescription()
  //
  /// Gets the Description of this definition.
  /// 
  /// Writes the Description property, with a trailing null
  /// character, into the pDescription buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the Description property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetDescriptionBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pDescription.
  /// 
  /// Succeeds if:
  /// - The pDescription pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   Description.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDescription arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold Description.
  ///
  /// @param pDescription [out, string, size_is(bufSize)] buffer into which Description is to be written
  /// @param bufSize [in] size of *pDescription buffer in bytes
  ///
  STDMETHOD(GetDescription) (THIS_
    aafCharacter *  pDescription,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetDescriptionBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetDescription().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetDescriptionBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;


  END_INTERFACE
};
#endif // __IAAFMetaDefinition_INTERFACE_DEFINED__



// IAAFMob

// ************************
//
// Interface IAAFMob
//
// ************************














#ifndef __IAAFMob_INTERFACE_DEFINED__
#define __IAAFMob_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFMob;


#undef  INTERFACE
#define INTERFACE   IAAFMob

DECLARE_INTERFACE_(IAAFMob, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFMob methods *** */

  //***********************************************************
  //
  // GetMobID()
  //
  /// This method returns the unique Mob ID associated with this mob.
  ///
  /// Succeeds if all of the following are true:
  /// - the pMobID pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pMobID.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMobID arg is NULL.
  ///
  /// @param pMobID [out] The unique media object id
  ///
  STDMETHOD(GetMobID) (THIS_
    aafMobID_t *  pMobID) PURE;


  //***********************************************************
  //
  // SetMobID()
  //
  /// When a mob is initially created, the Reference Implementation
  /// internally creates a mobID for the new mob.  This method should
  /// be used to change the mob's identity to an explicit mobID.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param mobID [in, ref] New Mob ID
  ///
  STDMETHOD(SetMobID) (THIS_
    aafMobID_constref  mobID) PURE;


  //***********************************************************
  //
  // SetName()
  //
  /// Sets the Mob Name string property.
  ///
  /// Set the Name property to the value specified in
  /// pName.  A copy is made of the data so the caller
  /// retains ownership of the *pName buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pName pointer is valid.
  /// 
  /// If this method fails the Name property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  ///
  /// @param pName [in, string] buffer from which Name is to be read
  ///
  STDMETHOD(SetName) (THIS_
    aafCharacter_constptr  pName) PURE;


  //***********************************************************
  //
  // GetName()
  //
  /// Gets the Mob Name string property.
  /// 
  /// Writes the Name property, with a trailing null
  /// character, into the pName buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the Name property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetNameBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pName.
  /// 
  /// Succeeds if:
  /// - The pName pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   Name.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold Name.
  ///
  /// @param pName [out, string, size_is(bufSize)] buffer into which Name is to be written
  /// @param bufSize [in] size of *pName buffer in bytes
  ///
  STDMETHOD(GetName) (THIS_
    aafCharacter *  pName,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetNameBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetName().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetNameBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;


  //***********************************************************
  //
  // CountSlots()
  //
  /// This method returns the number of slots contained by this mob.
  ///
  /// Succeeds if all of the following are true:
  /// - the pNumSlots pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pNumSlots.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumSlots arg is NULL.
  ///
  /// @param pNumSlots [out] Number of slots
  ///
  STDMETHOD(CountSlots) (THIS_
    aafNumSlots_t *  pNumSlots) PURE;


  //***********************************************************
  //
  // AppendSlot()
  //
  /// Appends the given mob slot to the mob.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pSlot pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSlot is null.
  ///
  /// @param pSlot [in] slot to append
  ///
  STDMETHOD(AppendSlot) (THIS_
    IAAFMobSlot * pSlot) PURE;


  //***********************************************************
  //
  // PrependSlot()
  //
  /// Prepends the given mob slot to the mob.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pSlot pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSlot is null.
  ///
  /// @param pSlot [in] slot to prepend
  ///
  STDMETHOD(PrependSlot) (THIS_
    IAAFMobSlot * pSlot) PURE;


  //***********************************************************
  //
  // InsertSlotAt()
  //
  /// Inserts the given slot into this mob at the given index.  All
  /// existing slots at the given and higher index will be moved up one
  /// index to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pSlot pointer is valid.
  /// - index is less than or equal to the result obtained by
  ///   CountSlots().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSlot is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than the result obtained from CountSlots().
  ///
  /// @param index [in] index where slot is to be inserted
  /// @param pSlot [in] slot to insert
  ///
  STDMETHOD(InsertSlotAt) (THIS_
    aafUInt32  index,
    IAAFMobSlot * pSlot) PURE;


  //***********************************************************
  //
  // RemoveSlotAt()
  //
  /// Removes the slot at the given index.  All existing slots at
  /// indices higher than the given index will be moved down one index
  /// to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - index is less than the result obtained by CountSlots().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is not less than the result obtained from
  ///     CountSlots().
  ///
  /// @param index [in] index of slot to be removed
  ///
  STDMETHOD(RemoveSlotAt) (THIS_
    aafUInt32  index) PURE;


  //***********************************************************
  //
  // GetSlotAt()
  //
  /// Returns the indexed slot in *ppSlot.
  /// 
  /// Succeeds if all of the following are true:
  /// - ppSlot is a valid pointer.
  /// - index is less than the result obtained by CountSlots().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppSlot is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is not less than the result obtained from
  ///     CountSlots().
  ///
  /// @param index [in] index of slot to be obtained
  /// @param ppSlot [out, retval] the returned slot
  ///
  STDMETHOD(GetSlotAt) (THIS_
    aafUInt32  index,
    IAAFMobSlot ** ppSlot) PURE;


  //***********************************************************
  //
  // GetSlots()
  //
  /// Return an enumeration for all mob slots.  The returned
  /// enumerator is AddRef()ed before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// @param ppEnum [out] Mob Slot Enumeration
  ///
  STDMETHOD(GetSlots) (THIS_
    IEnumAAFMobSlots ** ppEnum) PURE;


  //***********************************************************
  //
  // GetModTime()
  //
  /// This method will return the modification time for this mob.
  ///
  /// Succeeds if all of the following are true:
  /// - the pLastModified pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pLastModified.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLastModified arg is NULL.
  ///
  /// @param pLastModified [out] Modified Time
  ///
  STDMETHOD(GetModTime) (THIS_
    aafTimeStamp_t *  pLastModified) PURE;


  //***********************************************************
  //
  // SetModTime()
  //
  /// This method sets the modification time on a mob.  The
  /// modification time is initially set to the time that the mob
  /// was created.  The Reference Implementation does not maintain the
  /// modification time every time that a mob has been updated.
  /// Therefore, this method should be called explicitly to change the
  /// modification time.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param modTime [in, ref] New Modification Time
  ///
  STDMETHOD(SetModTime) (THIS_
    aafTimeStamp_constref  modTime) PURE;


  //***********************************************************
  //
  // GetCreateTime()
  //
  /// This method will return the creation time for this mob.
  ///
  /// Succeeds if all of the following are true:
  /// - the pCreationTime pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pCreationTime.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCreationTime arg is NULL.
  ///
  /// @param pCreationTime [out] Creation Time
  ///
  STDMETHOD(GetCreateTime) (THIS_
    aafTimeStamp_t *  pCreationTime) PURE;


  //***********************************************************
  //
  // SetCreateTime()
  //
  /// This method sets the creation time on a mob.  The
  /// creation time is initially set to the time that the mob
  /// was created.
  /// Therefore, this method should be called explicitly to change the
  /// creation time.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param createTime [in, ref] New Creation Time
  ///
  STDMETHOD(SetCreateTime) (THIS_
    aafTimeStamp_constref  createTime) PURE;


  //***********************************************************
  //
  // AppendComment()
  //
  /// Creates a user-defined comment and appends it to the specified
  /// Mob.  A Mob comment is implemented as a AAFTaggedValue object of type 
  /// WCharString.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pCategory pointer is valid.
  /// - the pComment pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pCategory or pComment args is NULL.
  ///
  /// @param pCategory [in,string] Comment heading
  /// @param pComment [in, string] Comment value
  ///
  STDMETHOD(AppendComment) (THIS_
    aafCharacter *  pCategory,
    aafCharacter_constptr  pComment) PURE;


  //***********************************************************
  //
  // CountComments()
  //
  /// Return total number of comments attached to this mob.
  ///
  /// Succeeds if all of the following are true:
  /// - the pNumComments pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pNumComments.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumComments arg is NULL.
  ///
  /// @param pNumComments [out] Number  of Mob Comments
  ///
  STDMETHOD(CountComments) (THIS_
    aafUInt32 *  pNumComments) PURE;


  //***********************************************************
  //
  // GetComments()
  //
  /// Return the enumeration for all mob comments.  The returned
  /// enumerator is AddRef()ed before it is returned.  Mob comments are 
  /// implemented as AAFTaggedValue of type WCharString.   The enumerator
  /// is implemented as a EnumAAAFTaggedValues.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// @param ppEnum [out] Mob Comments
  ///
  STDMETHOD(GetComments) (THIS_
    IEnumAAFTaggedValues ** ppEnum) PURE;


  //***********************************************************
  //
  // RemoveComment()
  //
  /// Removes the given comment from this mob.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pComment pointer is valid.
  /// - the given comment is present in the mob.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pComment is null.
  ///
  /// AAFRESULT_OBJECT_NOT_FOUND
  ///   - the given comment is not in this mob.
  ///
  /// @param pComment [in] Comment to remove
  ///
  STDMETHOD(RemoveComment) (THIS_
    IAAFTaggedValue * pComment) PURE;


  //***********************************************************
  //
  // AppendNewTimelineSlot()
  //
  /// This method creates a new timeline mob slot with the given
  /// property values and appends it to the input mob.
  /// 
  /// The returned mob slot is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSegment pointer is valid.
  /// - the pSlotName pointer is valid.
  /// - the ppNewSlot pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - any of pSegment, pSlotName, or ppNewSlot arguments is null.
  ///
  /// @param editRate [in] Edit rate property value
  /// @param pSegment [in] Segment to append as slot component
  /// @param slotID [in] new slot ID
  /// @param pSlotName [in, string] new slot name
  /// @param origin [in] The slot origin
  /// @param ppNewSlot [out] Newly created slot
  ///
  STDMETHOD(AppendNewTimelineSlot) (THIS_
    aafRational_t  editRate,
    IAAFSegment * pSegment,
    aafSlotID_t  slotID,
    aafCharacter_constptr  pSlotName,
    aafPosition_t  origin,
    IAAFTimelineMobSlot ** ppNewSlot) PURE;


  //***********************************************************
  //
  // GetMobInfo()
  //
  /// This method will get all mob property information is a single call.
  ///
  /// Caller may call GetNameBufLen() to determine the required pName
  /// buffer size.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pLastModified pointer is valid.
  /// - the pCreationTime pointer is valid.
  /// - the pName pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pLastModified,
  /// *pCreationTime, or *pName.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - any of pLastModified, pCreationTime, or pName arguments is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - bufSize indicates the buffer is too small to hold the string.
  ///
  /// @param pLastModified [out] Modified Time
  /// @param pCreationTime [out] Creation Time
  /// @param pName [out, size_is(bufSize), string] Mob Name
  /// @param bufSize [in] size of the supplied buffer.
  ///
  STDMETHOD(GetMobInfo) (THIS_
    aafTimeStamp_t *  pLastModified,
    aafTimeStamp_t *  pCreationTime,
    aafCharacter *  pName,
    aafInt32  bufSize) PURE;


  //***********************************************************
  //
  // OffsetToMobTimecode()
  //
  /// This method will determine the timecode at the given offset into
  /// the given timecode segment, and will return it in *pResult.  If
  /// pTcSeg is NULL, will search for the slot containing a timecode
  /// segment and will use that instead.
  ///
  /// Succeeds if all of the following are true:
  /// - the pTcSeg pointer is valid.
  /// - the pOffset pointer is valid.
  /// - the pResult pointer is valid.
  /// - Timecode track exists.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pOffset or pResult argument is NULL.
  ///
  /// AAFRESULT_TIMECODE_NOT_FOUND
  ///   - timecode track wasn't found.
  ///
  /// @param pTcSeg [in] Timecode Segment
  /// @param pOffset [in] Offset into segment in edit units for that segment's mob slot
  /// @param pResult [out] The resulting timecode
  ///
  STDMETHOD(OffsetToMobTimecode) (THIS_
    IAAFSegment * pTcSeg,
    aafPosition_t *  pOffset,
    aafTimecode_t *  pResult) PURE;


  //***********************************************************
  //
  // LookupSlot()
  //
  /// The method will find the mob slot for the given slot id.
  ///
  /// The returned mob slot is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppDestSlot pointer is valid.
  /// - the given slot ID is found.
  /// 
  /// If this method fails nothing will be written to *ppDestSlot.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDestSlot arg is NULL.
  ///
  /// @param slotId [in] The requested slot id
  /// @param ppDestSlot [out] The requested slot
  ///
  STDMETHOD(LookupSlot) (THIS_
    aafSlotID_t  slotId,
    IAAFMobSlot ** ppDestSlot) PURE;


  //***********************************************************
  //
  // ChangeRef()
  //
  /// Finds all Source Clips in the specified Mob that refer to the
  /// specified old Mob, and changes the references to point to the
  /// new Mob.
  ///
  /// This function traverses through the entire structure of the input
  /// Mob looking for Source Clips, and changes the sourceID property
  /// on all Source Clips with oldMobID to newMobID.
  ///
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param oldMobID [in, ref] Old Mob ID reference in source clip
  /// @param newMobID [in, ref] New Mob ID reference in source clip
  ///
  STDMETHOD(ChangeRef) (THIS_
    aafMobID_constref  oldMobID,
    aafMobID_constref  newMobID) PURE;


  //***********************************************************
  //
  // CloneExternal()
  //
  /// Clones the specified Source Mob, and optionally all dependent
  /// Mobs, to an external file, keeping the same MobID.  A pointer
  /// to the newly created destination mob is returned in *ppDestMob.
  /// 
  /// This function clones the specified Source Mob in the source file
  /// into a destination Mob, with the same MobID, in the destination
  /// file.  If resolveDependencies is kFollowDepend, the function
  /// also clones all Mobs referenced by the specified Source Mob.  If
  /// includeMedia is kIncludeMedia, the function also copies the
  /// media data associated with the Source Mob, returns the
  /// destination Mob, and clones all private data.
  ///
  /// If the media data is not in the file, the function does not
  /// attempt to find it in another file and clone it.  Both AAF files
  /// must be open before you call this function and both must have the
  /// same AAF Version number.
  ///
  /// The returned mob is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the pDestFile pointer is valid.
  /// - the ppDestMob pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pDestFile or ppDestMob arguments is NULL.
  ///
  /// @param resolveDependencies [in] Whether to clone dependent mobs
  /// @param includeMedia [in] Whether to include media data
  /// @param pDestFile [in] Destination AAF File
  /// @param ppDestMob [out] Destination Mob
  ///
  STDMETHOD(CloneExternal) (THIS_
    aafDepend_t  resolveDependencies,
    aafIncMedia_t  includeMedia,
    IAAFFile * pDestFile,
    IAAFMob ** ppDestMob) PURE;


  //***********************************************************
  //
  // Copy()
  //
  /// This function copies the specified Mob into a destination Mob in
  /// the same AAF file. The new Mob is returned through the destMob
  /// parameter. The function gives the destination Mob a new MobID and
  /// the name specified in the destMobName parameter. The function
  /// also copies all private data.
  /// 
  /// The returned mob is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the pDestMobName pointer is valid.
  /// - the ppDestMob pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pDestMobName or pDestMob arguments is NULL.
  ///
  /// @param pDestMobName [in, string] Optional Input. The name to be assigned to the new copy of the
  /// Mob.  The destMobName argument is optional. Specify a NULL
  /// value if no destination Mob name is desired.
  /// @param ppDestMob [out] Destination Mob
  ///
  STDMETHOD(Copy) (THIS_
    aafCharacter_constptr  pDestMobName,
    IAAFMob ** ppDestMob) PURE;
  ///

  //***********************************************************
  //
  // AppendKLVData()
  //
  /// Appends a pre-existing KLV Data object to the specified
  /// Mob.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pKLV pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - the pData arg is NULL.
  ///
  /// @param pData [in] KLV object
  ///
  STDMETHOD(AppendKLVData) (THIS_
    IAAFKLVData * pData) PURE;


  //***********************************************************
  //
  // CountKLVData()
  //
  /// Return total number of KLV data objects attached to this mob.
  ///
  /// Succeeds if all of the following are true:
  /// - the pNumData pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pNumComments.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumData arg is NULL.
  ///
  /// @param pNumData [out] Number  of KLV data objects
  ///
  STDMETHOD(CountKLVData) (THIS_
    aafUInt32 *  pNumData) PURE;


  //***********************************************************
  //
  // GetKLVData()
  //
  /// Return the enumeration for all KLV data objects on this mob.  The returned
  /// enumerator is AddRef()ed before it is returned.  The enumerator
  /// is implemented as a EnumAAFKLVData.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// @param ppEnum [out] KLV data objects
  ///
  STDMETHOD(GetKLVData) (THIS_
    IEnumAAFKLVData ** ppEnum) PURE;


  //***********************************************************
  //
  // RemoveKLVData()
  //
  /// Removes the given KLV data object from this mob.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pData pointer is valid.
  /// - the given KLV data object is present in the mob.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pData is null.
  ///
  /// AAFRESULT_OBJECT_NOT_FOUND
  ///   - the given KLV data object is not in this mob.
  ///
  /// @param pData [in] KLV data object to remove
  ///
  STDMETHOD(RemoveKLVData) (THIS_
    IAAFKLVData * pData) PURE;














  END_INTERFACE
};
#endif // __IAAFMob_INTERFACE_DEFINED__


// IAAFMobSlot

// ************************
//
// Interface IAAFMobSlot
//
// ************************





#ifndef __IAAFMobSlot_INTERFACE_DEFINED__
#define __IAAFMobSlot_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFMobSlot;

#undef  INTERFACE
#define INTERFACE   IAAFMobSlot

DECLARE_INTERFACE_(IAAFMobSlot, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFMobSlot methods *** */

  //***********************************************************
  //
  // GetSegment()
  //
  /// This method will get the segment for this mob slot and place an
  /// interface for it into the **ppResult argument.  If a segment
  /// exists, the result will be AddRef()ed.  If not, the result will
  /// be NULL.
  ///
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult arg is NULL.
  ///
  /// @param ppResult [out,retval] Segment property value
  ///
  STDMETHOD(GetSegment) (THIS_
    IAAFSegment ** ppResult) PURE;


  //***********************************************************
  //
  // SetName()
  //
  /// Sets the Mob Slot Name string property.
  ///
  /// Set the Name property to the value specified in
  /// pName.  A copy is made of the data so the caller
  /// retains ownership of the *pName buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pName pointer is valid.
  /// 
  /// If this method fails the Name property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  ///
  /// @param pName [in, string] buffer from which Name is to be read
  ///
  STDMETHOD(SetName) (THIS_
    aafCharacter_constptr  pName) PURE;


  //***********************************************************
  //
  // GetName()
  //
  /// Gets the Mob Slot Name string property.
  /// 
  /// Writes the Name property, with a trailing null
  /// character, into the pName buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the Name property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetNameBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pName.
  /// 
  /// Succeeds if:
  /// - The pName pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   Name.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold Name.
  ///
  /// @param pName [out, string, size_is(bufSize)] buffer into which Name is to be written
  /// @param bufSize [in] size of *pName buffer in bytes
  ///
  STDMETHOD(GetName) (THIS_
    aafCharacter *  pName,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetNameBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetName().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetNameBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;


  //***********************************************************
  //
  // GetPhysicalNum()
  //
  /// Returns information about the physical output channel associated
  /// with the  Slot.
  ///
  /// This function returns the physical slot number of the specified
  /// slot. The physical slot number identifies the physical slot
  /// associated with the media.  For File Source Mobs that describe
  /// stereo audio media, the left channel should have a PhysicalSlot
  /// of 1 and the right channel should have a Physical-Slot of 2.
  ///
  /// The function returns an error if the object specified in the slot
  /// parameter is not a slot.
  ///
  /// Succeeds if all of the following are true:
  /// - the pDatadef pointer is valid.
  /// - the object in the slot parameter is a slot.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDatadef arg is NULL.
  ///
  /// AAFRESULT_SLOT_NOT_FOUND
  ///   - object specified is not a slot.
  ///
  /// @param pResult [out,retval] The physical slot number property value
  ///
  STDMETHOD(GetPhysicalNum) (THIS_
    aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // GetDataDef()
  //
  /// This method will return the Data Definition object
  /// associated with the segment in this Mob Slot.  Common
  /// DataDefinitions are kAAFDataDef_Picture, kAAFDataDef_Sound, kAAFDataDef_Timecode,
  /// and kAAFDataDef_Edgecode.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppResult arg is NULL.
  ///
  /// @param ppResult [out,retval] Data Definition AUID
  ///
  STDMETHOD(GetDataDef) (THIS_
    IAAFDataDef ** ppResult) PURE;


  //***********************************************************
  //
  // GetSlotID()
  //
  /// This method will return the slot id of this mob slot.
  ///
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult arg is NULL.
  ///
  /// @param pResult [out,retval] Slot id of the Mob Slot
  ///
  STDMETHOD(GetSlotID) (THIS_
    aafSlotID_t *  pResult) PURE;


  //***********************************************************
  //
  // SetSegment()
  //
  /// This method will set the segment for this mob slot.  If a segment
  /// already exists for this mob slot, it will be discarded.
  /// 
  /// Always succeeds.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param pSegment [in] Segment property value
  ///
  STDMETHOD(SetSegment) (THIS_
    IAAFSegment * pSegment) PURE;


  //***********************************************************
  //
  // SetPhysicalNum()
  //
  /// This function sets the physical slot number of the specified
  /// slot.  The physical slot number identifies the physical slot
  /// associated with the media.  For File Source Mobs that describe
  /// stereo audio media, the left channel should have a PhysicalSlot
  /// of 1 and the right channel should have a Physical-Slot of 2.
  ///
  /// The function returns an error if the Mob Slot passed in is not a
  /// slot.
  /// 
  /// Succeeds if all of the following are true:
  /// - the Mob Slot passed in is a slot.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.
  ///
  /// AAFRESULT_SLOT_NOT_FOUND
  ///   - object specified is not a slot.
  ///
  /// @param number [in] The physical slot number property value
  ///
  STDMETHOD(SetPhysicalNum) (THIS_
    aafUInt32  number) PURE;


  //***********************************************************
  //
  // SetSlotID()
  //
  /// This method will set the slot id of this mob slot.
  /// 
  /// Always succeeds.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param value [in] Slot id of the Mob Slot
  ///
  STDMETHOD(SetSlotID) (THIS_
    aafSlotID_t  value) PURE;

  END_INTERFACE
};
#endif // __IAAFMobSlot_INTERFACE_DEFINED__



// IAAFMPEGVideoDescriptor

// ************************
//
// Interface IAAFMPEGVideoDescriptor
//
// ************************





#ifndef __IAAFMPEGVideoDescriptor_INTERFACE_DEFINED__
#define __IAAFMPEGVideoDescriptor_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFMPEGVideoDescriptor;

#undef  INTERFACE
#define INTERFACE   IAAFMPEGVideoDescriptor

DECLARE_INTERFACE_(IAAFMPEGVideoDescriptor, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFMPEGVideoDescriptor methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty
  /// IAAFMPEGVideoDescriptor-supporting object.  This method must be
  /// called after allocation, and before any other method can be
  /// called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  STDMETHOD(Initialize) (THIS) PURE;


  //***********************************************************
  //
  // SetSingleSequence()
  //
  /// Sets the SingleSequence property. This property is optional.
  /// 
  /// If this method fails, the SingleSequence property will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  ///
  /// @param singleSequence [in] value to assign to the SingleSequence property
  ///
  STDMETHOD(SetSingleSequence) (THIS_
    aafBoolean_t  singleSequence) PURE;


  //***********************************************************
  //
  // GetSingleSequence()
  //
  /// Gets the SingleSequence property.
  ///
  /// Succeeds if all of the following are true:
  /// - pSingleSequence is a valid pointer
  /// - the property is present.
  ///
  /// If this method fails, pSingleSequence will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSingleSequence is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pSingleSequence [out] The value of the SingleSequence property
  ///
  STDMETHOD(GetSingleSequence) (THIS_
    aafBoolean_t *  pSingleSequence) PURE;


  //***********************************************************
  //
  // SetConstantBPictureCount()
  //
  /// Sets the ConstantBPictureCount property. This property is optional.
  /// 
  /// If this method fails, the ConstantBPictureCount property will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  ///
  /// @param constantBPictureCount [in] value to assign to the ConstantBPictureCount property
  ///
  STDMETHOD(SetConstantBPictureCount) (THIS_
    aafBoolean_t  constantBPictureCount) PURE;


  //***********************************************************
  //
  // GetConstantBPictureCount()
  //
  /// Gets the ConstantBPictureCount property.
  ///
  /// Succeeds if all of the following are true:
  /// - pConstantBPictureCount is a valid pointer
  /// - the property is present.
  ///
  /// If this method fails, pConstantBPictureCount will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSingleSequence is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pConstantBPictureCount [out] value of the ConstantBPictureCount property
  ///
  STDMETHOD(GetConstantBPictureCount) (THIS_
    aafBoolean_t *  pConstantBPictureCount) PURE;


  //***********************************************************
  //
  // SetCodedContentScanning()
  //
  /// Sets the CodedContentScanning property.  This property is optional.
  ///
  /// Succeeds if all of the following are true:
  /// - codedContentDirection is a valid value.
  /// 
  /// If this method fails, the CodedContentScanning property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_AAFRESULT_INVALID_ENUM_VALUE
  ///   - codedContentDirection is not a valid value.
  ///
  /// @param codedContentScanning [in] Coded Content Scanning value.
  ///
  STDMETHOD(SetCodedContentScanning) (THIS_
    aafContentScanningType_t  codedContentScanning) PURE;


  //***********************************************************
  //
  // GetCodedContentScanning()
  //
  /// Gets the CodedContentScanning property.  This property is optional.
  ///
  /// Succeeds if all of the following are true:
  /// - pContentScanning is a valid pointer
  /// - the property is present.
  /// 
  /// If this method fails, pSContentScanning not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pContentScanning is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pContentScanning [out] Coded content scanning value.
  ///
  STDMETHOD(GetCodedContentScanning) (THIS_
    aafContentScanningType_t *  pContentScanning) PURE;


  //***********************************************************
  //
  // SetLowDelay()
  //
  /// Sets the LowDelay property.  This property is optional.
  ///
  /// If this method fails, the LowDelay property will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  ///
  /// @param lowDelay [in] value to assign to the LowDelay property
  ///
  STDMETHOD(SetLowDelay) (THIS_
    aafBoolean_t  lowDelay) PURE;


  //***********************************************************
  //
  // GetLowDelay()
  //
  /// Gets the LowDelay property.
  ///
  /// Succeeds if all of the following are true:
  /// - pLowDelay is a valid pointer
  /// - the property is present.
  ///
  /// If this method fails, pLowDelay will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLowDelay is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pLowDelay [out] value of the LowDelay property
  ///
  STDMETHOD(GetLowDelay) (THIS_
    aafBoolean_t *  pLowDelay) PURE;


  //***********************************************************
  //
  // SetClosedGOP()
  //
  /// Sets the ClosedGOP property. This property is optional.
  /// 
  /// If this method fails, the ClosedGOP property will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  ///
  /// @param closedGOP [in] value to assign to the ClosedGOP property
  ///
  STDMETHOD(SetClosedGOP) (THIS_
    aafBoolean_t  closedGOP) PURE;


  //***********************************************************
  //
  // GetClosedGOP()
  //
  /// Gets the ClosedGOP property.
  ///
  /// Succeeds if all of the following are true:
  /// - pClosedGOP is a valid pointer
  /// - the property is present.
  ///
  /// If this method fails, pClosedGOP will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pClosedGOP is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pClosedGOP [out] value of the ClosedGOP property
  ///
  STDMETHOD(GetClosedGOP) (THIS_
    aafBoolean_t *  pClosedGOP) PURE;


  //***********************************************************
  //
  // SetIdenticalGOP()
  //
  /// Sets the IdenticalGOP property. This is an optional property.
  /// 
  /// If this method fails, the IdenticalGOP property will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  ///
  /// @param identicalGOP [in] value to assign to the IdenticalGOP property
  ///
  STDMETHOD(SetIdenticalGOP) (THIS_
    aafBoolean_t  identicalGOP) PURE;


  //***********************************************************
  //
  // GetIdenticalGOP()
  //
  /// Gets the IdenticalGOP property.
  ///
  /// Succeeds if all of the following are true:
  /// - pIdenticalGOP is a valid pointer
  /// - the property is present.
  ///
  /// If this method fails, pIdenticalGOP will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pIdenticalGOP is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pIdenticalGOP [out] value of the IdenticalGOP property
  ///
  STDMETHOD(GetIdenticalGOP) (THIS_
    aafBoolean_t *  pIdenticalGOP) PURE;


  //***********************************************************
  //
  // SetMaxGOP()
  //
  /// Sets the MaxGOP property. This is an optional property.
  ///
  /// If this method fails, the MaxGOP property will not be
  /// changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param maxGOP [in] value to assign to the MaxGOP property
  ///
  STDMETHOD(SetMaxGOP) (THIS_
    aafUInt16  maxGOP) PURE;

  //***********************************************************
  //
  // GetMaxGOP()
  //
  /// Gets the MaxGOP property.
  ///
  /// Succeeds if all of the following are true:
  /// - pMaxGOP is a valid pointer
  /// - the property is present.
  ///
  /// If this method fails, pMaxGOP will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMaxGOP is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pMaxGOP [out] value of the MaxGOP property
  ///
  STDMETHOD(GetMaxGOP) (THIS_
    aafUInt16 *  pMaxGOP) PURE;


  //***********************************************************
  //
  // SetMaxBPictureCount()
  //
  /// Sets the MaxBPictureCount property. This is an optional property.
  ///
  /// If this method fails, the MaxBPictureCount property will not be
  /// changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param maxBPictureCount [in] value to assign to the MaxBPictureCount property
  ///
  STDMETHOD(SetMaxBPictureCount) (THIS_
    aafUInt16  maxBPictureCount) PURE;

  //***********************************************************
  //
  // GetMaxBPictureCount()
  //
  /// Gets the MaxBPictureCount property.
  ///
  /// Succeeds if all of the following are true:
  /// - pMaxBPictureCount is a valid pointer
  /// - the property is present.
  ///
  /// If this method fails, pMaxBPictureCount will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMaxBPictureCount is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pMaxBPictureCount [out] valud of the MaxBPictureCount property
  ///
  STDMETHOD(GetMaxBPictureCount) (THIS_
    aafUInt16 *  pMaxBPictureCount) PURE;


  //***********************************************************
  //
  // SetBitRate()
  //
  /// Sets the BitRate property. This is an optional property.
  ///
  /// If this method fails, the BitRate property will not be
  /// changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param bitRate [in] value to assign to the BitRate property
  ///
  STDMETHOD(SetBitRate) (THIS_
    aafUInt32  bitRate) PURE;

  //***********************************************************
  //
  // GetBitRate()
  //
  /// Gets the BitRate property.
  ///
  /// Succeeds if all of the following are true:
  /// - pBitRate is a valid pointer
  /// - the property is present.
  ///
  /// If this method fails, pBitRate will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBitRate is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pBitRate [out] value of the BitRate property
  ///
  STDMETHOD(GetBitRate) (THIS_
    aafUInt32 *  pBitRate) PURE;


  //***********************************************************
  //
  // SetProfileAndLevel()
  //
  /// Sets the ProfileAndLevel property. This is an optional property.
  ///
  /// If this method fails, the ProfileAndLevel property will not be
  /// changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param profileAndLevel [in] value to assign to the ProfileAndLevel property
  ///
  STDMETHOD(SetProfileAndLevel) (THIS_
    aafUInt8  profileAndLevel) PURE;

  //***********************************************************
  //
  // GetProfileAndLevel()
  //
  /// Gets the ProfileAndLevele property.
  ///
  /// Succeeds if all of the following are true:
  /// - pProfileAndLevel is a valid pointer
  /// - the property is present.
  ///
  /// If this method fails, pProfileAndLevel will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pProfileAndLevel is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pProfileAndLevel [out] value of the ProfileAndLevel property
  ///
  STDMETHOD(GetProfileAndLevel) (THIS_
    aafUInt8 *  pProfileAndLevel) PURE;


  END_INTERFACE
};
#endif // __IAAFMPEGVideoDescriptor_INTERFACE_DEFINED__



// IAAFMultipleDescriptor

// ************************
//
// Interface IAAFMultipleDescriptor
//
// ************************






#ifndef __IAAFMultipleDescriptor_INTERFACE_DEFINED__
#define __IAAFMultipleDescriptor_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFMultipleDescriptor;


#undef  INTERFACE
#define INTERFACE   IAAFMultipleDescriptor

DECLARE_INTERFACE_(IAAFMultipleDescriptor, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFMultipleDescriptor methods *** */


  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty
  /// IAAFMultipleDescriptor-supporting object.  This method must be
  /// called after allocation, and before any other method can be
  /// called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  STDMETHOD(Initialize) (THIS) PURE;

  //***********************************************************
  //
  // CountFileDescriptors()
  //
  /// Return the number of FileDescriptors attached to this essence
  /// descriptor.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pCount pointer is valid.
  /// 
  /// If this method fails nothing is written to *pCount.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCount is null.
  ///
  /// @param pResult [out] Returns the number of FileDescriptors
  ///
  STDMETHOD(CountFileDescriptors) (THIS_
    aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // AppendFileDescriptor()
  //
  /// Append another FileDescriptor to this essence descriptor.  Use this
  /// function to add a FileDescriptor to the end of the interleave pattern.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pFileDescriptor pointer is valid.
  /// - the pFileDescriptor pointer indicates an object which is not already
  ///   owned by any object
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFileDescriptor is null.
  ///
  /// AAFRESULT_OBJECT_ALREADY_ATTACHED
  ///   - the object pointed to by pFileDescriptor is already owned by this
  ///     or another object.
  ///
  /// @param pFileDescriptor [in] FileDescriptor to append
  ///
  STDMETHOD(AppendFileDescriptor) (THIS_
    IAAFFileDescriptor * pFileDescriptor) PURE;


  //***********************************************************
  //
  // PrependFileDescriptor()
  //
  /// Prepend another FileDescriptor to this essence descriptor.  Use this
  /// function to add a FileDescriptor to to the beginning of the interleave pattern.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pFileDescriptor pointer is valid.
  /// - the pFileDescriptor pointer indicates an object which is not already
  ///   owned by any object
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFileDescriptor is null.
  ///
  /// AAFRESULT_OBJECT_ALREADY_ATTACHED
  ///   - the object pointed to by pFileDescriptor is already owned by this
  ///     or another object.
  ///
  /// @param pFileDescriptor [in] FileDescriptor to append
  ///
  STDMETHOD(PrependFileDescriptor) (THIS_
    IAAFFileDescriptor * pFileDescriptor) PURE;


  //***********************************************************
  //
  // InsertFileDescriptorAt()
  //
  /// Inserts the given FileDescriptor at the given index.  FileDescriptors already
  /// existing at the given and higher indices will be moved to the
  /// next higher index to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pFileDescriptor pointer is valid.
  /// - index is less than or equal to the value returned by
  ///   CountFileDescriptors().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFileDescriptor is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than the value returned by
  ///     CountFileDescriptors().
  ///
  /// @param index [in] index at which FileDescriptor is to be inserted
  /// @param pFileDescriptor [in] FileDescriptor to append
  ///
  STDMETHOD(InsertFileDescriptorAt) (THIS_
    aafUInt32  index,
    IAAFFileDescriptor * pFileDescriptor) PURE;


  //***********************************************************
  //
  // GetFileDescriptorAt()
  //
  /// Retrieves the FileDescriptor at the given index.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pFileDescriptor pointer is valid.
  /// - index is less than the value returned by CountFileDescriptors().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFileDescriptor is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than or equal to the value returned by
  ///     CountFileDescriptors().
  ///
  /// @param index [in] index of FileDescriptor to retrieve
  /// @param ppFileDescriptor [out, retval] returned FileDescriptor
  ///
  STDMETHOD(GetFileDescriptorAt) (THIS_
    aafUInt32  index,
    IAAFFileDescriptor ** ppFileDescriptor) PURE;


  //***********************************************************
  //
  // RemoveFileDescriptorAt()
  //
  /// Removes the FileDescriptor at the given index.  FileDescriptors already
  /// existing at indices higher than the given index will be moved to
  /// the next lower index to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - index is less than the value returned by CountFileDescriptors().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than or equal to the value returned by
  ///     CountFileDescriptors().
  ///
  /// @param index [in] index of FileDescriptor to remove
  ///
  STDMETHOD(RemoveFileDescriptorAt) (THIS_
    aafUInt32  index) PURE;


  //***********************************************************
  //
  // GetFileDescriptors()
  //
  /// Returns an enumerator of all the FileDescriptors in 
  /// this MultipleDescriptor.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// @param ppEnum [out] An enumerator of the FileDescriptors in this MultipleDescriptor
  ///
  STDMETHOD(GetFileDescriptors) (THIS_
    IEnumAAFFileDescriptors ** ppEnum) PURE;


  END_INTERFACE
};
#endif // __IAAFMultipleDescriptor_INTERFACE_DEFINED__



// IAAFNestedScope

// ************************
//
// Interface IAAFNestedScope
//
// ************************






#ifndef __IAAFNestedScope_INTERFACE_DEFINED__
#define __IAAFNestedScope_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFNestedScope;

#undef  INTERFACE
#define INTERFACE   IAAFNestedScope

DECLARE_INTERFACE_(IAAFNestedScope, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFNestedScope methods *** */

  //***********************************************************
  //
  // AppendSegment()
  //
  /// Append another input segment to the list of source segments.  The
  /// last segment added will be used as the output of the nested
  /// scope, and usually contains operations whose inputs are scope
  /// references.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pSegment pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSegment is null.
  ///
  /// @param pSegment [in] Pointer to segment to be added
  ///
  STDMETHOD(AppendSegment) (THIS_
    IAAFSegment * pSegment) PURE;


  //***********************************************************
  //
  // PrependSegment()
  //
  /// Prepend another input segment to the list of source segments.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pSegment pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSegment is null.
  ///
  /// @param pSegment [in] Pointer to segment to be added
  ///
  STDMETHOD(PrependSegment) (THIS_
    IAAFSegment * pSegment) PURE;


  //***********************************************************
  //
  // InsertSegmentAt()
  //
  /// Insert an input segment to the list of source segments at the
  /// given index.  Segments already existing at the given and higher
  /// indices will be moved up one index to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pSegment pointer is valid.
  /// - index is less than or equal to the value returned by
  ///   CountSegments().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSegment is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than the value returned by
  ///     CountSegments().
  ///
  /// @param index [in] index where segment is to be inserted
  /// @param pSegment [in] Pointer to segment to be added
  ///
  STDMETHOD(InsertSegmentAt) (THIS_
    aafUInt32  index,
    IAAFSegment * pSegment) PURE;


  //***********************************************************
  //
  // RemoveSegmentAt()
  //
  /// Removes the indexed segment.  Segments already existing at
  /// indices greater than the given index will be moved down by one
  /// index to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pSegment pointer is valid.
  /// - index is less than the value returned by CountSegments().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSegment is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than or equal to the value returned by
  ///     CountSegments().
  ///
  /// @param index [in] index of segment to be removed
  ///
  STDMETHOD(RemoveSegmentAt) (THIS_
    aafUInt32  index) PURE;


  //***********************************************************
  //
  // CountSegments()
  //
  /// Returns the number of source segments currently contained.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails no value will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  ///
  /// @param pResult [out, retval] number of segments contained
  ///
  STDMETHOD(CountSegments) (THIS_
    aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // GetSegmentAt()
  //
  /// Retrieves the indexed segment.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// - index is less than the value returned by CountSegments().
  /// 
  /// If this method fails nothing will be written to *ppSegment.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than or equal to the value returned by
  ///     CountSegments().
  ///
  /// @param index [in] index of segment to retrieve
  /// @param ppSegment [out, retval] retrieved segment
  ///
  STDMETHOD(GetSegmentAt) (THIS_
    aafUInt32  index,
    IAAFSegment ** ppSegment) PURE;


  //***********************************************************
  //
  // GetSegments()
  //
  /// Return an enumerator for the ordered list of AAFSegments which
  /// make up the nested scope.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// @param ppEnum [out, retval] Slots - segment list  enumeration
  ///
  STDMETHOD(GetSegments) (THIS_
    IEnumAAFSegments ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IAAFNestedScope_INTERFACE_DEFINED__



// IAAFNetworkLocator

// ************************
//
// Interface IAAFNetworkLocator
//
// ************************



#ifndef __IAAFNetworkLocator_INTERFACE_DEFINED__
#define __IAAFNetworkLocator_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFNetworkLocator;

#undef  INTERFACE
#define INTERFACE   IAAFNetworkLocator

DECLARE_INTERFACE_(IAAFNetworkLocator, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFNetworkLocator methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty
  /// IAAFNetworkLocator-supporting object.  This method must be called
  /// after allocation, and before any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  STDMETHOD(Initialize) (THIS) PURE;










  END_INTERFACE
};
#endif // __IAAFNetworkLocator_INTERFACE_DEFINED__



// IAAFObject

// ************************
//
// Interface IAAFObject
//
// ************************











#ifndef __IAAFObject_INTERFACE_DEFINED__
#define __IAAFObject_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFObject;

#undef  INTERFACE
#define INTERFACE   IAAFObject

DECLARE_INTERFACE_(IAAFObject, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFObject methods *** */

  //***********************************************************
  //
  // GetGeneration()
  //
  /// Gets the generation of this object, which is represented by an
  /// AAFIdentification object.  This is used to detect when an object
  /// has been modified.
  ///
  /// This method will succeed if generation tracking is enabled for
  /// this object.  Call EnableGenerationTrackint() and
  /// DisableGenerationTrackint() to control generation tracking for
  /// this object.  Call IsGenerationTracked() to determine if
  /// generation tracking is currently enabled for this object.
  ///
  /// Succeeds if all of the following are true:
  /// - the given pGeneration pointer is valid.
  /// - generation tracking is enabled for this object.
  /// - this object is attached to a file.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppGeneration arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - Generation tracking is not enabled for this object.
  ///
  /// AAFRESULT_OBJECT_NOT_ATTACHED
  ///   - This object is not attached to a file from which generation
  ///     information can be obtained..
  ///
  /// @param ppGeneration [out] AAFIdentification object corresponding to this object's
  /// Generation ID
  ///
  STDMETHOD(GetGeneration) (THIS_
    IAAFIdentification ** ppGeneration) PURE;


  //***********************************************************
  //
  // GetGenerationAUID()
  //
  /// Shortcut to get the AUID representing the Identification
  /// representing this object's generation.  (Can also be obtained by
  /// calling this->GetGeneration(&pIdent), and using its result to
  /// call pIdent->GetAuid()).
  ///
  /// This method will succeed if generation tracking is enabled for
  /// this object.  Call EnableGenerationTrackint() and
  /// DisableGenerationTrackint() to control generation tracking for
  /// this object.  Call IsGenerationTracked() to determine if
  /// generation tracking is currently enabled for this object.
  ///
  /// Succeeds if all of the following are true:
  /// - the given pResult pointer is valid.
  /// - generation tracking is enabled for this object.
  /// - this object is attached to a file.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - Generation tracking is not enabled for this object.
  ///
  /// AAFRESULT_OBJECT_NOT_ATTACHED
  ///   - This object is not attached to a file from which generation
  ///     information can be obtained..
  ///
  /// @param pResult [out] AUID corresponding to this object's Generation ID
  ///
  STDMETHOD(GetGenerationAUID) (THIS_
    aafUID_t *  pResult) PURE;


  //***********************************************************
  //
  // GetDefinition()
  //
  /// Returns the class definition which describes this object
  /// instance.
  ///
  /// Succeeds if all of the following are true:
  /// - the given ppClassDef pointer is valid.
  ///
  /// Note! Use care when dealing with the object class.  Among the
  /// pitfalls to be avoided is that tests for equality will not
  /// reflect inheritance.  This becomes important if an unknown
  /// non-builtin (that is, user defined) object class ID is obtained.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppClassDef arg is NULL.
  ///
  /// @param ppClassDef [out] class definition of which this object is an instance.
  ///
  STDMETHOD(GetDefinition) (THIS_
    IAAFClassDef ** ppClassDef) PURE;


  //***********************************************************
  //
  // GetProperties()
  //
  /// Returns an enumerator across all properties actually contained in
  /// this object.  Each property is represented by an IAAFProperty
  /// interface.
  /// 
    /// *ppEnum is AddRef()ed before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// Note! This is a low-level method which allows direct access to
  /// properties.  If such access is done, any semantic checking (such
  /// as that which is performed in all other named property Get/Set
  /// methods) is not done here.  Users must use this method at their
  /// own risk.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  ///
  /// @param ppEnum [out, retval] Property Enumeration
  ///
  STDMETHOD(GetProperties) (THIS_
    IEnumAAFProperties ** ppEnum) PURE;


  //***********************************************************
  //
  // CountProperties()
  //
  /// Returns the number of properties currently present in this
  /// object.  This is the same number as will be accessed through
  /// GetProperties().
  /// 
  /// Note! This is a low-level method which allows direct access to
  /// properties.  If such access is done, any semantic checking (such
  /// as that which is performed in all other named property Get/Set
  /// methods) is not done here.  Users must use this method at their
  /// own risk.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCount arg is NULL.
  ///
  /// @param pCount [out] count of properties present in this object
  ///
  STDMETHOD(CountProperties) (THIS_
    aafUInt32 *  pCount) PURE;


  //***********************************************************
  //
  // GetPropertyValue()
  //
  /// Returns the requested Property Value.  The desired property data
  /// is identified by the given property definition.
  /// 
  /// Note! This is a low-level method which allows direct access to
  /// properties.  If such access is done, any semantic checking (such
  /// as that which is performed in all other named property Get/Set
  /// methods) is not done here.  Users must use this method at their
  /// own risk.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPropDef or ppPropVal arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_PROPERTY
  ///   - named property illegal for this object's class.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - named property is optional, but not present in this class.
  ///
  /// @param pPropDef [in] property definition indentifying desired property
  /// @param ppPropVal [out] returned AAFPropertyValue
  ///
  STDMETHOD(GetPropertyValue) (THIS_
    IAAFPropertyDef * pPropDef,
    IAAFPropertyValue ** ppPropVal) PURE;


  //***********************************************************
  //
  // SetPropertyValue()
  //
  /// Sets the value of the given property to the given value.  If the
  /// selected property is optional but not yet present, will make the
  /// property present before setting its value.
  ///
  /// Note! This is a low-level method which allows direct access to
  /// properties.  If such access is done, any semantic checking (such
  /// as that which is performed in all other named property Get/Set
  /// methods) is not done here.  Users must use this method at their
  /// own risk.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPropDef or ppPropVal arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_PROPERTY
  ///   - named property illegal for this object's class.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - named property is optional, but not present in this class.
  ///
  /// @param pPropDef [in] property definition indentifying desired property
  /// @param pPropVal [in] value to set.
  ///
  STDMETHOD(SetPropertyValue) (THIS_
    IAAFPropertyDef * pPropDef,
    IAAFPropertyValue * pPropVal) PURE;


  //***********************************************************
  //
  // IsPropertyPresent()
  //
  /// Sets *pResultReturns true in if named property is legal and is
  /// present; sets it to false if it is legal and is absent.
  /// 
  /// Note! This is a low-level method which allows direct access to
  /// properties.  If such access is done, any semantic checking (such
  /// as that which is performed in all other named property Get/Set
  /// methods) is not done here.  Users must use this method at their
  /// own risk.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_PROPERTY
  ///   - named property illegal for this object's class.
  ///
  /// @param pPropDef [in] property definition indentifying desired property
  /// @param pResult [out] true if present; false if not present
  ///
  STDMETHOD(IsPropertyPresent) (THIS_
    IAAFPropertyDef * pPropDef,
    aafBoolean_t*  pResult) PURE;


  //***********************************************************
  //
  // RemoveOptionalProperty()
  //
  /// Removes the property if named property is legal and is
  /// optional and present.
  /// 
  /// Note! This is a low-level method which allows direct access to
  /// properties.  If such access is done, any semantic checking (such
  /// as that which is performed in all other named property Get/Set
  /// methods) is not done here.  Users must use this method at their
  /// own risk.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_PROPERTY
  ///   - named property illegal for this object's class.
  ///
  /// @param pPropDef [in] property definition indentifying desired property
  ///
  STDMETHOD(RemoveOptionalProperty) (THIS_
    IAAFPropertyDef * pPropDef) PURE;


  //***********************************************************
  //
  // CreateOptionalPropertyValue()
  //
  /// Returns the requested Property Value.  The desired property data
  /// is identified by the given optional property definition.
  /// 
  /// Note! This is a low-level method which allows direct access to
  /// properties.  If such access is done, any semantic checking (such
  /// as that which is performed in all other named property Get/Set
  /// methods) is not done here.  Users must use this method at their
  /// own risk.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPropDef or ppPropVal arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_PROPERTY
  ///   - named property illegal for this object's class.
  ///
  /// AAFRESULT_PROP_ALREADY_PRESENT
  ///   - named property is optional, but already present in this class.
  ///
  /// @param pPropDef [in] property definition indentifying desired property
  /// @param ppPropVal [out] returned AAFPropertyValue
  ///
  STDMETHOD(CreateOptionalPropertyValue) (THIS_
    IAAFPropertyDef * pPropDef,
    IAAFPropertyValue ** ppPropVal) PURE;


  //***********************************************************
  //
  // GetDictionary()
  //
  /// Returns the dictionary for this object instance.
  ///
  /// Succeeds if all of the following are true:
  /// - the given ppDictionary pointer is valid.
  ///
  /// Note! Use care when dealing with the object class.  Among the
  /// pitfalls to be avoided is that tests for equality will not
  /// reflect inheritance.  This becomes important if an unknown
  /// non-builtin (that is, user defined) object class ID is obtained.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppClassDef arg is NULL.
  ///
  /// @param ppDictionary [out, retval] A pointer to an Dictionary pointer
  ///
  STDMETHOD(GetDictionary) (THIS_
    IAAFDictionary ** ppDictionary) PURE;


  //***********************************************************
  //
  // EnableGenerationTracking()
  //
  /// Calling this method will cause generation tracking to be enabled
  /// for this object.  Generation information will then be available
  /// through the GetGeneration() and GetGenerationAUID() methods.
  /// 
  /// Calling the DisableGenerationTracking() method will disable
  /// generation tracking for this object.
  /// 
  /// Generation tracking is disabled by default.
  ///
  /// This method always succeeds, even if generation tracking is
  /// already enabled.
  /// 
  /// This method will return the following result:
  ///  - AAFRESULT_SUCCESS
  STDMETHOD(EnableGenerationTracking) (THIS) PURE;


  //***********************************************************
  //
  // DisableGenerationTracking()
  //
  /// Calling this method will cause generation tracking to be disabled
  /// for this object.  Generation information will then not be
  /// available through the GetGeneration() and GetGenerationAUID()
  /// methods.
  /// 
  /// Calling the EnableGenerationTracking() method will enable
  /// generation tracking for this object.
  /// 
  /// Generation tracking is disabled by default.
  ///
  /// This method always succeeds, even if generation tracking is
  /// already disbled.
  /// 
  /// This method will return the following result:
  ///  - AAFRESULT_SUCCESS
  STDMETHOD(DisableGenerationTracking) (THIS) PURE;


  //***********************************************************
  //
  // IsGenerationTracked()
  //
  /// This method will set *pResult to AAFTrue if generations are
  /// being tracked for this object.  A result of AAFTrue indicates
  /// that generation information will be available through the
  /// GetGeneration() and GetGenerationAUID() methods.
  /// 
  /// Calling the EnableGenerationTracking() method will enable
  /// generation tracking for this object; calling the
  /// DisableGenerationTracking() method will disable generation
  /// tracking for this object.
  /// 
  /// Generation tracking is disabled by default.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult arg is NULL.
  ///
  /// @param pResult [out] set to true if generations are tracked; false otherwise
  ///
  STDMETHOD(IsGenerationTracked) (THIS_
    aafBoolean_t *  pResult) PURE;

  END_INTERFACE
};
#endif // __IAAFObject_INTERFACE_DEFINED__



// IAAFOperationDef

// ************************
//
// Interface IAAFOperationDef
//
// ************************







 

#ifndef __IAAFOperationDef_INTERFACE_DEFINED__
#define __IAAFOperationDef_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFOperationDef;

#undef  INTERFACE
#define INTERFACE   IAAFOperationDef

DECLARE_INTERFACE_(IAAFOperationDef, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFOperationDef methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Init all fields of a definition object.
  ///
  /// @param id [in, ref] AUID for new DefObject
  /// @param pName [in, string] Name for new DefObject
  /// @param pDescription [in, string] Description for new DefObject
  ///
  STDMETHOD(Initialize) (THIS_
    aafUID_constref  id,
    aafCharacter_constptr  pName,
    aafCharacter_constptr  pDescription) PURE;


  //***********************************************************
  //
  // GetDataDef()
  //
  /// Places the DataDefinition object attached to this
  /// IAAFOperationDef into the *ppDataDef argument.  The data
  /// definition will match one of the AUIDs in the file
  /// AAFDataDefs.h, (which includes kAAFDataDef_Picture, and
  /// kAAFDataDef_Sound), and indicates what type of data the operation will
  /// be performed upon.  For example, a video dissolve will have the
  /// data def kAAFDataDef_Picture.  If a data definition is used which is not
  /// from AAFDataDefs.h, then the client is responsible for making
  /// sure that a data definition object with that ID exists in the
  /// dictionary.  The SDK will take care of creating the standard data
  /// definitions.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppDataDefID pointer is valid.
  /// - A valid DataDefinition exists.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDataDef is null.
  ///
  /// AAFRESULT_INVALID_DATA_DEF
  ///   - There is no IAAFDataDefinition.  There has to be one of some
  ///     kind for this to be a valid operation definition.
  ///
  /// @param ppDataDef [out] Returned DataDefinition object
  ///
  STDMETHOD(GetDataDef) (THIS_
    IAAFDataDef ** ppDataDef) PURE;


  //***********************************************************
  //
  // SetDataDef()
  //
  /// Sets the IAAFDataDefinition of this IAAFOperationDef to be the
  /// given one.  The
  /// data definition will match one of the AUIDs in the file
  /// AAFDataDefs.h, (which includes kAAFDataDef_Picture, and
  /// kAAFDataDef_Sound), and indicates what type of data the operation will
  /// be performed upon.  For example, a video dissolve will have the
  /// data def kAAFDataDef_Picture.  If a data definition is used which is not
  /// from AAFDataDefs.h, then the client is responsible for making
  /// sure that a data definition object with that ID exists in the
  /// dictionary.  The SDK will take care of creating the standard data
  /// definitions.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDataDef is null.
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param pDataDef [in] Essence Descriptor object
  ///
  STDMETHOD(SetDataDef) (THIS_
    IAAFDataDef * pDataDef) PURE;


  //***********************************************************
  //
  // IsTimeWarp()
  //
  /// Returns the value of isTimeWarp.  IsTimeWarp is true if the
  /// length of an IAAFOperationGroup is different from the lengths of
  /// the input segments.  For example, a slow motion effect.
  ///
  /// Succeeds if all of the following are true:
  /// - the bIsTimeWarp pointer is valid.
  /// 
  /// If this method fails nothing will be written to *bIsTimeWarp.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - bIsTimeWarp arg is NULL.
  ///
  /// @param bIsTimeWarp [out, retval] pointer to the return value
  ///
  STDMETHOD(IsTimeWarp) (THIS_
    aafBoolean_t *  bIsTimeWarp) PURE;


  //***********************************************************
  //
  // SetIsTimeWarp()
  //
  /// Sets the IsTimeWarp boolean.  IsTimeWarp is true if the length of
  /// an IAAFOperationGroup is different from the lengths of the input
  /// segments.  For example, a slow motion effect.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param IsTimeWarp [in] is timewarp value
  ///
  STDMETHOD(SetIsTimeWarp) (THIS_
    aafBoolean_t  IsTimeWarp) PURE;


  //***********************************************************
  //
  // PrependDegradeToOperation()
  //
  /// Prepend another operation definition to the DegradeTo list of
  /// definitions.  Use this function to add an operation definition to
  /// be scanned first when searching for the a replacement (a more
  /// desirable alternate operation).
  /// 
  /// Succeeds if all of the following are true:
  /// - the pOperationDef pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pOperationDef is null.
  ///
  /// @param pOperationDef [in] Degrade To Operation Definition Object
  ///
  STDMETHOD(PrependDegradeToOperation) (THIS_
    IAAFOperationDef * pOperationDef) PURE;


  //***********************************************************
  //
  // AppendDegradeToOperation()
  //
  /// Append another operation definition to the DegradeTo list of
  /// definitions.  Use this function to add an operation definition to
  /// be scanned last when searching for the a replacement (a less
  /// desirable alternate operation).
  /// 
  /// Succeeds if all of the following are true:
  /// - the pOperationDef pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pOperationDef is null.
  ///
  /// @param pOperationDef [in] Degrade To operation Definition Object
  ///
  STDMETHOD(AppendDegradeToOperation) (THIS_
    IAAFOperationDef * pOperationDef) PURE;


  //***********************************************************
  //
  // InsertDegradeToOperationAt()
  //
  /// Insert an operation definition into the DegradeTo list of
  /// definitions at the given index.  Operation definitions already
  /// existing at the given and higher indices will be moved up to the
  /// next higher index to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pOperationDef pointer is valid.
  /// - index is less than or equal to the value returned by
  ///   CountDegradeToOperations().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pOperationDef is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than the value returned by
  ///     CountDegradeToOperations().
  ///
  /// @param index [in] index where operation def is to be inserted
  /// @param pOperationDef [in] Degrade To operation Definition Object
  ///
  STDMETHOD(InsertDegradeToOperationAt) (THIS_
    aafUInt32  index,
    IAAFOperationDef * pOperationDef) PURE;


  //***********************************************************
  //
  // RemoveDegradeToOperationAt()
  //
  /// Removes the indexed operation definition from the DegradeTo list
  /// of definitions.  Operation definitions already existing at
  /// indices higher than the given index will be moved down to the
  /// next lower index to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - index is less than the value returned by
  ///   CountDegradeToOperations().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater or equal to than the value returned by
  ///     CountDegradeToOperations().
  ///
  /// @param index [in] index where operation def is to be inserted
  ///
  STDMETHOD(RemoveDegradeToOperationAt) (THIS_
    aafUInt32  index) PURE;


  //***********************************************************
  //
  // GetDegradeToOperations()
  //
  /// Return an enumerator for aaf operation definitions, ordered from
  /// the most desirable to the least desirable alternative.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// @param ppEnum [out, retval] Operation Definition Enumeration
  ///
  STDMETHOD(GetDegradeToOperations) (THIS_
    IEnumAAFOperationDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountDegradeToOperations()
  //
  /// Retrieves the number of Degrade To operations currently present
  /// and places that number in *pResult.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  ///
  /// @param pResult [out, retval] resulting count of Degrade To operations
  ///
  STDMETHOD(CountDegradeToOperations) (THIS_
    aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // GetCategory()
  //
  /// This method returns an AUID indicating the category of the given operation.
  ///
  /// Succeeds if all of the following are true:
  /// - the pValue pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pValue.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pValue arg is NULL.
  ///
  /// @param pValue [out] The enumeration describing the current category
  ///
  STDMETHOD(GetCategory) (THIS_
    aafUID_t*  pValue) PURE;


  //***********************************************************
  //
  // SetCategory()
  //
  /// This method sets an AUID indicating the category of the given operation.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param value [in, ref] The enumeration describing the current categor
  ///
  STDMETHOD(SetCategory) (THIS_
    aafUID_constref  value) PURE;


  //***********************************************************
  //
  // GetNumberInputs()
  //
  /// Gets the Number of input media segments.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pNumberInputs pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pNumberInputs.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumberInputs arg is NULL.
  ///
  /// @param pNumberInputs [out, retval] Pointer to Number of Inputs
  ///
  STDMETHOD(GetNumberInputs) (THIS_
    aafInt32 *  pNumberInputs) PURE;


  //***********************************************************
  //
  // SetNumberInputs()
  //
  /// Sets the Number of input media segments.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param NumberInputs [in] Number of Inputs
  ///
  STDMETHOD(SetNumberInputs) (THIS_
    aafInt32  NumberInputs) PURE;


  //***********************************************************
  //
  // GetBypass()
  //
  /// Gets the Bypass media segment index, which is a value from 0
  /// to one less than that returned by GetNumberInputs().  This
  /// value allows the client application to pick one of the inputs
  /// (foreground, background, etc.) to stand in for the
  /// effect if it is not available, and none of the degrade to
  /// effects are available.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pBypass pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pBypass.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBypass arg is NULL.
  ///
  /// @param pBypass [out,retval] Pointer to a Bypass media segment index 
  ///
  STDMETHOD(GetBypass) (THIS_
    aafUInt32 *  pBypass) PURE;


  //***********************************************************
  //
  // SetBypass()
  //
  /// Sets the media segment index, which is a value from 0 to one
  /// less than that returned by GetNumberInputs().  This value
  /// allows the client application to pick one of the inputs
  /// (foreground, background, etc.) to stand in for the
  /// effect if it is not available, and none of the degrade to
  /// effects are available.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param bypass [in] Bypass media segment index
  ///
  STDMETHOD(SetBypass) (THIS_
    aafUInt32  bypass) PURE;


  //***********************************************************
  //
  // AddParameterDef()
  //
  /// Add the Parameter Definition object to the unordered list of
  /// parameter definitions. 
  /// 
  /// Succeeds if all of the following are true:
  /// - the pAAFParameterDef pointer is valid. 
  /// - the given Parameter Definition does not exists in this Operation
  ///   Definition already
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pAAFParameterDef is null.
  ///
  /// AAFRESULT_OBJECT_ALREADY_ATTACHED
  ///	- pAAFParameterDef is already in this OperationDef
  ///
  /// @param pParameterDef [in] Parameter definition Object
  ///
  STDMETHOD(AddParameterDef) (THIS_
    IAAFParameterDef * pParameterDef) PURE;


  //***********************************************************
  //
  // GetParameterDefs()
  //
  /// Return an enumerator for the unordered list of AAF Parameter
  /// definitions.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// @param ppEnum [out,retval] Parameter definition enumeration
  ///
  STDMETHOD(GetParameterDefs) (THIS_
    IEnumAAFParameterDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountParameterDefs()
  //
  /// This method returns the number of parameter defs.
  ///
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult arg is NULL.
  ///
  /// @param pResult [out] Number of parameter defs
  ///
  STDMETHOD(CountParameterDefs) (THIS_
    aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // LookupParameterDef()
  //
  /// This method looks up the parameter def corresponding to the given
  /// ID.
  ///
  /// Succeeds if all of the following are true:
  /// - the given ID corresponds to a known parameter def
  /// - the ppParameterDef pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppParameterDef.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pParameterDef arg is NULL.
  ///
  /// AAFRESULT_OBJECT_NOT_FOUND
  ///   - given ID does not correspond to a known parameter def.
  ///
  /// @param parameterDefId [in] ID of parameter def to look up
  /// @param ppParameterDef [out] resulting parameter def
  ///
  STDMETHOD(LookupParameterDef) (THIS_
    aafUID_constref  parameterDefId,
    IAAFParameterDef ** ppParameterDef) PURE;

  END_INTERFACE
};
#endif // __IAAFOperationDef_INTERFACE_DEFINED__



// IAAFOperationGroup

// ************************
//
// Interface IAAFOperationGroup
//
// ************************












#ifndef __IAAFOperationGroup_INTERFACE_DEFINED__
#define __IAAFOperationGroup_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFOperationGroup;

#undef  INTERFACE
#define INTERFACE   IAAFOperationGroup

DECLARE_INTERFACE_(IAAFOperationGroup, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFOperationGroup methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes an operation group object with the given property
  /// values.
  ///
  /// This function takes an already created operation definition
  /// object as an argument.  To add slots to the operation group, call
  /// AddNewSlot.  To add renderings, call SetRender.
  ///
  /// @param pDataDef [in] Data Definition Object
  /// @param length [in] Length property value
  /// @param operationDef [in] Operation Definition object
  ///
  STDMETHOD(Initialize) (THIS_
    IAAFDataDef * pDataDef,
    aafLength_t  length,
    IAAFOperationDef * operationDef) PURE;


  //***********************************************************
  //
  // GetOperationDefinition()
  //
  /// Returns the operation definition for this invocation.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppOperationDef pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppOperationDef.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - This property does not exist in the file.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppOperationDef arg is NULL.
  ///
  /// @param ppOperationDef [out] Operation definition object
  ///
  STDMETHOD(GetOperationDefinition) (THIS_
    IAAFOperationDef ** ppOperationDef) PURE;

  //***********************************************************
  //
  // SetOperationDefinition()
  //
  /// This function sets the operation definition for the given operation
  /// group.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pOperationDef pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pOperationDef arg is NULL.
  ///
  /// @param pOperationDef [in] Operation definition object
  ///
  STDMETHOD(SetOperationDefinition) (THIS_
    IAAFOperationDef * pOperationDef) PURE;

  //***********************************************************
  //
  // GetRender()
  //
  /// Returns the segment that represents the optional rendering on an
  /// operation group object.  Working and final renderings are handled
  /// by using an IAAFEssenceGroup as the segment. 
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppSourceRef pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppSourceRef.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - This property does not exist in the file.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppSourceRef arg is NULL.
  ///
  /// @param ppSourceRef [out] Final rendering segment
  ///
  STDMETHOD(GetRender) (THIS_
    IAAFSourceReference ** ppSourceRef) PURE;


  //***********************************************************
  //
  // IsATimeWarp()
  //
  /// This boolean function returns whether or not an operation group
  /// is a timewarp effect.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pIsTimeWarp pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pIsTimeWarp.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pIsTimeWarp arg is NULL.
  ///
  /// @param pIsTimeWarp [out, retval] Returned boolean value
  ///
  STDMETHOD(IsATimeWarp) (THIS_
    aafBoolean_t *  pIsTimeWarp) PURE;


  //***********************************************************
  //
  // GetBypassOverride()
  //
  /// Returns the optional bypass override propertyvalue from the input
  /// operation def object.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pBypassOverride pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pBypassOverride.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - This property does not exist in the file.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBypassOverride arg is NULL.
  ///
  /// @param pBypassOverride [out] Bypass override property value
  ///
  STDMETHOD(GetBypassOverride) (THIS_
    aafUInt32 *  pBypassOverride) PURE;


  //***********************************************************
  //
  // CountSourceSegments()
  //
  /// Returns the number of media sources to the operation group.
  ///
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult arg is NULL.
  ///
  /// @param pResult [out] Number of source media segments in the operation group
  ///
  STDMETHOD(CountSourceSegments) (THIS_
    aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // IsValidTranOperation()
  //
  /// Verifies that the input operation group object can be used in a
  /// transition.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pValidTransition pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pValidTransition.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pValidTransition arg is NULL.
  ///
  /// @param pValidTransition [out] TRUE if the operation group is valid in a transition
  ///
  STDMETHOD(IsValidTranOperation) (THIS_
    aafBoolean_t *  pValidTransition) PURE;


  //***********************************************************
  //
  // CountParameters()
  //
  /// Returns the number of parameters in the operation group.
  ///
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult arg is NULL.
  ///
  /// @param pResult [out] Number of parameter slots in the operation group
  ///
  STDMETHOD(CountParameters) (THIS_
    aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // AddParameter()
  //
  /// Adds a new parameter object.
  ///
  /// Succeeds if all of the following are true:
  /// - the pValue pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_DUPLICATE_PARAMETER
  ///   - The given argID is already present.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pValue arg is NULL.
  ///
  /// @param pParameter [in] Parameter to place in operation group slot
  ///
  STDMETHOD(AddParameter) (THIS_
    IAAFParameter * pParameter) PURE;


  //***********************************************************
  //
  // AppendInputSegment()
  //
  /// Appends another input segment to an operation group.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pSegment pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_DUPLICATE_INDEX
  ///   - The given index value is already present.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSegment arg is NULL.
  ///
  /// @param pSegment [in] Segment to place in operation group
  ///
  STDMETHOD(AppendInputSegment) (THIS_
    IAAFSegment * pSegment) PURE;


  //***********************************************************
  //
  // PrependInputSegment()
  //
  /// Prepends another input segment to an operation group.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pSegment pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_DUPLICATE_INDEX
  ///   - The given index value is already present.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSegment arg is NULL.
  ///
  /// @param pSegment [in] Segment to place in operation group
  ///
  STDMETHOD(PrependInputSegment) (THIS_
    IAAFSegment * pSegment) PURE;


  //***********************************************************
  //
  // InsertInputSegmentAt()
  //
  /// Inserts an input segment to an operation group at the given
  /// index.  The existing segments at the given and higher indices are
  /// moved up by one to make room.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pSegment pointer is valid.
  /// - the index is not greater than the value returned by
  ///   CountInputSegments().
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_DUPLICATE_INDEX
  ///   - The given index value is already present.
  ///
  /// AAFRESULT_BAD_INDEX
  ///   - index is greater than the value returned by
  ///     CountInputSegments().
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSegment arg is NULL.
  ///
  /// @param index [in] index to place this segment
  /// @param pSegment [in] Segment to place in operation group
  ///
  STDMETHOD(InsertInputSegmentAt) (THIS_
    aafUInt32  index,
    IAAFSegment * pSegment) PURE;


  //***********************************************************
  //
  // SetRender()
  //
  /// This function sets the final rendering for the given operation
  /// group to the input source clip.  (Multiple renderings may exist if
  /// the source clip refers to a master mob that contains a Essence
  /// group.)
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppSourceRef pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppSourceRef arg is NULL.
  ///
  /// @param ppSourceRef [in] A segment containing a representation of the rendering
  ///
  STDMETHOD(SetRender) (THIS_
    IAAFSourceReference * ppSourceRef) PURE;


  //***********************************************************
  //
  // SetBypassOverride()
  //
  /// This function sets the optional bypass override property on the
  /// given operation group object.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param bypassOverride [in] Bypass override
  ///
  STDMETHOD(SetBypassOverride) (THIS_
    aafUInt32  bypassOverride) PURE;


  //***********************************************************
  //
  // GetParameters()
  //
  /// returns an enumerator across all parameters.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  ///
  /// @param ppEnum [out] Parameter enumerator
  ///
  STDMETHOD(GetParameters) (THIS_
    IEnumAAFParameters ** ppEnum) PURE;


  //***********************************************************
  //
  // LookupParameter()
  //
  /// Given an argID, returns the corresponding parameter slot and
  /// parameter slot value.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppParameter pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppParameter.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_MISSING_PARAMETER
  ///   - The given argID is not present.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppParameter arg is NULL.
  ///
  /// @param argID [in] Arg ID
  /// @param ppParameter [out] Parameter object
  ///
  STDMETHOD(LookupParameter) (THIS_
    aafArgIDType_constref  argID,
    IAAFParameter ** ppParameter) PURE;


  //***********************************************************
  //
  // GetInputSegmentAt()
  //
  /// Given an index, returns the corresponding input segment.
  /// Working and final renderings are handled by using an
  /// IAAFEssenceGroup as the segment.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppInputSegment pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppInputSegment.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_MISSING_INDEX
  ///   - The given index value is not present.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppInputSegment arg is NULL.
  ///
  /// @param index [in] 0-based index into the effet inputs
  /// @param ppInputSegment [out] Input segment
  ///
  STDMETHOD(GetInputSegmentAt) (THIS_
    aafUInt32  index,
    IAAFSegment ** ppInputSegment) PURE;


  //***********************************************************
  //
  // RemoveInputSegmentAt()
  //
  /// Removes the segment at the given index.  Existing segments at
  /// higher indices are moved down by one to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - index is less than the result of CountInputSegments().
  /// 
  /// If this method fails no state will be changed.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_MISSING_INDEX
  ///   - The given index value is not present.
  ///
  /// @param index [in] 0-based index into the effect inputs
  ///
  STDMETHOD(RemoveInputSegmentAt) (THIS_
    aafUInt32  index) PURE;

  END_INTERFACE
};
#endif // __IAAFOperationGroup_INTERFACE_DEFINED__



// IAAFPCMDescriptor

// ************************
//
// Interface IAAFPCMDescriptor
//
// ************************



#ifndef __IAAFPCMDescriptor_INTERFACE_DEFINED__
#define __IAAFPCMDescriptor_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFPCMDescriptor;

#undef  INTERFACE
#define INTERFACE   IAAFPCMDescriptor

DECLARE_INTERFACE_(IAAFPCMDescriptor, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFPCMDescriptor methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, IAAFPCMDescriptor-supporting
  /// object. This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  STDMETHOD(Initialize) (THIS) PURE;


  //***********************************************************
  //
  // SetBlockAlign()
  //
  /// Sets the number of bytes used to store one sample of all channels.
  /// This property is required.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the BlockAlign property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// @param blockAlign [in] The number of bytes used to store one sample of all channels.
  ///
  STDMETHOD(SetBlockAlign) (THIS_
    aafUInt16  blockAlign) PURE;


  //***********************************************************
  //
  // GetBlockAlign()
  //
  /// Gets the number of bytes used to store one sample of all channels.
  /// This property is required.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pBlockAlign pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pBlockAlign.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBlockAlign arg is NULL.
  ///
  /// @param pBlockAlign [out] The number of bytes used to store one sample of all channels.
  ///
  STDMETHOD(GetBlockAlign) (THIS_
    aafUInt16 *  pBlockAlign) PURE;


  //***********************************************************
  //
  // SetSequenceOffset()
  //
  /// Sets the frame number of the beginning of the essence data
  /// within a five-frame sequence. This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the SequenceOffset property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// @param offset [in] Zero-based ordinal frame number of the beginning of
	/// the essence data within a five-frame sequence.
  ///
  STDMETHOD(SetSequenceOffset) (THIS_
    aafUInt8  offset) PURE;


  //***********************************************************
  //
  // GetSequenceOffset()
  //
  /// Gets the frame number of the beginning of the essence data
  /// within a five-frame sequence. This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pOffset pointer is valid.
  /// - the property is present.
  /// 
  /// If this method fails nothing will be written to *pOffset.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pOffset arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pOffset [out] Zero-based ordinal frame number of the beginning of
	/// the essence data within a five-frame sequence.
  ///
  STDMETHOD(GetSequenceOffset) (THIS_
    aafUInt8 *  pOffset) PURE;


  //***********************************************************
  //
  // SetAverageBPS()
  //
  /// Sets the average bytes per second of the essence stream.
  /// This property is required.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the AverageBPS property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// @param bps [in] Average bytes per second of the essence stream.
  ///
  STDMETHOD(SetAverageBPS) (THIS_
    aafUInt32  bps) PURE;


  //***********************************************************
  //
  // GetAverageBPS()
  //
  /// Gets the average bytes per second of the essence stream.
  /// This property is required.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pBps pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pBps.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBps arg is NULL.
  ///
  /// @param pBps [out] Average bytes per second of the essence stream.
  ///
  STDMETHOD(GetAverageBPS) (THIS_
    aafUInt32 *  pBps) PURE;


  //***********************************************************
  //
  // SetChannelAssignment()
  //
  /// Sets the channel assignment scheme. This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the ChannelAssignment property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// @param channelAssignment [in, ref] The channel assignment to use.
  ///
  STDMETHOD(SetChannelAssignment) (THIS_
    aafUID_constref  channelAssignment) PURE;


  //***********************************************************
  //
  // GetChannelAssignment()
  //
  /// Gets the channel assignment scheme. This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pChannelAssignment pointer is valid.
  /// - the property is present.
  /// 
  /// If this method fails nothing will be written to *pChannelAssignment.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pChannelAssignment arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pChannelAssignment [out] The channel assignment in use.
  ///
  STDMETHOD(GetChannelAssignment) (THIS_
    aafUID_t *  pChannelAssignment) PURE;


  //***********************************************************
  //
  // AreAllPeakEnvelopePropertiesPresent()
  //
  /// Places TRUE into *pArePresent if the following optional
  /// properties are set on the descriptor:
  ///   PeakEnvelopeVersion
  ///   PeakEnvelopeFormat
  ///   PointsPerPeakValue
  ///   PeakEnvelopeBlockSize
  ///   PeakChannels
  ///   PeakFrames
  ///   PeakOfPeaksPosition
  ///   PeakEnvelopeTimestamp
  ///   PeakEnvelopeData
  ///
  /// Succeeds if all of the following are true:
  /// - the pArePresent pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pIsPresent.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pArePresent arg is NULL.
  ///
  /// @param pArePresent [out] The flag indicating presence of the optional properties
	/// that form peak envelope.
  ///
  STDMETHOD(AreAllPeakEnvelopePropertiesPresent) (THIS_
    aafBoolean_t *  pArePresent) PURE;


  //***********************************************************
  //
  // SetPeakEnvelopeVersion()
  //
  /// Sets the version of the peak envelope data.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the version will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// @param version [in] Version of the peak envelope data.
  ///
  STDMETHOD(SetPeakEnvelopeVersion) (THIS_
    aafUInt32  version) PURE;


  //***********************************************************
  //
  // GetPeakEnvelopeVersion()
  //
  /// Gets the version of the peak envelope data.
  /// This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pVersion pointer is valid.
  /// - the property is present.
  /// 
  /// If this method fails nothing will be written to *pVersion.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pVersion arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pVersion [out] Version of the peak envelope data.
  ///
  STDMETHOD(GetPeakEnvelopeVersion) (THIS_
    aafUInt32 *  pVersion) PURE;


  //***********************************************************
  //
  // SetPeakEnvelopeFormat()
  //
  /// Sets the format of the peak point.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the format will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// @param format [in] Format of the peak point.
  ///
  STDMETHOD(SetPeakEnvelopeFormat) (THIS_
    aafUInt32  format) PURE;


  //***********************************************************
  //
  // GetPeakEnvelopeFormat()
  //
  /// Gets the format of the peak point.
  /// This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pFormat pointer is valid.
  /// - the property is present.
  /// 
  /// If this method fails nothing will be written to *pFormat.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFormat arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pFormat [out] Format of the peak point.
  ///
  STDMETHOD(GetPeakEnvelopeFormat) (THIS_
    aafUInt32 *  pFormat) PURE;


  //***********************************************************
  //
  // SetPointsPerPeakValue()
  //
  /// Sets the number of peak points per peak value.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the PointsPerPeakValue property will
  /// not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// @param pointCount [in] The number of peak points per peak value.
  ///
  STDMETHOD(SetPointsPerPeakValue) (THIS_
    aafUInt32  pointCount) PURE;


  //***********************************************************
  //
  // GetPointsPerPeakValue()
  //
  /// Gets the number of peak points per peak value.
  /// This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pPointCount pointer is valid.
  /// - the property is present.
  /// 
  /// If this method fails nothing will be written to *pPointCount.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPointCount arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pPointCount [out] The number of peak points per peak value.
  ///
  STDMETHOD(GetPointsPerPeakValue) (THIS_
    aafUInt32 *  pPointCount) PURE;


  //***********************************************************
  //
  // SetPeakEnvelopeBlockSize()
  //
  /// Sets the number of audio samples used to generate each peak frame.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the PeakEnvelopeBlockSize property will
  /// not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// @param blockSize [in] The number of audio samples used to generate each peak frame.
  ///
  STDMETHOD(SetPeakEnvelopeBlockSize) (THIS_
    aafUInt32  blockSize) PURE;


  //***********************************************************
  //
  // GetPeakEnvelopeBlockSize()
  //
  /// Gets the number of audio samples used to generate each peak frame.
  /// This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pBlockSize pointer is valid.
  /// - the property is present.
  /// 
  /// If this method fails nothing will be written to *pBlockSize.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBlockSize arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pBlockSize [out] The number of audio samples used to generate each peak frame.
  ///
  STDMETHOD(GetPeakEnvelopeBlockSize) (THIS_
    aafUInt32 *  pBlockSize) PURE;


  //***********************************************************
  //
  // SetPeakChannelCount()
  //
  /// Sets the number of peak channels.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the channel count will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// @param channelCount [in] The number of peak channels.
  ///
  STDMETHOD(SetPeakChannelCount) (THIS_
    aafUInt32  channelCount) PURE;


  //***********************************************************
  //
  // GetPeakChannelCount()
  //
  /// Gets the number of peak channels.
  /// This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pChannelCount pointer is valid.
  /// - the property is present.
  /// 
  /// If this method fails nothing will be written to *pChannelCount.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pChannelCount arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pChannelCount [out] The number of peak channels.
  ///
  STDMETHOD(GetPeakChannelCount) (THIS_
    aafUInt32 *  pChannelCount) PURE;


  //***********************************************************
  //
  // SetPeakFrameCount()
  //
  /// Sets the number of peak frames.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the frame count will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// @param frameCount [in] The number of peak frames.
  ///
  STDMETHOD(SetPeakFrameCount) (THIS_
    aafUInt32  frameCount) PURE;


  //***********************************************************
  //
  // GetPeakFrameCount()
  //
  /// Gets the number of peak frames.
  /// This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pFrameCount pointer is valid.
  /// - the property is present.
  /// 
  /// If this method fails nothing will be written to *pFrameCount.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFrameCount arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pFrameCount [out] The number of peak frames.
  ///
  STDMETHOD(GetPeakFrameCount) (THIS_
    aafUInt32 *  pFrameCount) PURE;


  //***********************************************************
  //
  // SetPeakOfPeaksPosition()
  //
  /// Sets the offset to the first audio sample whose absolute
  /// value is the maximum value of the entire audio file.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the PeakOfPeaksPosition property will
  /// not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// @param position [in] The offset to peak of peaks
  ///
  STDMETHOD(SetPeakOfPeaksPosition) (THIS_
    aafPosition_t  position) PURE;


  //***********************************************************
  //
  // GetPeakOfPeaksPosition()
  //
  /// Gets the offset to the first audio sample whose absolute
  /// value is the maximum value of the entire audio file.
  /// This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pPosition pointer is valid.
  /// - the property is present.
  /// 
  /// If this method fails nothing will be written to *pPosition.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPosition arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pPosition [out] The offset to peak of peaks.
  ///
  STDMETHOD(GetPeakOfPeaksPosition) (THIS_
    aafPosition_t *  pPosition) PURE;


  //***********************************************************
  //
  // SetPeakEnvelopeTimestamp()
  //
  /// Sets the time stamp of the creation of the peak data.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the time stamp will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// @param timeStamp [in] The time stamp of the creation of the peak data.
  ///
  STDMETHOD(SetPeakEnvelopeTimestamp) (THIS_
    aafTimeStamp_constref  timeStamp) PURE;


  //***********************************************************
  //
  // GetPeakEnvelopeTimestamp()
  //
  /// Gets the time stamp of the creation of the peak data.
  /// This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pTimeStamp pointer is valid.
  /// - the property is present.
  /// 
  /// If this method fails nothing will be written to *pTimeStamp.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTimeStamp arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pTimeStamp [out] The time stamp of the creation of the peak data.
  ///
  STDMETHOD(GetPeakEnvelopeTimestamp) (THIS_
    aafTimeStamp_t *  pTimeStamp) PURE;


  //***********************************************************
  //
  // SetPeakEnvelopeDataPosition()
  //
  /// Sets the offset from the beginning of peak envelope data.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the object is persistent (attached to a file).
  /// 
  /// If this method fails the position will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_OBJECT_NOT_PERSISTENT
  ///   - the object is not persistent.
  ///
  /// @param position [in] Offset from the beginning of peak envelope data.
  ///
  STDMETHOD(SetPeakEnvelopeDataPosition) (THIS_
    aafPosition_t  position) PURE;


  //***********************************************************
  //
  // GetPeakEnvelopeDataPosition()
  //
  /// Gets the offset from the beginning of peak envelope data.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pPosition pointer is valid.
  /// - the object is persistent (attached to a file).
  /// 
  /// If this method fails nothing will be written to *pPosition.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPosition arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the PeakEnvelopeData property is not present.
  ///
  /// AAFRESULT_OBJECT_NOT_PERSISTENT
  ///   - the object is not persistent.
  ///
  /// @param pPosition [out] Offset from the beginning of peak envelope data.
  ///
  STDMETHOD(GetPeakEnvelopeDataPosition) (THIS_
    aafPosition_t *  pPosition) PURE;


  //***********************************************************
  //
  // GetPeakEnvelopeDataSize()
  //
  /// Gets the size of peak envelope data.
  /// PeakEnvelopeData is optional property.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pSize pointer is valid.
  /// - the PeakEnvelopeData property is present.
  /// - the object is persistent (attached to a file).
  /// 
  /// If this method fails nothing will be written to *pSize.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSize arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the PeakEnvelopeData property is not present.
  ///
  /// AAFRESULT_OBJECT_NOT_PERSISTENT
  ///   - the object is not persistent.
  ///
  /// @param pSize [out] The size of peak envelope data.
  ///
  STDMETHOD(GetPeakEnvelopeDataSize) (THIS_
    aafLength_t *  pSize) PURE;


  //***********************************************************
  //
  // WritePeakEnvelopeData()
  //
  /// Write the specified bytes to the peak envelope data stream.
  /// 
  /// Succeeds if all of the following are true:
  /// - the number of bytes to write is non-zero.
  /// - the buffer pointer is valid.
  /// - the pBytesWritten pointer is valid.
  /// - the object is initialized.
  /// - the object is persistent (attached to a file).
  /// 
  /// If this method fails the PeakEnvelopeData property will
  /// not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - bytes arg is larger than zero.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - buffer arg is NULL.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBytesWritten arg is NULL.
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_OBJECT_NOT_PERSISTENT
  ///   - the object is not persistent.
  ///
  /// AAFRESULT_CONTAINERWRITE
  ///   - writing failed.
  ///
  /// @param bytes [in] Write this many bytes
  /// @param buffer [out, size_is(bytes)] Data to write
  /// @param pBytesWritten [out,ref] Number of bytes actually written.
  ///
  STDMETHOD(WritePeakEnvelopeData) (THIS_
    aafUInt32  bytes,
    aafDataBuffer_t  buffer,
    aafUInt32 *  pBytesWritten) PURE;


  //***********************************************************
  //
  // ReadPeakEnvelopeData()
  //
  /// Read the specified number of bytes from the peak envelope data
  /// stream into buffer.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the number of bytes to read is non-zero.
  /// - the buffer pointer is valid.
  /// - the pBytesRead pointer is valid.
  /// - the PeakEnvelopeData property is present.
  /// - the object is persistent (attached to a file).
  /// - not yet reached the end of the data stream.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// AAFRESULT_END_OF_DATA
  ///   - trying to read beyond the end of the data stream.
  /// 
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  /// 
  /// AAFRESULT_INVALID_PARAM
  ///   - bytes arg is larger than zero.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - buffer arg is NULL.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBytesRead arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the PeakEnvelopeData property is not present.
  ///
  /// AAFRESULT_OBJECT_NOT_PERSISTENT
  ///   - the object is not persistent.
  ///
  /// @param bytes [in] Read this many bytes
  /// @param buffer [out, size_is(bytes)] Buffer to read the data to
  /// @param pBytesRead [out,ref] Number of bytes actually read.
  ///
  STDMETHOD(ReadPeakEnvelopeData) (THIS_
    aafUInt32  bytes,
    aafDataBuffer_t  buffer,
    aafUInt32 *  pBytesRead) PURE;

  END_INTERFACE
};
#endif // __IAAFPCMDescriptor_INTERFACE_DEFINED__



// IAAFParameter

// ************************
//
// Interface IAAFParameter
//
// ************************




 

#ifndef __IAAFParameter_INTERFACE_DEFINED__
#define __IAAFParameter_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFParameter;

#undef  INTERFACE
#define INTERFACE   IAAFParameter

DECLARE_INTERFACE_(IAAFParameter, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFParameter methods *** */


  //***********************************************************
  //
  // GetParameterDefinition()
  //
  /// Places the parameter definition of the operation parameter into
  /// the *ppParmDef argument.  The length of an operation parameter is
  /// in the same edit units and has the same value as the
  /// IAAFOperationGroup enclosing this parameter.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppParmDef pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppParmDef is null.
  ///
  /// @param ppParmDef [out,retval] New parameter definition
  ///
  STDMETHOD(GetParameterDefinition) (THIS_
    IAAFParameterDef ** ppParmDef) PURE;

  //***********************************************************
  //
  // GetTypeDefinition()
  //
  /// Places the IAAFTypeDefinition of the data value inside this
  /// parameter into the *ppTypeDef argument.  The data value is the
  /// value of the parameter.  It is often an integer or rational, and
  /// may change over time.  An example of a value would be the
  /// "level" parameter of a video dissolve, which has control
  /// points with a value of zero (0 percent B material) at the
  /// start, to one (100 percent B material) at the end.  The data
  /// value will actually be stored in either AAFConstantValue or one
  /// of the AAFControlPoints inside of an AAFVaryingValue.
  ///
  /// The definition is stored in the base class because it should be
  /// constant for all control points inside of a varying value.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTypeDef is null.
  ///
  /// @param ppTypeDef [out,retval] Type Definition of the data value inside of this object
  ///
  STDMETHOD(GetTypeDefinition) (THIS_
    IAAFTypeDef ** ppTypeDef) PURE;

  END_INTERFACE
};
#endif // __IAAFParameter_INTERFACE_DEFINED__



// IAAFParameterDef

// ************************
//
// Interface IAAFParameterDef
//
// ************************


 

#ifndef __IAAFParameterDef_INTERFACE_DEFINED__
#define __IAAFParameterDef_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFParameterDef;

#undef  INTERFACE
#define INTERFACE   IAAFParameterDef

DECLARE_INTERFACE_(IAAFParameterDef, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFParameterDef methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Init all fields of a definition object.
  ///
  /// @param id [in, ref] AUID for new DefObject
  /// @param pName [in, string] Name for new DefObject
  /// @param pDescription [in, string] Description for new DefObject
  /// @param pType [in] The type definition for all parameters that use this definition
  ///
  STDMETHOD(Initialize) (THIS_
    aafUID_constref  id,
    aafCharacter_constptr  pName,
    aafCharacter_constptr  pDescription,
    IAAFTypeDef * pType) PURE;


  //***********************************************************
  //
  // GetTypeDefinition()
  //
  /// Places the AAFTypeDef object attached to this IAAFParameterDef
  /// into the *ppTypeDef argument.  If none exists yet, NULL is
  /// placed into the *ppTypeDef argument.
  ///
  /// The returned AAFTypeDef object, if it exists, is AddRef()ed
  /// before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppTypeDef pointer is valid.
  /// - A valid AAFTypeDef exists.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTypeDef is null.
  ///
  /// AAFRESULT_NO_ESSENCE_DESC
  ///   - There is no AAFTypeDef.  There has to be one of some
  ///     kind for this to be a valid operation definition.
  ///
  /// @param ppTypeDef [retval,out] Pointer to a type definition
  ///
  STDMETHOD(GetTypeDefinition) (THIS_
    IAAFTypeDef ** ppTypeDef) PURE;


  //***********************************************************
  //
  // SetDisplayUnits()
  //
  /// Sets the Display Units string property.
  ///
  /// Set the DisplayUnits property to the value specified in
  /// pDisplayUnits.  A copy is made of the data so the caller
  /// retains ownership of the *pDisplayUnits buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pDisplayUnits pointer is valid.
  /// 
  /// If this method fails the DisplayUnits property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDisplayUnits arg is NULL.
  ///
  /// @param pDisplayUnits [in, string] buffer from which DisplayUnits is to be read
  ///
  STDMETHOD(SetDisplayUnits) (THIS_
    aafCharacter_constptr  pDisplayUnits) PURE;


  //***********************************************************
  //
  // GetDisplayUnits()
  //
  /// Gets the Display Units string property.
  /// 
  /// Writes the DisplayUnits property, with a trailing null
  /// character, into the pDisplayUnits buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the DisplayUnits property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetDisplayUnitsBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pDisplayUnits.
  /// 
  /// Succeeds if:
  /// - The pDisplayUnits pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   DisplayUnits.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDisplayUnits arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold DisplayUnits.
  ///
  /// @param pDisplayUnits [out, string, size_is(bufSize)] buffer into which DisplayUnits is to be written
  /// @param bufSize [in] size of *pDisplayUnits buffer in bytes
  ///
  STDMETHOD(GetDisplayUnits) (THIS_
    aafCharacter *  pDisplayUnits,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetDisplayUnitsBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetDisplayUnits().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetDisplayUnitsBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;

  END_INTERFACE
};
#endif // __IAAFParameterDef_INTERFACE_DEFINED__



// IAAFPhysicalDescriptor

// ************************
//
// Interface IAAFPhysicalDescriptor
//
// ************************




#ifndef __IAAFPhysicalDescriptor_INTERFACE_DEFINED__
#define __IAAFPhysicalDescriptor_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFPhysicalDescriptor;

#undef  INTERFACE
#define INTERFACE   IAAFPhysicalDescriptor

DECLARE_INTERFACE_(IAAFPhysicalDescriptor, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFPhysicalDescriptor methods *** */



  END_INTERFACE
};
#endif // __IAAFPhysicalDescriptor_INTERFACE_DEFINED__



// IAAFPlainEssenceData

// ************************
//
// Interface IAAFPlainEssenceData
//
// ************************




#ifndef __IAAFPlainEssenceData_INTERFACE_DEFINED__
#define __IAAFPlainEssenceData_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFPlainEssenceData;

#undef  INTERFACE
#define INTERFACE   IAAFPlainEssenceData

DECLARE_INTERFACE_(IAAFPlainEssenceData, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFPlainEssenceData methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Associates a weak reference to the given file mob with the
  /// essence data.
  ///
  /// Succeeds if all of the following are true:
  /// - the pFileMob pointer is valid and points to 
  /// a file mob (contains a file descriptor).
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFileMob is null.
  ///
  /// @param pFileMob [in] reference to a file mob
  ///
  STDMETHOD(Initialize) (THIS_
    IAAFSourceMob * pFileMob) PURE;


  //***********************************************************
  //
  // Write()
  //
  /// Write pre-interleaved data to a essence stream.
  ///
  /// @param bytes [in] write this many bytes
  /// @param buffer [out, size_is(bytes)] here is the buffer
  /// @param bytesWritten [out,ref] 
  ///
  STDMETHOD(Write) (THIS_
    aafUInt32  bytes,
    aafDataBuffer_t  buffer,
    aafUInt32 *  bytesWritten) PURE;


  //***********************************************************
  //
  // Read()
  //
  /// Read pre-interleaved data from a essence stream.
  ///
  /// @param bytes [in] read this many bytes
  /// @param buffer [out, size_is(bytes), length_is(*bytesRead)] here is the buffer
  /// @param bytesRead [out,ref] 
  ///
  STDMETHOD(Read) (THIS_
    aafUInt32  bytes,
    aafDataBuffer_t  buffer,
    aafUInt32 *  bytesRead) PURE;


  //***********************************************************
  //
  // SetPosition()
  //
  /// Seek to absolute position within the essence data.
  ///
  /// @param offset [in] offset from beginning of essence
  ///
  STDMETHOD(SetPosition) (THIS_
    aafPosition_t  offset) PURE;


  //***********************************************************
  //
  // GetPosition()
  //
  /// Get the absolute position within the essence data.
  ///
  /// @param pOffset [out] offset from beginning of essence
  ///
  STDMETHOD(GetPosition) (THIS_
    aafPosition_t*  pOffset) PURE;


  //***********************************************************
  //
  // GetSize()
  //
  /// Return the total size of the essence data.
  ///
  /// @param pSize  [out] size of essence data
  ///
  STDMETHOD(GetSize) (THIS_
    aafLength_t *  pSize ) PURE;


  //***********************************************************
  //
  // WriteSampleIndex()
  //
  /// Write pre-interleaved data to a sample index stream.
  ///
  /// @param bytes [in] write this many bytes to the sample index stream
  /// @param buffer [out, size_is(bytes)] here is the buffer
  /// @param bytesWritten [out,ref] 
  ///
  STDMETHOD(WriteSampleIndex) (THIS_
    aafUInt32  bytes,
    aafDataBuffer_t  buffer,
    aafUInt32 *  bytesWritten) PURE;


  //***********************************************************
  //
  // ReadSampleIndex()
  //
  /// Read pre-interleaved data from a sample index stream.
  ///
  /// @param bytes [in] read this many bytes from the sample index stream
  /// @param buffer [out, size_is(bytes), length_is(*bytesRead)] here is the buffer
  /// @param bytesRead [out,ref] 
  ///
  STDMETHOD(ReadSampleIndex) (THIS_
    aafUInt32  bytes,
    aafDataBuffer_t  buffer,
    aafUInt32 *  bytesRead) PURE;


  //***********************************************************
  //
  // SetSampleIndexPosition()
  //
  /// Seek to absolute position within the sample index data.
  ///
  /// @param offset [in] offset from beginning of sample index
  ///
  STDMETHOD(SetSampleIndexPosition) (THIS_
    aafPosition_t  offset) PURE;


  //***********************************************************
  //
  // GetSampleIndexPosition()
  //
  /// Get the absolute position within the sample index data.
  ///
  /// @param pOffset [out] offset from beginning of sample index
  ///
  STDMETHOD(GetSampleIndexPosition) (THIS_
    aafPosition_t*  pOffset) PURE;


  //***********************************************************
  //
  // GetSampleIndexSize()
  //
  /// Return the total size of the sample index data.
  ///
  /// @param pSize  [out] size of sample index data
  ///
  STDMETHOD(GetSampleIndexSize) (THIS_
    aafLength_t *  pSize ) PURE;


  //***********************************************************
  //
  // SetFileMob()
  //
  /// Associates a weak reference to the given file mob with the
  /// essence data.
  ///
  /// Succeeds if all of the following are true:
  /// - the pFileMob pointer is valid and points to 
  /// a file mob (contains a file descriptor).
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFileMob is null.
  ///
  /// @param pFileMob [in] reference to a file mob
  ///
  STDMETHOD(SetFileMob) (THIS_
    IAAFSourceMob * pFileMob) PURE;


  //***********************************************************
  //
  // GetFileMob()
  //
  /// Associates a weak reference to the given file mob with the
  /// essence data.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppFileMob pointer is valid and a weak
  /// reference to the associated file mob can be
  /// resolved.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppFileMob is null.
  ///
  /// @param ppFileMob [in] reference to a file mob
  ///
  STDMETHOD(GetFileMob) (THIS_
    IAAFSourceMob ** ppFileMob) PURE;


  //***********************************************************
  //
  // GetFileMobID()
  //
  /// Return the mob id used to find the file mob associated with this
  /// essence.  The file mob must exist in the same file as this
  /// essence data.
  ///
  /// @param pFileMobID [out] the file mob id associated with essence
  ///
  STDMETHOD(GetFileMobID) (THIS_
    aafMobID_t *  pFileMobID) PURE;





  END_INTERFACE
};
#endif // __IAAFPlainEssenceData_INTERFACE_DEFINED__


// IAAFPlainStreamData

// ************************
//
// Interface IAAFPlainStreamData
//
// ************************




#ifndef __IAAFPlainStreamData_INTERFACE_DEFINED__
#define __IAAFPlainStreamData_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFPlainStreamData;

#undef  INTERFACE
#define INTERFACE   IAAFPlainStreamData

DECLARE_INTERFACE_(IAAFPlainStreamData, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFPlainStreamData methods *** */


  //***********************************************************
  //
  // GetSize()
  //
  /// Returns number of bytes contained in the referenced property
  /// value.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  /// - pSize is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pStreamPropertyValue or pSize arg is NULL.
  ///
  /// @param pStreamPropertyValue [in] stream property value
  /// @param pSize [out] count of bytes in the specified stream property value
  ///
  STDMETHOD(GetSize) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    aafInt64 *  pSize) PURE;

  //***********************************************************
  //
  // SetSize()
  //
  /// Set the number of bytes contained in the give stream property value
  /// to newElementCount
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - If pStreamPropertyValue arg is NULL.
  ///
  /// @param pStreamPropertyValue [in] stream property value
  /// @param newSize [in] new count of bytes in the specified stream property value
  ///
  STDMETHOD(SetSize) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    aafInt64  newSize) PURE;

  //***********************************************************
  //
  // GetPosition()
  //
  /// Returns the byte position of the current element in the stream. 
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  /// - pPosition is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pStreamPropertyValue or pPosition arg is NULL.
  ///
  /// @param pStreamPropertyValue [in] stream property value
  /// @param pPosition [out] current byte position in the specified stream property value
  ///
  STDMETHOD(GetPosition) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    aafInt64 *  pPosition) PURE;

  //***********************************************************
  //
  // SetPosition()
  //
  /// Make the current byte position to the one at newPosition in the stream 
  /// property value. 
  ///
  /// Succeeds if:
  /// - pStreamPropertyValue is a valid pointer.
  /// - the new position is valid
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - If pStreamPropertyValue arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - newPosition is outside the bounds of the stream.
  ///
  /// @param pStreamPropertyValue [in] stream property value
  /// @param newPosition [in] the new position in the specified stream property value
  ///
  STDMETHOD(SetPosition) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    aafInt64  newPosition) PURE;


  //***********************************************************
  //
  // Read()
  //
  /// Sequential access.
  /// Copies the data at the position of the stream to the given
  /// buffer.
  ///
  /// Succeeds if all of the following are true:
  /// - the pStreamPropertyValue pointer is valid.
  /// - the pData pointer is valid.
  /// - the indicated bytes exist in the stream.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pStreamPropertyValue or pData arg is NULL.
  ///
  /// @param pStreamPropertyValue [in] stream property value to read
  /// @param dataSize [in] number of bytes to read
  /// @param pData [out, size_is(dataSize), length_is(*bytesRead)] buffer into which one element from the stream should be written
  /// @param bytesRead [out,ref] number of bytes actually read (will be either dataSize or 0 if there 
  /// is in error)
  ///
  STDMETHOD(Read) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    aafUInt32  dataSize,
    aafMemPtr_t  pData,
    aafUInt32 *  bytesRead) PURE;

  //***********************************************************
  //
  // Write()
  //
  /// Sequential access.
  /// Copies the data in the given buffer into the stream at the 
  /// current position of the stream..
  ///
  /// Succeeds if all of the following are true:
  /// - the pStreamPropertyValue pointer is valid.
  /// - the pData pointer is valid.
  /// - the indicated bytes could be written to the stream.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pStreamPropertyValue or pData arg is NULL.
  ///
  /// @param pStreamPropertyValue [in] stream property value to modify
  /// @param dataSize [in] number of bytes to write
  /// @param pData [in, ref, size_is(dataSize)] buffer into which should contain one element to be written to the stream
  ///
  STDMETHOD(Write) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    aafUInt32  dataSize,
    aafMemPtr_t  pData) PURE;

  //***********************************************************
  //
  // Append()
  //
  /// Extending the stream.
  /// Copies the data in the given buffer into the stream at the 
  /// end of the stream.
  ///
  /// Succeeds if all of the following are true:
  /// - the pStreamPropertyValue pointer is valid.
  /// - the pData pointer is valid.
  /// - the indicated bytes could be appended to the stream.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pStreamPropertyValue or pData arg is NULL.
  ///
  /// @param pStreamPropertyValue [in] stream property value to modify
  /// @param dataSize [in] number of bytes to write (must be equal to the element type length)
  /// @param pData [in, ref, size_is(dataSize)] buffer into which should contain one element to be written to the stream
  ///
  STDMETHOD(Append) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    aafUInt32  dataSize,
    aafMemPtr_t  pData) PURE;


  //***********************************************************
  //
  // HasStoredByteOrder()
  //
  /// Returns kAAFTrue if the stream has a stored byte order or 
  /// kAAFFalse otherwise.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  /// - pHasByteOrder is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pStreamPropertyValue or pHasByteOrder arg is NULL.
  ///
  /// @param pStreamPropertyValue [in] stream property value
  /// @param pHasByteOrder [out] kAAFTrue if this stream has a stored byte order
  ///
  STDMETHOD(HasStoredByteOrder) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    aafBoolean_t *  pHasByteOrder) PURE;

  //***********************************************************
  //
  // GetStoredByteOrder()
  //
  /// Access byte order of the stream.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  /// - pByteOrder is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pStreamPropertyValue or pByteOrder arg is NULL.
  ///
  /// @param pStreamPropertyValue [in] stream property value
  /// @param pByteOrder [out] Pointer to variable where byte order is to be copied
  ///
  STDMETHOD(GetStoredByteOrder) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    eAAFByteOrder_t *  pByteOrder) PURE;

  //***********************************************************
  //
  // SetStoredByteOrder()
  //
  /// Sets the byte order to be associated with this stream. Note: the stream
  /// must be empty.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  /// - stream is empty.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - If pStreamPropertyValue arg is NULL.
  ///
  /// @param pStreamPropertyValue [in] stream property value
  /// @param byteOrder [in] byte order is to be stored with the stream
  ///
  STDMETHOD(SetStoredByteOrder) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    eAAFByteOrder_t  byteOrder) PURE;

  //***********************************************************
  //
  // ClearStoredByteOrder()
  //
  /// Clears the byte order to be associated with this stream. Note: the stream
  /// must be empty.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  /// - stream is empty.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - If pStreamPropertyValue arg is NULL.
  ///
  /// @param pStreamPropertyValue [in] stream property value
  ///
  STDMETHOD(ClearStoredByteOrder) (THIS_
    IAAFPropertyValue * pStreamPropertyValue) PURE;


  //***********************************************************
  //
  // ReadElements()
  //
  /// Access in typed chunks of Elements.
  /// Copies the data at the current position of the stream to the given
  /// buffer. Requires that any structures declared within element 
  /// typedef have had their offsets registered with that type.
  ///
  /// Succeeds if all of the following are true:
  /// - the pStreamPropertyValue pointer is valid.
  /// - the pElementType pointer is valid.
  /// - the pData pointer is valid.
  /// - dataSize indicates pData is large enough to hold the data.
  /// - compile-time struct has had its member offests registered.
  /// - the indicated elements exist in this stream type def.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pStreamPropertyValue or pElementType or pBytesRead or pData arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - dataSize indicates pData is too small.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for element typedef.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - there are not dataSize bytes left in the stream.
  ///
  /// @param pStreamPropertyValue [in] stream property value to read
  /// @param pElementType [in] the type definition of the elements to read
  /// @param dataSize [in] number of bytes to read (must be evenly divisible by the element 
  /// type length)
  /// @param pData [out, size_is(dataSize), length_is(*pBytesRead)] buffer into which elements from the stream should be written
  /// @param pBytesRead [out,ref] number of bytes actually read (will be either dataSize or 0 if 
  /// there is in error)
  ///
  STDMETHOD(ReadElements) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    IAAFTypeDef * pElementType,
    aafUInt32  dataSize,
    aafMemPtr_t  pData,
    aafUInt32 *  pBytesRead) PURE;

  //***********************************************************
  //
  // WriteElements()
  //
  /// Access in typed chunks of Elements.
  /// Copies the data in the given buffer into the stream at the  
  /// current position of the stream. Requires that any structures 
  /// declared within element 
  /// typedef have had their offsets registered with that type..
  ///
  /// Succeeds if all of the following are true:
  /// - the pStreamPropertyValue pointer is valid.
  /// - the pElementType pointer is valid.
  /// - the pData pointer is valid.
  /// - dataSize indicates pData is large enough to hold the data.
  /// - compile-time struct has had its member offests registered.
  /// - the indicated elements exist in this stream type def.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pStreamPropertyValue or pElementType or pData arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - dataSize indicates pData is an even multiple of the given 
  ///     element type size.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for the element typedef.
  ///
  /// @param pStreamPropertyValue [in] stream property value to modify
  /// @param pElementType [in] the type definition of the elements to read
  /// @param dataSize [in] number of bytes to write (must be evenly divisible by the element type 
  /// length)
  /// @param pData [in, ref, size_is(dataSize)] buffer into which elements from the stream should be written
  ///
  STDMETHOD(WriteElements) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    IAAFTypeDef * pElementType,
    aafUInt32  dataSize,
    aafMemPtr_t  pData) PURE;


  /// Extend in chunks of typed Elements

  //***********************************************************
  //
  // AppendElements()
  //
  /// Access in typed chunks of Elements.
  /// Copies the data in the given buffer onto the end of the stream. 
  /// Requires that any structures declared within element 
  /// typedef have had their offsets registered with that type..
  ///
  /// Succeeds if all of the following are true:
  /// - the pStreamPropertyValue pointer is valid.
  /// - the pElementType pointer is valid.
  /// - the pData pointer is valid.
  /// - dataSize indicates pData is large enough to hold the data.
  /// - compile-time struct has had its member offests registered.
  /// - the indicated elements exist in this stream type def.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pStreamPropertyValue or pElementType or pData arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - dataSize indicates pData is an even multiple of the given 
  ///     element type size.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for the element typedef.
  ///
  /// @param pStreamPropertyValue [in] stream property value to modify
  /// @param pElementType [in] the type definition of the elements to read
  /// @param dataSize [in] number of bytes to write (must be evenly divisible by the element type 
  /// length)
  /// @param pData [in, ref, size_is(dataSize)] buffer into which elements from the stream should be written
  ///
  STDMETHOD(AppendElements) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    IAAFTypeDef * pElementType,
    aafUInt32  dataSize,
    aafMemPtr_t  pData) PURE;





  END_INTERFACE
};
#endif // __IAAFPlainStreamData_INTERFACE_DEFINED__


// IAAFPluginDef

// ************************
//
// Interface IAAFPluginDef
//
// ************************






#ifndef __IAAFPluginDef_INTERFACE_DEFINED__
#define __IAAFPluginDef_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFPluginDef;

#undef  INTERFACE
#define INTERFACE   IAAFPluginDef

DECLARE_INTERFACE_(IAAFPluginDef, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFPluginDef methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Init all fields of a definition object.
  ///
  /// @param id [in, ref] AUID for new DefObject
  /// @param pName [in] Name for new DefObject
  /// @param pDescription [in] Description for new DefObject
  ///
  STDMETHOD(Initialize) (THIS_
    aafUID_constref  id,
    aafCharacter_constptr  pName,
    aafCharacter_constptr  pDescription) PURE;

  //***********************************************************
  //
  // GetCategoryClass()
  //
  /// Obtains the Category Class, which is identifies the stored
  /// classID of the subclass of AAFPluggableDefinition which
  /// references this plugin descriptor.  This ID is written into the
  /// caller-allocated aafUID_t specified by the pCategoryClass
  /// argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pCategoryClass pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pCategoryClass.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCategoryClass arg is NULL.
  ///
  /// @param pCategoryClass [out] The CategoryClass
  ///
  STDMETHOD(GetCategoryClass) (THIS_
    aafUID_t *  pCategoryClass) PURE;


  //***********************************************************
  //
  // SetCategoryClass()
  //
  /// Sets the Category Class, which is identifies the stored classID
  /// of the subclass of AAFPluggableDefinition which references this
  /// plugin descriptor.
  /// 
  /// If this method fails the Category Class property will not be
  /// changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param categoryClass [in, ref] The Category Class
  ///
  STDMETHOD(SetCategoryClass) (THIS_
    aafUID_constref  categoryClass) PURE;


  //***********************************************************
  //
  // GetPluginVersion()
  //
  /// Gets the Plugin Version property associated with this plugin
  /// descriptor and places it into *pVersion. 
  ///
  /// Succeeds if all of the following are true:
  /// - the pVersion pointer is valid.
  /// 
  /// If this method fails, nothing will be written to *pVersion.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pVersion arg is NULL.
  ///
  /// @param pVersion [out] The Plugin Version
  ///
  STDMETHOD(GetPluginVersion) (THIS_
    aafVersionType_t *  pVersion) PURE;


  //***********************************************************
  //
  // SetPluginVersion()
  //
  /// Sets the plugin version property of this plugin descriptor.
  ///
  /// Succeeds if all of the following are true:
  /// - pVersion pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pVersion arg is NULL.
  ///
  /// @param pVersion [in] The plugin Version
  ///
  STDMETHOD(SetPluginVersion) (THIS_
    aafVersionType_t *  pVersion) PURE;


  //***********************************************************
  //
  // SetPluginVersionString()
  //
  /// Sets the Plugin Version String property.
  ///
  /// Set the PluginVersionString property to the value specified in
  /// pPluginVersionString.  A copy is made of the data so the caller
  /// retains ownership of the *pPluginVersionString buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pPluginVersionString pointer is valid.
  /// 
  /// If this method fails the PluginVersionString property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPluginVersionString arg is NULL.
  ///
  /// @param pPluginVersionString [in, string] buffer from which PluginVersionString is to be read
  ///
  STDMETHOD(SetPluginVersionString) (THIS_
    aafCharacter_constptr  pPluginVersionString) PURE;


  //***********************************************************
  //
  // GetPluginVersionString()
  //
  /// Gets the Plugin Version String property.
  /// 
  /// Writes the PluginVersionString property, with a trailing null
  /// character, into the pPluginVersionString buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the PluginVersionString property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetPluginVersionStringBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pPluginVersionString.
  /// 
  /// Succeeds if:
  /// - The pPluginVersionString pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   PluginVersionString.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPluginVersionString arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold PluginVersionString.
  ///
  /// @param pPluginVersionString [out, string, size_is(bufSize)] buffer into which PluginVersionString is to be written
  /// @param bufSize [in] size of *pPluginVersionString buffer in bytes
  ///
  STDMETHOD(GetPluginVersionString) (THIS_
    aafCharacter *  pPluginVersionString,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetPluginVersionStringBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetPluginVersionString().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetPluginVersionStringBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;


  //***********************************************************
  //
  // SetPluginManufacturerName()
  //
  /// Sets the Plugin Manufacturer Name string property.
  ///
  /// Set the PluginManufacturerName property to the value specified in
  /// pPluginManufacturerName.  A copy is made of the data so the caller
  /// retains ownership of the *pPluginManufacturerName buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pPluginManufacturerName pointer is valid.
  /// 
  /// If this method fails the PluginManufacturerName property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPluginManufacturerName arg is NULL.
  ///
  /// @param pPluginManufacturerName [in, string] buffer from which PluginManufacturerName is to be read
  ///
  STDMETHOD(SetPluginManufacturerName) (THIS_
    aafCharacter_constptr  pPluginManufacturerName) PURE;


  //***********************************************************
  //
  // GetPluginManufacturerName()
  //
  /// Gets the Plugin Manufacturer Name string property.
  /// 
  /// Writes the PluginManufacturerName property, with a trailing null
  /// character, into the pPluginManufacturerName buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the PluginManufacturerName property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetPluginManufacturerNameBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pPluginManufacturerName.
  /// 
  /// Succeeds if:
  /// - The pPluginManufacturerName pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   PluginManufacturerName.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPluginManufacturerName arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold PluginManufacturerName.
  ///
  /// @param pPluginManufacturerName [out, string, size_is(bufSize)] buffer into which PluginManufacturerName is to be written
  /// @param bufSize [in] size of *pPluginManufacturerName buffer in bytes
  ///
  STDMETHOD(GetPluginManufacturerName) (THIS_
    aafCharacter *  pPluginManufacturerName,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetPluginManufacturerNameBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetPluginManufacturerName().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetPluginManufacturerNameBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;


  //***********************************************************
  //
  // GetManufacturerInfo()
  //
  /// This method will get an AAFNetworkLocator pointing to
  /// ManufacturerInfo for this plugin and place an interface for the
  /// locator into the **ppResult argument.  If a ManufacturerInfo
  /// locator exists, the result will be AddRef()ed. If not, the
  /// result will be NULL.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppResult arg is NULL.
  ///
  /// @param ppResult [out, retval] ManufacturerInfo property value
  ///
  STDMETHOD(GetManufacturerInfo) (THIS_
    IAAFNetworkLocator ** ppResult) PURE;


  //***********************************************************
  //
  // SetManufacturerInfo()
  //
  /// This method will set a locator pointing to the location of
  /// ManufacturerInfo for this plugin.  If a ManufacturerInfo
  /// already exists for this mob slot, it will be discarded.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param pManufacturerInfo [in] ManufacturerInfo property value
  ///
  STDMETHOD(SetManufacturerInfo) (THIS_
    IAAFNetworkLocator * pManufacturerInfo) PURE;


  //***********************************************************
  //
  // GetManufacturerID()
  //
  /// Obtains the manufacturer ID, which is identifies the manfacturer
  /// of this plugin.  This ID is written into the caller-allocated
  /// aafUID_t specified by the pManufacturerID argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pManufacturerID pointer is valid.
  /// 
  /// If this method fails nothing will be written to
  /// *pManufacturerID.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pManufacturerID arg is NULL.
  ///
  /// @param pManufacturerID [out] The ManufacturerID
  ///
  STDMETHOD(GetManufacturerID) (THIS_
    aafUID_t *  pManufacturerID) PURE;


  //***********************************************************
  //
  // SetManufacturerID()
  //
  /// Sets the manufacturer ID, which is identifies the manufacturer
  /// of this plugin.
  /// 
  /// If this method fails the ManufacturerID property will not be
  /// changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param manufacturerID [in, ref] The Category Class
  ///
  STDMETHOD(SetManufacturerID) (THIS_
    aafUID_constref  manufacturerID) PURE;


  //***********************************************************
  //
  // GetHardwarePlatform()
  //
  /// Obtains the hardware platform ID, which identifies the hardware
  /// platform which is required to use this plugin.  This ID is
  /// written into the caller-allocated variable specified by the
  /// pHardwarePlatform argument. The type aafHardwarePlatform_t is an
  /// extensible enumerated type, and the value given must be either
  /// standard or in the type dictionary.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pHardwarePlatform pointer is valid.
  /// 
  /// If this method fails nothing will be written to
  /// *pHardwarePlatform.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pHardwarePlatform arg is NULL.
  ///
  /// @param pHardwarePlatform [out] The HardwarePlatform
  ///
  STDMETHOD(GetHardwarePlatform) (THIS_
    aafHardwarePlatform_t *  pHardwarePlatform) PURE;


  //***********************************************************
  //
  // SetHardwarePlatform()
  //
  /// Sets the hardware platform ID, which identifies the hardware
  /// platform which is required to use this plugin.  The type
  /// aafHardwarePlatform_t is an extensible enumerated type, and the
  /// value given must be either standard or in the type dictionary.
  /// 
  /// If this method fails the HardwarePlatform property will not be
  /// changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param hardwarePlatform [in] The Category Class
  ///
  STDMETHOD(SetHardwarePlatform) (THIS_
    aafHardwarePlatform_constref  hardwarePlatform) PURE;


  //***********************************************************
  //
  // GetPlatformVersionRange()
  //
  /// Gets the minimum and maximum platform Version properties
  /// associated with this plugin descriptor and places it into
  /// *pMinVersion, and *pMaxVersion.  These are the minimum and
  /// maximum versions of the platform for which this plugin will
  /// function.
  ///
  /// Succeeds if all of the following are true:
  /// - both pMinVersion and pMaxVersion pointers are valid.
  /// 
  /// If this method fails, nothing will be written to *pMinVersion or
  /// *pMaxVersion.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMinVersion or pMaxVersion arg is NULL.
  ///
  /// @param pMinVersion [out] The Minimum Platform Version
  /// @param pMaxVersion [out] The Maximum Platform Version
  ///
  STDMETHOD(GetPlatformVersionRange) (THIS_
    aafVersionType_t *  pMinVersion,
    aafVersionType_t *  pMaxVersion) PURE;


  //***********************************************************
  //
  // SetPlatformMinimumVersion()
  //
  /// Sets the maximum platform Version property of this plugin
  /// descriptor.  This is the minimum version of the platform for
  /// which this plugin will function.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param minVersion [in] The Minimum Platform Version
  ///
  STDMETHOD(SetPlatformMinimumVersion) (THIS_
    aafVersionType_constref  minVersion) PURE;


  //***********************************************************
  //
  // SetPlatformMaximumVersion()
  //
  /// Sets the maximum platform Version properties associated with this
  /// plugin descriptor.  This is the maximum version of the platform
  /// for which this plugin will function.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param maxVersion [in] The Maximum Platform Version
  ///
  STDMETHOD(SetPlatformMaximumVersion) (THIS_
    aafVersionType_constref  maxVersion) PURE;


  //***********************************************************
  //
  // GetEngine()
  //
  /// Obtains the software engine ID, which identifies the software
  /// subsystem used for essence management and playback used by the
  /// plugin.  This ID is written into the caller-allocated variable
  /// specified by the pHardwarePlatform argument.  The type
  /// aafEngine_t is an extensible, enumerated type, and the value
  /// given must be either standard or in the type dictionary.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pHardwarePlatform pointer is valid.
  /// 
  /// If this method fails nothing will be written to
  /// *pHardwarePlatform.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEngine arg is NULL.
  ///
  /// @param pEngine [out] The software engine
  ///
  STDMETHOD(GetEngine) (THIS_
    aafEngine_t *  pEngine) PURE;


  //***********************************************************
  //
  // SetEngine()
  //
  /// Sets the software engine ID, which identifies the software
  /// subsystem used for essence management and playback used by the
  /// plugin.  The type aafEngine_t is an extensible enumerated type,
  /// and the value given must be either standard or in the type
  /// dictionary.
  /// 
  /// If this method fails the engine property will not be
  /// changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param engine [in] The software engine
  ///
  STDMETHOD(SetEngine) (THIS_
    aafEngine_constref  engine) PURE;


  //***********************************************************
  //
  // GetEngineVersionRange()
  //
  /// Gets the minimum and maximum engine Version properties of the
  /// engine which is associated with this plugin and places it into
  /// *pMinVersion, and *pMaxVersion.  These are the minimum and
  /// maximum versions of the engine for which this plugin will
  /// function.
  ///
  /// Succeeds if all of the following are true:
  /// - both pMinVersion and pMaxVersion pointers are valid.
  /// 
  /// If this method fails, nothing will be written to *pMinVersion or
  /// *pMaxVersion.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMinVersion or pMaxVersion arg is NULL.
  ///
  /// @param pMinVersion [out] The Minimum Engine Version
  /// @param pMaxVersion [out] The Maximum Engine Version
  ///
  STDMETHOD(GetEngineVersionRange) (THIS_
    aafVersionType_t *  pMinVersion,
    aafVersionType_t *  pMaxVersion) PURE;


  //***********************************************************
  //
  // SetEngineMinimumVersion()
  //
  /// Sets the minimum engine Version property to the minimum useful
  /// version of the engine which is associated with this plugin.  This
  /// is the minimum version of the engine for which this plugin will
  /// function.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param minVersion [in] The Minimum Engine Version
  ///
  STDMETHOD(SetEngineMinimumVersion) (THIS_
    aafVersionType_constref  minVersion) PURE;


  //***********************************************************
  //
  // SetEngineMaximumVersion()
  //
  /// Sets the minimum engine Version property to the maximum useful
  /// version of the engine which is associated with this plugin.  This
  /// is the maximum version of the engine for which this plugin will
  /// function.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param pMaxVersion [in] The Minimum Engine Version
  ///
  STDMETHOD(SetEngineMaximumVersion) (THIS_
    aafVersionType_constref  pMaxVersion) PURE;


  //***********************************************************
  //
  // GetPluginAPI()
  //
  /// Obtains the manufacturer ID Class, which identifies the plugin
  /// interface supported by the plugin.  This ID is written into the
  /// caller-allocated variable specified by the pPluginAPI argument.
  /// The type aafPluginAPI_t is an extensible enumerated type, and
  /// the value given must be either standard or in the type
  /// dictionary.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pPluginAPI pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pPluginAPI.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPluginAPI arg is NULL.
  ///
  /// @param pPluginAPI [out] The PluginAPI
  ///
  STDMETHOD(GetPluginAPI) (THIS_
    aafPluginAPI_t *  pPluginAPI) PURE;


  //***********************************************************
  //
  // SetPluginAPI()
  //
  /// Obtains the manufacturer ID, which identifies the plugin
  /// interface supported by the plugin.
  /// 
  /// The type aafPluginAPI_t is an extensible enumerated type, and
  /// the value given must be either standard or in the type dictionary.
  /// 
  /// If this method fails the PluginAPI property will not be
  /// changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param pluginAPI [in] The Category Class
  ///
  STDMETHOD(SetPluginAPI) (THIS_
    aafPluginAPI_constref  pluginAPI) PURE;


  //***********************************************************
  //
  // GetPluginAPIVersionRange()
  //
  /// Gets the minimum and maximum plugin API Version properties of the
  /// plugin API which is associated with this plugin descriptor and
  /// places it into *pMinVersion, and *pMaxVersion.  These are the
  /// minimum and maximum versions of the PluginAPI for which this
  /// plugin will function.
  ///
  /// Succeeds if all of the following are true:
  /// - both pMinVersion and pMaxVersion pointers are valid.
  /// 
  /// If this method fails, nothing will be written to *pMinVersion or
  /// *pMaxVersion.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMinVersion or pMaxVersion arg is NULL.
  ///
  /// @param pMinVersion [out] The Minimum Plugin API Version
  /// @param pMaxVersion [out] The Maximum Plugin API Version
  ///
  STDMETHOD(GetPluginAPIVersionRange) (THIS_
    aafVersionType_t *  pMinVersion,
    aafVersionType_t *  pMaxVersion) PURE;


  //***********************************************************
  //
  // SetPluginAPIMinimumVersion()
  //
  /// Sets the minimum plugin API Version property to the minimum
  /// useful version of the plugin API which is associated with this
  /// plugin.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param minVersion [out] The Minimum Plugin API Version
  ///
  STDMETHOD(SetPluginAPIMinimumVersion) (THIS_
    aafVersionType_constref  minVersion) PURE;


  //***********************************************************
  //
  // SetPluginAPIMaximumVersion()
  //
  /// Sets the maximum engine Version property to the maximum useful
  /// version of the plugin API which is associated with this plugin.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param maxVersion [in] The Maximum Plugin API Version
  ///
  STDMETHOD(SetPluginAPIMaximumVersion) (THIS_
    aafVersionType_constref  maxVersion) PURE;


  //***********************************************************
  //
  // IsSoftwareOnly()
  //
  /// Tells whether the given plugin is capable of running in a
  /// software-only environment.  A value of AAFTrue indicates that no
  /// additional hardware is required.  If the result is AAFTrue, then
  /// this plugin may also support hardware acceleration, as long as
  /// it also contains a software method of processing the data.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pIsSoftwareOnly pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pIsSoftwareOnly.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pIsSoftwareOnly arg is NULL.
  ///
  /// @param pIsSoftwareOnly [out] The IsSoftwareOnly
  ///
  STDMETHOD(IsSoftwareOnly) (THIS_
    aafBoolean_t *  pIsSoftwareOnly) PURE;


  //***********************************************************
  //
  // SetIsSoftwareOnly()
  //
  /// Sets whether the given plugin is capable of running in a
  /// software-only environment, and returns AAFFalse if any hardware
  /// is required.  If isSoftwareOnly is AAFTrue, then this plugin may
  /// also support hardware acceleration, as long as it also contains
  /// a software method of processing the data.  If this method fails
  /// the isSoftwareOnly property will not be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param isSoftwareOnly [in] The isSoftwareOnly flag
  ///
  STDMETHOD(SetIsSoftwareOnly) (THIS_
    aafBoolean_t  isSoftwareOnly) PURE;


  //***********************************************************
  //
  // IsAccelerated()
  //
  /// Tells whether the given plugin is capable of running with a
  /// hardware accelerator.  If the result is AAFTrue, then this
  /// plugin may also support software decompression.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pIsAccelerated pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pIsAccelerated.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pIsAccelerated arg is NULL.
  ///
  /// @param pIsAccelerated [out] The IsAccelerated
  ///
  STDMETHOD(IsAccelerated) (THIS_
    aafBoolean_t *  pIsAccelerated) PURE;


  //***********************************************************
  //
  // SetIsAccelerated()
  //
  /// Tells whether the given plugin is capable of running with a
  /// hardware accelerator.  If the result is AAFTrue, then this
  /// plugin may also support software decompression.
  ///
  /// If this method fails the IsAccelerated property will not be
  /// changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param isAccelerated [in] The isAccelerated flag
  ///
  STDMETHOD(SetIsAccelerated) (THIS_
    aafBoolean_t  isAccelerated) PURE;


  //***********************************************************
  //
  // SupportsAuthentication()
  //
  /// Tells whether the given plugin is capable of supporting
  /// authentication.  The methods for authenticating a plugin are
  /// still <tbd>.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pSupportsAuthentication pointer is valid.
  /// 
  /// If this method fails nothing will be written to
  /// *pSupportsAuthentication.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSupportsAuthentication arg is NULL.
  ///
  /// @param pSupportsAuthentication [out] The SupportsAuthentication
  ///
  STDMETHOD(SupportsAuthentication) (THIS_
    aafBoolean_t *  pSupportsAuthentication) PURE;


  //***********************************************************
  //
  // SetSupportsAuthentication()
  //
  /// Tells whether the given plugin is capable of supporting
  /// authentication.  The methods for authenticating a plugin are
  /// still <tbd>.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param SupportsAuthentication [in] The SupportsAuthentication flag
  ///
  STDMETHOD(SetSupportsAuthentication) (THIS_
    aafBoolean_t  SupportsAuthentication) PURE;



  //***********************************************************
  //
  // CountLocators()
  //
  /// Return the number of locators attached to this plugin descriptor.
  /// The number of locators may be zero if the plugin is in the
  /// current file.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pCount pointer is valid.
  /// 
  /// If this method fails nothing is written to *pCount.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCount is null.
  ///
  /// @param pResult [out] Returns the number of locators
  ///
  STDMETHOD(CountLocators) (THIS_
    aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // AppendLocator()
  //
  /// Append another locator to this plugin descriptor.  Use this
  /// function to add a locator to be scanned last when searching for
  /// the plugin (a secondary location for the plugin).
  /// 
  /// Succeeds if all of the following are true:
  /// - the pLocator pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLocator is null.
  ///
  /// @param pLocator [in] Locator to append
  ///
  STDMETHOD(AppendLocator) (THIS_
    IAAFLocator * pLocator) PURE;


  //***********************************************************
  //
  // PrependLocator()
  //
  /// Append another locator to this plugin descriptor.  Use this
  /// function to add a locator to be scanned first when searching for
  /// the plugin (a new primary location for the plugin).
  /// 
  /// Succeeds if all of the following are true:
  /// - the pLocator pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLocator is null.
  ///
  /// @param pLocator [in] Locator to append
  ///
  STDMETHOD(PrependLocator) (THIS_
    IAAFLocator * pLocator) PURE;


  //***********************************************************
  //
  // InsertLocatorAt()
  //
  /// Insert another locator to this plugin descriptor at the given
  /// index.  Locators already existing at the named and higher indices
  /// will be moved up to the next higher index to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - index is less than or equal to the value returned by
  ///   CountLocators().
  /// - the pLocator pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLocator is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than the value returned by
  ///     CountLocators().
  ///
  /// @param index [in] index to insert locator
  /// @param pLocator [in] Locator to insert
  ///
  STDMETHOD(InsertLocatorAt) (THIS_
    aafUInt32  index,
    IAAFLocator * pLocator) PURE;


  //***********************************************************
  //
  // GetLocatorAt()
  //
  /// Gets the locator which exists in this plugin descriptor at the
  /// given index.
  /// 
  /// Succeeds if all of the following are true:
  /// - index is less than the value returned by CountLocators().
  /// - the ppLocator pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppLocator is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than or equal to the value returned by
  ///     CountLocators().
  ///
  /// @param index [in] index to insert locator
  /// @param ppLocator [out] returned Locator
  ///
  STDMETHOD(GetLocatorAt) (THIS_
    aafUInt32  index,
    IAAFLocator ** ppLocator) PURE;


  //***********************************************************
  //
  // RemoveLocatorAt()
  //
  /// Removes the locator which exists in this plugin descriptor at the
  /// given index.  Locators already existing at indices higher than
  /// the named index will be moved down to the next higher index to
  /// accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - index is less than the value returned by CountLocators().
  /// - the ppLocator pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppLocator is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than or equal to the value returned by
  ///     CountLocators().
  ///
  /// @param index [in] index to insert locator
  ///
  STDMETHOD(RemoveLocatorAt) (THIS_
    aafUInt32  index) PURE;



  //***********************************************************
  //
  // GetLocators()
  //
  /// Places an IEnumAAFPluginLocators enumerator for the plugin
  /// locators contained in the AAFPluginDescriptor into the *ppEnum
  /// argument.
  /// 
  /// The returned enumerator is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// E_FAIL
  ///   - Failed to create the enumerator.
  ///
  /// @param ppEnum [out, retval] Plugin Locator Enumeration
  ///
  STDMETHOD(GetLocators) (THIS_
    IEnumAAFPluginLocators ** ppEnum) PURE;

    //***********************************************************
  //
  // SetDefinitionObjectID()
  //
  /// Sets the definition object handled by this plugin.
  ///
  /// @param pDef [in] AUID of an AAFDefinitionObject
  ///
  STDMETHOD(SetDefinitionObjectID) (THIS_
    aafUID_t  pDef) PURE;

    //***********************************************************
  //
  // GetDefinitionObjectID()
  //
  /// Gets the definition object handled by this plugin.
  ///
  /// @param ppDef [retval,out] AUID of an AAFDefinitionObject
  ///
  STDMETHOD(GetDefinitionObjectID) (THIS_
    aafUID_t*  ppDef) PURE;


  END_INTERFACE
};
#endif // __IAAFPluginDef_INTERFACE_DEFINED__




// IAAFPluginManager

// ************************
//
// Interface IAAFPluginManager
//
// ************************





#ifndef __IAAFPluginManager_INTERFACE_DEFINED__
#define __IAAFPluginManager_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFPluginManager;

#undef  INTERFACE
#define INTERFACE   IAAFPluginManager

DECLARE_INTERFACE_(IAAFPluginManager, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFPluginManager methods *** */

  //***********************************************************
  //
  // RegisterSharedPlugins()
  //
  /// Attempts to load and register all of the AAF plugin files found
  /// in shared installation directory.
  STDMETHOD(RegisterSharedPlugins) (THIS) PURE;


  //***********************************************************
  //
  // RegisterPluginDirectory()
  //
  /// Attempts to load and register all of the AAF plugin files found
  /// in the given directory.
  ///
  /// @param directoryName [in] Pointer to the name of directory to look for plugins.
  ///
  STDMETHOD(RegisterPluginDirectory) (THIS_
    aafCharacter_constptr  directoryName) PURE;


  //***********************************************************
  //
  // RegisterPluginFile()
  //
  /// Attempts to load and register all of the AAF plugins found
  /// in the given file.
  ///
  /// @param fileName [in] Pointer to the name of plugin file to register.
  ///
  STDMETHOD(RegisterPluginFile) (THIS_
    aafCharacter_constptr  fileName) PURE;


  //***********************************************************
  //
  // EnumLoadedPlugins()
  //
  /// Returns an enumerator which enumerates over all of the loaded
  /// plugin choices through the *ppEnum argument.  The returned
  /// enumerator is AddRef()ed before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - if ppEnum is null.
  ///
  /// @param categoryID [in, ref] Which category ID do we want to enumerate
  /// @param ppEnum [out,retval] Loaded Plugin Enumeration
  ///
  STDMETHOD(EnumLoadedPlugins) (THIS_
    aafUID_constref  categoryID,
    IEnumAAFLoadedPlugins ** ppEnum) PURE;


  //***********************************************************
  //
  // CreatePluginDefinition()
  //
  /// Given a plugin definition ID, find a plugin and manufactures a
  /// plugin descriptor of the correct class for this plugin, filling
  /// in the values, and returning the definition through the
  /// *pPluginDesc argument.  The returned definition is AddRef()ed
  /// before it is returned.  You must call QueryInterface on the
  /// result in order to find the correct interface, and are
  /// responsible for adding the definition to the correct place in the
  /// dictionary, as well as preventing duplicates. The resulting
  /// definiton has the plugin descriptor already attached.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pPluginDesc pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - if pPluginDesc is null.
  ///
  /// @param pluginDefID [in, ref] Which plugin definition do you want to create
  /// @param pDictionary [in] The dictionary of the file where the descriptor is to be created
  /// @param ppPluginDef [out] The interface of the returned definition
  ///
  STDMETHOD(CreatePluginDefinition) (THIS_
    aafUID_constref  pluginDefID,
    IAAFDictionary * pDictionary,
    IAAFDefObject**  ppPluginDef) PURE;


  //***********************************************************
  //
  // CreateInstance()
  //
  /// Create an object contained within one of the loaded plugin
  /// files.
  /// 
  /// Succeeds if all of the following are true:
  /// - the rclsid was found by the plugin manager
  /// - the interface corresponding to riid is supported by the plugin
  /// - if pUnkOuter is not NULL and given plugin supports aggregation
  ///   and riid must be a reference to IID_IUnknown.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// E_INVALIDARG
  ///   - if ppPlugin is null.
  ///   - pUnkOuter is not NULL and riid is not IID_IUnknown.
  ///
  /// AAFRESULT_EXTENSION_NOT_FOUND
  ///   - The given rclsid could not be found by the Plugin Manager.
  ///
  /// E_NOINTERFACE
  ///   - if initial interface given by riid is not supported by the
  ///     plugin.
  ///
  /// @param rclsid [in] The class id of the plugin object do you want to create
  /// @param pUnkOuter [in] The controlling unknown of the new instance
  /// @param riid [in] The IID of the initialial interface for the new plugin instance
  /// @param ppPlugin [out,iid_is(riid)] The IID of the initialial interface for the new plugin instance
  ///
  STDMETHOD(CreateInstance) (THIS_
    REFCLSID  rclsid,
    IUnknown *  pUnkOuter,
    REFIID  riid,
    void **  ppPlugin) PURE;

  END_INTERFACE
};
#endif // __IAAFPluginManager_INTERFACE_DEFINED__



// IAAFProperty

// ************************
//
// Interface IAAFProperty
//
// ************************






#ifndef __IAAFProperty_INTERFACE_DEFINED__
#define __IAAFProperty_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFProperty;

#undef  INTERFACE
#define INTERFACE   IAAFProperty

DECLARE_INTERFACE_(IAAFProperty, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFProperty methods *** */

  //***********************************************************
  //
  // GetDefinition()
  //
  /// Returns the definition of this property.
  ///
  /// Succeeds if:
  /// - This object has already been Initialize()d.
  /// - The ppPropDef pointer is valid.
  /// - The associated property definition can be found in the
  ///   dictionary.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppPropDef arg is NULL.
  ///
  /// AAFRESULT_BAD_PROP
  ///   - The definition for this property could not be found in the
  ///     dictionary.
  ///
  /// @param ppPropDef [out] This property's definition
  ///
  STDMETHOD(GetDefinition) (THIS_
    IAAFPropertyDef ** ppPropDef) PURE;


  //***********************************************************
  //
  // GetValue()
  //
  /// Returns the Property Value object associated with this property.
  ///
  /// Succeeds if:
  /// - This object has already been Initialize()d.
  /// - The ppPval pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppValue arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - The given property is optional and not present.
  ///
  /// @param ppValue [out] The Property Value object associated with this property.
  ///
  STDMETHOD(GetValue) (THIS_
    IAAFPropertyValue ** ppValue) PURE;

  END_INTERFACE
};
#endif // __IAAFProperty_INTERFACE_DEFINED__



// IAAFPropertyDef

// ************************
//
// Interface IAAFPropertyDef
//
// ************************




 

#ifndef __IAAFPropertyDef_INTERFACE_DEFINED__
#define __IAAFPropertyDef_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFPropertyDef;

#undef  INTERFACE
#define INTERFACE   IAAFPropertyDef

DECLARE_INTERFACE_(IAAFPropertyDef, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFPropertyDef methods *** */

  //***********************************************************
  //
  // GetTypeDef()
  //
  /// Returns a reference to this property's type definition.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  ///
  /// @param ppTypeDef [out] definition of type contained by this property
  ///
  STDMETHOD(GetTypeDef) (THIS_
    IAAFTypeDef ** ppTypeDef) PURE;


  //***********************************************************
  //
  // GetName()
  //
  /// Gets the human-legible name.
  /// 
  /// Writes the Name property, with a trailing null
  /// character, into the pName buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the Name property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetNameBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pName.
  /// 
  /// Succeeds if:
  /// - The pName pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   Name.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold Name.
  ///
  /// @param pName [out, string, size_is(bufSize)] buffer into which Name is to be written
  /// @param bufSize [in] size of *pName buffer in bytes
  ///
  STDMETHOD(GetName) (THIS_
    aafCharacter *  pName,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetNameBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetName().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetNameBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;


  //***********************************************************
  //
  // GetIsOptional()
  //
  /// Sets *pIsOptional to AAFTrue for properties that are optional.
  /// Sets it to AAFFalse for properties that are mandatory.
  ///
  /// Succeeds if:
  /// - The pIsOptional pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - The pIsOptional pointer is NULL.
  ///
  /// @param pIsOptional [out, retval] pointer to the result
  ///
  STDMETHOD(GetIsOptional) (THIS_
    aafBoolean_t *  pIsOptional) PURE;

  //***********************************************************
  //
  // GetIsUniqueIdentifier()
  //
  /// Sets *pIsUniqueIdentifier to AAFTrue for properties that are optional.
  /// Sets it to AAFFalse for properties that are mandatory.
  ///
  /// Succeeds if:
  /// - The pIsUniqueIdentifier pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - The pIsUniqueIdentifier pointer is NULL.
  ///
  /// @param pIsUniqueIdentifier [out, retval] pointer to the result
  ///
  STDMETHOD(GetIsUniqueIdentifier) (THIS_
    aafBoolean_t *  pIsUniqueIdentifier) PURE;




  //***********************************************************
  //
  // SetDescription()
  //
  /// Sets the description of the property definition.
  ///
  /// Set the Description property to the value specified in
  /// pDescription.  A copy is made of the data so the caller
  /// retains ownership of the *pDescription buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pDescription pointer is valid.
  /// 
  /// If this method fails the Description property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDescription arg is NULL.
  ///
  /// @param pDescription [in, string] buffer from which Description is to be read
  ///
  STDMETHOD(SetDescription) (THIS_
    aafCharacter_constptr  pDescription) PURE;


  //***********************************************************
  //
  // GetDescription()
  //
  /// Gets the description of the property definition.
  /// 
  /// Writes the Description property, with a trailing null
  /// character, into the pDescription buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the Description property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetDescriptionBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pDescription.
  /// 
  /// Succeeds if:
  /// - The pDescription pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   Description.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDescription arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold Description.
  ///
  /// @param pDescription [out, string, size_is(bufSize)] buffer into which Description is to be written
  /// @param bufSize [in] size of *pDescription buffer in bytes
  ///
  STDMETHOD(GetDescription) (THIS_
    aafCharacter *  pDescription,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetDescriptionBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetDescription().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetDescriptionBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;


  END_INTERFACE
};
#endif // __IAAFPropertyDef_INTERFACE_DEFINED__



// IAAFPropertyValue

// ************************
//
// Interface IAAFPropertyValue
//
// ************************




#ifndef __IAAFPropertyValue_INTERFACE_DEFINED__
#define __IAAFPropertyValue_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFPropertyValue;

#undef  INTERFACE
#define INTERFACE   IAAFPropertyValue

DECLARE_INTERFACE_(IAAFPropertyValue, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFPropertyValue methods *** */

  //***********************************************************
  //
  // GetType()
  //
  /// Returns the type definition associated with this property value.
  /// If this Property Value is not of a recognized type (such as from
  /// a damaged or incorrectly construct file) this method will return
  /// a raw access type which can be used to access the property data
  /// in a raw manner.
  ///
  /// Succeeds if:
  /// - The ppTypeDef pointer is valid.
  /// - The associated type definition can be found in the dictionary.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTypeDef arg is NULL.
  ///
  /// @param ppTypeDef [out] The type definition associated with this property value
  ///
  STDMETHOD(GetType) (THIS_
    IAAFTypeDef ** ppTypeDef) PURE;


  //***********************************************************
  //
  // IsDefinedType()
  //
  /// Returns false if this property value's type is not (necessarily)
  /// the one which was defined for it.  That may be the case if this
  /// property value was read from a damaged file where type
  /// information was not available; in that case GetType() will return
  /// the raw access type for this value.
  ///
  /// If this property value's type is the one which was defined for
  /// it, this method will return true and GetType() will return that
  /// defined type for this value.
  ///
  /// Succeeds if:
  /// - The pIsDefined pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pIsDefined arg is NULL.
  ///
  /// @param pIsDefined [out] result
  ///
  STDMETHOD(IsDefinedType) (THIS_
    aafBoolean_t *  pIsDefined) PURE;

  END_INTERFACE
};
#endif // __IAAFPropertyValue_INTERFACE_DEFINED__



// IAAFPulldown

// ************************
//
// Interface IAAFPulldown
//
// ************************



#ifndef __IAAFPulldown_INTERFACE_DEFINED__
#define __IAAFPulldown_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFPulldown;

#undef  INTERFACE
#define INTERFACE   IAAFPulldown

DECLARE_INTERFACE_(IAAFPulldown, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFPulldown methods *** */

  //***********************************************************
  //
  // GetInputSegment()
  //
  /// Places the input Segment object in this pulldown into the
  /// *ppInputSegment argument.  If none exists yet, NULL is placed
  /// into the *ppInputSegment argument.
  ///
  /// The returned segment object, if it exists, is AddRef()ed
  /// before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppInputSegment pointer is valid.
  /// - A valid segment exists.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppInputSegment is null.
  ///
  /// @param ppInputSegment [out] Returns the input Segment object
  ///
  STDMETHOD(GetInputSegment) (THIS_
    IAAFSegment ** ppInputSegment) PURE;


  //***********************************************************
  //
  // SetInputSegment()
  //
  /// Sets the input segment .
  ///
  /// Succeeds if all of the following are true:
  /// - the pInputSegment pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pInputSegment is null.
  ///
  /// @param pInputSegment [in] A Segment object
  ///
  STDMETHOD(SetInputSegment) (THIS_
    IAAFSegment * pInputSegment) PURE;


  //***********************************************************
  //
  // GetPulldownKind()
  //
  /// Returns the pulldownKind property of this pulldown through the
  /// *pPulldownKind argument.  The pulldown kinds include
  /// kThreeTwoPD, kPalPD, kOneToOneNTSC, kOneToOnePAL, and
  /// kVideoTapNTSC.
  ///
  /// Succeeds if all of the following are true:
  /// - the pPulldownKind pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPulldownKind is null.
  ///
  /// @param pPulldownKind [out] Returns the pulldownKind property
  ///
  STDMETHOD(GetPulldownKind) (THIS_
    aafPulldownKind_t *  pPulldownKind) PURE;


  //***********************************************************
  //
  // SetPulldownKind()
  //
  /// Sets the pulldown kind field of this pulldown object.  The
  /// pulldown kinds include kThreeTwoPD, kPalPD, kOneToOneNTSC,
  /// kOneToOnePAL, and kVideoTapNTSC.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pInputSegment is null.
  ///
  /// @param pulldownKind [in] A Segment object
  ///
  STDMETHOD(SetPulldownKind) (THIS_
    aafPulldownKind_t  pulldownKind) PURE;


  //***********************************************************
  //
  // GetPulldownDirection()
  //
  /// Returns the pulldownDirection field of this pulldown through the
  /// *pPulldownDirection argument.  The valid
  /// pulldown directions are:
  ///    kVideoToFilmSpeed -- The input segment is at videoSpeed, and
  ///                         the pulldown object is on a mob slot at
  ///                         film edit rate.
  ///    kFilmToVideoSpeed -- The input segment is at film edit rate.
  ///
  /// The value kVideoToFilmSpeed is used when connecting 24fps file
  /// mobs to tape mobs. 
  ///
  /// The value kFilmToVideoSpeed is used when connecting tape mobs to
  /// film mobs.
  ///
  /// Succeeds if all of the following are true:
  /// - the pPulldownDirection pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPulldownDirection is null.
  ///
  /// @param pPulldownDirection [out] Returns the input Segment object
  ///
  STDMETHOD(GetPulldownDirection) (THIS_
    aafPulldownDir_t *  pPulldownDirection) PURE;


  //***********************************************************
  //
  // SetPulldownDirection()
  //
  /// Sets the pulldown direction field of this pulldown object.  The
  /// valid pulldown directions are:
  ///    kVideoToFilmSpeed -- The input segment is at videoSpeed, and
  ///                         the pulldown object is on a mob slot at
  ///                         film edit rate.
  ///    kFilmToVideoSpeed -- The input segment is at film edit rate.
  ///
  /// The value kVideoToFilmSpeed is used when connecting 24fps file
  /// mobs to tape mobs.
  ///
  /// The value kFilmToVideoSpeed is used when connecting tape mobs to
  /// film mobs.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pInputSegment is null.
  ///
  /// @param pulldownDirection [in] A Segment object
  ///
  STDMETHOD(SetPulldownDirection) (THIS_
    aafPulldownDir_t  pulldownDirection) PURE;


  //***********************************************************
  //
  // GetPhaseFrame()
  //
  /// Returns the phaseFrame field of this pulldown through the
  /// *pPhaseFrame argument.  The phase frame field specifies the phase
  /// within the repeating pattern used to map between the two edit
  /// rates. A value of zero specifies that the pulldown object starts
  /// at the begining of the pattern.
  ///
  /// Succeeds if all of the following are true:
  /// - the pPhaseFrame pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPhaseFrame is null.
  ///
  /// @param pPhaseFrame [out] Returns the input Segment object
  ///
  STDMETHOD(GetPhaseFrame) (THIS_
    aafPhaseFrame_t *  pPhaseFrame) PURE;


  //***********************************************************
  //
  // SetPhaseFrame()
  //
  /// Sets the phase frame field of this pulldown object.  The phase
  /// frame field specifies the phase within the repeating pattern used
  /// to map between the two edit rates. A value of zero specifies that
  /// the pulldown object starts at the begining of the pattern.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pInputSegment is null.
  ///
  /// @param phaseFrame [in] A Segment object
  ///
  STDMETHOD(SetPhaseFrame) (THIS_
    aafPhaseFrame_t  phaseFrame) PURE;







  END_INTERFACE
};
#endif // __IAAFPulldown_INTERFACE_DEFINED__



// IAAFRGBADescriptor

// ************************
//
// Interface IAAFRGBADescriptor
//
// ************************







#ifndef __IAAFRGBADescriptor_INTERFACE_DEFINED__
#define __IAAFRGBADescriptor_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFRGBADescriptor;


#undef  INTERFACE
#define INTERFACE   IAAFRGBADescriptor

DECLARE_INTERFACE_(IAAFRGBADescriptor, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFRGBADescriptor methods *** */

  //***********************************************************
  //
  // SetPixelLayout()
  //
  /// Sets the layout and structure of the components in a single pixel.
  /// The layout array is an Array of 8 aafRGBAComponent_t.  The 'Code' field of the struct is
  /// from the set:
  ///   	- kAAFCompNone
  /// 	- kAAFCompAlpha
  /// 	- kAAFCompBlue
  /// 	- kAAFCompFill
  /// 	- kAAFCompGreen
  /// 	- kAAFCompPalette
  /// 	- kAAFCompRed
  ///
  /// The 'Size' field of the struct is the component size in bits.
  /// 
  /// If you set less than 8 entries, the remaining entries will be padded with kAAFCompNone and a size of zero.
  /// If this method fails the PixelLayout property will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param numberElements [in] The number of elements in each array
  /// @param PixelLayoutArray [in] Array of up to 8 aafRGBAComponent_t indicating component order and size.
  ///
  STDMETHOD(SetPixelLayout) (THIS_
    aafUInt32  numberElements,
    aafRGBAComponent_t*  PixelLayoutArray) PURE;

  //***********************************************************
  //
  // CountPixelLayoutElements()
  //
  /// This function returns the number of components in a pixel.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails no state is changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  ///
  /// @param pResult [out] Number of components
  ///
  STDMETHOD(CountPixelLayoutElements) (THIS_
    aafUInt32 *  pResult) PURE;

  //***********************************************************
  //
  // GetPixelLayout()
  //
  /// Gets the layout and structure of the components in a single pixel.
  /// The layout array is an Array of 8 aafRGBAComponent_t.  The 'Code' field of the struct is
  /// from the set:
  ///   	- kAAFCompNone
  /// 	- kAAFCompAlpha
  /// 	- kAAFCompBlue
  /// 	- kAAFCompFill
  /// 	- kAAFCompGreen
  /// 	- kAAFCompPalette
  /// 	- kAAFCompRed
  ///
  /// The 'Size' field of the struct is the component size in bits.
  /// 
  /// If you Get more entries than were set, the extra entries will be padded with kAAFCompNone and a size of zero.
  ///
  /// If this method fails, PixelLayoutArray will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumberElements or PixelLayoutArray or PixelStructureArray is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - numberElements indicates that the array is too small to hold
  ///     the data.
  ///
  /// @param numberElements [in] The number of elements in the array
  /// @param PixelLayoutArray [out, size_is(numberElements)] Array to hold up to 8 aafRGBAComponent_t indicating component order and size.
  ///
  STDMETHOD(GetPixelLayout) (THIS_
    aafUInt32  numberElements,
    aafRGBAComponent_t*  PixelLayoutArray) PURE;

  //***********************************************************
  //
  // SetPalette()
  //
  /// Sets the palette property.  The palette must be in the form specified
  /// by the palette layout and palette structure parameters.
  /// 
  /// Succeeds if all of the following are true:
  /// - pPalette is a valid pointer
  /// 
  /// If this method fails, the palette property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPalette is NULL.
  ///
  /// @param numberElements [in] The number of bytes in the array
  /// @param pPalette [in, size_is(numberElements)] Array to hold the palette information
  ///
  STDMETHOD(SetPalette) (THIS_
    aafUInt32  numberElements,
    aafUInt8*  pPalette) PURE;


  //***********************************************************
  //
  // GetPalette()
  //
  /// Sets the palette property.  The palette must be in the form specified
  /// by the palette layout and palette structure parameters.
  /// The values are written to the array specified by pPalette,
  /// which is of size numberElements.  The required size may be found
  /// by calling GetPaletteSize().
  /// 
  /// Succeeds if all of the following are true:
  /// - pPalette is a valid pointer.
  /// - numberElements indicates the array is large enough to hold the
  ///   data.
  /// 
  /// If this method fails, pPalette will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumberElements is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - numberElements indicates that the array is too small to hold
  ///     the data.
  ///
  /// @param numberRecords [in] The number of bytes in the array
  /// @param pPalette [out, size_is(numberRecords)] Array to hold the palette information
  ///
  STDMETHOD(GetPalette) (THIS_
    aafUInt32  numberRecords,
    aafUInt8*  pPalette) PURE;


  //***********************************************************
  //
  // GetPaletteSize()
  //
  /// Get the number of bytes in the VideoLineMap property array.
  /// 
  /// Succeeds if all of the following are true:
  /// - pNumberBytes is a valid pointer
  /// 
  /// If this method fails, *pNumberBytes will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumberBytes is NULL.
  ///
  /// @param pNumberBytes [out] The number of bytes in the array
  ///
  STDMETHOD(GetPaletteSize) (THIS_
    aafUInt32 *  pNumberBytes) PURE;

  //***********************************************************
  //
  // CountPaletteLayoutElements()
  //
  /// This function returns the number of components in a pixel.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails no state is changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  ///
  /// @param pResult [out] Number of components
  ///
  STDMETHOD(CountPaletteLayoutElements) (THIS_
    aafUInt32 *  pResult) PURE;

  //***********************************************************
  //
  // SetPaletteLayout()
  //
  /// Sets the layout and structure of the components in a single pixel.
  /// The layout array is an Array of 8 aafRGBAComponent_t.  The 'Code' field of the struct is
  /// from the set:
  ///   	- kAAFCompNone
  /// 	- kAAFCompAlpha
  /// 	- kAAFCompBlue
  /// 	- kAAFCompFill
  /// 	- kAAFCompGreen
  /// 	- kAAFCompPalette
  /// 	- kAAFCompRed
  ///
  /// The 'Size' field of the struct is the component size in bits.
  /// 
  /// If you set less than 8 entries, the remaining entries will be padded with kAAFCompNone and a size of zero.
  /// If this method fails the PaletteLayout property will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param numberElements [in] The number of elements in the array
  /// @param PaletteLayoutArray [in] Array of up to 8 bytes indicating component size, matching layout, and terminated by a zero byte.
  ///
  STDMETHOD(SetPaletteLayout) (THIS_
    aafUInt32  numberElements,
    aafRGBAComponent_t*  PaletteLayoutArray) PURE;

  //***********************************************************
  //
  // GetPaletteLayout()
  //
  /// The layout array is an Array of 8 aafRGBAComponent_t.  The 'Code' field of the struct is
  /// from the set:
  ///   	- kAAFCompNone
  /// 	- kAAFCompAlpha
  /// 	- kAAFCompBlue
  /// 	- kAAFCompFill
  /// 	- kAAFCompGreen
  /// 	- kAAFCompPalette
  /// 	- kAAFCompRed
  ///
  /// The 'Size' field of the struct is the component size in bits.
  /// 
  /// If you Get more entries than were set, the extra entries will be padded with kAAFCompNone and a size of zero.
  ///
  /// If this method fails, PaletteLayoutArray will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumberElements or PaletteLayoutArray is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - numberElements indicates that the array is too small to hold
  ///     the data.
  ///
  /// @param numberElements [in] The number of elements in each array
  /// @param PaletteLayoutArray [out, size_is(numberElements)] Array to hold 8 aafRGBAComponent_t indicating component order and size.
  ///
  STDMETHOD(GetPaletteLayout) (THIS_
    aafUInt32  numberElements,
    aafRGBAComponent_t*  PaletteLayoutArray) PURE;













  END_INTERFACE
};
#endif // __IAAFRGBADescriptor_INTERFACE_DEFINED__


// IAAFRandomFile

// ************************
//
// Interface IAAFRandomFile
//
// ************************





#ifndef __IAAFRandomFile_INTERFACE_DEFINED__
#define __IAAFRandomFile_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFRandomFile;

#undef  INTERFACE
#define INTERFACE   IAAFRandomFile

DECLARE_INTERFACE_(IAAFRandomFile, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFRandomFile methods *** */

  //***********************************************************
  //
  // GetFileBits()
  //
  /// Since the purpose of this method is to obtain file data after a
  /// file has been created, it will only succeed if this file has
  /// already been Open()ed and then Close()d, or if it was never
  /// opened with write access.
  /// 
  /// Succeeds if:
  /// - The ppGetFileBits argument is valid
  /// - This file has been opened for write or modify, and has been
  ///   subsequently closed.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppGetFileBits arg is NULL.
  ///
  /// AAFRESULT_BADOPEN
  /// - This file has never been opened
  ///
  /// AAFRESULT_NOT_WRITEABLE
  /// - This file has never been opened for write or modify
  ///
  /// AAFRESULT_BADCLOSE
  /// - This file has not been closed after being opened.
  ///
  /// @param ppGetFileBits [out] The interface to the GetFileBits object
  ///
  STDMETHOD(GetFileBits) (THIS_
    IAAFGetFileBits ** ppGetFileBits) PURE;


  //***********************************************************
  //
  // Revert()
  //
  /// Reverts this file to the previously-saved state.
    /// NOTE! Stub only.   Implementation not yet added.
  ///

  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Revert) (THIS) PURE;


  //***********************************************************
  //
  // SaveAsFile()
  //
  /// Associates this file with the storage specified in pDestFile.
  /// Any objects contained in pDestFile will be lost.
  /// 
  /// Behaves in a manner similar to SaveCopyAs(), except that
  /// SaveAs() will change this object to be associated with the new
  /// file.
  /// 
  /// Special case: if f->SaveAs(f) is called, passing this as the
  /// save-to argument, the operation will save everything including
  /// things which have not changed.
    /// NOTE! Stub only.   Implementation not yet added.
  ///

  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param pDestFile [in] The destination file into which the contents of this file are to
  /// be written.
  ///
  STDMETHOD(SaveAsFile) (THIS_
    IAAFFile * pDestFile) PURE;


  //***********************************************************
  //
  // SetFileBits()
  //
  /// Since the purpose of this method is to specify file data with
  /// which a file is to be created, it will only succeed if this file
  /// has not yet been Open()ed.
  ///
  /// Succeeds if:
  /// - The ppSetFileBits argument is valid
  /// - This file has not yet been opened.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppSetFileBits arg is NULL.
  ///
  /// AAFRESULT_BADOPEN
  /// - This file has has already been opened
  ///
  /// AAFRESULT_NOT_READABLE
  /// - This read or modify has not been specified for this file
  ///
  /// @param ppSetFileBits [out] The interface to the SetFileBits object
  ///
  STDMETHOD(SetFileBits) (THIS_
    IAAFSetFileBits ** ppSetFileBits) PURE;

  END_INTERFACE
};
#endif // __IAAFRandomFile_INTERFACE_DEFINED__



// IAAFRandomRawStorage

// ************************
//
// Interface IAAFRandomRawStorage
//
// ************************



#ifndef __IAAFRandomRawStorage_INTERFACE_DEFINED__
#define __IAAFRandomRawStorage_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFRandomRawStorage;

#undef  INTERFACE
#define INTERFACE   IAAFRandomRawStorage

DECLARE_INTERFACE_(IAAFRandomRawStorage, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFRandomRawStorage methods *** */

  //***********************************************************
  //
  // ReadAt()
  //
  /// Attempts to read bufsize bytes from this storage.  Places the
  /// data into buf, and puts the actual number of bytes read into
  /// *pNumRead.  If the end of the storage is encountered before
  /// bufSize bytes can be read, the value written into *pNumRead may
  /// be smaller than bufSize.
  ///
  /// This call will advance the current position by *pNumRead bytes.
  ///
  /// Succeeds if:
  /// - The pNumRead pointer is valid.
  /// - This storage is open for read or read/write.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - buf or pNumRead arg is NULL.
  ///
  /// AAFRESULT_NOT_READABLE
  ///   - This storage is not open for read or read/write.
  ///
  /// @param position [in] position in this storage from which data is read
  /// @param buf [out, size_is(bufSize), length_is(*pNumRead)] Buffer into which data is read
  /// @param bufSize [in] Size of buf in bytes
  /// @param pNumRead [out] Number of bytes read
  ///
  STDMETHOD(ReadAt) (THIS_
    aafUInt64  position,
    aafMemPtr_t  buf,
    aafUInt32  bufSize,
    aafUInt32 *  pNumRead) PURE;


  //***********************************************************
  //
  // WriteAt()
  //
  /// Writes bufsize bytes into this storage.  Obtains the data
  /// from buf.
  ///
  /// This call may fail if the capacity of this storage cannot be
  /// extended sufficiently to complete the request.  The client can
  /// call SetSize() to attempt to reserve capacity for the storage;
  /// if the SetSize() call succeeds, subsequent Write() calls
  /// within requested that capacty are guaranteed to succeed.
  ///
  /// This call will advance the current position by bufSize bytes.
  ///
  /// Succeeds if:
  /// - The pNumWritten pointer is valid.
  /// - This storage is open for write or read/write.
  /// - Sufficient capacity exists in this storage to perform the
  ///   write.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumWritten arg is NULL.
  ///
  /// AAFRESULT_NOT_WRITEABLE
  ///   - This storage is not open for write or read/write.
  ///
  /// AAFRESULT_OFFSET_SIZE
  ///   - It is not possible to extend the allocated size of this
  ///     storage.
  ///
  /// @param position [in] position in this storage into which data is written
  /// @param buf [in, size_is(bufSize)] Buffer from which data is written
  /// @param bufSize [in] Number of bytes
  /// @param pNumWritten [out] Number of bytes written
  ///
  STDMETHOD(WriteAt) (THIS_
    aafUInt64  position,
    aafMemConstPtr_t  buf,
    aafUInt32  bufSize,
    aafUInt32 *  pNumWritten) PURE;


  //***********************************************************
  //
  // GetSize()
  //
  /// Returns the highest byte position in this storage which has been
  /// written so far.
  ///
  /// Succeeds if:
  /// - The pSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSize arg is NULL.
  ///
  /// @param pSize [out] Number of bytes currently in this storage
  ///
  STDMETHOD(GetSize) (THIS_
    aafUInt64 *  pSize) PURE;


  //***********************************************************
  //
  // IsExtendable()
  //
  /// Sets *pResult to true if the memory allocated to this storage can
  /// be dynamically extened; sets it to false otherwise.
  ///
  /// Succeeds if:
  /// - The pResult pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult arg is NULL.
  ///
  /// @param pResult [out] set to true if extendable
  ///
  STDMETHOD(IsExtendable) (THIS_
    aafBoolean_t *  pResult) PURE;


  //***********************************************************
  //
  // GetExtent()
  //
  /// Returns the number of bytes currently allocated storage.
  ///
  /// Succeeds if:
  /// - The pSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pExtent arg is NULL.
  ///
  /// @param pExtent [out] Number of bytes currently allocated for this storage
  ///
  STDMETHOD(GetExtent) (THIS_
    aafUInt64 *  pExtent) PURE;


  //***********************************************************
  //
  // SetExtent()
  //
  /// Requests the given capacity for this storage.  If successful,
  /// subsequent calls to WriteAt() and IAAFRawStorage::Write()
  /// within that capacity are guaranteed to succeed.
  ///
  /// Succeeds if:
  /// - It is permissible to set the extent of this storage.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_OFFSET_SIZE
  ///   - This storage has insufficient capacity to perform the write.
  ///
  /// @param extent [in] Number of bytes capacity requested for this storage
  ///
  STDMETHOD(SetExtent) (THIS_
    aafUInt64  extent) PURE;

  END_INTERFACE
};
#endif // __IAAFRandomRawStorage_INTERFACE_DEFINED__



// IAAFRawStorage

// ************************
//
// Interface IAAFRawStorage
//
// ************************



#ifndef __IAAFRawStorage_INTERFACE_DEFINED__
#define __IAAFRawStorage_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFRawStorage;

#undef  INTERFACE
#define INTERFACE   IAAFRawStorage

DECLARE_INTERFACE_(IAAFRawStorage, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFRawStorage methods *** */

  //***********************************************************
  //
  // IsReadable()
  //
  /// Sets *pResult to true if this storage is readable; sets it to
  /// false otherwise.
  ///
  /// Succeeds if:
  /// - The pResult pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult arg is NULL.
  ///
  /// @param pResult [out] set to true if readable
  ///
  STDMETHOD(IsReadable) (THIS_
    aafBoolean_t *  pResult) PURE;


  //***********************************************************
  //
  // Read()
  //
  /// Attempts to read bufsize bytes from this stream.  Places the data
  /// into buf, and puts the actual number of bytes read into
  /// *pNumRead.  If the end of the stream is encountered before
  /// bufSize bytes can be read, the value written into *pNumRead may
  /// be smaller than bufSize.
  ///
  /// This call will advance the current position by *pNumRead bytes.
  ///
  /// Succeeds if:
  /// - The pNumBytes pointer is valid.
  /// - This stream is open for read or read/write.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - buf or pNumRead arg is NULL.
  ///
  /// AAFRESULT_NOT_READABLE
  ///   - This stream is not open for read or read/write.
  ///
  /// @param buf [out, size_is(bufSize), length_is(*pNumRead)] Buffer into which data is read
  /// @param bufSize [in] Size of buf in bytes
  /// @param pNumRead [out] Number of bytes read
  ///
  STDMETHOD(Read) (THIS_
    aafMemPtr_t  buf,
    aafUInt32  bufSize,
    aafUInt32 *  pNumRead) PURE;


  //***********************************************************
  //
  // IsWriteable()
  //
  /// Sets *pResult to true if this storage is writeable; sets it to
  /// false otherwise.
  ///
  /// Succeeds if:
  /// - The pResult pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult arg is NULL.
  ///
  /// @param pResult [out] set to true if writeable
  ///
  STDMETHOD(IsWriteable) (THIS_
    aafBoolean_t *  pResult) PURE;


  //***********************************************************
  //
  // Write()
  //
  /// Writes bufsize bytes into this stream.  Obtains the data
  /// from buf.
  ///
  /// This call may fail if the stream has insufficient capacity to
  /// complete the request.  If this storage supports the
  /// IAAFRandomRawStorage interface, the client can call
  /// IAAFRandomRawStorage::SetSize() to attempt to reserve capacity
  /// in the stream; if the SetSize() call succeeds, subsequent
  /// Write() calls within that capacity are guaranteed to succeed.
  ///
  /// This call will advance the current position by bufSize bytes.
  ///
  /// Succeeds if:
  /// - This stream is open for write or read/write.
  /// - Sufficient capacity exists in this stream to perform the
  ///   write.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_WRITEABLE
  ///   - This stream is not open for write or read/write.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - This stream has insufficient capacity to perform the write.
  ///
  /// @param buf [in, size_is(bufSize)] Buffer from which data is written
  /// @param bufSize [in] Number of bytes to write
  /// @param pNumWritten [out] Number of bytes written
  ///
  STDMETHOD(Write) (THIS_
    aafMemConstPtr_t  buf,
    aafUInt32  bufSize,
    aafUInt32 *  pNumWritten) PURE;


  //***********************************************************
  //
  // Synchronize()
  //
  /// Synchronizes any cached data with the underlying storage.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Synchronize) (THIS) PURE;

  END_INTERFACE
};
#endif // __IAAFRawStorage_INTERFACE_DEFINED__



// IAAFRIFFChunk

// ************************
//
// Interface IAAFRIFFChunk
//
// ************************





#ifndef __IAAFRIFFChunk_INTERFACE_DEFINED__
#define __IAAFRIFFChunk_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFRIFFChunk;


#undef  INTERFACE
#define INTERFACE   IAAFRIFFChunk

DECLARE_INTERFACE_(IAAFRIFFChunk, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFRIFFChunk methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty
  /// IAAFRIFFChunk-supporting object. The data content is initially
  /// empty.
  ///
  /// This method must be called after allocation, and before any other
  /// method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// @param chunkID [in] ChunkID value
  ///
  STDMETHOD(Initialize) (THIS_
    aafUInt32  chunkID) PURE;


  //***********************************************************
  //
  // SetChunkID()
  //
  /// Sets the ChunkID property.
                        
  ///
  /// Succeeds if all of the following are true:
  /// - This object has already been had Initialize() called on it.
  ///
  /// If this method fails, the ChunkID property will not be
  /// changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param chunkID [in] ChunkID to set
  ///
  STDMETHOD(SetChunkID) (THIS_
    aafUInt32  chunkID) PURE;

  //***********************************************************
  //
  // GetChunkID()
  //
  /// Gets the ChunkID property.
  ///
  ///
  /// Succeeds if all of the following are true:
  /// - pChunkID is a valid pointer
  ///
  /// If this method fails, pChunkID will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pChunkID is NULL.
  ///
  /// @param pChunkID [out] Retrieved ChunkID
  ///
  STDMETHOD(GetChunkID) (THIS_
    aafUInt32 *  pChunkID) PURE;


  //***********************************************************
  //
  // Read()
  //
  /// Reads data from this RIFFChunk at the current position. Advances the position by the number of bytes read.
  ///
  /// @param bytes [in] read this many bytes
  /// @param buffer [out, size_is(bytes), length_is(*pBytesRead)] buffer to receive chunk data
  /// @param pBytesRead [out,ref] 
  ///
  STDMETHOD(Read) (THIS_
    aafUInt32  bytes,
    aafDataBuffer_t  buffer,
    aafUInt32 *  pBytesRead) PURE;


  //***********************************************************
  //
  // Write()
  //
  /// Write data to this RIFFChunk at the current position. Advances the position
/// by the number of bytes written. Any data beyond the new position is lost; 
///that is, the buffer is truncated.
  ///
  /// @param bytes [in] write this many bytes
  /// @param buffer [out, size_is(bytes)] chunk data to write
  /// @param pBytesWritten [out,ref] actual number of bytes written
  ///
  STDMETHOD(Write) (THIS_
    aafUInt32  bytes,
    aafDataBuffer_t  buffer,
    aafUInt32 *  pBytesWritten) PURE;


  //***********************************************************
  //
  // SetPosition()
  //
  /// Seeks to absolute position within the RIFFChunk data. The next Read or Write
/// call will operate from the given position.
  ///
  /// @param offset [in] offset from beginning of the RIFFChunk data
  ///
  STDMETHOD(SetPosition) (THIS_
    aafPosition_t  offset) PURE;


  //***********************************************************
  //
  // GetPosition()
  //
  /// Gets the current position within the RIFFChunk data. This is the position at
///which the next Read or Write call will operate.
  ///
  /// @param pOffset [out] current offset from beginning of the RIFFChunk data
  ///
  STDMETHOD(GetPosition) (THIS_
    aafPosition_t*  pOffset) PURE;


  //***********************************************************
  //
  // GetLength()
  //
  /// Returns the total size of the RIFFChunk data, in bytes.
  ///
  /// @param pLength [out] length of the RIFFChunk data
  ///
  STDMETHOD(GetLength) (THIS_
    aafLength_t *  pLength) PURE;



  END_INTERFACE
};
#endif // __IAAFRIFFChunk_INTERFACE_DEFINED__



// IAAFRecordingDescriptor

// ************************
//
// Interface IAAFRecordingDescriptor
//
// ************************






#ifndef __IAAFRecordingDescriptor_INTERFACE_DEFINED__
#define __IAAFRecordingDescriptor_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFRecordingDescriptor;


#undef  INTERFACE
#define INTERFACE   IAAFRecordingDescriptor

DECLARE_INTERFACE_(IAAFRecordingDescriptor, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFRecordingDescriptor methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty
  /// IAAFRecordingDescriptor object.  This method must be called
  /// after allocation, and before any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  STDMETHOD(Initialize) (THIS) PURE;


  END_INTERFACE
};
#endif // __IAAFRecordingDescriptor_INTERFACE_DEFINED__



// IAAFScopeReference

// ************************
//
// Interface IAAFScopeReference
//
// ************************




#ifndef __IAAFScopeReference_INTERFACE_DEFINED__
#define __IAAFScopeReference_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFScopeReference;

#undef  INTERFACE
#define INTERFACE   IAAFScopeReference

DECLARE_INTERFACE_(IAAFScopeReference, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFScopeReference methods *** */

  //***********************************************************
  //
  // Create()
  //
  /// Constructs a Scope Reference object.
  /// 
  /// If this method fails the length property will not be
  /// changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param RelativeScope [in] Number of nested scopes to pass to find the Nested Scope slot
  /// @param RelativeSlot [in] Number of slots to look backwards from the slot containing the
  /// Scope Reference
  ///
  STDMETHOD(Create) (THIS_
    aafUInt32  RelativeScope,
    aafUInt32  RelativeSlot) PURE;

  //***********************************************************
  //
  // Initialize()
  //
  /// Constructs a Scope Reference object.
  /// 
  /// If this method fails the length property will not be
  /// changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param pDataDef [in] Data definition for referenced slot
  /// @param RelativeScope [in] Number of nested scopes to pass to find the Nested Scope slot
  /// @param RelativeSlot [in] Number of slots to look backwards from the slot containing the
  /// Scope Reference
  ///
  STDMETHOD(Initialize) (THIS_
    IAAFDataDef * pDataDef,
    aafUInt32  RelativeScope,
    aafUInt32  RelativeSlot) PURE;

  //***********************************************************
  //
  // GetRelativeScope()
  //
  /// Gets the number of nested scopes to pass to find the Nested Scope
  /// slot.
  ///	
  /// Succeeds if all of the following are true:
  /// - the pnRelativeScope pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pnRelativeScope.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pnRelativeScope arg is NULL.
  ///
  /// @param pnRelativeScope [retval][out] Pointer to a Relative Scope
  ///
  STDMETHOD(GetRelativeScope) (THIS_
    aafUInt32 *  pnRelativeScope) PURE;


  //***********************************************************
  //
  // GetRelativeSlot()
  //
  /// Gets the number of slots that preced the slot containing the
  /// Scope Reference. 
  ///	
  /// Succeeds if all of the following are true:
  /// - the pnRelativeScope pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pnRelativeSlot.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pnRelativeSlot arg is NULL.
  ///
  /// @param pnRelativeSlot [retval][out] Pointer to a Relative Slot
  ///
  STDMETHOD(GetRelativeSlot) (THIS_
    aafUInt32 *  pnRelativeSlot) PURE;

  END_INTERFACE
};
#endif // __IAAFScopeReference_INTERFACE_DEFINED__



// IAAFSegment

// ************************
//
// Interface IAAFSegment
//
// ************************



#ifndef __IAAFSegment_INTERFACE_DEFINED__
#define __IAAFSegment_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFSegment;

#undef  INTERFACE
#define INTERFACE   IAAFSegment

DECLARE_INTERFACE_(IAAFSegment, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFSegment methods *** */

  //***********************************************************
  //
  // SegmentOffsetToTC()
  //
  /// Converts the given Segment offset to timecode.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pOffset pointer is valid.
  /// - the pTimeCode pointer is valid.
  /// 
  /// If this method fails the value of pTimecode is left unchanged.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - any arg is NULL.
  ///
  /// AAFRESULT_TIMECODE_NOT_FOUND
  ///   - the given offset is not available in this segment.
  ///
  /// @param pOffset [in] Pointer to a Segment Offset to be convert to Timecode
  /// @param pTimecode [out] The converted timecode to be returned
  ///
  STDMETHOD(SegmentOffsetToTC) (THIS_
    aafPosition_t *  pOffset,
    aafTimecode_t *  pTimecode) PURE;


  //***********************************************************
  //
  // SegmentTCToOffset()
  //
  /// Converts the given Timecode to an Offset.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pTimeCode pointer is valid.
  /// - the pEditRate pointer is valid
  /// - the pFrameOffset pointer is valid.
  /// 
  /// If this method fails the value of pOffset is left unchanged.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - any arg is NULL.
  ///
  /// AAFRESULT_TIMECODE_NOT_FOUND
  ///   - the given timecode is not available in this segment.
  ///
  /// @param pTimecode [in] Pointer to a timecode to be converted to Offset
  /// @param pEditRate [in] The edit rate for the given timecode 
  /// @param pOffset [out] Frame Offset to be returned if found
  ///
  STDMETHOD(SegmentTCToOffset) (THIS_
    aafTimecode_t *  pTimecode,
    aafRational_t *  pEditRate,
    aafFrameOffset_t *  pOffset) PURE;

  END_INTERFACE
};
#endif // __IAAFSegment_INTERFACE_DEFINED__



// IAAFSelector

// ************************
//
// Interface IAAFSelector
//
// ************************





#ifndef __IAAFSelector_INTERFACE_DEFINED__
#define __IAAFSelector_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFSelector;

#undef  INTERFACE
#define INTERFACE   IAAFSelector

DECLARE_INTERFACE_(IAAFSelector, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFSelector methods *** */

  //***********************************************************
  //
  // GetSelectedSegment()
  //
  /// Places the Selected Segment object in this Selector into the
  /// *ppSelSegment argument.  If none exists yet, NULL is placed into
  /// the *ppSelSegment argument.
  ///
  /// The returned essence descriptor object, if it exists, is
  /// AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppSelSegment pointer is valid.
  /// - A valid segment exists.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppSelSegment is null.
  ///
  /// @param ppSelSegment [out] Returned the selected Segment object
  ///
  STDMETHOD(GetSelectedSegment) (THIS_
    IAAFSegment ** ppSelSegment) PURE;


  //***********************************************************
  //
  // SetSelectedSegment()
  //
  /// Sets the Selected segment.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSelSegment pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSelSegment is null.
  ///
  /// @param pSelSegment [in] A Segment object
  ///
  STDMETHOD(SetSelectedSegment) (THIS_
    IAAFSegment * pSelSegment) PURE;


  //***********************************************************
  //
  // AppendAlternateSegment()
  //
  /// This function appends the input segment to the alternate segment
  /// list, the alternate list of segments represents unused
  /// alternative segments. 
  ///
  /// This method will AddRef() the segment if it succeeds.
  ///
  /// If the segment is successfully appended to the set of
  /// alternates, the reference count of the segment is incremented.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the pSegment pointer is valid.
  /// 
  /// If this method fails no state is changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSegment is null.
  ///
  /// @param pSegment [in] Segment to append to the Alternate list of segments
  ///
  STDMETHOD(AppendAlternateSegment) (THIS_
    IAAFSegment * pSegment) PURE;


  //***********************************************************
  //
  // GetNumAlternateSegments()
  //
  /// This function returns the number of segments in the set.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the pNumSegments pointer is valid.
  /// 
  /// If this method fails no state is changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumSegments is null.
  ///
  /// @param pNumSegments [out] Number of Alternate Segments
  ///
  STDMETHOD(GetNumAlternateSegments) (THIS_
    aafInt32 *  pNumSegments) PURE;


  //***********************************************************
  //
  // EnumAlternateSegments()
  //
  /// Places an IEnumAAFSegments enumerator for the alterante segments
  /// contained in the selector into the *ppEnum argument.
  /// 
  /// The returned enumerator is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// E_FAIL
  ///   - Failed to create the enumerator.
  ///
  /// @param ppEnum [out, retval] Segment Enumeration
  ///
  STDMETHOD(EnumAlternateSegments) (THIS_
    IEnumAAFSegments ** ppEnum) PURE;

  //***********************************************************
  //
  // RemoveAlternateSegment()
  //
  /// Removes the given Segment from the selector.
  ///
  /// Succeeds if all of the following are true:
  /// - the v pointer is valid.
  /// - the given segment is currently in the collection.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEssenceData is null.
  ///
  /// AAFRESULT_SEGMENT_NOT_FOUND
  ///   - the given segment is not already contained.
  ///
  /// @param pSegment [in] Segment to remove
  ///
  STDMETHOD(RemoveAlternateSegment) (THIS_
    IAAFSegment * pSegment) PURE;


  END_INTERFACE
};
#endif // __IAAFSelector_INTERFACE_DEFINED__



// IAAFSequence

// ************************
//
// Interface IAAFSequence
//
// ************************








#ifndef __IAAFSequence_INTERFACE_DEFINED__
#define __IAAFSequence_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFSequence;

#undef  INTERFACE
#define INTERFACE   IAAFSequence

DECLARE_INTERFACE_(IAAFSequence, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFSequence methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// This function sets the properties on a newly created sequence
  /// object with the given property values. The length of the sequence
  /// is initially set to 0.  When components are appended to the
  /// sequence with the AppendComponent() call, the length of the
  /// appended component is added to the length of the sequence.  The
  /// given DataDef specifies the kind of data which all components to
  /// be contained in this sequence must share.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has not yet been initialized.
  /// 
  /// If this method fails no state is changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDataDef is null.
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// @param pDataDef [in] DataDef of this object
  ///
  STDMETHOD(Initialize) (THIS_
    IAAFDataDef * pDataDef) PURE;


  //***********************************************************
  //
  // AppendComponent()
  //
  /// This function appends the input component to the given sequence,
  /// enforcing bottom up creation of mobs.  The length of the sequence
  /// is incremented by the size of the component, unless the
  /// component is a transition.  If the component is a transition, it
  /// verifies that it is not the first object in a transition, and
  /// that it is not neighboring another transition.  It also verifies
  /// that there is enough source material on either side of the
  /// transition.  The function also verifies that the datadefs are
  /// compatible.
  ///
  /// This method will AddRef() the component if it succeeds.
  ///
  /// If the component is successfully appended to the sequence, the
  /// reference count of the component is incremented.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the pComponent pointer is valid.
  /// 
  /// If this method fails no state is changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pComponent is null.
  ///
  /// AAFRESULT_INVALID_DATADEF
  ///   - The data kind of the component is not compatible with the 
  ///     data def of the sequence.
  ///
  /// AAFRESULT_LEADING_TRAN
  ///   - Attempted to append a transition as the first component of
  ///     a sequence.  A sequence can not start with a transition. 
  ///
  /// AAFRESULT_ADJACENT_TRAN
  ///   - Attempted to append a transition next to a transition.  A
  ///     sequence can not contain back to back transitions.
  ///
  /// AAFRESULT_INSUFF_TRAN_MATERIAL
  ///   - There is not enough source material to add this component.
  ///
  /// @param pComponent [in] Component to append to the sequence
  ///
  STDMETHOD(AppendComponent) (THIS_
    IAAFComponent * pComponent) PURE;


  //***********************************************************
  //
  // PrependComponent()
  //
  /// This function prepends the input component to the given
  /// sequence, enforcing bottom up creation of mobs.  The length of
  /// the sequence is incremented by the size of the component, unless
  /// the component is a transition.  If the component is a
  /// transition, it verifies that it is not the first object in a
  /// transition, and that it is not neighboring another transition.
  /// It also verifies that there is enough source material on either
  /// side of the transition.  The function also verifies that the
  /// datadefs are compatible.
  ///
  /// This method will AddRef() the component if it succeeds.
  ///
  /// If the component is successfully appended to the sequence, the
  /// reference count of the component is incremented.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the pComponent pointer is valid.
  /// 
  /// If this method fails no state is changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pComponent is null.
  ///
  /// AAFRESULT_INVALID_DATADEF
  ///   - The data kind of the component is not compatible with the 
  ///     data def of the sequence.
  ///
  /// AAFRESULT_LEADING_TRAN
  ///   - Attempted to append a transition as the first component of
  ///     a sequence.  A sequence can not start with a transition. 
  ///
  /// AAFRESULT_ADJACENT_TRAN
  ///   - Attempted to append a transition next to a transition.  A
  ///     sequence can not contain back to back transitions.
  ///
  /// AAFRESULT_INSUFF_TRAN_MATERIAL
  ///   - There is not enough source material to add this component.
  ///
  /// @param pComponent [in] Component to prepend to the sequence
  ///
  STDMETHOD(PrependComponent) (THIS_
    IAAFComponent * pComponent) PURE;


  //***********************************************************
  //
  // InsertComponentAt()
  //
  /// This function inserts the input component into the given sequence
  /// at the given index, enforcing bottom up creation of mobs.  The
  /// length of the sequence is incremented by the size of the
  /// component, unless the component is a transition.  If the
  /// component is a transition, it verifies that it is not the first
  /// object in a transition, and that it is not neighboring another
  /// transition.  It also verifies that there is enough source
  /// material on either side of the transition.  The function also
  /// verifies that the datadefs are compatible.
  ///
  /// This method will AddRef() the component if it succeeds.
  ///
  /// If the component is successfully appended to the sequence, the
  /// reference count of the component is incremented.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the pComponent pointer is valid.
  /// - index is less than or equal to the value returned by
  ///   CountComponents().
  /// 
  /// If this method fails no state is changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pComponent is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than the value returned by
  ///     CountComponents().
  ///
  /// AAFRESULT_INVALID_DATADEF
  ///   - The data kind of the component is not compatible with the 
  ///     data def of the sequence.
  ///
  /// AAFRESULT_LEADING_TRAN
  ///   - Attempted to append a transition as the first component of
  ///     a sequence.  A sequence can not start with a transition. 
  ///
  /// AAFRESULT_ADJACENT_TRAN
  ///   - Attempted to append a transition next to a transition.  A
  ///     sequence can not contain back to back transitions.
  ///
  /// AAFRESULT_INSUFF_TRAN_MATERIAL
  ///   - There is not enough source material to add this component.
  ///
  /// @param index [in] index to insert component
  /// @param pComponent [in] Component to insert into the sequence
  ///
  STDMETHOD(InsertComponentAt) (THIS_
    aafUInt32  index,
    IAAFComponent * pComponent) PURE;


  //***********************************************************
  //
  // GetComponentAt()
  //
  /// This function retrieves the input component at the given index in
  /// the given sequence.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the ppComponent pointer is valid.
  /// - index is less than the value returned by
  ///   CountComponents().
  /// 
  /// If this method fails nothing will be written to *ppComponent.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pComponent is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than or equal to the value returned by
  ///     CountComponents().
  ///
  /// @param index [in] index of component to retrieve
  /// @param ppComponent [out, retval] Retrieved component
  ///
  STDMETHOD(GetComponentAt) (THIS_
    aafUInt32  index,
    IAAFComponent ** ppComponent) PURE;


  //***********************************************************
  //
  // RemoveComponentAt()
  //
  /// This function removes the input component at the given index in
  /// the given sequence.  Components already existing at indices
  /// higher than the given index will be moved to the next lower index
  /// to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - index is less than the value returned by
  ///   CountComponents().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than or equal to the value returned by
  ///     CountComponents().
  ///
  /// @param index [in] index of component to remove
  ///
  STDMETHOD(RemoveComponentAt) (THIS_
    aafUInt32  index) PURE;


  //***********************************************************
  //
  // CountComponents()
  //
  /// This function returns the number of components in the sequence.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails no state is changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  ///
  /// @param pResult [out] Number of components
  ///
  STDMETHOD(CountComponents) (THIS_
    aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // GetComponents()
  //
  /// Places an IEnumAAFComponents enumerator for the components
  /// contained in the sequence into the *ppEnum argument.
  /// 
  /// The returned enumerator is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// E_FAIL
  ///   - Failed to create the enumerator.
  ///
  /// @param ppEnum [out, retval] Component Enumeration
  ///
  STDMETHOD(GetComponents) (THIS_
    IEnumAAFComponents ** ppEnum) PURE;







  END_INTERFACE
};
#endif // __IAAFSequence_INTERFACE_DEFINED__



// IAAFSetFileBits

// ************************
//
// Interface IAAFSetFileBits
//
// ************************



#ifndef __IAAFSetFileBits_INTERFACE_DEFINED__
#define __IAAFSetFileBits_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFSetFileBits;

#undef  INTERFACE
#define INTERFACE   IAAFSetFileBits

DECLARE_INTERFACE_(IAAFSetFileBits, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFSetFileBits methods *** */

  //***********************************************************
  //
  // WriteAt()
  //
  /// Writes bufsize bytes into this file at the given byte offset.
  /// Obtains the data from buf.  A value of zero for position
  /// indicates the beginning of the stream.
  ///
  /// Succeeds if sufficient space is available in the file to write
  /// the given number of bytes at the given position.  It's possible
  /// to guarantee that this method will succeed if SetSize() is first
  /// called to reserve the required space.  If SetSize() is not first
  /// called to reserve the space, this method will attempt to request
  /// it, but this attempt may fail.
  ///
  /// Succeeds if:
  /// - The buf argument is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - buf arg is NULL.
  ///
  /// AAFRESULT_DATA_SIZE
  ///   - The requested space is not available.
  ///
  /// @param buf [in, size_is(bufSize)] Buffer from which data is written
  /// @param bufSize [in] Number of bytes
  /// @param position [in] The position in bytes at which to read
  ///
  STDMETHOD(WriteAt) (THIS_
    aafMemPtr_t  buf,
    aafUInt32  bufSize,
    aafUInt64  position) PURE;


  //***********************************************************
  //
  // SetSize()
  //
  /// Attempts to reserve size bytes of storage.
  ///
  /// Succeeds if:
  /// - The requested space is available.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_DATA_SIZE
  ///   - size bytes are not available.
  ///
  /// @param size [in] The requested file size
  ///
  STDMETHOD(SetSize) (THIS_
    aafUInt64  size) PURE;

  END_INTERFACE
};
#endif // __IAAFSetFileBits_INTERFACE_DEFINED__



// IAAFSoundDescriptor

// ************************
//
// Interface IAAFSoundDescriptor
//
// ************************



#ifndef __IAAFSoundDescriptor_INTERFACE_DEFINED__
#define __IAAFSoundDescriptor_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFSoundDescriptor;

#undef  INTERFACE
#define INTERFACE   IAAFSoundDescriptor

DECLARE_INTERFACE_(IAAFSoundDescriptor, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFSoundDescriptor methods *** */

  //***********************************************************
  //
  // SetCompression()
  //
  /// Sets the kind of compression and format of compression
  /// information of the sound essence data. This property is
  /// optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the Compression property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param compression [in] Identifies kind of compression and format of
  /// compression information.
  ///
  STDMETHOD(SetCompression) (THIS_
    aafUID_constref  compression) PURE;


  //***********************************************************
  //
  // GetCompression()
  //
  /// Gets the kind of compression and format of compression
  /// information of the sound essence data. This property is
  /// optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pCompression pointer is valid.
  /// - the property is present.
  /// 
  /// If this method fails nothing will be written to *pCompression.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCompression arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pCompression [out] Compression of the sound essence data.
  ///
  STDMETHOD(GetCompression) (THIS_
    aafUID_t *  pCompression) PURE;


  //***********************************************************
  //
  // SetChannelCount()
  //
  /// Sets the number of channels of sound represented by
  /// this descriptor. This property is required.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the Channels property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param channelCount [in] The number of channels of sound represented
  /// by this descriptor.
  ///
  STDMETHOD(SetChannelCount) (THIS_
    aafUInt32  channelCount) PURE;


  //***********************************************************
  //
  // GetChannelCount()
  //
  /// Gets the number of channels of sound represented by
  /// this descriptor. This property is required.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pChannelCount pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pChannelCount.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pChannelCount arg is NULL.
  ///
  /// @param pChannelCount [out] The number of channels of sound represented
  /// by this descriptor.
  ///
  STDMETHOD(GetChannelCount) (THIS_
    aafUInt32 *  pChannelCount) PURE;


  //***********************************************************
  //
  // SetAudioSamplingRate()
  //
  /// Sets the sample rate of audio represented by this descriptor.
  /// This property is required.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the AudioSamplingRate property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param rate [in] Sample rate of audio essence.
  ///
  STDMETHOD(SetAudioSamplingRate) (THIS_
    aafRational_t  rate) PURE;


  //***********************************************************
  //
  // GetAudioSamplingRate()
  //
  /// Gets the sample rate of audio represented by this descriptor.
  /// This property is required.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pRate pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pRate.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pRate arg is NULL.
  ///
  /// @param pRate [out] Sample rate of audio essence.
  ///
  STDMETHOD(GetAudioSamplingRate) (THIS_
    aafRational_t *  pRate) PURE;


  //***********************************************************
  //
  // SetIsLocked()
  //
  /// Sets the Locked flag which indicates whether the number of
  /// samples per frame is locked or unlocked. This property is
  /// optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the Locked property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param locked [in] Is number of samples per frame locked to video?
  ///
  STDMETHOD(SetIsLocked) (THIS_
    aafBoolean_t  locked) PURE;


  //***********************************************************
  //
  // IsLocked()
  //
  /// Gets the Locked flag which indicates whether the number of
  /// samples per frame is locked or unlocked. This property is
  /// optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pLocked pointer is valid.
  /// - the property is present.
  /// 
  /// If this method fails nothing will be written to *pLocked.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLocked arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pLocked [out] Is number of samples per frame locked to video?
  ///
  STDMETHOD(IsLocked) (THIS_
    aafBoolean_t *  pLocked) PURE;


  //***********************************************************
  //
  // SetElectroSpatialFormulation()
  //
  /// Sets the electro-spatial form of the signal. This property is
  /// optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the ElectroSpatial property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param formulation [in] Electro-spatial form of the signal.
  ///
  STDMETHOD(SetElectroSpatialFormulation) (THIS_
    aafElectroSpatialFormulation_t  formulation) PURE;


  //***********************************************************
  //
  // GetElectroSpatialFormulation()
  //
  /// Gets the electro-spatial form of the signal. This property is
  /// optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pFormulation pointer is valid.
  /// - the property is present.
  /// 
  /// If this method fails nothing will be written to *pFormulation.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFormulation arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pFormulation [out] Electro-spatial form of the signal.
  ///
  STDMETHOD(GetElectroSpatialFormulation) (THIS_
    aafElectroSpatialFormulation_t *  pFormulation) PURE;


  //***********************************************************
  //
  // SetAudioRefLevel()
  //
  /// Sets the audio reference level. This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the AudioRefLevel property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param level [in] Audio reference level.
  ///
  STDMETHOD(SetAudioRefLevel) (THIS_
    aafInt8  level) PURE;


  //***********************************************************
  //
  // GetAudioRefLevel()
  //
  /// Gets the audio reference level. This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pLevel pointer is valid.
  /// - the property is present.
  /// 
  /// If this method fails nothing will be written to *pLevel.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLevel arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pLevel [out] Audio reference level.
  ///
  STDMETHOD(GetAudioRefLevel) (THIS_
    aafInt8 *  pLevel) PURE;


  //***********************************************************
  //
  // SetDialNorm()
  //
  /// Sets the dial norm. This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the DialNorm property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param dialNorm [in] Dial norm.
  ///
  STDMETHOD(SetDialNorm) (THIS_
    aafInt8  dialNorm) PURE;


  //***********************************************************
  //
  // GetDialNorm()
  //
  /// Gets the dial norm. This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pDialNorm pointer is valid.
  /// - the property is present.
  /// 
  /// If this method fails nothing will be written to *pDialNorm.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDialNorm arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pDialNorm [out] Dial norm.
  ///
  STDMETHOD(GetDialNorm) (THIS_
    aafInt8 *  pDialNorm) PURE;


  //***********************************************************
  //
  // SetQuantizationBits()
  //
  /// Sets the number of quantization bits. This property is required.
  ///  
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// 
  /// If this method fails the QuantizationBits property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param bitsCount [in] Number of quantization bits.
  ///
  STDMETHOD(SetQuantizationBits) (THIS_
    aafUInt32  bitsCount) PURE;


  //***********************************************************
  //
  // GetQuantizationBits()
  //
  /// Gets the number of quantization bits. This property is required.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the pBitsCount pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pBitsCount.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBitsCount arg is NULL.
  ///
  /// @param pBitsCount [out] Number of quantization bits.
  ///
  STDMETHOD(GetQuantizationBits) (THIS_
    aafUInt32 *  pBitsCount) PURE;

  END_INTERFACE
};
#endif // __IAAFSoundDescriptor_INTERFACE_DEFINED__



// IAAFSourceClip

// ************************
//
// Interface IAAFSourceClip
//
// ************************





#ifndef __IAAFSourceClip_INTERFACE_DEFINED__
#define __IAAFSourceClip_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFSourceClip;

#undef  INTERFACE
#define INTERFACE   IAAFSourceClip

DECLARE_INTERFACE_(IAAFSourceClip, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFSourceClip methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// This method initializes a source clip object with
  /// the given properties.  Only required properties are set.
  /// Optional properties are added with separate functions.
  ///
  /// Succeds if:
  /// - This object has not already been Initialize()d.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDataDef argument is NULL.
  ///
  /// @param pDataDef [in] Data Definition object
  /// @param length [in] Length property value
  /// @param sourceRef [in] Source Reference
  ///
  STDMETHOD(Initialize) (THIS_
    IAAFDataDef * pDataDef,
    aafLength_constref  length,
    aafSourceRef_t  sourceRef) PURE;


  //***********************************************************
  //
  // GetFade()
  //
  /// This function returns the optional fade information from a
  /// source clip.  This function only applies to audio source clips.
  /// Length units are specified by the containing mob slot's edit
  /// rate.
  ///
  /// Succeeds if all of the following are true:
  /// - This object has already been Initialize()d.
  /// - the all argument pointers are valid.
  /// 
  /// If this method fails nothing will be written to any of the
  /// locations specified by the arguments.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - any argument is NULL.
  ///
  /// @param pFadeInLen [out] Fade In Length
  /// @param pFadeInType [out] Fade In Type
  /// @param pFadeInPresent [out] Fade In Type
  /// @param pFadeOutLen [out] Fade Out Length
  /// @param pFadeOutType [out] Fade Out Type
  /// @param pFadeOutPresent [out] Fade In Type
  ///
  STDMETHOD(GetFade) (THIS_
    aafLength_t *  pFadeInLen,
    aafFadeType_t *  pFadeInType,
    aafBoolean_t *  pFadeInPresent,
    aafLength_t *  pFadeOutLen,
    aafFadeType_t *  pFadeOutType,
    aafBoolean_t *  pFadeOutPresent) PURE;


  //***********************************************************
  //
  // ResolveRef()
  //
  /// Given a source clip object, this function returns a pointer
  /// to the mob that it references.
  ///
  /// The returned mob is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - This object has already been Initialize()d.
  /// - the ppMob pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppMob.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppMob arg is NULL.
  ///
  /// AAFRESULT_MOB_NOT_FOUND
  ///   - this mob does not exist.
  ///
  /// @param ppMob [out] Referenced mob
  ///
  STDMETHOD(ResolveRef) (THIS_
    IAAFMob ** ppMob) PURE;


  //***********************************************************
  //
  // GetSourceReference()
  //
  /// This function returns the source reference of this source clip.
  ///
  /// Note: the 3 properties of a source Clip that make up the "source
  /// reference" are sourceID, sourceTrackID, and startTime.
  ///
  /// Succeeds if all of the following are true:
  /// - This object has already been Initialize()d.
  /// - the pSourceRef pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pSourceRef.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSourceRef arg is NULL.
  ///
  /// @param pSourceRef [out] Source Reference
  ///
  STDMETHOD(GetSourceReference) (THIS_
    aafSourceRef_t *  pSourceRef) PURE;


  //***********************************************************
  //
  // SetFade()
  //
  /// This function sets the optional fade properties on this source
  /// clip object.  The fade properties only apply to a source clip of
  /// data definition (or convertible to a data definition) of type
  /// Sound.  All arguments should be specified.  Length units are
  /// specified by the containing mob slot's edit rate.
  /// 
  /// Succeeds if all of the following are true:
  /// - This object has already been Initialize()d.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param fadeInLen [in] Fade In Length
  /// @param fadeInType [in] Fade In Type
  /// @param fadeOutLen [in] Fade Out Length
  /// @param fadeOutType [in] Fade Out Type
  ///
  STDMETHOD(SetFade) (THIS_
    aafInt32  fadeInLen,
    aafFadeType_t  fadeInType,
    aafInt32  fadeOutLen,
    aafFadeType_t  fadeOutType) PURE;


  //***********************************************************
  //
  // SetSourceReference()
  //
  /// This function sets the source reference of this source clip.
  ///
  /// Note: the  3 properties of a source Clip that make up the "source
  /// reference" are sourceID, sourceTrackID, and startTime.
  /// 
  /// Succeeds if all of the following are true:
  /// - This object has already been Initialize()d.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param sourceRef [in] Source Reference
  ///
  STDMETHOD(SetSourceReference) (THIS_
    aafSourceRef_t  sourceRef) PURE;

  END_INTERFACE
};
#endif // __IAAFSourceClip_INTERFACE_DEFINED__



// IAAFSourceMob

// ************************
//
// Interface IAAFSourceMob
//
// ************************








#ifndef __IAAFSourceMob_INTERFACE_DEFINED__
#define __IAAFSourceMob_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFSourceMob;

#undef  INTERFACE
#define INTERFACE   IAAFSourceMob

DECLARE_INTERFACE_(IAAFSourceMob, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFSourceMob methods *** */
  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty IAAFSourceMob-supporting
  /// object.  This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  STDMETHOD(Initialize) (THIS) PURE;


  //***********************************************************
  //
  // GetEssenceDescriptor()
  //
  /// Places the Essence Descriptor object attached to this Mob into the
  /// *ppEssence argument.  If none exists yet, NULL is placed into the
  /// *ppEssence argument.
  ///
  /// The returned essence descriptor object, if it exists, is
  /// AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppEssence pointer is valid.
  /// - A valid essence descriptor exists.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEssence is null.
  ///
  /// AAFRESULT_NO_ESSENCE_DESC
  ///   - There is no essence descriptor.  There has to be one of some
  ///     kind for this to be a valid Mob.
  ///
  /// @param ppEssence [out] Returned Essence Descriptor object
  ///
  STDMETHOD(GetEssenceDescriptor) (THIS_
    IAAFEssenceDescriptor ** ppEssence) PURE;


  //***********************************************************
  //
  // SetEssenceDescriptor()
  //
  /// Sets the Essence Descriptor of this Mob to be the given one.
  ///
  /// Succeeds if all of the following are true:
  /// - the pEssence pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEssence is null.
  ///
  /// @param pEssence [in] Essence Descriptor object
  ///
  STDMETHOD(SetEssenceDescriptor) (THIS_
    IAAFEssenceDescriptor * pEssence) PURE;


  //***********************************************************
  //
  // AddNilReference()
  //
  /// This function adds a slot containing a NIL [sourceID 0.0....]
  /// Source Clip.  This special SourceID indicates that the mob chain
  /// ends here, which indicates that no record exists of what the
  /// essence was derived from.  Some AAFSourceClip is still required
  /// on the track to indicate that the track exists, and may be
  /// referenced from other Mobs.
  ///
  /// Examples of Source Mobs that are not derived from a previous
  /// source of essence are: Tape Source Mobs that were not created
  /// from film; File Source Mobs whose digital essence data was
  /// originally generated by computer and was not digitized from
  /// videotape.
  ///
  /// Succeeds if all of the following are true:
  /// - The pDataDef parameter is valid.
  /// - editRate is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - the pDataDef parameter is NULL.
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_BADRATE
  ///   - the editRate is not valid.
  ///
  /// @param slotID [in] SlotID to be assigned to the new slot
  /// @param length [in] Duration of the Source Clip to be added to the new slot
  /// @param pDataDef [in] Data definition of the new slot
  /// @param editRate [in] Edit rate of the new slot
  ///
  STDMETHOD(AddNilReference) (THIS_
    aafSlotID_t  slotID,
    aafLength_t  length,
    IAAFDataDef * pDataDef,
    aafRational_t  editRate) PURE;


  //***********************************************************
  //
  // AppendTimecodeSlot()
  //
  /// This function adds a Timecode slot to a specified tape Mob or
  /// film Mob, with a specified starting timecode, length, and edit
  /// rate.  Your must also call SpecifyValidCodeRange to add the
  /// Filler to the other essence slots to indicate that the Timecode
  /// is valid for that channel.
  /// 
  /// Note: The startTC parameter is expressed in frames since
  /// midnight.
  /// 
  /// The length32 parameter can be the value FULL_RANGE, in which
  /// case the length is 24 hours.
  ///
  /// Succeeds if all of the following are true:
  /// - The specified slot ID is not yet used.
  /// - This source mob references an AAFTapeDescriptor as an essence
  ///   descriptor.
  /// 
  /// If this method fails no state is changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_SLOT_EXISTS
  ///   - The specified slotID already exists.
  ///
  /// AAFRESULT_TAPEDESC_ONLY
  ///   - Valid only for AAFSourceMob referencing an AAFTapeDescriptor
  ///     as EssenceDescriptor.
  ///
  /// @param editrate [in] Edit rate of Timecode slot
  /// @param slotID [in] SlotID of Timecode slot
  /// @param startTC [in] Starting time code
  /// @param length32 [in] Duration of Timecode.
  ///
  STDMETHOD(AppendTimecodeSlot) (THIS_
    aafRational_t  editrate,
    aafInt32  slotID,
    aafTimecode_t  startTC,
    aafFrameLength_t  length32) PURE;


  //***********************************************************
  //
  // AppendEdgecodeSlot()
  //
  /// Adds an Edgecode slot to a specified film Mob, with a specified
  /// starting edgecode, length, and edit rate. You must add a essence
  /// slot with SpecifyValidCodeRange to make the edgecode slot valid.
  ///
  /// Succeeds if all of the following are true:
  /// - The specified slot ID is not yet used.
  /// - This source mob references an AAFFilmDescriptor as an essence
  ///   descriptor.
  /// 
  /// If this method fails no state is changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_SLOT_EXISTS
  ///   - The specified slotID already exists.
  ///
  /// AAFRESULT_FILMDESC_ONLY
  ///   - Valid only for AAFSourceMob referencing an AAFFilmDescriptor
  ///     as EssenceDescriptor.
  ///
  /// @param editrate [in] Edit rate of the Edgecode slot
  /// @param slotID [in] SlotID to assign to the new Edgecode slot
  /// @param startEC [in] Starting Edgecode
  /// @param length32 [in] Length of the Edgecode component in the slot
  /// @param filmKind [in] The film kind.
  /// Can be one of:
  /// - kFtNull
  /// - kFt35MM
  /// - kFt16MM
  /// - kFt8MM
  /// - kFt65MM
  /// @param codeFormat [in] The code format.
  /// Can be one of:
  /// - kEtNull
  /// - kEtKeycode
  /// - kEtEdgenum4
  /// - kEtEdgenum5
  /// @param header [in] The Edgecode's 8-byte header
  ///
  STDMETHOD(AppendEdgecodeSlot) (THIS_
    aafRational_t  editrate,
    aafInt32  slotID,
    aafFrameOffset_t  startEC,
    aafFrameLength_t  length32,
    aafFilmType_t  filmKind,
    aafEdgeType_t  codeFormat,
    aafEdgecodeHeader_t  header) PURE;


  //***********************************************************
  //
  // SpecifyValidCodeRange()
  //
  /// Adds slot containing Source Clips to a Source Mob to indicate
  /// that the Timecode or Edgecode is valid for that channel.
  ///
  /// Note: The pEssenceKind parameter requires a data kind valid for a
  /// essence stream.  Valid data kinds are:
  /// - Picture
  /// - Sound
  ///
  /// Succeeds if all of the following are true:
  /// - the pEssenceKind pointer is valid.
  /// - The specified slot ID is not yet used.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEssenceKind is null.
  ///
  /// AAFRESULT_SLOT_EXISTS
  ///   - The specified slotID already exists.
  ///
  /// @param pEssenceKind [in] Data kind for the slot to be added
  /// @param slotID [in] SlotID for the slot to be added
  /// @param editrate [in] Edit rate for the slot to be added
  /// @param startOffset [in] Start offset for the slot to be added
  /// @param length32 [in] Duration of the Source Clip in the slot
  ///
  STDMETHOD(SpecifyValidCodeRange) (THIS_
    IAAFDataDef * pEssenceKind,
    aafSlotID_t  slotID,
    aafRational_t  editrate,
    aafFrameOffset_t  startOffset,
    aafFrameLength_t  length32) PURE;


  //***********************************************************
  //
  // AppendPhysSourceRef()
  //
  /// Connects this Source Mob with the physical Source Mob that
  /// describes the previous generation of essence, appending it to
  /// existing Mob data.  If a physical Source Mob, such as a File
  /// Source Mob or tape Source Mob, references another physical
  /// Source Mob as its ancestor, with no pulldown, then this
  /// function makes the connection between the two.
  ///
  /// Functionally, this is a helper function to create a slot with an
  /// AAFSourceClip referencing a particular piece of media.  This
  /// function takes many parameters because the components of an
  /// aafSourceRef_t have been broken out as separate parameters.
  ///
  /// The ancestor of an AAFSourceMob with an AAFFileDescriptor is often an
  /// AAFTapeDescriptor or NIL.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSourceRefObj pointer is valid.
  /// - the pEssenceKind pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSourceRefObj or pEssenceKind is null.
  ///
  /// @param editrate [in] Edit rate of slot to contain reference
  /// @param aMobSlot [in] SlotID of slot to contain reference
  /// @param pEssenceKind [in] Data kind of slot to contain reference.  Requires a data kind
  /// valid for a essence stream.  Valid data kinds are:
  /// - Picture
  /// - Sound
  /// @param ref [in] Reference to a Physical Source Mob
  /// @param srcRefLength [in] Length of the Source Clip
  ///
  STDMETHOD(AppendPhysSourceRef) (THIS_
    aafRational_t  editrate,
    aafSlotID_t  aMobSlot,
    IAAFDataDef * pEssenceKind,
    aafSourceRef_t  ref,
    aafLength_t  srcRefLength) PURE;


  //***********************************************************
  //
  // NewPhysSourceRef()
  //
  /// Connects this Source Mob with the physical Source Mob that
  /// describes the previous generation of essence, replacing any
  /// existing Mob data.  If a physical Source Mob, such as a File
  /// Source Mob or tape Source Mob, references another physical
  /// Source Mob as its ancestor, with no pulldown, then this
  /// function makes the connection between the two.
  ///
  /// Functionally, this is a helper function to create a slot with an
  /// AAFSourceClip referencing a particular piece of media.  This
  /// function takes many parameters because the components of an
  /// aafSourceRef_t have been broken out as separate parameters.
  ///
  /// The ancestor of an AAFSourceMob with an AAFFileDescriptor is often an
  /// AAFTapeDescriptor or NIL.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSourceRefObj pointer is valid.
  /// - the pEssenceKind pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSourceRefObj or pEssenceKind is null.
  ///
  /// @param editrate [in] Edit rate of slot to contain reference
  /// @param aMobSlot [in] SlotID of slot to contain reference
  /// @param pEssenceKind [in] Data kind of slot to contain reference.  Requires a data kind
  /// valid for a essence stream.  Valid data kinds are:
  /// - Picture
  /// - Sound
  /// @param ref [in] Reference to a Physical Source Mob
  /// @param srcRefLength [in] Length of the Source Clip
  ///
  STDMETHOD(NewPhysSourceRef) (THIS_
    aafRational_t  editrate,
    aafSlotID_t  aMobSlot,
    IAAFDataDef * pEssenceKind,
    aafSourceRef_t  ref,
    aafLength_t  srcRefLength) PURE;


  //***********************************************************
  //
  // AddPulldownRef()
  //
  /// Connects the specified Source Mob with the physical Source Mob
  /// that describes the previous generation of essence, with an
  /// additional AAFPulldown as part of the reference to indicate a non
  /// 1-1 relationship Between the two. 
  ///
  /// Functionally, this is a helper function to create a slot with an
  /// AAFPulldown object which references an AAFSourceClip, which
  /// references a particular piece of media.  This function takes many
  /// parameters because the components of an aafSourceRef_t and the
  /// AAFPulldown object have been broken out as separate parameters.
  ///
  /// The ancestor of an AAFSourceMob with an AAFTapeDescriptor is
  /// often an AAFFilmDescriptor or NIL.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSourceRefObj pointer is valid.
  /// - the pEssenceKind pointer is valid.
  /// - a valid pulldown direction was specified.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSourceRefObj or pEssenceKind is null.
  ///
  /// AAFRESULT_PULLDOWN_DIRECTION
  ///   - an invalid pulldown direction was specified.
  ///
  /// @param addType [in] Tells whether to overwrite an existing slot segment, or create
  /// a sequence and append
  /// @param editrate [in] Edit rate of slot to contain reference
  /// @param aMobSlot [in] SlotID of slot to contain reference
  /// @param pEssenceKind [in] Data kind of slot to contain reference.  Requires a data kind
  /// valid for a essence stream.  Valid data kinds are:
  /// - Picture
  /// - Sound
  /// @param ref [in] Reference to a Physical Source Mob
  /// @param srcRefLength [in] Length of the Source Clip in the Source Mob
  /// @param pulldownKind [in] Method of conversion.  Possible values are:
  /// - kAAFTwoThreePD	    -- Normal NTSC-20fps pulldown
  /// - kAAFPALPD
  /// - kAAFOneToOneNTSC   -- NTSC recorded as 1 frame == 1 film frame.
  /// - kAAFOneToOnePAL    -- PAL recorded as 1 frame == 1 film frame.
  /// @param phaseFrame objPass phase of first frame
  /// @param direction enumIn Direction of the pulldown conversion. Possible values are:
  ///
  ///  - kAAFTapeToFilmSpeed -- Used to link a file descriptor with a
  ///							 tape descriptor.
  ///  - kAAFFilmToTapeSpeed -- Used to link a tape descriptor with a
  ///							 film descriptor.
  ///
  STDMETHOD(AddPulldownRef) (THIS_
    aafAppendOption_t  addType,
    aafRational_t  editrate,
    aafSlotID_t  aMobSlot,
    IAAFDataDef * pEssenceKind,
    aafSourceRef_t  ref,
    aafLength_t  srcRefLength,
    aafPulldownKind_t  pulldownKind,
    aafPhaseFrame_t  phaseFrame,
    aafPulldownDir_t  direction) PURE;


  END_INTERFACE
};
#endif // __IAAFSourceMob_INTERFACE_DEFINED__



// IAAFSourceReference

// ************************
//
// Interface IAAFSourceReference
//
// ************************



#ifndef __IAAFSourceReference_INTERFACE_DEFINED__
#define __IAAFSourceReference_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFSourceReference;

#undef  INTERFACE
#define INTERFACE   IAAFSourceReference

DECLARE_INTERFACE_(IAAFSourceReference, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFSourceReference methods *** */
  //***********************************************************
  //
  // GetSourceID()
  //
  /// Gets the SourceID and places it into the pSourceID argument.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSourceID pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pSourceID.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSourceID arg is NULL.
  ///
  /// @param pSourceID [retval][out] Place to put source ID
  ///
  STDMETHOD(GetSourceID) (THIS_
    aafMobID_t *  pSourceID) PURE;


  //***********************************************************
  //
  // SetSourceID()
  //
  /// Sets the SourceID using the sourceID argument.
  /// 
  /// Always succeeds.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param sourceID [in] Source ID to set
  ///
  STDMETHOD(SetSourceID) (THIS_
    aafMobID_constref   sourceID) PURE;


  //***********************************************************
  //
  // GetSourceMobSlotID()
  //
  /// Gets the Mob Slot ID and places it into the pMobSlotID argument.
  ///
  /// Succeeds if all of the following are true:
  /// - the pMobSlotID pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pMobSlotID.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMobSlotID arg is NULL.
  ///
  /// @param pMobSlotID [retval][out] Place to put source mob slot ID
  ///
  STDMETHOD(GetSourceMobSlotID) (THIS_
    aafSlotID_t *  pMobSlotID) PURE;


  //***********************************************************
  //
  // SetSourceMobSlotID()
  //
  /// Sets the mob slot ID using the mobSlotID argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - (preconditions here)
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// (other error codes here.)
  ///
  /// @param mobSlotID [in] Source Mob ID to set
  ///
  STDMETHOD(SetSourceMobSlotID) (THIS_
    aafSlotID_t   mobSlotID) PURE;










  END_INTERFACE
};
#endif // __IAAFSourceReference_INTERFACE_DEFINED__


// IAAFStaticMobSlot

// ************************
//
// Interface IAAFStaticMobSlot
//
// ************************





#ifndef __IAAFStaticMobSlot_INTERFACE_DEFINED__
#define __IAAFStaticMobSlot_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFStaticMobSlot;

#undef  INTERFACE
#define INTERFACE   IAAFStaticMobSlot

DECLARE_INTERFACE_(IAAFStaticMobSlot, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFStaticMobSlot methods *** */



  END_INTERFACE
};
#endif // __IAAFStaticMobSlot_INTERFACE_DEFINED__



// IAAFTIFFDescriptor

// ************************
//
// Interface IAAFTIFFDescriptor
//
// ************************


  


#ifndef __IAAFTIFFDescriptor_INTERFACE_DEFINED__
#define __IAAFTIFFDescriptor_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTIFFDescriptor;

#undef  INTERFACE
#define INTERFACE   IAAFTIFFDescriptor

DECLARE_INTERFACE_(IAAFTIFFDescriptor, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTIFFDescriptor methods *** */

  //***********************************************************
  //
  // SetIsUniform()
  //
  /// Set to TRUE if essence data has the same number of rows per strip
  /// throughout.
  ///
  /// Always succeeds.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param IsUniform [in] Sets the IsUniform flag value
  ///
  STDMETHOD(SetIsUniform) (THIS_
    aafBoolean_t  IsUniform) PURE;


  //***********************************************************
  //
  // GetIsUniform()
  //
  /// Places TRUE into *pIsUniform if the data has the same number of
  /// rows per strip throughout.
  ///
  /// Succeeds if all of the following are true:
  /// - the pIsUniform pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pIsUniform.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pIsUniform arg is NULL.
  ///
  /// @param pIsUniform [out] Gets the IsUniform flag value
  ///
  STDMETHOD(GetIsUniform) (THIS_
    aafBoolean_t *  pIsUniform) PURE;


  //***********************************************************
  //
  // SetIsContiguous()
  //
  /// Set to TRUE if essence data is stored in contiguous bytes.
  /// 
  /// Always succeeds.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param IsContiguous [in] is data stores in contiguous bytes
  ///
  STDMETHOD(SetIsContiguous) (THIS_
    aafBoolean_t  IsContiguous) PURE;


  //***********************************************************
  //
  // GetIsContiguous()
  //
  /// Places TRUE into *pIsContiguous if essence data is stored in
  /// contiguous bytes.
  ///
  /// Succeeds if all of the following are true:
  /// - the pIsContiguous pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pIsContiguous.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pIsContiguous arg is NULL.
  ///
  /// @param pIsContiguous [out] is this data stored in contiguous bytes
  ///
  STDMETHOD(GetIsContiguous) (THIS_
    aafBoolean_t *  pIsContiguous) PURE;


  //***********************************************************
  //
  // SetLeadingLines()
  //
  /// Sets the number of leading lines in the TIFF image file.
  /// 
  /// This method succeeds if all of the following are true:
  /// - LeadingLines is  equal or greater than 0(zero).
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param LeadingLines [in] Number of leading lines to be thrown away Optional
  ///
  STDMETHOD(SetLeadingLines) (THIS_
    aafInt32  LeadingLines) PURE;


  //***********************************************************
  //
  // GetLeadingLines()
  //
  /// Gets the leading lines of the TIFF image.
  ///
  /// This method succeeds if all of the following are true:
  /// - the pLeadingLines pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pLeadingLines.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLeadingLines arg is NULL.
  ///
  /// @param pLeadingLines [out] Address to store the number of leading lines
  ///
  STDMETHOD(GetLeadingLines) (THIS_
    aafInt32 *  pLeadingLines) PURE;


  //***********************************************************
  //
  // SetTrailingLines()
  //
  /// Sets the number of trailing lines in the TIFF image file
  /// 
  /// This method succeeds if all of the following are true:
  /// - TrailingLines is  equal or greater than 0(zero).
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param TrailingLines [in] Number of trailing lines to be thrown away Optional.
  ///
  STDMETHOD(SetTrailingLines) (THIS_
    aafInt32  TrailingLines) PURE;


  //***********************************************************
  //
  // GetTrailingLines()
  //
  /// Gets the trailing lines of the TIFF image.
  ///
  /// This method succeeds if all of the following are true:
  /// - the pTrailingLines pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pTrailingLines.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTrailingLines arg is NULL.
  ///
  /// @param pTrailingLines [out] Address to store the number of trailing lines.
  ///
  STDMETHOD(GetTrailingLines) (THIS_
    aafInt32 *  pTrailingLines) PURE;


  //***********************************************************
  //
  // SetJPEGTableID()
  //
  /// Sets the JPEG table code for  the TIFF image file
  /// 
  /// This method always succeeds .
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param JPEGTableID [in] Registered JPEG table code or JT_NULL.
  ///
  STDMETHOD(SetJPEGTableID) (THIS_
    aafJPEGTableID_t  JPEGTableID) PURE;


  //***********************************************************
  //
  // GetJPEGTableID()
  //
  /// Gets the JPEG table code of the TIFF image.
  ///
  /// This method succeeds if all of the following are true:
  /// - the pJPEGTableID pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pJPEGTableID.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pJPEGTableID arg is NULL.
  ///
  /// @param pJPEGTableID [out] Address to store the nJPEG table code
  ///
  STDMETHOD(GetJPEGTableID) (THIS_
    aafJPEGTableID_t *  pJPEGTableID) PURE;


  //***********************************************************
  //
  // GetSummary()
  //
  /// Gets a copy of the TIFF IFD file information without the media.
  /// 
  /// Succeeds if all of the following are true:
  /// - pSummary is a valid pointer.
  /// - The size of the buffer is large enough to hold the TIFF IFD
  ///   file information. 
  /// 
  /// If this method fails pSummary will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSummary arg is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - The buffer is too small to hold the WAVE file information.
  ///
  /// @param size [in] Size of preallocated buffer
  /// @param pSummary [out, size_is(size)] Preallocated buffer to hold the TIFF IFD file information
  ///
  STDMETHOD(GetSummary) (THIS_
    aafUInt32  size,
    aafDataValue_t  pSummary) PURE;


  //***********************************************************
  //
  // GetSummaryBufferSize()
  //
  /// Returns the size of the buffer required for the GetSummary()
  /// method.  The value is placed into the location specified by pSize.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSize pointer is valid.
  ///
  /// If this method fails nothing will be written to *pSize.
  ///
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSize arg is NULL.
  ///
  /// @param pSize [out] required buffer size
  ///
  STDMETHOD(GetSummaryBufferSize) (THIS_
    aafUInt32 *  pSize) PURE;


  //***********************************************************
  //
  // SetSummary()
  //
  /// Sets the TIFF IFD file information.
  /// 
  /// Succeeds if all of the following are true:
  /// - pSummary is a valid pointer
  /// 
  /// If this method fails the summary property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSummary arg is NULL.
  ///
  /// @param size [in] Size of preallocated buffer
  /// @param pSummary [in, size_is(size)] buffer containing value
  ///
  STDMETHOD(SetSummary) (THIS_
    aafUInt32  size,
    aafDataValue_t  pSummary) PURE;

  END_INTERFACE
};
#endif // __IAAFTIFFDescriptor_INTERFACE_DEFINED__



// IAAFTaggedValue

// ************************
//
// Interface IAAFTaggedValue
//
// ************************




#ifndef __IAAFTaggedValue_INTERFACE_DEFINED__
#define __IAAFTaggedValue_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTaggedValue;

#undef  INTERFACE
#define INTERFACE   IAAFTaggedValue

DECLARE_INTERFACE_(IAAFTaggedValue, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTaggedValue methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a new tagged value object to be identified with the
  /// given the given type, and with the given human-legible name.
  ///
  /// This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  /// - pName is a valid pointer.
  /// - pTypeDef is a valid pointer and registered
  /// - pValue is a valid pointer
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - This object has already had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName or pTypeDef or pValue arg is NULL.
  /// 
  ///
  /// @param pName [in, string] User defined name (tag) of this tagged value object
  /// @param pTypeDef [in] Type Definition of the following value data
  /// @param valueSize [in] Size of preallocated buffer
  /// @param pValue [in, size_is(valueSize)] buffer containing value
  ///
  STDMETHOD(Initialize) (THIS_
    aafCharacter_constptr  pName,
    IAAFTypeDef * pTypeDef,
    aafUInt32  valueSize,
    aafDataBuffer_t  pValue) PURE;


  //***********************************************************
  //
  // GetName()
  //
  /// Gets the Name string property.
  /// 
  /// Writes the Name property, with a trailing null
  /// character, into the pName buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the Name property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetNameBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pName.
  /// 
  /// Succeeds if:
  /// - The pName pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   Name.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold Name.
  ///
  /// @param pName [out, string, size_is(bufSize)] buffer into which Name is to be written
  /// @param bufSize [in] size of *pName buffer in bytes
  ///
  STDMETHOD(GetName) (THIS_
    aafCharacter *  pName,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetNameBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetName().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetNameBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;


  //***********************************************************
  //
  // GetTypeDefinition()
  //
  /// Returns the type definition for this invocation.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppTypeDef pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppTypeDef.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - This property does not exist in the file.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTypeDef arg is NULL.
  ///
  /// @param ppTypeDef [out] Type definition object
  ///
  STDMETHOD(GetTypeDefinition) (THIS_
    IAAFTypeDef ** ppTypeDef) PURE;


  //***********************************************************
  //
  // GetValue()
  //
  /// Writes the value into the pValue buffer.  The buffer is allocated
  /// by the caller, and the size of the buffer is given by
  /// valueSize.
  /// 
  /// Caller may call GetValueBufLen() to determine the
  /// required buffer size.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pValue pointer is valid.
  /// - valueSize indicates the buffer is large enough to hold the name.
  /// 
  /// If this method fails nothing will be written to *pValue.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pValue arg is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - valueSize indicates the buffer is too small to hold the value.
  ///
  /// @param valueSize [in] Size of preallocated buffer
  /// @param pValue [out, size_is(valueSize), length_is(*bytesRead)] Preallocated buffer to hold value
  /// @param bytesRead [out] Number of actual bytes read
  ///
  STDMETHOD(GetValue) (THIS_
    aafUInt32  valueSize,
    aafDataBuffer_t  pValue,
    aafUInt32 *  bytesRead) PURE;


  //***********************************************************
  //
  // GetValueBufLen()
  //
  /// Returns the length of buffer required for the GetValue() method.
  /// The value is placed into the location specified by pLen.
  ///
  /// Succeeds if all of the following are true:
  /// - the pLen pointer is valid.
  ///
  /// If this method fails nothing will be written to *pLen.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLen arg is NULL.
  ///
  /// @param pLen [out] Pointer to an variable used to return the length
  ///
  STDMETHOD(GetValueBufLen) (THIS_
    aafUInt32 *  pLen) PURE;

  //***********************************************************
  //
  // SetValue()
  //
  /// The data value is set from a buffer of size valueSize and type.
  ///
  /// Succeeds if all of the following are true:
  /// - pTypeDef is valid and registered with the object's dictionary.
  /// - the pValue pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTypeDef is null.
  ///
  /// @param valueSize [in] Size of preallocated buffer
  /// @param pValue [in, size_is(valueSize)] buffer containing value
  ///
  STDMETHOD(SetValue) (THIS_
    aafUInt32  valueSize,
    aafDataBuffer_t  pValue) PURE;


  END_INTERFACE
};
#endif // __IAAFTaggedValue_INTERFACE_DEFINED__



// IAAFTaggedValueDefinition

// ************************
//
// Interface IAAFTaggedValueDefinition
//
// ************************






#ifndef __IAAFTaggedValueDefinition_INTERFACE_DEFINED__
#define __IAAFTaggedValueDefinition_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTaggedValueDefinition;


#undef  INTERFACE
#define INTERFACE   IAAFTaggedValueDefinition

DECLARE_INTERFACE_(IAAFTaggedValueDefinition, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTaggedValueDefinition methods *** */


  //***********************************************************
  //
  // Initialize()
  //
  /// Init all fields of a definition object.
  ///
  /// @param id [in, ref] AUID for new DefObject
  /// @param pName [in, string] Name for new DefObject
  /// @param pDescription [in, string] Description for new DefObject
  ///
  STDMETHOD(Initialize) (THIS_
    aafUID_constref  id,
    aafCharacter_constptr  pName,
    aafCharacter_constptr  pDescription) PURE;

  //***********************************************************
  //
  // AddParentProperty()
  //
  /// Add a property definition to the tagged value definition.
  ///
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pParentProperty is null.
  ///
  /// @param pParentProperty [in] Property definition to add.
  ///
  STDMETHOD(AddParentProperty) (THIS_
    IAAFPropertyDef * pParentProperty) PURE;

  //***********************************************************
  //
  // GetParentProperties()
  //
  /// Writes an enumerator for the property definitions into *ppEnum.
  /// A reference is added to the new enumerator before it is returned.
  ///
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// @param ppEnum [out] Property definition enumerator.
  ///
  STDMETHOD(GetParentProperties) (THIS_
    IEnumAAFPropertyDefs ** ppEnum) PURE;

  //***********************************************************
  //
  // CountParentProperties()
  //
  /// Writes the total number of property definitions into *pNumProperties if,
  /// and only if, the method succeeds.
  ///
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// @param pNumProperties [out] Number of property definitions.
  ///
  STDMETHOD(CountParentProperties) (THIS_
    aafUInt32*  pNumProperties) PURE;

  //***********************************************************
  //
  // RemoveParentProperty()
  //
  /// Removes the given property definition.
  ///
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - The property definition is not in this tagged value definition.
  ///
  /// @param pParentProperty [in] Property to remove.
  ///
  STDMETHOD(RemoveParentProperty) (THIS_
    IAAFPropertyDef * pParentProperty) PURE;


  END_INTERFACE
};
#endif // __IAAFTaggedValueDefinition_INTERFACE_DEFINED__



// IAAFTapeDescriptor

// ************************
//
// Interface IAAFTapeDescriptor
//
// ************************




#ifndef __IAAFTapeDescriptor_INTERFACE_DEFINED__
#define __IAAFTapeDescriptor_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTapeDescriptor;

#undef  INTERFACE
#define INTERFACE   IAAFTapeDescriptor

DECLARE_INTERFACE_(IAAFTapeDescriptor, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTapeDescriptor methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty
  /// IAAFTapeDescriptor-supporting object.  This method must be called
  /// after allocation, and before any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  STDMETHOD(Initialize) (THIS) PURE;


  //***********************************************************
  //
  // SetTapeManufacturer()
  //
  /// Sets the Tape Manufacturer string property.
  ///
  /// Set the TapeManufacturer property to the value specified in
  /// pTapeManufacturer.  A copy is made of the data so the caller
  /// retains ownership of the *pTapeManufacturer buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pTapeManufacturer pointer is valid.
  /// 
  /// If this method fails the TapeManufacturer property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTapeManufacturer arg is NULL.
  ///
  /// @param pTapeManufacturer [in, string] buffer from which TapeManufacturer is to be read
  ///
  STDMETHOD(SetTapeManufacturer) (THIS_
    aafCharacter_constptr  pTapeManufacturer) PURE;


  //***********************************************************
  //
  // GetTapeManufacturer()
  //
  /// Gets the Tape Manufacturer string property.
  /// 
  /// Writes the TapeManufacturer property, with a trailing null
  /// character, into the pTapeManufacturer buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the TapeManufacturer property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetTapeManufacturerBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pTapeManufacturer.
  /// 
  /// Succeeds if:
  /// - The pTapeManufacturer pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   TapeManufacturer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTapeManufacturer arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold TapeManufacturer.
  ///
  /// @param pTapeManufacturer [out, string, size_is(bufSize)] buffer into which TapeManufacturer is to be written
  /// @param bufSize [in] size of *pTapeManufacturer buffer in bytes
  ///
  STDMETHOD(GetTapeManufacturer) (THIS_
    aafCharacter *  pTapeManufacturer,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetTapeManufacturerBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetTapeManufacturer().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetTapeManufacturerBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;


  //***********************************************************
  //
  // SetTapeModel()
  //
  /// Sets the Tape Model string property.
  ///
  /// Set the TapeModel property to the value specified in
  /// pTapeModel.  A copy is made of the data so the caller
  /// retains ownership of the *pTapeModel buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pTapeModel pointer is valid.
  /// 
  /// If this method fails the TapeModel property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTapeModel arg is NULL.
  ///
  /// @param pTapeModel [in, string] buffer from which TapeModel is to be read
  ///
  STDMETHOD(SetTapeModel) (THIS_
    aafCharacter_constptr  pTapeModel) PURE;


  //***********************************************************
  //
  // GetTapeModel()
  //
  /// Gets the Tape Model string property.
  /// 
  /// Writes the TapeModel property, with a trailing null
  /// character, into the pTapeModel buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the TapeModel property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetTapeModelBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pTapeModel.
  /// 
  /// Succeeds if:
  /// - The pTapeModel pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   TapeModel.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTapeModel arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold TapeModel.
  ///
  /// @param pTapeModel [out, string, size_is(bufSize)] buffer into which TapeModel is to be written
  /// @param bufSize [in] size of *pTapeModel buffer in bytes
  ///
  STDMETHOD(GetTapeModel) (THIS_
    aafCharacter *  pTapeModel,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetTapeModelBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetTapeModel().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetTapeModelBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;


  //***********************************************************
  //
  // SetTapeFormFactor()
  //
  /// Sets the form factor [case size] of the tape.
  /// 
  /// This method succeeds if all of the following are true:
  /// - formFactor represents a valid format.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_BAD_TYPE
  ///	- formFactor is invalid.
  ///
  /// @param formFactor [in] ex: kVHSVideoTape, kDATCartridge 
  ///
  STDMETHOD(SetTapeFormFactor) (THIS_
    aafTapeCaseType_t  formFactor) PURE;


  //***********************************************************
  //
  // GetTapeFormFactor()
  //
  /// Gets the form factor [case size] of the tape.
  /// 
  /// This method succeeds if all of the following are true:
  /// - the pFormFactor pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFormFactor arg is NULL.
  ///
  /// @param formFactor [out] ex: kVHSVideoTape, kDATCartridge
  ///
  STDMETHOD(GetTapeFormFactor) (THIS_
    aafTapeCaseType_t *  formFactor) PURE;


  //***********************************************************
  //
  // SetSignalType()
  //
  /// Sets the signal standard recorded on the tape.
  /// 
  /// This method succeeds if all of the following are true:
  ///	videoSignal represents a valid video signal type.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_BAD_TYPE
  ///	- videoSignal is invalid.
  ///
  /// @param videoSignal [in] ex: kNTSCSignal
  ///
  STDMETHOD(SetSignalType) (THIS_
    aafVideoSignalType_t  videoSignal) PURE;


  //***********************************************************
  //
  // GetSignalType()
  //
  /// Gets the signal standard recorded on the tape.
  /// 
  /// This method succeeds if all of the following are true:
  /// - the pVideoSignal pointer is valid.
  ///
  /// If this method fails nothing will be written to *pVideoSignal.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pVideoSignal arg is NULL.
  ///
  /// @param pVideoSignal [out] ex: kNTSCSignal
  ///
  STDMETHOD(GetSignalType) (THIS_
    aafVideoSignalType_t *  pVideoSignal) PURE;


  //***********************************************************
  //
  // SetTapeFormat()
  //
  /// Sets the recording method of the tape.
  /// 
  /// This method succeeds if all of the following are true:
  /// - tapeFormat represents a valid tape format type.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_BAD_TYPE
  ///	- tapeFormat is invalid.
  ///
  /// @param tapeFormat [in] ex: kBetacamFormat, kBetacamSPFormat
  ///
  STDMETHOD(SetTapeFormat) (THIS_
    aafTapeFormatType_t  tapeFormat) PURE;


  //***********************************************************
  //
  // GetTapeFormat()
  //
  /// Gets the recording method of the tape.
  ///
  /// Succeeds if all of the following are true:
  /// - the pTapeFormat pointer is valid.
  /// 
  /// This method succeeds if all of the following are true:
  /// - the pTapeFormat pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTapeFormat arg is NULL.
  ///
  /// @param pTapeFormat [out] ex: kBetacamFormat, kBetacamSPFormat
  ///
  STDMETHOD(GetTapeFormat) (THIS_
    aafTapeFormatType_t *  pTapeFormat) PURE;


  //***********************************************************
  //
  // SetTapeLength()
  //
  /// Sets the length of the tape in minutes.
  /// 
  /// This method succeeds if all of the following are true:
  /// - tapeLength is a positive number.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_BAD_LENGTH
  ///	- tapeLength is negative.
  ///
  /// @param tapeLength [in] The length of the tape in minutes.
  ///
  STDMETHOD(SetTapeLength) (THIS_
    aafUInt32  tapeLength) PURE;


  //***********************************************************
  //
  // GetTapeLength()
  //
  /// Gets the length of the tape in minutes.
  ///
  /// This method succeeds if all of the following are true:
  /// - the pTapeLength pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pTapeLength.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTapeLength arg is NULL.
  ///
  /// @param pTapeLength [out] The length of the tape in minutes.
  ///
  STDMETHOD(GetTapeLength) (THIS_
    aafUInt32 *  pTapeLength) PURE;

  END_INTERFACE
};
#endif // __IAAFTapeDescriptor_INTERFACE_DEFINED__



// IAAFTextLocator

// ************************
//
// Interface IAAFTextLocator
//
// ************************




#ifndef __IAAFTextLocator_INTERFACE_DEFINED__
#define __IAAFTextLocator_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTextLocator;

#undef  INTERFACE
#define INTERFACE   IAAFTextLocator

DECLARE_INTERFACE_(IAAFTextLocator, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTextLocator methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty
  /// IAAFNetworkLocator-supporting object.  This method must be called
  /// after allocation, and before any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  STDMETHOD(Initialize) (THIS) PURE;


  //***********************************************************
  //
  // SetName()
  //
  /// Sets the Name string property.
  ///
  /// Set the Name property to the value specified in
  /// pName.  A copy is made of the data so the caller
  /// retains ownership of the *pName buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pName pointer is valid.
  /// 
  /// If this method fails the Name property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  ///
  /// @param pName [in, string] buffer from which Name is to be read
  ///
  STDMETHOD(SetName) (THIS_
    aafCharacter_constptr  pName) PURE;


  //***********************************************************
  //
  // GetName()
  //
  /// Gets the Name string property.
  /// 
  /// Writes the Name property, with a trailing null
  /// character, into the pName buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the Name property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetNameBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pName.
  /// 
  /// Succeeds if:
  /// - The pName pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   Name.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold Name.
  ///
  /// @param pName [out, string, size_is(bufSize)] buffer into which Name is to be written
  /// @param bufSize [in] size of *pName buffer in bytes
  ///
  STDMETHOD(GetName) (THIS_
    aafCharacter *  pName,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetNameBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetName().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetNameBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;

  END_INTERFACE
};
#endif // __IAAFTextLocator_INTERFACE_DEFINED__



// IAAFTimecode

// ************************
//
// Interface IAAFTimecode
//
// ************************



#ifndef __IAAFTimecode_INTERFACE_DEFINED__
#define __IAAFTimecode_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTimecode;

#undef  INTERFACE
#define INTERFACE   IAAFTimecode

DECLARE_INTERFACE_(IAAFTimecode, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTimecode methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes this object with the given length and timecode
  /// values.  Length is specified in units of the edit rate of the
  /// containing timeline mob slot.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has not yet been initialized.
  /// - the pTimecode pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTimecode argument is NULL.
  ///
  /// @param length [in] Length Property Value
  /// @param pTimecode [in] Timecode Value (startFrame, drop, fps)
  ///
  STDMETHOD(Initialize) (THIS_
    aafLength_t  length,
    aafTimecode_t*  pTimecode) PURE;


  //***********************************************************
  //
  // GetTimecode()
  //
  /// Get the timecode fields.
  ///
  /// Succeeds if all of the following are true:
  /// - the pTimecode pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pTimecode.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTimecode arg is NULL.
  ///
  /// @param pTimecode [out] Timecode (startFrame, drop, fps)
  ///
  STDMETHOD(GetTimecode) (THIS_
    aafTimecode_t *  pTimecode) PURE;


  //***********************************************************
  //
  // SetTimecode()
  //
  /// Set the timecode fields.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pTimecode pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTimecode arg is NULL.
  ///
  /// @param timecode [in] Timecode (startFrame, drop, fps)
  ///
  STDMETHOD(SetTimecode) (THIS_
    aafTimecode_t *  timecode) PURE;





  END_INTERFACE
};
#endif // __IAAFTimecode_INTERFACE_DEFINED__



// IAAFTimecodeStream

// ************************
//
// Interface IAAFTimecodeStream
//
// ************************




#ifndef __IAAFTimecodeStream_INTERFACE_DEFINED__
#define __IAAFTimecodeStream_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTimecodeStream;

#undef  INTERFACE
#define INTERFACE   IAAFTimecodeStream

DECLARE_INTERFACE_(IAAFTimecodeStream, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTimecodeStream methods *** */

  //***********************************************************
  //
  // GetPositionTimecode()
  //
  /// Get the timecode fields at the given position.
  ///
  /// @param position [in] Zero based offset to set the timecode at
  /// @param timecode [out] Timecode [startFrame drop fps]
  ///
  STDMETHOD(GetPositionTimecode) (THIS_
    aafPosition_t  position,
    aafTimecode_t *  timecode) PURE;


  //***********************************************************
  //
  // SetPositionTimecode()
  //
  /// Set the timecode fields for a given frame.  The frame index must
  /// be within the length of the object.
  ///
  /// @param position [in] Zero-based offset to set the timecode at
  /// @param timecode [in] Timecode [startFrame  drop  fps]
  ///
  STDMETHOD(SetPositionTimecode) (THIS_
    aafPosition_t  position,
    aafTimecode_t  timecode) PURE;


  //***********************************************************
  //
  // GetUserDataLength()
  //
  /// Gets the length of the user data for one frame.
  ///
  /// @param length [out] Fixed length of the user data [userbits] in bytes
  ///
  STDMETHOD(GetUserDataLength) (THIS_
    aafInt32 *  length) PURE;


  //***********************************************************
  //
  // GetUserDataAtPosition()
  //
  /// Gets the user data [userbits] for a particular frame.
  ///
  /// @param position [in] Zero-based offset
  /// @param buflen [in] Length of the buffer
  /// @param buffer [out] Passed in and filled with user data
  ///
  STDMETHOD(GetUserDataAtPosition) (THIS_
    aafPosition_t  position,
    aafInt32  buflen,
    aafDataBuffer_t  buffer) PURE;


  //***********************************************************
  //
  // SetUserDataAtPosition()
  //
  /// Gets the user data [userbits] for a particular frame.
  ///
  /// @param position [in] Zero-based offset to set the userbits at
  /// @param buflen [in] Length of the buffer
  /// @param buffer [in] user data for the given frame
  ///
  STDMETHOD(SetUserDataAtPosition) (THIS_
    aafPosition_t  position,
    aafInt32  buflen,
    aafDataBuffer_t  buffer) PURE;
							 

  //***********************************************************
  //
  // SetSampleRate()
  //
  /// Sets the sample rate of the timecode data.
  ///
  /// @param sampleRate [in] The sample rate of the timecode data
  ///
  STDMETHOD(SetSampleRate) (THIS_
    aafRational_t  sampleRate) PURE;


  //***********************************************************
  //
  // GetSampleRate()
  //
  /// Gets the sample rate of the timecode data.
  ///
  /// @param pSampleRate [out] The sample rate of the timecode data
  ///
  STDMETHOD(GetSampleRate) (THIS_
    aafRational_t *  pSampleRate) PURE;


  //***********************************************************
  //
  // SetSourceType()
  //
  /// Sets the type (LTC or VITC) of the timecode data.
  ///
  /// @param sourceType [in] The type (LTC or VITC) of the timecode data
  ///
  STDMETHOD(SetSourceType) (THIS_
    aafTimecodeSourceType_t  sourceType) PURE;


  //***********************************************************
  //
  // GetSourceType()
  //
  /// Gets the type (LTC or VITC) of the timecode data.
  ///
  /// @param pSourceType [out] The type (LTC or VITC) of the timecode data
  ///
  STDMETHOD(GetSourceType) (THIS_
    aafTimecodeSourceType_t *  pSourceType) PURE;


  //***********************************************************
  //
  // GetSampleSize()
  //
  /// Gets the size (in samples) of one sample of the timecode data.
  ///
  /// @param pSampleSize [out] The size (in bytes) of one sample of the timecode data
  ///
  STDMETHOD(GetSampleSize) (THIS_
    aafUInt32 *  pSampleSize) PURE;


  //***********************************************************
  //
  // GetSource()
  //
  /// Writes the entire timecode data value into the pValue buffer.
  /// The buffer is allocated by the caller, and the size of the
  /// buffer is given by valueSize.
  /// 
  /// Caller may call GetValueBufLen() to determine the
  /// required buffer size.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pValue pointer is valid.
  /// - valueSize indicates the buffer is large enough to hold the name.
  /// 
  /// If this method fails nothing will be written to *pValue.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pValue arg is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - valueSize indicates the buffer is too small to hold the value.
  ///
  /// @param valueSize [in] Size of preallocated buffer
  /// @param pValue [out, size_is(valueSize),length_is(*bytesRead)] Preallocated buffer to hold value
  /// @param bytesRead [out] Number of actual bytes read
  ///
  STDMETHOD(GetSource) (THIS_
    aafUInt32  valueSize,
    aafDataBuffer_t  pValue,
    aafUInt32*  bytesRead) PURE;


  //***********************************************************
  //
  // GetSourceBufLen()
  //
  /// Returns the length of buffer required for the GetValue()
  /// method.  The value is placed into the location specified by
  /// pLen.
  ///
  /// Succeeds if all of the following are true:
  /// - the pLen pointer is valid.
  ///
  /// If this method fails nothing will be written to *pLen.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLen arg is NULL.
  ///
  /// @param pLen [out] Pointer to an variable used to return the length
  ///
  STDMETHOD(GetSourceBufLen) (THIS_
    aafUInt32 *  pLen) PURE;


  //***********************************************************
  //
  // SetSource()
  //
  /// The data value is set from a buffer of size valueSize.
  ///
  /// Succeeds if all of the following are true:
  /// - the pValue pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pValue is null.
  ///
  /// @param valueSize [in] Size of preallocated buffer
  /// @param pValue [in, size_is(valueSize)] buffer containing value
  ///
  STDMETHOD(SetSource) (THIS_
    aafUInt32  valueSize,
    aafDataBuffer_t  pValue) PURE;







  END_INTERFACE
};
#endif // __IAAFTimecodeStream_INTERFACE_DEFINED__



// IAAFTimecodeStream12M

// ************************
//
// Interface IAAFTimecodeStream12M
//
// ************************



#ifndef __IAAFTimecodeStream12M_INTERFACE_DEFINED__
#define __IAAFTimecodeStream12M_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTimecodeStream12M;


#undef  INTERFACE
#define INTERFACE   IAAFTimecodeStream12M

DECLARE_INTERFACE_(IAAFTimecodeStream12M, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTimecodeStream12M methods *** */





  END_INTERFACE
};
#endif // __IAAFTimecodeStream12M_INTERFACE_DEFINED__



// IAAFTimelineMobSlot

// ************************
//
// Interface IAAFTimelineMobSlot
//
// ************************



#ifndef __IAAFTimelineMobSlot_INTERFACE_DEFINED__
#define __IAAFTimelineMobSlot_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTimelineMobSlot;

#undef  INTERFACE
#define INTERFACE   IAAFTimelineMobSlot

DECLARE_INTERFACE_(IAAFTimelineMobSlot, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTimelineMobSlot methods *** */
  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty
  /// IAAFTimelineMobSlot-supporting object.  This method must be
  /// called after allocation, and before any other method can be
  /// called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  STDMETHOD(Initialize) (THIS) PURE;


  //***********************************************************
  //
  // GetEditRate()
  //
  /// This method will get the edit rate for this mob slot.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pEditRate pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEditRate arg is NULL.
  ///
  /// @param pEditRate [out,retval] Edit rate property value
  ///
  STDMETHOD(GetEditRate) (THIS_
    aafRational_t *  pEditRate) PURE;


  //***********************************************************
  //
  // SetEditRate()
  //
  /// This method will get set edit rate for this mob slot.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param editRate [in] Edit rate property value
  ///
  STDMETHOD(SetEditRate) (THIS_
    aafRational_constref  editRate) PURE;


  //***********************************************************
  //
  // GetOrigin()
  //
  /// This method will return the origin of this mob slot.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pOrigin pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pOrigin arg is NULL.
  ///
  /// @param pOrigin [out,retval] Origin property value
  ///
  STDMETHOD(GetOrigin) (THIS_
    aafPosition_t *  pOrigin) PURE;


  //***********************************************************
  //
  // SetOrigin()
  //
  /// This method will set the origin of this mob slot.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.).
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param origin [in] Origin property value
  ///
  STDMETHOD(SetOrigin) (THIS_
    aafPosition_t  origin) PURE;








  END_INTERFACE
};
#endif // __IAAFTimelineMobSlot_INTERFACE_DEFINED__


// IAAFTransition

// ************************
//
// Interface IAAFTransition
//
// ************************








#ifndef __IAAFTransition_INTERFACE_DEFINED__
#define __IAAFTransition_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTransition;

#undef  INTERFACE
#define INTERFACE   IAAFTransition

DECLARE_INTERFACE_(IAAFTransition, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTransition methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Constructor which allows specification of starting values.
  ///
  /// @param pDataDef [in] Data Definition Object
  /// @param length [in] Length property value
  /// @param cutPoint [in] The point at which a cut would be inserted if the transition
	/// were removed
  /// @param op [in] A reference to an operation group object
  ///
  STDMETHOD(Initialize) (THIS_
    IAAFDataDef * pDataDef,
    aafLength_t  length,
    aafPosition_t  cutPoint,
    IAAFOperationGroup * op) PURE;	 


  //***********************************************************
  //
  // GetCutPoint()
  //
  /// Gets the point at which a cut would be inserted if the transition
  /// were removed.
  ///
  /// @param cutPoint [out] Cut Point
  ///
  STDMETHOD(GetCutPoint) (THIS_
    aafPosition_t *  cutPoint) PURE;


  //***********************************************************
  //
  // GetOperationGroup()
  //
  /// Gets the OperationGroup associated with the transition.
  ///
  /// @param groupObj [out] OperationGroup used by transition
  ///
  STDMETHOD(GetOperationGroup) (THIS_
    IAAFOperationGroup ** groupObj) PURE;


  //***********************************************************
  //
  // SetCutPoint()
  //
  /// Sets the point at which a cut would be inserted if the transition
  /// were removed.
  ///
  /// @param cutPoint [in] Cut Point
  ///
  STDMETHOD(SetCutPoint) (THIS_
    aafPosition_t  cutPoint) PURE;


  //***********************************************************
  //
  // SetOperationGroup()
  //
  /// Sets the operation group associated with the transition.
  ///
  /// @param opgroup [in] Operation group used by transition
  ///
  STDMETHOD(SetOperationGroup) (THIS_
    IAAFOperationGroup * opgroup) PURE;

  END_INTERFACE
};
#endif // __IAAFTransition_INTERFACE_DEFINED__



// IAAFTypeDef

// ************************
//
// Interface IAAFTypeDef
//
// ************************



#ifndef __IAAFTypeDef_INTERFACE_DEFINED__
#define __IAAFTypeDef_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDef;

#undef  INTERFACE
#define INTERFACE   IAAFTypeDef

DECLARE_INTERFACE_(IAAFTypeDef, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDef methods *** */

  //***********************************************************
  //
  // GetTypeCategory()
  //
  /// Returns the type category to which this type definition belongs.
  /// 
  /// Succeeds if:
  /// - The pTid argument is valid
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTid arg is NULL.
  ///
  /// @param pTid [out] Returned type category
  ///
  STDMETHOD(GetTypeCategory) (THIS_
    eAAFTypeCategory_t *  pTid) PURE;


  //***********************************************************
  //
  // RawAccessType()
  //
  /// This method returns the type def through which values of this
  /// type may be accessed if the client wishes to access the value as
  /// as raw data.
    /// NOTE! Stub only.   Implementation not yet added.
  ///

  /// 
  /// Succeeds if:
  /// - The ppRawTYPEDEF argument is valid
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppRawTypeDef arg is NULL.
  ///
  /// @param ppRawTypeDef [out] the raw access type definition
  ///
  STDMETHOD(RawAccessType) (THIS_
    IAAFTypeDef ** ppRawTypeDef) PURE;



  END_INTERFACE
};
#endif // __IAAFTypeDef_INTERFACE_DEFINED__



// IAAFTypeDefCharacter

// ************************
//
// Interface IAAFTypeDefCharacter
//
// ************************





#ifndef __IAAFTypeDefCharacter_INTERFACE_DEFINED__
#define __IAAFTypeDefCharacter_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDefCharacter;

#undef  INTERFACE
#define INTERFACE   IAAFTypeDefCharacter

DECLARE_INTERFACE_(IAAFTypeDefCharacter, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDefCharacter methods *** */


  //***********************************************************
  //
  // CreateValueFromCharacter()
  //
  /// Gets a property value corresponding to the character data. 
  /// 
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - The pCharacterValue pointer is valid.
  /// - The ppActualPropertyValue pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppCharacterValue is not a valid pointer.
  ///
  ///
  /// @param character [in] character data to write the the new value
  /// @param ppCharacterValue [out] character property value with the given character
  ///
  STDMETHOD(CreateValueFromCharacter) (THIS_
    aafCharacter  character,
    IAAFPropertyValue ** ppCharacterValue) PURE;

  //***********************************************************
  //
  // GetCharacter()
  //
  /// Gets a character from the property value. 
  /// 
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - The pCharacterValue pointer is valid.
  /// - The ppActualPropertyValue pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - pCharacterValue is not a valid character property value.
  ///
  ///
  /// @param pCharacterValue [in] character property value to read
  /// @param pCharacter [out] character that is read
  ///
  STDMETHOD(GetCharacter) (THIS_
    IAAFPropertyValue * pCharacterValue,
    aafCharacter *  pCharacter) PURE;

  //***********************************************************
  //
  // SetCharacter()
  //
  /// Sets a character into the given property value. 
  /// 
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - The pCharacterValue pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - pCharacterValue is not a valid character property value.
  ///
  ///
  /// @param pCharacterValue [in] character property value to modify
  /// @param character [in] character that is written
  ///
  STDMETHOD(SetCharacter) (THIS_
    IAAFPropertyValue * pCharacterValue,
    aafCharacter  character) PURE;




  END_INTERFACE
};
#endif // __IAAFTypeDefCharacter_INTERFACE_DEFINED__



// IAAFTypeDefEnum

// ************************
//
// Interface IAAFTypeDefEnum
//
// ************************




#ifndef __IAAFTypeDefEnum_INTERFACE_DEFINED__
#define __IAAFTypeDefEnum_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDefEnum;

#undef  INTERFACE
#define INTERFACE   IAAFTypeDefEnum

DECLARE_INTERFACE_(IAAFTypeDefEnum, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDefEnum methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes this type def to be identified by the given guid, to
  /// be implemented as the given data type, and to contain the given
  /// elements (names and values).  The given data type must be an
  /// integral type.  It is considered an error if multiple elements
  /// have the same name or the same value.  The values and names are
  /// given in parallel arrays, each of which has numElements
  /// elements.
  ///
  /// This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  /// - pID is a valid pointer.
  /// - pType is a valid pointer.
  /// - pElementValues is a valid pointer.
  /// - pElementNames is a valid pointer.
  /// - pTypeName is a valid pointer.
  /// - base type is integral type.
  /// - no duplicate names or values are found.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - This object has already had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - any pointer argument arg is NULL.
  ///
  /// AAFRESULT_DUPLICATE
  ///   - duplicate name or value is found.
  ///
  /// AAFRESULT_BAD_TYPE
  ///   - base type is not integral type.
  ///
  /// @param id [in, ref] auid to be used to identify this type
  /// @param pType [in] Type of values in this enumeration.
  /// Has to be of type Int
  /// @param pElementValues [in, size_is(numElems)] array of element values to be represented in this enumerated
  /// type
  /// @param pElementNames [in, size_is(numElems)] array of element names to be represented in this enumerated
  /// type
  /// @param numElems [in] number of members in pElementValues and pElementNames arrays
  /// @param pTypeName [in] friendly name of this type definition
  ///
  STDMETHOD(Initialize) (THIS_
    aafUID_constref  id,
    IAAFTypeDef * pType,
    aafInt64 *  pElementValues,
    aafString_t *  pElementNames,
    aafUInt32  numElems,
    aafCharacter_constptr  pTypeName) PURE;


  //***********************************************************
  //
  // CreateValueFromName()
  //
  /// Creates a property value which contains an Enum type.  A
  /// lookup on the Name is done to find a match in the list of 
  /// legal enumerations for this type. If the Name specified is not
  /// found to exist then an INVALID_PARAM error code is returned.
  /// If it succeeds then a newly-created property value in ppPropVal
  /// is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the Name pointer is valid.
  /// - the ppPropVal pointer is valid.
  ///
  /// If this method fails nothing will be written to *ppPropVal.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppPropVal arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - the Name specified is not in the list of legal Enumerations.
  ///
  /// @param Name [in] the Name of a valid Enum symbol
  /// @param ppPropVal [out] newly created property value
  ///
  STDMETHOD(CreateValueFromName) (THIS_
    aafCharacter_constptr  Name,
    IAAFPropertyValue ** ppPropVal) PURE;
  
  
  
  //***********************************************************
  //
  // GetElementType()
  //
  /// Returns the type definition of the values which are found in this
  /// enumeration.
  /// 
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - The ppTypeDef pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTypeDef arg is NULL.
  ///
  /// @param ppTypeDef [out] type definition of values of this enumeration
  ///
  STDMETHOD(GetElementType) (THIS_
    IAAFTypeDef ** ppTypeDef) PURE;

  //***********************************************************
  //
  // GetElementValue()
  //
  /// Gets the indexed element in this enumerated type.  The
  /// value is written into the client-allocated *pOutValue.  Index
  /// must be less than the value returned by CountElements().
  ///
  /// Succeeds if:
  /// - pOutValue is a valid pointer.
  /// - index is less than CountElements().
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pOutValue arg is NULL.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is not less than CountElements().
  ///
  /// @param index [in] index of element to retrieve
  /// @param pOutValue [out] requested value
  ///
  STDMETHOD(GetElementValue) (THIS_
    aafUInt32  index,
    aafInt64 *  pOutValue) PURE;

  //***********************************************************
  //
  // GetElementName()
  //
  /// Gets the indexed element in this enumerated type.  The
  /// Name is written into the client-allocated *pOutValue. The
  /// bufSize argument should be large enough to hold the pOutValue.
  /// Index must be less than the value returned by CountElements().
  ///
  /// Caller may call GetElementNameBufLen() to determine the
  /// required buffer size.
  ///  
  /// Succeeds if:
  /// - pOutValue is a valid pointer.
  /// - index is less than CountElements().
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pOutValue arg is NULL.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is not less than CountElements().
  ///
  /// AAFRESULT_SMALLBUF
  ///   - bufSize indicates the buffer is too small to hold the string.
  ///
  ///
  /// @param index [in] index of element to retrieve
  /// @param pOutValue [out, size_is(bufSize)] requested value
  /// @param bufSize [in] The size of the pOutValue buffer in bytes
  ///
  STDMETHOD(GetElementName) (THIS_
    aafUInt32  index,
    aafCharacter *  pOutValue,
    aafUInt32  bufSize) PURE;
  
  

  //***********************************************************
  //
  // GetElementNameBufLen()
  //
  /// Returns the length of buffer required for the GetElementName()
  /// method, in bytes.  The value is placed into the location
  /// specified by pLen. The value will include space required for the
  /// trailing null character.
  ///
  /// Succeeds if the following is true:
  /// - the pLen pointer is valid.
  /// - index is less than CountElements().
  ///
  /// If this method fails nothing will be written to *pLen.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLen arg is NULL.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is not less than CountElements().
  ///
  ///
  /// @param index [in] index of element to retrieve
  /// @param pLen [out] required buffer length, in bytes
  ///
  STDMETHOD(GetElementNameBufLen) (THIS_
    aafUInt32  index,
    aafUInt32 *  pLen) PURE;



  
  //***********************************************************
  //
  // CountElements()
  //
  /// Returns number of enumeration elements contained.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pCount is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCount arg is NULL.
  ///
  /// @param pCount [out] count of elements within this enumeration
  ///
  STDMETHOD(CountElements) (THIS_
    aafUInt32 *  pCount) PURE;



  //***********************************************************
  //
  // GetNameFromValue()
  //
  /// Writes the human-legible tag associated with the given value in
  /// this enumerated type.  The name is written, with a trailing null
  /// character, into the pName buffer.  The buffer is allocated by
  /// the caller.  The size of the buffer is given by bufSize.
  /// 
  /// Caller may call GetNameBufLenFromValue() to determine the
  /// required buffer size.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pValue pointer is valid.
  /// - the pName pointer is valid.
  /// - bufSize indicates the buffer is large enough to hold the name.
  /// - the integer value is associated with an element of this
  ///   enumerated type.
  /// 
  /// If this method fails nothing will be written to
  /// *pName.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pValue or pName arg is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - bufSize indicates the buffer is too small to hold the string.
  ///
  /// AAFRESULT_BAD_PARAM
  ///   - the given value is not associated with an element of
  ///     this type.
  ///
  /// @param pValue [in] value of element to get
  /// @param pName [out, size_is(bufSize), string] buffer into which the element name is written
  /// @param bufSize [in] The size of the pName buffer, in bytes
  ///
  STDMETHOD(GetNameFromValue) (THIS_
    IAAFPropertyValue * pValue,
    aafCharacter *  pName,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetNameBufLenFromValue()
  //
  /// Returns the length of buffer required for the GetNameFromValue()
  /// method, in bytes.  The value is placed into the location
  /// specified by pLen. The value will include space required for the
  /// trailing null character.
  ///
  /// Succeeds if all of the following are true:
  /// - the pValue pointer is valid.
  /// - the pLen pointer is valid.
  /// - the value is associated with an element of this enumerated
  ///   type.
  ///
  /// If this method fails nothing will be written to *pLen.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pValue or pLen arg is NULL.
  ///
  /// AAFRESULT_BAD_PARAM
  ///   - the given value is not associated with an element of this
  ///     type.
  ///
  /// @param pValue [in] value of element to get
  /// @param pLen [out] required buffer length, in bytes
  ///
  STDMETHOD(GetNameBufLenFromValue) (THIS_
    IAAFPropertyValue * pValue,
    aafUInt32 *  pLen) PURE;


  //***********************************************************
  //
  // GetNameFromInteger()
  //
  /// Writes the human-legible tag associated with the given value in
  /// this enumerated type.  The name is written, with a trailing null
  /// character, into the pName buffer.  The buffer is allocated by
  /// the caller.  The size of the buffer is given by bufSize.
  /// 
  /// Caller may call GetNameBufLenFromInteger() to determine the
  /// required buffer size.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pName pointer is valid.
  /// - bufSize indicates the buffer is large enough to hold the name.
  /// - the integer value is associated with an element of this
  ///   enumerated type.
  /// 
  /// If this method fails nothing will be written to
  /// *pName.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - bufSize indicates the buffer is too small to hold the string.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - the given value is not associated with an element of
  ///     this type.
  ///
  /// @param value [in] value of element to get
  /// @param pName [out, size_is(bufSize), string] buffer into which the element name is written
  /// @param bufSize [in] The size of the pName buffer, in bytes
  ///
  STDMETHOD(GetNameFromInteger) (THIS_
    aafInt64  value,
    aafCharacter *  pName,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetNameBufLenFromInteger()
  //
  /// Returns the length of buffer required for the GetNameFromInteger()
  /// method, in bytes.  The value is placed into the location
  /// specified by pLen. The value will include space required for the
  /// trailing null character.
  ///
  /// Succeeds if all of the following are true:
  /// - the pLen pointer is valid.
  /// - the value is associated with an element of this enumerated
  ///   type.
  ///
  /// If this method fails nothing will be written to *pLen.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLen arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - the given value is not associated with an element of this
  ///     type.
  ///
  /// @param value [in] value of element to get
  /// @param pLen [out] required buffer length, in bytes
  ///
  STDMETHOD(GetNameBufLenFromInteger) (THIS_
    aafInt64  value,
    aafUInt32 *  pLen) PURE;


  //***********************************************************
  //
  // GetIntegerValue()
  //
  /// Gets the value from the given property value and writes it as an
  /// integer into *pValueOut.
  ///
  /// Succeeds if:
  /// - The pPropValIn pointer is valid.
  /// - The pValueOut pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pPropValIn or ppPropValOut arg is NULL.
  ///
  /// @param pPropValIn [in] property value to read
  /// @param pValueOut [out] value of the enum represented by the given input property value
  ///
  STDMETHOD(GetIntegerValue) (THIS_
    IAAFPropertyValue * pPropValIn,
    aafInt64 *  pValueOut) PURE;


  //***********************************************************
  //
  // SetIntegerValue()
  //
  /// Sets the given property to the value given in pValueIn.
  ///
  /// Succeeds if:
  /// - The pPropValToSet pointer is valid.
  /// - valueIn is a correct value for this enumerated type.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPropValToSet arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - valueIn is not a correct value for this enumerated type.
  ///   - pPropValIn's type doesn't match GetElementType()
  ///
  /// @param pPropValToSet [in] property value to set
  /// @param valueIn [in] new value of the enum represented by the given property value
  ///
  STDMETHOD(SetIntegerValue) (THIS_
    IAAFPropertyValue * pPropValToSet,
    aafInt64  valueIn) PURE;


  //***********************************************************
  //
  // RegisterSize()
  //
  /// Allows client to register to the reference implementation a
  /// runtime C enum to represent objects of this TypeDef.  The size of
  /// the enum to be represented should be passed as the enumSize
  /// argument.  This allows the reference implementation to write
  /// property values into compile-time-defined C enums intelligible
  /// by the local machine and compiler.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param enumSize [in] size of this enum
  ///
  STDMETHOD(RegisterSize) (THIS_
    aafUInt32  enumSize) PURE;


  END_INTERFACE
};
#endif // __IAAFTypeDefEnum_INTERFACE_DEFINED__



// IAAFTypeDefExtEnum

// ************************
//
// Interface IAAFTypeDefExtEnum
//
// ************************




#ifndef __IAAFTypeDefExtEnum_INTERFACE_DEFINED__
#define __IAAFTypeDefExtEnum_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDefExtEnum;

#undef  INTERFACE
#define INTERFACE   IAAFTypeDefExtEnum

DECLARE_INTERFACE_(IAAFTypeDefExtEnum, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDefExtEnum methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes this type def to be identified by the given guid.  No
  /// element values are initially specified; they must be supplied
  /// later using the AppendElement method.
  ///
  /// This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  /// - pID is a valid pointer.
  /// - pTypeName is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - This object has already had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTypeName arg is NULL.
  ///
  /// AAFRESULT_DUPLICATE
  ///   - duplicate name or value is found.
  ///
  /// @param id [in, ref] auid to be used to identify this type
  /// @param pTypeName [in] friendly name of this type definition
  ///
  STDMETHOD(Initialize) (THIS_
    aafUID_constref  id,
    aafCharacter_constptr  pTypeName) PURE;

  //***********************************************************
  //
  // CreateValueFromName()
  //
  /// Creates a property value which contains an Enum type.  A
  /// lookup on the Name is done to find a match in the list of 
  /// legal enumerations for this type. If the Name specified is not
  /// found to exist then an INVALID_PARAM error code is returned.
  /// If it succeeds then a newly-created property value in ppPropVal
  /// is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the Name pointer is valid.
  /// - the ppPropVal pointer is valid.
  ///
  /// If this method fails nothing will be written to *ppPropVal.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppPropVal arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - the Name specified is not in the list of legal Enumerations.
  ///
  /// @param Name [in] the Name of a valid Enum symbol
  /// @param ppPropVal [out] newly created property value
  ///
  STDMETHOD(CreateValueFromName) (THIS_
    aafCharacter_constptr  Name,
    IAAFPropertyValue ** ppPropVal) PURE;
  

  //***********************************************************
  //
  // CountElements()
  //
  /// Returns number of enumeration elements contained.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pCount is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCount arg is NULL.
  ///
  /// @param pCount [out] count of elements within this enumeration
  ///
  STDMETHOD(CountElements) (THIS_
    aafUInt32 *  pCount) PURE;


  //***********************************************************
  //
  // GetElementValue()
  //
  /// Gets the indexed element in this enumerated type.  The
  /// value is written into the client-allocated *pOutValue.  Index
  /// must be less than the value returned by CountElements().
  ///
  /// Succeeds if:
  /// - pOutValue is a valid pointer.
  /// - index is less than CountElements().
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pOutValue arg is NULL.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is not less than CountElements().
  ///
  /// @param index [in] index of element to retrieve
  /// @param pOutValue [out] requested value
  ///
  STDMETHOD(GetElementValue) (THIS_
    aafUInt32  index,
    aafUID_t *  pOutValue) PURE;


  //***********************************************************
  //
  // GetElementName()
  //
  /// Gets the indexed element in this enumerated type.  The
  /// Name is written into the client-allocated *pOutValue. The
  /// bufSize argument should be large enough to hold the pOutValue.
  /// Index must be less than the value returned by CountElements().
  ///
  /// Caller may call GetElementNameBufLen() to determine the
  /// required buffer size.
  ///  
  /// Succeeds if:
  /// - pOutValue is a valid pointer.
  /// - index is less than CountElements().
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pOutValue arg is NULL.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is not less than CountElements().
  ///
  /// AAFRESULT_SMALLBUF
  ///   - bufSize indicates the buffer is too small to hold the string.
  ///
  ///
  /// @param index [in] index of element to retrieve
  /// @param pOutValue [out, size_is(bufSize)] requested value
  /// @param bufSize [in] The size of the pOutValue buffer in bytes
  ///
  STDMETHOD(GetElementName) (THIS_
    aafUInt32  index,
    aafCharacter *  pOutValue,
    aafUInt32  bufSize) PURE;
  
  //***********************************************************
  //
  // GetElementNameBufLen()
  //
  /// Returns the length of buffer required for the GetElementName()
  /// method, in bytes.  The value is placed into the location
  /// specified by pLen. The value will include space required for the
  /// trailing null character.
  ///
  /// Succeeds if the following is true:
  /// - the pLen pointer is valid.
  /// - index is less than CountElements().
  ///
  /// If this method fails nothing will be written to *pLen.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLen arg is NULL.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is not less than CountElements().
  ///
  ///
  /// @param index [in] index of element to retrieve
  /// @param pLen [out] required buffer length, in bytes
  ///
  STDMETHOD(GetElementNameBufLen) (THIS_
    aafUInt32  index,
    aafUInt32 *  pLen) PURE;


  //***********************************************************
  //
  // GetNameFromValue()
  //
  /// Writes the human-legible tag associated with the given value in
  /// this enumerated type.  The name is written, with a trailing null
  /// character, into the pName buffer.  The buffer is allocated by
  /// the caller.  The size of the buffer is given by bufSize.
  /// 
  /// Caller may call GetNameBufLenFromValue() to determine the
  /// required buffer size.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pValue pointer is valid.
  /// - the pName pointer is valid.
  /// - bufSize indicates the buffer is large enough to hold the name.
  /// - the integer value is associated with an element of this
  ///   enumerated type.
  /// 
  /// If this method fails nothing will be written to
  /// *pName.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pValue or pName arg is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - bufSize indicates the buffer is too small to hold the string.
  ///
  /// AAFRESULT_BAD_PARAM
  ///   - the given value is not associated with an element of
  ///     this type.
  ///
  /// @param pValue [in] value of element to get
  /// @param pName [out, size_is(bufSize), string] buffer into which the element name is written
  /// @param bufSize [in] The size of the pName buffer, in bytes
  ///
  STDMETHOD(GetNameFromValue) (THIS_
    IAAFPropertyValue * pValue,
    aafCharacter *  pName,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetNameBufLenFromValue()
  //
  /// Returns the length of buffer required for the GetNameFromValue()
  /// method, in bytes.  The value is placed into the location
  /// specified by pLen. The value will include space required for the
  /// trailing null character.
  ///
  /// Succeeds if all of the following are true:
  /// - the pValue pointer is valid.
  /// - the pLen pointer is valid.
  /// - the value is associated with an element of this enumerated
  ///   type.
  ///
  /// If this method fails nothing will be written to *pLen.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pValue or pLen arg is NULL.
  ///
  /// AAFRESULT_BAD_PARAM
  ///   - the given value is not associated with an element of this
  ///     type.
  ///
  /// @param pValue [in] value of element to get
  /// @param pLen [out] required buffer length, in bytes
  ///
  STDMETHOD(GetNameBufLenFromValue) (THIS_
    IAAFPropertyValue * pValue,
    aafUInt32 *  pLen) PURE;


  //***********************************************************
  //
  // GetNameFromAUID()
  //
  /// Writes the human-legible tag associated with the given value in
  /// this enumerated type.  The name is written, with a trailing null
  /// character, into the pName buffer.  The buffer is allocated by
  /// the caller.  The size of the buffer is given by bufSize.
  /// 
  /// Caller may call GetNameBufLenFromAUID() to determine the
  /// required buffer size.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pName pointer is valid.
  /// - bufSize indicates the buffer is large enough to hold the name.
  /// - the integer value is associated with an element of this
  ///   enumerated type.
  /// 
  /// If this method fails nothing will be written to
  /// *pName.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - bufSize indicates the buffer is too small to hold the string.
  ///
  /// AAFRESULT_BAD_PARAM
  ///   - the given value is not associated with an element of
  ///     this type.
  ///
  /// @param value [in, ref] value of element to get
  /// @param pName [out, size_is(bufSize), string] buffer into which the element name is written
  /// @param bufSize [in] The size of the pName buffer, in bytes
  ///
  STDMETHOD(GetNameFromAUID) (THIS_
    aafUID_constref  value,
    aafCharacter *  pName,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetNameBufLenFromAUID()
  //
  /// Returns the length of buffer required for the GetNameFromInteger()
  /// method, in bytes.  The value is placed into the location
  /// specified by pLen. The value will include space required for the
  /// trailing null character.
  ///
  /// Succeeds if all of the following are true:
  /// - the pLen pointer is valid.
  /// - the value is associated with an element of this enumerated
  ///   type.
  ///
  /// If this method fails nothing will be written to *pLen.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLen arg is NULL.
  ///
  /// AAFRESULT_BAD_PARAM
  ///   - the given value is not associated with an element of this
  ///     type.
  ///
  /// @param value [in, ref] value of element to get
  /// @param pLen [out] required buffer length, in bytes
  ///
  STDMETHOD(GetNameBufLenFromAUID) (THIS_
    aafUID_constref  value,
    aafUInt32 *  pLen) PURE;


  //***********************************************************
  //
  // GetAUIDValue()
  //
  /// Gets the value from the given property value and writes it as an
  /// AUID into *pValueOut.
  ///
  /// Succeeds if:
  /// - The pPropValIn pointer is valid.
  /// - The pValueOut pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pPropValIn or ppPropValOut arg is NULL.
  ///
  /// @param pPropValIn [in] property value to read
  /// @param pValueOut [out] value of the enum represented by the given input property value
  ///
  STDMETHOD(GetAUIDValue) (THIS_
    IAAFPropertyValue * pPropValIn,
    aafUID_t *  pValueOut) PURE;


  //***********************************************************
  //
  // SetAUIDValue()
  //
  /// Sets the given property to the value given in valueIn.
  ///
  /// Succeeds if:
  /// - The pPropValToSet pointer is valid.
  /// - valueIn is a correct value for this enumerated type.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPropValToSet arg is NULL.
  ///
  /// AAFRESULT_BAD_PARAM
  ///   - valueIn is not a correct value for this enumerated type.
  ///   - pPropValIn's type doesn't match GetElementType()
  ///
  /// @param pPropValToSet [in] property value to set
  /// @param valueIn [in, ref] new value of the enum represented by the given property value
  ///
  STDMETHOD(SetAUIDValue) (THIS_
    IAAFPropertyValue * pPropValToSet,
    aafUID_constref  valueIn) PURE;


  //***********************************************************
  //
  // AppendElement()
  //
  /// Appends a new element to this extendible enumeration.  The
  /// element will have the given name and value.  It is not legal to
  /// have elements with duplicate names or values.
  /// 
  /// Succeeds if:
  /// - the pName pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  ///
  /// AAFRESULT_DUPLICATE
  ///   - duplicate name or value is found.
  ///
  /// @param value [in, ref] value of appended element
  /// @param pName [in] name of appended element
  ///
  STDMETHOD(AppendElement) (THIS_
    aafUID_constref  value,
    aafCharacter_constptr  pName) PURE;




  END_INTERFACE
};
#endif // __IAAFTypeDefExtEnum_INTERFACE_DEFINED__



// IAAFTypeDefFixedArray

// ************************
//
// Interface IAAFTypeDefFixedArray
//
// ************************





#ifndef __IAAFTypeDefFixedArray_INTERFACE_DEFINED__
#define __IAAFTypeDefFixedArray_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDefFixedArray;

#undef  INTERFACE
#define INTERFACE   IAAFTypeDefFixedArray

DECLARE_INTERFACE_(IAAFTypeDefFixedArray, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDefFixedArray methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes this type def to contain elements of the given type,
  /// and have the given fixed size.  Note that it is only possible to
  /// use certain types as the element type.  Those permissible types
  /// include:
  /// - AAFTypeDefInt
  /// - AAFTypeDefRecord
  /// - AAFTypeDefEnum
  /// - AAFTypeDefExtEnum
  /// - AAFTypeDefFixedArray
  ///
  /// This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  /// - pID is a valid pointer.
  /// - pTypeDef is a valid pointer.
  /// - pTypeName is a valid pointer.
  /// - element type is permissible for use in a FixedArray.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - This object has already had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pTypeDef or pTypeName arg is NULL.
  ///
  /// AAFRESULT_BAD_TYPE
  ///   - an illegal element type was given.
  ///
  /// @param id [in, ref] auid to be used to identify this type
  /// @param pTypeDef [in] type of each element to be contained in this array
  /// @param nElements [in] number of elements to be in this array
  /// @param pTypeName [in] friendly name of this type definition
  ///
  STDMETHOD(Initialize) (THIS_
    aafUID_constref  id,
    IAAFTypeDef * pTypeDef,
    aafUInt32  nElements,
    aafCharacter_constptr  pTypeName) PURE;


  //***********************************************************
  //
  // GetType()
  //
  /// Returns the type of elements in this array.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - ppTypeDef is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTypeDef arg is NULL.
  ///
  /// @param ppTypeDef [out] type of elements in this array
  ///
  STDMETHOD(GetType) (THIS_
    IAAFTypeDef ** ppTypeDef) PURE;


  //***********************************************************
  //
  // GetCount()
  //
  /// Returns number of elements in this array.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pCount is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCount arg is NULL.
  ///
  /// @param pCount [out] count of elements in this array
  ///
  STDMETHOD(GetCount) (THIS_
    aafUInt32 *  pCount) PURE;


  //***********************************************************
  //
  // CreateValueFromValues()
  //
  /// Creates a property value which contains a fixed array type.  The
  /// array elements in the property value are initialized to contain
  /// the given values, passed in the pElementValues array.
  /// numElements, which indicates the size of the pElementValues
  /// array, must match the value returned by GetCount().  Returns
  /// the newly-created property value in ppPropVal.
  ///
  /// Succeeds if all of the following are true:
  /// - the pElementValues pointer is valid.
  /// - the ppPropVal pointer is valid.
  /// - numElements matches the number of elements in this array
  ///
  /// If this method fails nothing will be written to *ppPropVal.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pElementValues or ppPropVal arg is NULL.
  ///
  /// AAFRESULT_BAD_PARAM
  ///   - numElements does not match GetCount().
  ///
  /// @param ppElementValues [in, size_is(numElements)] array of property values for elements of array value which
  /// is to be created.
  /// @param numElements [in] size of pElementValues array.
  /// @param ppPropVal [out] newly-created property value
  ///
  STDMETHOD(CreateValueFromValues) (THIS_
    IAAFPropertyValue ** ppElementValues,
    aafUInt32  numElements,
    IAAFPropertyValue ** ppPropVal) PURE;


  //***********************************************************
  //
  // CreateValueFromCArray()
  //
  /// Creates a property value which contains a fixed array type.  The
  /// array elements in the property value are initialized from data in
  /// a C array which is pointed to by pInitData.  Requires that any
  /// structures declared within this array typedef have had their
  /// offsets registered with that type.  Returns the newly-created
  /// property value in ppPropVal.
  ///
  /// Succeeds if all of the following are true:
  /// - the pInitData pointer is valid.
  /// - the ppPropVal pointer is valid.
  /// - initDataSize indicates pInitData is the correct size.
  /// - compile-time struct has had its member offests registered.
  ///
  /// If this method fails nothing will be written to *ppPropVal.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pInitData or ppPropVal arg is NULL.
  ///
  /// AAFRESULT_BAD_PARAM
  ///   - initDataSize indicates pInitData is of the wrong size.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - any contained struct offsets have not yet been registered for
  ///    that typedef.
  ///
  /// @param pInitData [in, size_is(initDataSize)] pointer to compile-time C array containing data to use
  /// @param initDataSize [in] size of data in pInitData, in bytes
  /// @param ppPropVal [out] newly created property value
  ///
  STDMETHOD(CreateValueFromCArray) (THIS_
    aafMemPtr_t  pInitData,
    aafUInt32  initDataSize,
    IAAFPropertyValue ** ppPropVal) PURE;


  //***********************************************************
  //
  // GetElementValue()
  //
  /// Gets a single property value corresponding to the indexed array
  /// element.  Places a property value representing the array element
  /// identified by the index into ppOutPropval.  Index is zero-based,
  /// and must be less than the value returned by GetCount().
  /// 
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - the index exists in this array type def.
  /// - The pInPropVal pointer is valid.
  /// - The ppOutPropVal pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pInPropVal or ppOutPropVal arg is NULL.
  ///
  /// AAFRESULT_BAD_PARAM
  ///   - The given index is out of range for this array type def.
  ///
  /// @param pInPropVal [in] property value to read
  /// @param index [in] zero-based index into elements in this array type
  /// @param ppOutPropVal [out] value that is read
  ///
  STDMETHOD(GetElementValue) (THIS_
    IAAFPropertyValue * pInPropVal,
    aafUInt32  index,
    IAAFPropertyValue ** ppOutPropVal) PURE;


  //***********************************************************
  //
  // GetCArray()
  //
  /// Copies all the array data contained in the given property value,
  /// interpreted as a fixed array of this type, into the C array
  /// pointed to by pData.  Requires that any structures declared
  /// within this array typedef have had their offsets registered with
  /// that type.
  ///
  /// Succeeds if all of the following are true:
  /// - the pPropVal pointer is valid.
  /// - the pData pointer is valid.
  /// - dataSize indicates pData is large enough to hold the data.
  /// - compile-time struct has had its member offests registered.
  ///
  /// If this method fails nothing will be written to *ppPropVal.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pPropVal or pData arg is NULL.
  ///
  /// AAFRESULT_BAD_PARAM
  ///   - dataSize indicates pData is too small.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for this typedef.
  ///
  /// @param pPropVal [in] property value to read
  /// @param pData [out, size_is(dataSize)] buffer into which C array data should be written
  /// @param dataSize [in] size of pData buffer in bytes
  ///
  STDMETHOD(GetCArray) (THIS_
    IAAFPropertyValue * pPropVal,
    aafMemPtr_t  pData,
    aafUInt32  dataSize) PURE;


  //***********************************************************
  //
  // SetElementValue()
  //
  /// Sets the value of the single, indicated element of the fixed
  /// array contained in pPropVal, to the value contained in
  /// pMemberPropVal.  Index is zero-based, and must be less than the
  /// value returned by GetCount().  Property value must be of the
  /// same type as returned by GetType().
  /// 
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - the index exists in this array type def.
  /// - The pInPropVal pointer is valid.
  /// - The ppOutPropVal pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pInPropVal or ppOutPropVal arg is NULL.
  ///
  /// AAFRESULT_BAD_PARAM
  ///   - The given index is out of range for this array type def.
  ///
  /// @param pPropVal [in] property value to write
  /// @param index [in] zero-based index into members in this array type
  /// @param pMemberPropVal [in] value to be placed into this array
  ///
  STDMETHOD(SetElementValue) (THIS_
    IAAFPropertyValue * pPropVal,
    aafUInt32  index,
    IAAFPropertyValue * pMemberPropVal) PURE;


  //***********************************************************
  //
  // SetCArray()
  //
  /// Copies all the array data contained in the C array pointed to by
  /// pData into the given property value, interpreting the data as a
  /// fixed array of this type.  Requires that any structures declared
  /// within this typedef have had their offsets registered with that
  /// type.
  ///
  /// Succeeds if all of the following are true:
  /// - the pPropVal pointer is valid.
  /// - the pData pointer is valid.
  /// - dataSize indicates pData contains the correct amount of data.
  /// - any contained compile-time struct has had its member offests
  ///   registered.
  ///
  /// If this method fails nothing will be written to *ppPropVal.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pPropVal or pData arg is NULL.
  ///
  /// AAFRESULT_BAD_PARAM
  ///  - dataSize indicates pData is not the correct size.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - offsets of any contained struct have not yet been registered.
  ///
  /// @param pPropVal [in] property value to write
  /// @param pData [in, size_is(dataSize)] buffer from which C array data should be read
  /// @param dataSize [in] size of pData buffer in bytes
  ///
  STDMETHOD(SetCArray) (THIS_
    IAAFPropertyValue * pPropVal,
    aafMemPtr_t  pData,
    aafUInt32  dataSize) PURE;




  //***********************************************************
  //
  // GetElements()
  //
  /// Returns an enumerator across elements in this set.
  /// 
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - The PSetPropVal pointer is valid.
  /// - The ppEnum pointer is valid.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either PSetPropVal or ppEnum arg is NULL.
  ///
  /// @param PSetPropVal [in] property value to read
  /// @param ppEnum [out] enumerator across property values
  ///
  STDMETHOD(GetElements) (THIS_
    IAAFPropertyValue * PSetPropVal,
    IEnumAAFPropertyValues ** ppEnum) PURE;


  END_INTERFACE
};
#endif // __IAAFTypeDefFixedArray_INTERFACE_DEFINED__



// IAAFTypeDefIndirect

// ************************
//
// Interface IAAFTypeDefIndirect
//
// ************************





#ifndef __IAAFTypeDefIndirect_INTERFACE_DEFINED__
#define __IAAFTypeDefIndirect_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDefIndirect;

#undef  INTERFACE
#define INTERFACE   IAAFTypeDefIndirect

DECLARE_INTERFACE_(IAAFTypeDefIndirect, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDefIndirect methods *** */



  //***********************************************************
  //
  // CreateValueFromActualValue()
  //
  /// Creates an indirect property value which contains the actual type.  
  /// Returns the newly-created property value in ppIndirectPropertyValue.
  ///
  /// Succeeds if all of the following are true:
  /// - the pActualValue pointer is valid.
  /// - the ppIndirectPropertyValue pointer is valid.
  ///
  /// If this method fails nothing will be written to *ppIndirectPropertyValue.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pActualValue or ppIndirectPropertyValue arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - initDataSize indicates pInitData is of the wrong size.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for this typedef.
  ///
  /// @param pActualValue [in] pointer to actual value
  /// @param ppIndirectPropertyValue [out] newly created property value
  ///
  STDMETHOD(CreateValueFromActualValue) (THIS_
    IAAFPropertyValue * pActualValue,
    IAAFPropertyValue ** ppIndirectPropertyValue) PURE;

  //***********************************************************
  //
  // CreateValueFromActualData()
  //
  /// Creates an indirect property value which contains data of the 
  /// actual type.  Returns the newly-created property value in
  /// ppIndirectPropertyValue.
  ///
  /// Succeeds if all of the following are true:
  /// - the pActualType pointer is valid and registered
  /// - the pInitData pointer is valid.
  /// - the ppIndirectPropertyValue pointer is valid.
  /// - initDataSize indicates pInitData is the correct size for 
  ///   the actual type.
  /// - compile-time struct has had its member offests registered.
  ///
  /// If this method fails nothing will be written to *ppIndirectPropertyValue.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pActualType or InitData or ppIndirectPropertyValue arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - initDataSize indicates pInitData is of the wrong size.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for this typedef.
  ///
  /// @param pActualType [in] the actual type of the data
  /// @param pInitData [in, size_is(initDataSize)] pointer to buffer containing data to use
  /// @param initDataSize [in] size of data in pInitData
  /// @param ppIndirectPropertyValue [out] newly created property value
  ///
  STDMETHOD(CreateValueFromActualData) (THIS_
    IAAFTypeDef * pActualType,
    aafMemPtr_t  pInitData,
    aafUInt32  initDataSize,
    IAAFPropertyValue ** ppIndirectPropertyValue) PURE;


  //***********************************************************
  //
  // GetActualValue()
  //
  /// Gets a property value corresponding to the actual data. 
  /// 
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - The pIndirectPropertyValue pointer is valid.
  /// - The ppActualPropertyValue pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pIndirectPropertyValue or ppActualPropertyValue arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - initDataSize indicates pInitData is of the wrong size.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for this typedef.
  ///
  /// @param pIndirectPropertyValue [in] indirect property value to read
  /// @param ppActualPropertyValue [out] value that is read
  ///
  STDMETHOD(GetActualValue) (THIS_
    IAAFPropertyValue * pIndirectPropertyValue,
    IAAFPropertyValue ** ppActualPropertyValue) PURE;
  ///)

  //***********************************************************
  //
  // GetActualSize()
  //
  /// Return the size of the actual data withing the indirect property value.
  ///
  ///
  /// Succeeds if all of the following are true:
  /// - the pIndirectPropertyValue pointer is valid.
  /// - the pActualSize pointer is valid.
  ///
  /// If this method fails nothing will be written to *pActualSize.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pIndirectPropertyValue or pActualSize arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - the type of pIndirectPropertyValue was not indirect. 
  ///
  /// AAFRESULT_TYPE_NOT_FOUND
  ///   - the actual type cannot be found in the dictionary.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for 
  ///    the actual typedef.
  ///
  /// @param pIndirectPropertyValue [in] indirect property value to read
  /// @param pActualSize [out] actual data size
  ///
  STDMETHOD(GetActualSize) (THIS_
    IAAFPropertyValue * pIndirectPropertyValue,
    aafUInt32 *  pActualSize) PURE;
  //***********************************************************
  //
  // GetActualType()
  //
  /// Return the type definition of the  actual data within the indirect property value.
  ///
  ///
  /// Succeeds if all of the following are true:
  /// - the pIndirectPropertyValue pointer is valid.
  /// - the pActualType pointer is valid.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pIndirectPropertyValue or pActualType arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - the type of pIndirectPropertyValue was not indirect. 
  ///
  /// AAFRESULT_TYPE_NOT_FOUND
  ///   - the actual type cannot be found in the dictionary.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for 
  ///    the actual typedef.
  ///
  /// @param pIndirectPropertyValue [in] indirect property value to read
  /// @param pActualType [out] the type definition of the actual data
  ///
  STDMETHOD(GetActualType) (THIS_
    IAAFPropertyValue * pIndirectPropertyValue,
    IAAFTypeDef ** pActualType) PURE;

  //***********************************************************
  //
  // GetActualData()
  //
  /// Copies all the actual data contained in the given indirect property value,
  /// interpreted as the actual type for this indirect property value, into the 
  /// buffer pointed to by pData.
  ///
  /// Succeeds if all of the following are true:
  /// - the pPropVal pointer is valid.
  /// - the pData pointer is valid.
  /// - dataSize indicates pData is large enough to hold the data.
  ///
  /// If this method fails nothing will be written to *ppPropVal.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pPropVal or pData arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - dataSize indicates pData is too small.
  ///
  /// AAFRESULT_TYPE_NOT_FOUND
  ///   - the actual type cannot be found in the dictionary.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for 
  ///    the actual typedef.
  ///
  /// @param pPropVal [in] indirect property value to read
  /// @param pData [out, size_is(dataSize)] buffer into which actual data should be written
  /// @param dataSize [in] size of pData buffer in bytes
  ///
  STDMETHOD(GetActualData) (THIS_
    IAAFPropertyValue * pPropVal,
    aafMemPtr_t  pData,
    aafUInt32  dataSize) PURE;




  END_INTERFACE
};
#endif // __IAAFTypeDefIndirect_INTERFACE_DEFINED__



// IAAFTypeDefInt

// ************************
//
// Interface IAAFTypeDefInt
//
// ************************




#ifndef __IAAFTypeDefInt_INTERFACE_DEFINED__
#define __IAAFTypeDefInt_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDefInt;

#undef  INTERFACE
#define INTERFACE   IAAFTypeDefInt

DECLARE_INTERFACE_(IAAFTypeDefInt, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDefInt methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes this type def to be identified by the given guid, to
  /// have the given size in bytes, and to be signed or unsigned.
  ///
  /// The implementation of this method may only allow certain values
  /// for intSize.  It *will* allow at least 1, 2, 4, and 8-byte
  /// integers; some implementations may allow more than that.
  ///
  /// This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  /// - intSize is a valid value.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - This object has already had Initialize() called on it.
  ///
  /// AAFRESULT_BAD_SIZE
  ///  - intSize is not a valid value.
  ///
  /// @param id [in, ref] auid to be used to identify this type
  /// @param intSize [in] the size of this integer type in bytes
  /// @param isSigned [in] true if this integer type is signed; false for unsigned
  /// @param pTypeName [in, string] friendly name of this type definition
  ///
  STDMETHOD(Initialize) (THIS_
    aafUID_constref  id,
    aafUInt8  intSize,
    aafBoolean_t  isSigned,
    aafCharacter_constptr  pTypeName) PURE;


  //***********************************************************
  //
  // CreateValue()
  //
  /// Creates a property value which contains an integer.  Initializes
  /// it to contain the given integer value.  The initialization value
  /// is passed through pVal; the size of the initialzation value is
  /// given in valSize.
  ///
  /// valSize may be smaller than GetSize() for this typedef; if so,
  /// the value is lsb-justified and sign-extended (for signed) or
  /// zero-filled (for unsigned).
  ///
  /// The implementation of this method may only allow certain values
  /// for valSize.  It *will* allow at least 1, 2, 4, and 8-byte
  /// integers; some implementations may allow more than that.
  ///
  /// Succeeds if:
  /// - The pVal pointer is valid.
  /// - The ppPropVal pointer is valid.
  /// - valSize is no larger than GetSize() for this typedef.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pVal or ppPropVal arg is NULL.
  ///
  /// AAFRESULT_BAD_SIZE
  ///   - valSize is larger than GetSize() for this typedef, or
  ///     valSize is not a supported value.
  ///
  /// @param pVal [in, size_is(valSize)] pointer to integer initialization value
  /// @param valSize [in] size of integer, in bytes, in pVal
  /// @param ppPropVal [out] newly created property value
  ///
  STDMETHOD(CreateValue) (THIS_
    aafMemPtr_t  pVal,
    aafUInt32  valSize,
    IAAFPropertyValue ** ppPropVal) PURE;


  //***********************************************************
  //
  // GetInteger()
  //
  /// Returns the integer value of this property.  The value
  /// to set is passed through pVal.  The size of the pVal buffer is
  /// given in valSize.  valSize may be larger than GetSize(); if so,
  /// the value is lsb-justified and sign-extended (for signed) or
  /// zero-filled (for unsigned).
  ///
  /// valSize may be smaller than GetSize() for this typedef; if so,
  /// the value is lsb-justified and sign-extended (for signed) or
  /// zero-filled (for unsigned).
  ///
  /// The implementation of this method may only allow certain values
  /// for valSize.  It *will* allow at least 1, 2, 4, and 8-byte
  /// integers; some implementations may allow more than that.
  ///
  /// Succeeds if:
  /// - The pPropVal pointer is valid.
  /// - The pVal pointer is valid.
  /// - valSize indicates that pVal is large enough to hold the value.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pPropVal or pVal arg is NULL.
  ///
  /// AAFRESULT_BAD_SIZE
  ///   - valSize is smaller than GetSize() for this typedef, or
  ///     valSize is not a supported value.
  ///
  /// AAFRESULT_BAD_TYPE
  ///   - The type associated with pPropVal cannot be read as an
  ///     integral type, or the int size of pPropVal is larger than the
  ///     int size of this type.
  ///
  /// @param pPropVal [in] property value from which value is to be read
  /// @param pVal [out, size_is(valSize)] buffer into which value is written
  /// @param valSize [in] size of pVal buffer in bytes
  ///
  STDMETHOD(GetInteger) (THIS_
    IAAFPropertyValue * pPropVal,
    aafMemPtr_t  pVal,
    aafUInt32  valSize) PURE;


  //***********************************************************
  //
  // SetInteger()
  //
  /// Sets this property value to the given integer value.  The value
  /// to set is passed in pVal, and the size of the value in pVal is
  /// given in valSize.  valSize may be smaller than GetSize(); if so,
  /// the value is lsb-justified and sign-extended (for signed) or
  /// zero-filled (for unsigned).
  ///
  /// Succeeds if:
  /// - The pPropVal pointer is valid.
  /// - The pVal pointer is valid.
  /// - valSize indicates that pVal is large enough to hold the value.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pPropVal or pVal arg is NULL.
  ///
  /// AAFRESULT_BAD_SIZE
  ///   - valSize is larger than GetSize() for this typedef.
  ///
  /// @param pPropVal [in] property value from which value is to be read
  /// @param pVal [in, size_is(valSize)] buffer from which value is read
  /// @param valSize [in] size of pVal buffer in bytes
  ///
  STDMETHOD(SetInteger) (THIS_
    IAAFPropertyValue * pPropVal,
    aafMemPtr_t  pVal,
    aafUInt32  valSize) PURE;


  //***********************************************************
  //
  // GetSize()
  //
  /// Returns the size of the integral value defined by this type
  /// definition. 
  ///
  /// Succeeds if:
  /// - The pSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSize arg is NULL.
  ///
  /// @param pSize [out] the returned size of this integral value, in bytes
  ///
  STDMETHOD(GetSize) (THIS_
    aafUInt32 *  pSize) PURE;


  //***********************************************************
  //
  // IsSigned()
  //
  /// Puts true in *pSigned if property values defined with this type
  /// def are signed; puts false there for unsigned property values.
  ///
  /// Succeeds if:
  /// - The pSigned pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSigned arg is NULL.
  ///
  /// @param pSigned [out] set to true if this integer type is signed; set to false for
  /// unsigned
  ///
  STDMETHOD(IsSigned) (THIS_
    aafBoolean_t *  pSigned) PURE;




  END_INTERFACE
};
#endif // __IAAFTypeDefInt_INTERFACE_DEFINED__



// IAAFTypeDefObjectRef

// ************************
//
// Interface IAAFTypeDefObjectRef
//
// ************************







#ifndef __IAAFTypeDefObjectRef_INTERFACE_DEFINED__
#define __IAAFTypeDefObjectRef_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDefObjectRef;

#undef  INTERFACE
#define INTERFACE   IAAFTypeDefObjectRef

DECLARE_INTERFACE_(IAAFTypeDefObjectRef, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDefObjectRef methods *** */


  //***********************************************************
  //
  // GetObjectType()
  //
  /// Returns the class def representing objects to which this type def
  /// can refer.  The returned type def is the class definition of the
  /// least-derived type which is permissible to be represented.
  ///
  /// Succeeds if:
  /// - this object has been Initialize()d.
  /// - The ppObjType pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppObjType arg is NULL.
  ///
  /// @param ppObjType [out] class def of objects permitted to be referenced
  ///
  STDMETHOD(GetObjectType) (THIS_
    IAAFClassDef ** ppObjType) PURE;

  //***********************************************************
  //
  // CreateValue()
  //
  /// Creates a property value which contains an object reference.
  /// Initializes it to refer to the given object, and returns the
  /// newly-created property value in ppPropVal.
  ///
  /// Succeeds if:
  /// - The pObj pointer is valid.
  /// - The ppPropVal pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pObj or ppPropVal arg is NULL.
  ///
  /// @param pObj [in] object with which to initialize this object reference
  /// @param ppPropVal [out] newly created property value
  ///
  STDMETHOD(CreateValue) (THIS_
    IUnknown * pObj,
    IAAFPropertyValue ** ppPropVal) PURE;

  //***********************************************************
  //
  // GetObject()
  //
  /// Returns the object contained in the named property value.
  /// Requires that pPropVal be a strong object reference or a weak
  /// object reference.
  ///
  /// Succeeds if:
  /// - The pPropVal pointer is valid.
  /// - The ppObject pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pPropVal or ppObject arg is NULL.
  ///
  /// @param pPropVal [in] property value from which value is to be read
  /// @param iid [in] interface id of the required output
  /// @param ppObject [out, iid_is(iid)] pointer to object value
  ///
  STDMETHOD(GetObject) (THIS_
    IAAFPropertyValue * pPropVal,
    REFIID  iid,
    IUnknown ** ppObject) PURE;


  //***********************************************************
  //
  // SetObject()
  //
  /// Sets the named property value to refer to the named object.
  /// Requires that pPropVal be a strong object reference or a weak
  /// object reference.
  ///
  /// Succeeds if:
  /// - The pPropVal pointer is valid.
  /// - The ppObject pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pPropVal or ppObject arg is NULL.
  ///
  /// @param pPropVal [in] property value from which value is to be read
  /// @param pObject [in] pointer to object value
  ///
  STDMETHOD(SetObject) (THIS_
    IAAFPropertyValue * pPropVal,
    IUnknown * pObject) PURE;




  END_INTERFACE
};
#endif // __IAAFTypeDefObjectRef_INTERFACE_DEFINED__



// IAAFTypeDefOpaque

// ************************
//
// Interface IAAFTypeDefOpaque
//
// ************************





#ifndef __IAAFTypeDefOpaque_INTERFACE_DEFINED__
#define __IAAFTypeDefOpaque_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDefOpaque;

#undef  INTERFACE
#define INTERFACE   IAAFTypeDefOpaque

DECLARE_INTERFACE_(IAAFTypeDefOpaque, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDefOpaque methods *** */


  //***********************************************************
  //
  // GetActualTypeID()
  //
  /// Return the type id of the  actual data within the opaque property value.
  ///
  ///
  /// Succeeds if all of the following are true:
  /// - the pOpaquePropertyValue pointer is valid.
  /// - the pActualType pointer is valid.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pOpaquePropertyValue or pActualTypeID arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - the type of pOpaquePropertyValue was not opaque. 
  ///
  ///
  /// @param pOpaquePropertyValue [in] indirect property value to read
  /// @param pActualTypeID [out] the type id of the actual data
  ///
  STDMETHOD(GetActualTypeID) (THIS_
    IAAFPropertyValue * pOpaquePropertyValue,
    aafUID_t *  pActualTypeID) PURE;

  //***********************************************************
  //
  // GetHandle()
  //
  /// Used to read and save an unknown property without having to know its contents.
  /// This call fills in a handle to a block of data which can be saved in you application, and
  /// later written to another file using SetHandle().  Writes the data into the pHandle buffer. 
  /// The buffer is allocated by the caller, and the size of the buffer is given by
  /// handleSize.
  /// 
  /// Caller may call GetHandleBufLen() to determine the
  /// required buffer size.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pHandle pointer is valid.
  /// - handleSize indicates the buffer is large enough to hold the
  ///   name.
  /// 
  /// If this method fails nothing will be written to *pHandle.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pHandle arg is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - handleSize indicates the buffer is too small to hold the
  ///     handle.
  ///
  /// @param pPropVal [in] value to get data from.
  /// @param handleSize [in] Size of preallocated buffer
  /// @param pHandle [out, size_is(handleSize),length_is(*bytesRead)] Preallocated buffer to hold handle
  /// @param bytesRead [out] Number of actual bytes read
  ///
  STDMETHOD(GetHandle) (THIS_
    IAAFPropertyValue * pPropVal,
    aafUInt32  handleSize,
    aafDataBuffer_t  pHandle,
    aafUInt32*  bytesRead) PURE;


  //***********************************************************
  //
  // GetHandleBufLen()
  //
  /// Returns the length of buffer required for the GetHandle()
  /// method.  The handle is placed into the location specified by
  /// pLen.
  ///
  /// Succeeds if all of the following are true:
  /// - the pLen pointer is valid.
  ///
  /// If this method fails nothing will be written to *pLen.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLen arg is NULL.
  ///
  /// @param pPropVal [in] value to set.
  /// @param pLen [out] Pointer to an variable used to return the length
  ///
  STDMETHOD(GetHandleBufLen) (THIS_
    IAAFPropertyValue * pPropVal,
    aafUInt32 *  pLen) PURE;

  //***********************************************************
  //
  // SetHandle()
  //
  /// This call takes a block of unknown data created by a previous call to GetHandle()
  /// and saved in you application, and sets an opaque property value.
  ///
  /// Succeeds if all of the following are true:
  /// - the pHandle pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pHandle is null.
  ///
  /// @param pPropVal [in] value to write data to.
  /// @param handleSize [in] Size of preallocated buffer
  /// @param pHandle [in, size_is(handleSize)] buffer containing handle
  ///
  STDMETHOD(SetHandle) (THIS_
    IAAFPropertyValue * pPropVal,
    aafUInt32  handleSize,
    aafDataBuffer_t  pHandle) PURE;

  //***********************************************************
  //
  // CreateValueFromHandle()
  //
  /// This call takes a block of unknown data created by GetHandle()
  /// and saved in you application, and creates an opaque property value.
  /// Returns the newly-created property value in ppOpaquePropertyValue.
  ///
  /// Succeeds if all of the following are true:
  /// - the pInitData pointer is valid.
  /// - the ppOpaquePropertyValue pointer is valid.
  /// - initDataSize indicates pInitData is the correct size for 
  ///   the actual type.
  /// - compile-time struct has had its member offests registered.
  ///
  /// If this method fails nothing will be written to *ppOpaquePropertyValue.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pInitData or ppOpaquePropertyValue arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - initDataSize indicates pInitData is of the wrong size.
  ///
  /// @param pInitData [in, size_is(initDataSize)] pointer to buffer containing handle to use
  /// @param initDataSize [in] size of handle in pInitData
  /// @param ppOpaquePropertyValue [out] newly created property value
  ///
  STDMETHOD(CreateValueFromHandle) (THIS_
    aafMemPtr_t  pInitData,
    aafUInt32  initDataSize,
    IAAFPropertyValue ** ppOpaquePropertyValue) PURE;




  END_INTERFACE
};
#endif // __IAAFTypeDefOpaque_INTERFACE_DEFINED__



// IAAFTypeDefRecord

// ************************
//
// Interface IAAFTypeDefRecord
//
// ************************





#ifndef __IAAFTypeDefRecord_INTERFACE_DEFINED__
#define __IAAFTypeDefRecord_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDefRecord;

#undef  INTERFACE
#define INTERFACE   IAAFTypeDefRecord

DECLARE_INTERFACE_(IAAFTypeDefRecord, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDefRecord methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes this type def to be identified by the given guid, and
  /// to contain the given members (types and names).  It is considered
  /// an error if multiple members have the same name.  Note that it is
  /// only possible to use certain types as member types.  Those
  /// permissible types include:
  /// - AAFTypeDefInt
  /// - AAFTypeDefRecord
  /// - AAFTypeDefEnum
  /// - AAFTypeDefExtEnum
  /// - AAFTypeDefFixedArray
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  /// - pID is a valid pointer.
  /// - pMemberTypes is a valid pointer.
  /// - pMemberNames is a valid pointer.
  /// - pTypeName is a valid pointer.
  /// - all specified member types are permissible for use in a Record.
  /// - all member names are unique.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - This object has already had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMemberTypes, pMemberNames, or pTypeName arg is NULL.
  ///
  /// AAFRESULT_BAD_TYPE
  ///   - an illegal member type was given.
  ///
  /// AAFRESULT_DUPLICATE
  ///   - a duplicate member name was given.
  ///
  /// @param id [in, ref] auid to be used to identify this type
  /// @param ppMemberTypes [in, size_is(numMembers)] array of member types to be represented in this record
  /// type
  /// @param pMemberNames [in, size_is(numMembers)] array of member names to be represented in this enumerated
  /// type
  /// @param numMembers [in] number of members in pMemberInfo array
  /// @param pTypeName [in] friendly name of this type definition
  ///
  STDMETHOD(Initialize) (THIS_
    aafUID_constref  id,
    IAAFTypeDef ** ppMemberTypes,
    aafString_t *  pMemberNames,
    aafUInt32  numMembers,
    aafCharacter_constptr  pTypeName) PURE;


  //***********************************************************
  //
  // GetMemberType()
  //
  /// Returns the type definition of the indexed member in this
  /// record type.  Index is zero-based, and must be less than the
  /// value returned by GetCount().
  /// 
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - the index exists in this record type def.
  /// - The ppTypeDef pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTypeDef arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - The given index is out of range for this record type def.
  ///
  /// @param index [in] zero-based index into members in this record type
  /// @param ppTypeDef [out] type definition of indexed member
  ///
  STDMETHOD(GetMemberType) (THIS_
    aafUInt32  index,
    IAAFTypeDef ** ppTypeDef) PURE;


  //***********************************************************
  //
  // GetMemberName()
  //
  /// Writes the human-legible tag associated with the indexed member
  /// in this record type.  Index is zero-based, and must be less
  /// than the value returned by GetCount().  The name is written,
  /// with a trailing null character, into the pName buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.
  /// 
  /// Caller may call GetMemberNameBufLen() to determine the required
  /// buffer size.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pName pointer is valid.
  /// - bufSize indicates the buffer is large enough to hold the name.
  /// 
  /// If this method fails nothing will be written to
  /// *pName.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  /// 
  /// AAFRESULT_SMALLBUF
  ///   - bufSize indicates the buffer is too small to hold the string.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - the given integer value is not associated with a member of
  ///     this type.
  ///
  /// @param index [in] zero-based index into members in this record type
  /// @param pName [out, size_is(bufSize), string] buffer into which the member name is written
  /// @param bufSize [in] The size of the pName buffer, in bytes
  ///
  STDMETHOD(GetMemberName) (THIS_
    aafUInt32  index,
    aafCharacter *  pName,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetMemberNameBufLen()
  //
  /// Returns the length of buffer required for the GetMemberName()
  /// method.  Index is zero-based, and must be less than the value
  /// returned by GetCount().  The value is placed into the location
  /// specified by pLen. The value will include space required for the
  /// trailing null character.
  ///
  /// Succeeds if all of the following are true:
  /// - the pLen pointer is valid.
  /// - the integer value is associated with a member of this
  ///   enumerated type.
  ///
  /// If this method fails nothing will be written to *pLen.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLen arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - the given integer value is not associated with a member of
  ///     this type.
  ///
  /// @param index [in] zero-based index into members in this record type
  /// @param pLen [out] required buffer length, in bytes
  ///
  STDMETHOD(GetMemberNameBufLen) (THIS_
    aafUInt32  index,
    aafUInt32 *  pLen) PURE;


  //***********************************************************
  //
  // CreateValueFromValues()
  //
  /// Creates a property value which contains a record type.  The
  /// record members in the property value are initialized to
  /// contain the given values, passed in the pMemberValues array.
  /// numMembers, which indicates the size of the pMemberValues array,
  /// must match the value returned by GetCount().  Returns the
  /// newly-created property value in ppPropVal.
  ///
  /// Succeeds if all of the following are true:
  /// - the pMemberValues pointer is valid.
  /// - the ppPropVal pointer is valid.
  /// - numMembers matches the number of members in this record.
  ///
  /// If this method fails nothing will be written to *ppPropVal.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pMemberValues or ppPropVal arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - numMembers does not match GetCount().
  ///
  /// @param pMemberValues [in, size_is(numMembers)] array of property values for members of record value which
  /// is to be created.
  /// @param numMembers [in] size of pMemberValues array.
  /// @param ppPropVal [out] newly-created property value
  ///
  STDMETHOD(CreateValueFromValues) (THIS_
    IAAFPropertyValue ** pMemberValues,
    aafUInt32  numMembers,
    IAAFPropertyValue ** ppPropVal) PURE;


  //***********************************************************
  //
  // CreateValueFromStruct()
  //
  /// Creates a property value which contains a record type.  The
  /// record members in the property value are initialized from data
  /// in a struct which is pointed to by pInitData.  Requires that the
  /// structure pointed to by pInitData has had its offsets registered
  /// with this type.  Returns the newly-created property value in
  /// ppPropVal.
  ///
  /// Succeeds if all of the following are true:
  /// - the pInitData pointer is valid.
  /// - the ppPropVal pointer is valid.
  /// - initDataSize indicates pInitData is the correct size.
  /// - compile-time struct has had its member offests registered.
  ///
  /// If this method fails nothing will be written to *ppPropVal.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pInitData or ppPropVal arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - initDataSize indicates pInitData is of the wrong size.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for this typedef.
  ///
  /// @param pInitData [in, size_is(initDataSize)] pointer to compile-time struct containing data to use
  /// @param initDataSize [in] size of data in pInitData
  /// @param ppPropVal [out] newly created property value
  ///
  STDMETHOD(CreateValueFromStruct) (THIS_
    aafMemPtr_t  pInitData,
    aafUInt32  initDataSize,
    IAAFPropertyValue ** ppPropVal) PURE;


  //***********************************************************
  //
  // GetValue()
  //
  /// Gets a single property value corresponding to the indicated
  /// record member.  Places a property value representing the
  /// record member identified by the index into ppOutPropval.
  /// Index is zero-based, and must be less than the value returned by
  /// GetCount().
  /// 
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - the index exists in this record type def.
  /// - The pInPropVal pointer is valid.
  /// - The ppOutPropVal pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pInPropVal or ppOutPropVal arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - The given index is out of range for this record type def.
  ///
  /// @param pInPropVal [in] property value to read
  /// @param index [in] zero-based index into members in this record type
  /// @param ppOutPropVal [out] value that is read
  ///
  STDMETHOD(GetValue) (THIS_
    IAAFPropertyValue * pInPropVal,
    aafUInt32  index,
    IAAFPropertyValue ** ppOutPropVal) PURE;


  //***********************************************************
  //
  // GetStruct()
  //
  /// Copies all the member data contained in the given property value,
  /// interpreted as a record of this type, into the struct pointed
  /// to by pData.  Requires that the struct pointed to by pData has
  /// had its offsets registered with this type.
  ///
  /// Succeeds if all of the following are true:
  /// - the pPropVal pointer is valid.
  /// - the pData pointer is valid.
  /// - dataSize indicates pData is large enough to hold the data.
  /// - compile-time struct has had its member offests registered.
  ///
  /// If this method fails nothing will be written to *ppPropVal.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pPropVal or pData arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - dataSize indicates pData is too small.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for this typedef.
  ///
  /// @param pPropVal [in] property value to read
  /// @param pData [out, size_is(dataSize)] buffer into which struct data should be written
  /// @param dataSize [in] size of pData buffer in bytes
  ///
  STDMETHOD(GetStruct) (THIS_
    IAAFPropertyValue * pPropVal,
    aafMemPtr_t  pData,
    aafUInt32  dataSize) PURE;


  //***********************************************************
  //
  // SetValue()
  //
  /// Sets the value of the single, indicated record member of the
  /// record contained in pPropVal, to the value contained in
  /// pMemberPropVal.  Index is zero-based, and must be less than the
  /// value returned by GetCount().
  /// 
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - the index exists in this record type def.
  /// - The pInPropVal pointer is valid.
  /// - The ppOutPropVal pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pInPropVal or ppOutPropVal arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - The given index is out of range for this record type def.
  ///
  /// @param pPropVal [in] property value to write
  /// @param index [in] zero-based index into members in this record type
  /// @param pMemberPropVal [in] value to be placed into this record
  ///
  STDMETHOD(SetValue) (THIS_
    IAAFPropertyValue * pPropVal,
    aafUInt32  index,
    IAAFPropertyValue * pMemberPropVal) PURE;


  //***********************************************************
  //
  // SetStruct()
  //
  /// Copies all the member data contained in the struct pointed to by
  /// pData into the given property value, interpreting the data as a record of
  /// this type.  Requires that the struct pointed to by pData has had
  /// its offsets registered with this type.
  ///
  /// Succeeds if all of the following are true:
  /// - the pPropVal pointer is valid.
  /// - the pData pointer is valid.
  /// - dataSize indicates pData contains the correct amount of data.
  /// - compile-time struct has had its member offests registered.
  ///
  /// If this method fails nothing will be written to *ppPropVal.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pPropVal or pData arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - dataSize indicates pData is not the correct size.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for this typedef.
  ///
  /// @param pPropVal [in] property value to write
  /// @param pData [in, size_is(dataSize)] buffer from which struct data should be read
  /// @param dataSize [in] size of pData buffer in bytes
  ///
  STDMETHOD(SetStruct) (THIS_
    IAAFPropertyValue * pPropVal,
    aafMemPtr_t  pData,
    aafUInt32  dataSize) PURE;


  //***********************************************************
  //
  // GetCount()
  //
  /// Returns number of members in this record type.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pCount is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCount arg is NULL.
  ///
  /// @param pCount [out] count of members in this record type
  ///
  STDMETHOD(GetCount) (THIS_
    aafUInt32 *  pCount) PURE;


  //***********************************************************
  //
  // RegisterMembers()
  //
  /// Allows client to register to the reference implementation a
  /// runtime C struct to represent objects of this TypeDef.  Offsets
  /// for each member in the struct are passed in as an array of
  /// integers; size indicates the number of members in the array.
  /// The offset is given in bytes from the start address of the
  /// struct.  This allows the reference implementation to write
  /// property values into compile-time-defined C structs intelligible
  /// by the local machine and compiler.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pOffsets is a valid pointer.
  /// - numMembers matches the number of members defined for this
  ///   record type.
  /// - all types of the fields in this record already have their
  ///   offsets registered.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pOffsets arg is NULL.
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - numMembers does not match number of members in this record
  ///     type.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///   - The type of any field in this record has not yet had its
  ///     offsets registered.
  ///
  /// AAFRESULT_DEFAULT_ALREADY_USED
  ///   - The default registration for this type has already been used
  ///     to persist or unpersist a property containing this type.
  ///
  /// @param pOffsets [in] array containing offset for each record member
  /// @param numMembers [in] number of members in pOffsets
  /// @param structSize [in] size of this struct
  ///
  STDMETHOD(RegisterMembers) (THIS_
    aafUInt32 *  pOffsets,
    aafUInt32  numMembers,
    aafUInt32  structSize) PURE;

  END_INTERFACE
};
#endif // __IAAFTypeDefRecord_INTERFACE_DEFINED__



// IAAFTypeDefRename

// ************************
//
// Interface IAAFTypeDefRename
//
// ************************




#ifndef __IAAFTypeDefRename_INTERFACE_DEFINED__
#define __IAAFTypeDefRename_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDefRename;

#undef  INTERFACE
#define INTERFACE   IAAFTypeDefRename

DECLARE_INTERFACE_(IAAFTypeDefRename, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDefRename methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes this type def to be an alias for the given type
  /// (similar to a C typedef).
  /// 
  /// This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  /// - pBaseType is a valid pointer.
  /// - pTypeName is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  /// 
  /// AAFRESULT_NULL_PARAM
  ///   - pBaseType or pTypeName is null.
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// @param id [in, ref] auid to be used to identify this type
  /// @param pBaseType [in] type to which this is an alias
  /// @param pTypeName [in, string] friendly name of this type definition
  ///
  STDMETHOD(Initialize) (THIS_
    aafUID_constref  id,
    IAAFTypeDef * pBaseType,
    aafCharacter_constptr  pTypeName) PURE;


  //***********************************************************
  //
  // GetBaseType()
  //
  /// Returns the type definition to which this type def is an alias.
  ///
  /// Succeeds if:
  /// - this object has been Initialize()d.
  /// - The ppBaseType pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppBaseType pointer is NULL.
  ///
  /// @param ppBaseType [out] type definition for which this is an alias
  ///
  STDMETHOD(GetBaseType) (THIS_
    IAAFTypeDef ** ppBaseType) PURE;


  //***********************************************************
  //
  // GetBaseValue()
  //
  /// Gets the property value of the base type from the given property
  /// value of the typedef type and places a pointer to the base type's
  /// property value into *ppOutPropVal.
  ///
  /// Succeeds if:
  /// - The pInPropVal pointer is valid.
  /// - The ppOutPropVal pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pInPropVal or ppOutPropVal is NULL.
  ///
  /// @param pInPropVal [in] property value from which value is to be read
  /// @param ppOutPropVal [out] pointer to property value represented by base type
  ///
  STDMETHOD(GetBaseValue) (THIS_
    IAAFPropertyValue * pInPropVal,
    IAAFPropertyValue ** ppOutPropVal) PURE;

  //***********************************************************
  //
  // CreateValue()
  //
  /// Gets the property value of the typedef type from the given property
  /// value of the base type and places a pointer to the base type's
  /// property value into *ppOutPropVal.
  ///
  /// Succeeds if:
  /// - The pInPropVal pointer is valid.
  /// - The ppOutPropVal pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pInPropVal or ppOutPropVal is NULL.
  ///
  /// @param pInPropVal [in] property value from which value is to be read
  /// @param ppOutPropVal [out] pointer to property value represented by rename type
  ///
  STDMETHOD(CreateValue) (THIS_
    IAAFPropertyValue * pInPropVal,
    IAAFPropertyValue ** ppOutPropVal) PURE;



  END_INTERFACE
};
#endif // __IAAFTypeDefRename_INTERFACE_DEFINED__



// IAAFTypeDefSet

// ************************
//
// Interface IAAFTypeDefSet
//
// ************************





#ifndef __IAAFTypeDefSet_INTERFACE_DEFINED__
#define __IAAFTypeDefSet_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDefSet;

#undef  INTERFACE
#define INTERFACE   IAAFTypeDefSet

DECLARE_INTERFACE_(IAAFTypeDefSet, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDefSet methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes this type def to contain elements of the given type.
  ///
  /// This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  /// - pTypeName is a valid pointer.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - This object has already had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTypeName arg is NULL.
  ///
  /// @param id [in] auid to be used to identify this type
  /// @param pTypeDef [in] type of each element to be contained in this set
  /// @param pTypeName [in,string] friendly name of this type definition
  ///
  STDMETHOD(Initialize) (THIS_
    aafUID_constref  id,
    IAAFTypeDef * pTypeDef,
    aafCharacter_constptr  pTypeName) PURE;

  //***********************************************************
  //
  // GetElementType()
  //
  /// Returns the type of elements in this set.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - ppTypeDef is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTypeDef arg is NULL.
  ///
  /// @param ppTypeDef [out] type of elements in this array
  ///
  STDMETHOD(GetElementType) (THIS_
    IAAFTypeDef ** ppTypeDef) PURE;

  //***********************************************************
  //
  // AddElement()
  //
  /// Adds an element to the set, setting it to the
  /// value given in pElementPropertyValue.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pSetPropertyValue pointer is valid.
  /// - pElementPropertyValue pointer is valid.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pSetPropertyValue or pElementPropertyValue arg is NULL.
  ///
  /// @param pSetPropertyValue [in] property value corresponding to set to which element is added
  /// @param pElementPropertyValue [in] value to be added to this set
  ///
  STDMETHOD(AddElement) (THIS_
    IAAFPropertyValue * pSetPropertyValue,
    IAAFPropertyValue * pElementPropertyValue) PURE;

  //***********************************************************
  //
  // RemoveElement()
  //
  /// Removes an element from the set.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pSetPropertyValue pointer is valid.
  /// - pElementPropertyValue pointer is valid.
  /// - The given element was in the set.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pSetPropertyValue or pElementPropertyValue arg is NULL.
  ///
  /// @param pSetPropertyValue [in] property value corresponding to set from which element is removed
  /// @param pElementPropertyValue [in] value to be removed from this set
  ///
  STDMETHOD(RemoveElement) (THIS_
    IAAFPropertyValue * pSetPropertyValue,
    IAAFPropertyValue * pElementPropertyValue) PURE;

  //***********************************************************
  //
  // ContainsElement()
  //
  /// Tests if an element is in the set.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pSetPropertyValue pointer is valid.
  /// - pElementPropertyValue pointer is valid.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pSetPropertyValue or pElementPropertyValue arg is NULL.
  ///
  /// @param pSetPropertyValue [in] property value corresponding to set to which element is added
  /// @param pElementPropertyValue [in] value whose presence is being tested in this set
  /// @param pContainsElement [out] value to be added to this set
  ///
  STDMETHOD(ContainsElement) (THIS_
    IAAFPropertyValue * pSetPropertyValue,
    IAAFPropertyValue * pElementPropertyValue,
    aafBoolean_t*  pContainsElement) PURE;



  //***********************************************************
  //
  // GetCount()
  //
  /// Returns number of elements in the referenced property value.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pSetPropertyValue is a valid pointer.
  /// - pCount is a valid pointer.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pSetPropertyValue or pCount arg is NULL.
  ///
  /// @param pSetPropertyValue [in] property value of array
  /// @param pCount [out] count of elements in the specified set property value
  ///
  STDMETHOD(GetCount) (THIS_
    IAAFPropertyValue * pSetPropertyValue,
    aafUInt32 *  pCount) PURE;


  //***********************************************************
  //
  // CreateKey()
  //
  /// Returns number of elements in the referenced property value.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pSetPropertyValue is a valid pointer.
  /// - pCount is a valid pointer.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pSetPropertyValue or pCount arg is NULL.
  ///
  /// @param pKeyPtr [in,size_is(length)] Pointer to the key value bytes
  /// @param length [in] The size of the key in bytes
  /// @param ppKey [out] An interface which may be passed to LookupElement() or ContainsKey()
  ///
  STDMETHOD(CreateKey) (THIS_
    aafDataBuffer_t  pKeyPtr,
    aafUInt32  length,
    IAAFPropertyValue ** ppKey) PURE;


  //***********************************************************
  //
  // LookupElement()
  //
  /// Looks up the given key (created by CreateKey()) and returns the propertyValue
  /// of the entry, or an error if the entry is not present.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pSetPropertyValue is a valid pointer.
  /// - pCount is a valid pointer.
  /// - An entry with the correct key is present in the set.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pSetPropertyValue or pSetPropertyValue or ppElementPropertyValue arg is NULL.
  ///
  /// @param pSetPropertyValue [in] property value of set
  /// @param pKey [in] A key returned from CreateKey()
  /// @param ppElementPropertyValue [out] The returned property value
  ///
  STDMETHOD(LookupElement) (THIS_
    IAAFPropertyValue * pSetPropertyValue,
    IAAFPropertyValue * pKey,
    IAAFPropertyValue ** ppElementPropertyValue) PURE;

  //***********************************************************
  //
  // ContainsKey()
  //
  /// Looks up the given key (created by CreateKey()) and returns AAFTrue if the entry
  /// is present, or AAFFalse if the entry is not present.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pSetPropertyValue is a valid pointer.
  /// - pCount is a valid pointer.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pSetPropertyValue or pContainsKey arg is NULL.
  ///
  /// @param pSetPropertyValue [in] property value of set
  /// @param pKey [in] A key returned from CreateKey()
  /// @param pContainsKey [out] Value returned is AAFTrue if an entry with the correct key is present
  ///
  STDMETHOD(ContainsKey) (THIS_
    IAAFPropertyValue * pSetPropertyValue,
    IAAFPropertyValue * pKey,
    aafBoolean_t*  pContainsKey) PURE;


  //***********************************************************
  //
  // GetElements()
  //
  /// Returns an enumerator across elements in this set.
  /// 
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - The pSetPropertyValue pointer is valid.
  /// - The ppEnum pointer is valid.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pSetPropertyValue or ppEnum arg is NULL.
  ///
  /// @param pSetPropertyValue [in] property value to read
  /// @param ppEnum [out] enumerator across property values
  ///
  STDMETHOD(GetElements) (THIS_
    IAAFPropertyValue * pSetPropertyValue,
    IEnumAAFPropertyValues ** ppEnum) PURE;



  END_INTERFACE
};
#endif // __IAAFTypeDefSet_INTERFACE_DEFINED__



// IAAFTypeDefStream

// ************************
//
// Interface IAAFTypeDefStream
//
// ************************





#ifndef __IAAFTypeDefStream_INTERFACE_DEFINED__
#define __IAAFTypeDefStream_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDefStream;

#undef  INTERFACE
#define INTERFACE   IAAFTypeDefStream

DECLARE_INTERFACE_(IAAFTypeDefStream, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDefStream methods *** */

  //***********************************************************
  //
  // GetSize()
  //
  /// Returns number of bytes contained in the referenced property
  /// value.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  /// - pSize is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pStreamPropertyValue or pSize arg is NULL.
  ///
  /// @param pStreamPropertyValue [in] stream property value
  /// @param pSize [out] count of bytes in the specified stream property value
  ///
  STDMETHOD(GetSize) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    aafInt64 *  pSize) PURE;

  //***********************************************************
  //
  // SetSize()
  //
  /// Set the number of bytes contained in the give stream property value
  /// to newElementCount
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - If pStreamPropertyValue arg is NULL.
  ///
  /// @param pStreamPropertyValue [in] stream property value
  /// @param newSize [in] new count of bytes in the specified stream property value
  ///
  STDMETHOD(SetSize) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    aafInt64  newSize) PURE;

  //***********************************************************
  //
  // GetPosition()
  //
  /// Returns the byte position of the current element in the stream. 
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  /// - pPosition is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pStreamPropertyValue or pPosition arg is NULL.
  ///
  /// @param pStreamPropertyValue [in] stream property value
  /// @param pPosition [out] current byte position in the specified stream property value
  ///
  STDMETHOD(GetPosition) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    aafInt64 *  pPosition) PURE;

  //***********************************************************
  //
  // SetPosition()
  //
  /// Make the current byte position to the one at newPosition in the stream 
  /// property value. 
  ///
  /// Succeeds if:
  /// - pStreamPropertyValue is a valid pointer.
  /// - the new position is valid
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - If pStreamPropertyValue arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - newPosition is outside the bounds of the stream.
  ///
  /// @param pStreamPropertyValue [in] stream property value
  /// @param newPosition [in] the new position in the specified stream property value
  ///
  STDMETHOD(SetPosition) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    aafInt64  newPosition) PURE;


  //***********************************************************
  //
  // Read()
  //
  /// Sequential access.
  /// Copies the data at the position of the stream to the given
  /// buffer.
  ///
  /// Succeeds if all of the following are true:
  /// - the pStreamPropertyValue pointer is valid.
  /// - the pData pointer is valid.
  /// - the indicated bytes exist in the stream.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pStreamPropertyValue or pData arg is NULL.
  ///
  /// @param pStreamPropertyValue [in] stream property value to read
  /// @param dataSize [in] number of bytes to read
  /// @param pData [out, size_is(dataSize), length_is(*bytesRead)] buffer into which one element from the stream should be written
  /// @param bytesRead [out,ref] number of bytes actually read (will be either dataSize or 0 if there 
  /// is in error)
  ///
  STDMETHOD(Read) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    aafUInt32  dataSize,
    aafMemPtr_t  pData,
    aafUInt32 *  bytesRead) PURE;

  //***********************************************************
  //
  // Write()
  //
  /// Sequential access.
  /// Copies the data in the given buffer into the stream at the 
  /// current position of the stream..
  ///
  /// Succeeds if all of the following are true:
  /// - the pStreamPropertyValue pointer is valid.
  /// - the pData pointer is valid.
  /// - the indicated bytes could be written to the stream.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pStreamPropertyValue or pData arg is NULL.
  ///
  /// @param pStreamPropertyValue [in] stream property value to modify
  /// @param dataSize [in] number of bytes to write
  /// @param pData [in, ref, size_is(dataSize)] buffer into which should contain one element to be written to the stream
  ///
  STDMETHOD(Write) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    aafUInt32  dataSize,
    aafMemPtr_t  pData) PURE;

  //***********************************************************
  //
  // Append()
  //
  /// Extending the stream.
  /// Copies the data in the given buffer into the stream at the 
  /// end of the stream.
  ///
  /// Succeeds if all of the following are true:
  /// - the pStreamPropertyValue pointer is valid.
  /// - the pData pointer is valid.
  /// - the indicated bytes could be appended to the stream.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pStreamPropertyValue or pData arg is NULL.
  ///
  /// @param pStreamPropertyValue [in] stream property value to modify
  /// @param dataSize [in] number of bytes to write (must be equal to the element type length)
  /// @param pData [in, ref, size_is(dataSize)] buffer into which should contain one element to be written to the stream
  ///
  STDMETHOD(Append) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    aafUInt32  dataSize,
    aafMemPtr_t  pData) PURE;


  //***********************************************************
  //
  // HasStoredByteOrder()
  //
  /// Returns kAAFTrue if the stream has a stored byte order or 
  /// kAAFFalse otherwise.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  /// - pHasByteOrder is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pStreamPropertyValue or pHasByteOrder arg is NULL.
  ///
  /// @param pStreamPropertyValue [in] stream property value
  /// @param pHasByteOrder [out] kAAFTrue if this stream has a stored byte order
  ///
  STDMETHOD(HasStoredByteOrder) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    aafBoolean_t *  pHasByteOrder) PURE;

  //***********************************************************
  //
  // GetStoredByteOrder()
  //
  /// Access byte order of the stream.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  /// - pByteOrder is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pStreamPropertyValue or pByteOrder arg is NULL.
  ///
  /// @param pStreamPropertyValue [in] stream property value
  /// @param pByteOrder [out] Pointer to variable where byte order is to be copied
  ///
  STDMETHOD(GetStoredByteOrder) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    eAAFByteOrder_t *  pByteOrder) PURE;

  //***********************************************************
  //
  // SetStoredByteOrder()
  //
  /// Sets the byte order to be associated with this stream. Note: the stream
  /// must be empty.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  /// - stream is empty.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - If pStreamPropertyValue arg is NULL.
  ///
  /// @param pStreamPropertyValue [in] stream property value
  /// @param byteOrder [in] byte order is to be stored with the stream
  ///
  STDMETHOD(SetStoredByteOrder) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    eAAFByteOrder_t  byteOrder) PURE;

  //***********************************************************
  //
  // ClearStoredByteOrder()
  //
  /// Clears the byte order to be associated with this stream. Note: the stream
  /// must be empty.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  /// - stream is empty.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - If pStreamPropertyValue arg is NULL.
  ///
  /// @param pStreamPropertyValue [in] stream property value
  ///
  STDMETHOD(ClearStoredByteOrder) (THIS_
    IAAFPropertyValue * pStreamPropertyValue) PURE;

  //***********************************************************
  //
  // ReadElements()
  //
  /// Access in typed chunks of Elements.
  /// Copies the data at the current position of the stream to the given
  /// buffer. Requires that any structures declared within element 
  /// typedef have had their offsets registered with that type.
  ///
  /// Succeeds if all of the following are true:
  /// - the pStreamPropertyValue pointer is valid.
  /// - the pElementType pointer is valid.
  /// - the pData pointer is valid.
  /// - dataSize indicates pData is large enough to hold the data.
  /// - compile-time struct has had its member offests registered.
  /// - the indicated elements exist in this stream type def.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pStreamPropertyValue or pElementType or pBytesRead or pData arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - dataSize indicates pData is too small.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for element typedef.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - there are not dataSize bytes left in the stream.
  ///
  /// @param pStreamPropertyValue [in] stream property value to read
  /// @param pElementType [in] the type definition of the elements to read
  /// @param dataSize [in] number of bytes to read (must be evenly divisible by the element 
  /// type length)
  /// @param pData [out, size_is(dataSize), length_is(*pBytesRead)] buffer into which elements from the stream should be written
  /// @param pBytesRead [out,ref] number of bytes actually read (will be either dataSize or 0 if 
  /// there is in error)
  ///
  STDMETHOD(ReadElements) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    IAAFTypeDef * pElementType,
    aafUInt32  dataSize,
    aafMemPtr_t  pData,
    aafUInt32 *  pBytesRead) PURE;

  //***********************************************************
  //
  // WriteElements()
  //
  /// Access in typed chunks of Elements.
  /// Copies the data in the given buffer into the stream at the  
  /// current position of the stream. Requires that any structures 
  /// declared within element 
  /// typedef have had their offsets registered with that type..
  ///
  /// Succeeds if all of the following are true:
  /// - the pStreamPropertyValue pointer is valid.
  /// - the pElementType pointer is valid.
  /// - the pData pointer is valid.
  /// - dataSize indicates pData is large enough to hold the data.
  /// - compile-time struct has had its member offests registered.
  /// - the indicated elements exist in this stream type def.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pStreamPropertyValue or pElementType or pData arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - dataSize indicates pData is an even multiple of the given 
  ///     element type size.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for the element typedef.
  ///
  /// @param pStreamPropertyValue [in] stream property value to modify
  /// @param pElementType [in] the type definition of the elements to read
  /// @param dataSize [in] number of bytes to write (must be evenly divisible by the element type 
  /// length)
  /// @param pData [in, ref, size_is(dataSize)] buffer into which elements from the stream should be written
  ///
  STDMETHOD(WriteElements) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    IAAFTypeDef * pElementType,
    aafUInt32  dataSize,
    aafMemPtr_t  pData) PURE;


  /// Extend in chunks of typed Elements

  //***********************************************************
  //
  // AppendElements()
  //
  /// Access in typed chunks of Elements.
  /// Copies the data in the given buffer onto the end of the stream. 
  /// Requires that any structures declared within element 
  /// typedef have had their offsets registered with that type..
  ///
  /// Succeeds if all of the following are true:
  /// - the pStreamPropertyValue pointer is valid.
  /// - the pElementType pointer is valid.
  /// - the pData pointer is valid.
  /// - dataSize indicates pData is large enough to hold the data.
  /// - compile-time struct has had its member offests registered.
  /// - the indicated elements exist in this stream type def.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pStreamPropertyValue or pElementType or pData arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - dataSize indicates pData is an even multiple of the given 
  ///     element type size.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for the element typedef.
  ///
  /// @param pStreamPropertyValue [in] stream property value to modify
  /// @param pElementType [in] the type definition of the elements to read
  /// @param dataSize [in] number of bytes to write (must be evenly divisible by the element type 
  /// length)
  /// @param pData [in, ref, size_is(dataSize)] buffer into which elements from the stream should be written
  ///
  STDMETHOD(AppendElements) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    IAAFTypeDef * pElementType,
    aafUInt32  dataSize,
    aafMemPtr_t  pData) PURE;





  END_INTERFACE
};
#endif // __IAAFTypeDefStream_INTERFACE_DEFINED__


// IAAFTypeDefString

// ************************
//
// Interface IAAFTypeDefString
//
// ************************




#ifndef __IAAFTypeDefString_INTERFACE_DEFINED__
#define __IAAFTypeDefString_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDefString;

#undef  INTERFACE
#define INTERFACE   IAAFTypeDefString

DECLARE_INTERFACE_(IAAFTypeDefString, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDefString methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes this type def to contain elements of the given type.
  /// Note that it is only possible to use certain types as the element
  /// type.  Those permissible types include:
  ///
  /// - AAFTypeDefInt
  ///
  /// This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  /// - pID is a valid pointer.
  /// - pTypeDef is a valid pointer.
  /// - pTypeName is a valid pointer.
  /// - element type is permissible for use in a String.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - This object has already had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pTypeDef or pTypeName arg is NULL.
  ///
  /// @param id [in, ref] auid to be used to identify this type
  /// @param pTypeDef [in] type of each element to be contained in this array
  /// @param pTypeName [in] friendly name of this type definition
  ///
  STDMETHOD(Initialize) (THIS_
    aafUID_constref  id,
    IAAFTypeDef * pTypeDef,
    aafCharacter_constptr  pTypeName) PURE;


  //***********************************************************
  //
  // GetType()
  //
  /// Returns the type of elements in this string.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - ppTypeDef is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTypeDef arg is NULL.
  ///
  /// @param ppTypeDef [out] type of elements in this array
  ///
  STDMETHOD(GetType) (THIS_
    IAAFTypeDef ** ppTypeDef) PURE;


  //***********************************************************
  //
  // GetCount()
  //
  /// Returns number of elements contained in the referenced property
  /// value.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pPropVal is a valid pointer.
  /// - pCount is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pPropVal or pCount arg is NULL.
  ///
  /// @param pPropVal [in] property value of array
  /// @param pCount [out] count of elements in the specified string property value
  ///
  STDMETHOD(GetCount) (THIS_
    IAAFPropertyValue * pPropVal,
    aafUInt32 *  pCount) PURE;


  //***********************************************************
  //
  // CreateValueFromCString()
  //
  /// Creates a property value which contains a string type.  The
  /// string in the property value are initialized from data in a C
  /// string which is pointed to by pInitData.  Returns the
  /// newly-created property value in ppPropVal.  The size of the
  /// newly-created string property value will be determined by the
  /// size of the initialization C array, as communicated by
  /// initDataSize.
  ///
  /// Succeeds if all of the following are true:
  /// - the pInitData pointer is valid.
  /// - the ppPropVal pointer is valid.
  ///
  /// If this method fails nothing will be written to *ppPropVal.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pInitData or ppPropVal arg is NULL.
  ///
  /// @param pInitData [in, size_is(initDataSize)] pointer to compile-time C string containing data to use
  /// @param initDataSize [in] size of data in pInitData, in bytes
  /// @param ppPropVal [out] newly created property value
  ///
  STDMETHOD(CreateValueFromCString) (THIS_
    aafMemPtr_t  pInitData,
    aafUInt32  initDataSize,
    IAAFPropertyValue ** ppPropVal) PURE;


  //***********************************************************
  //
  // SetCString()
  //
  /// Copies all the string data contained in the C array pointed to by
  /// pData into the given property value, interpreting the data as a
  /// string of this type.  If dataSize indicates an array size
  /// different from the size currently in the indicated array property
  /// value, that array property value will be resized.
  ///
  /// Succeeds if all of the following are true:
  /// - the pPropVal pointer is valid.
  /// - the pData pointer is valid.
  ///
  /// If this method fails nothing will be written to *ppPropVal.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pPropVal or pData arg is NULL.
  ///
  /// @param pPropVal [in] property value to write
  /// @param pData [in, size_is(dataSize)] buffer from which C string data should be read
  /// @param dataSize [in] size of pData buffer in bytes
  ///
  STDMETHOD(SetCString) (THIS_
    IAAFPropertyValue * pPropVal,
    aafMemPtr_t  pData,
    aafUInt32  dataSize) PURE;


  //***********************************************************
  //
  // AppendElements()
  //
  /// Appends elements to the end of the array, setting them to the
  /// values given in the pElements array.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pInPropVal pointer is valid.
  /// - pElements pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pInPropVal or pElements arg is NULL.
  ///
  /// @param pInPropVal [in] property value corresponding to string to which elements are to
  /// be appended
  /// @param pElements [in] Null-terminated array of elements to be appended
  ///
  STDMETHOD(AppendElements) (THIS_
    IAAFPropertyValue * pInPropVal,
    aafMemPtr_t  pElements) PURE;


  //***********************************************************
  //
  // GetElements()
  //
  /// Gets the value of this property as a string and places it into
  /// pBuffer.  bufferSize indicates the size of the buffer, in bytes.
  /// 
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - The pInPropVal pointer is valid.
  /// - bufferSize indicates that pBuffer is large enough to hold the
  ///   data.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pInPropVal arg is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - bufferSize indicates that pBuffer is too small to hold the
  ///     data.
  ///
  /// @param pInPropVal [in] property value to read
  /// @param pBuffer [out] array of values that are read
  /// @param bufferSize [in] size of pBuffer, in bytes
  ///
  STDMETHOD(GetElements) (THIS_
    IAAFPropertyValue * pInPropVal,
    aafMemPtr_t  pBuffer,
    aafUInt32  bufferSize) PURE;




  END_INTERFACE
};
#endif // __IAAFTypeDefString_INTERFACE_DEFINED__



// IAAFTypeDefStrongObjRef

// ************************
//
// Interface IAAFTypeDefStrongObjRef
//
// ************************





#ifndef __IAAFTypeDefStrongObjRef_INTERFACE_DEFINED__
#define __IAAFTypeDefStrongObjRef_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDefStrongObjRef;

#undef  INTERFACE
#define INTERFACE   IAAFTypeDefStrongObjRef

DECLARE_INTERFACE_(IAAFTypeDefStrongObjRef, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDefStrongObjRef methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes this type def to be a reference to objects of
  /// the given type, and assigns this object the given AUID.  pObjType
  /// points to the class definition of the least-derived class which
  /// is possible to be contained in property values of this type.
  /// 
  /// This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  /// - pObjType is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - This object has already had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pObjType or pTypeName arg is NULL.
  ///
  /// @param id [in, ref] auid to be used to identify this type
  /// @param pObjType [in] class def of objects permitted to be referenced
  /// @param pTypeName [in, string] friendly name of this type definition
  ///
  STDMETHOD(Initialize) (THIS_
    aafUID_constref  id,
    IAAFClassDef * pObjType,
    aafCharacter_constptr  pTypeName) PURE;





  END_INTERFACE
};
#endif // __IAAFTypeDefStrongObjRef_INTERFACE_DEFINED__



// IAAFTypeDefVariableArray

// ************************
//
// Interface IAAFTypeDefVariableArray
//
// ************************





#ifndef __IAAFTypeDefVariableArray_INTERFACE_DEFINED__
#define __IAAFTypeDefVariableArray_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDefVariableArray;

#undef  INTERFACE
#define INTERFACE   IAAFTypeDefVariableArray

DECLARE_INTERFACE_(IAAFTypeDefVariableArray, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDefVariableArray methods *** */
  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes this type def to contain elements of the given type.
  /// Note that it is only possible to use certain types as the element
  /// type.  Those permissible types include:
  /// - AAFTypeDefInt
  /// - AAFTypeDefRecord
  /// - AAFTypeDefEnum
  /// - AAFTypeDefExtEnum
  /// - AAFTypeDefFixedArray
  /// - AAFTypeDefObjectRef
  ///
  /// This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  /// - pID is a valid pointer.
  /// - pTypeDef is a valid pointer.
  /// - pTypeName is a valid pointer.
  /// - element type is permissible for use in a VariableArray.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - This object has already had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pTypeDef or pTypeName arg is NULL.
  ///
  /// AAFRESULT_BAD_TYPE
  ///   - an illegal element type was given.
  ///
  /// @param id [in, ref] auid to be used to identify this type
  /// @param pTypeDef [in] type of each element to be contained in this array
  /// @param pTypeName [in] friendly name of this type definition
  ///
  STDMETHOD(Initialize) (THIS_
    aafUID_constref  id,
    IAAFTypeDef * pTypeDef,
    aafCharacter_constptr  pTypeName) PURE;


  //***********************************************************
  //
  // GetType()
  //
  /// Returns the type of elements in this array.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - ppTypeDef is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTypeDef arg is NULL.
  ///
  /// @param ppTypeDef [out] type of elements in this array
  ///
  STDMETHOD(GetType) (THIS_
    IAAFTypeDef ** ppTypeDef) PURE;


  //***********************************************************
  //
  // GetCount()
  //
  /// Returns number of array elements in the referenced property
  /// value.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pPropVal is a valid pointer.
  /// - pCount is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pPropVal or pCount arg is NULL.
  ///
  /// @param pPropVal [in] property value of array
  /// @param pCount [out] count of elements in the specified array property value
  ///
  STDMETHOD(GetCount) (THIS_
    IAAFPropertyValue * pPropVal,
    aafUInt32 *  pCount) PURE;


  //***********************************************************
  //
  // AppendElement()
  //
  /// Appends an element to the end of the array, setting it to the
  /// value given in pMemberPropVal.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pInPropVal pointer is valid.
  /// - pMemberPropVal pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pInPropVal or pMemberPropVal arg is NULL.
  ///
  /// @param pInPropVal [in] property value corresponding to array to which element is appended
  /// @param pMemberPropVal [in] value to be appended to this array
  ///
  STDMETHOD(AppendElement) (THIS_
    IAAFPropertyValue * pInPropVal,
    IAAFPropertyValue * pMemberPropVal) PURE;


  //***********************************************************
  //
  // CreateEmptyValue()
  //
  /// Creates an empty property value which contains a variable array
  /// type that initially is empty (that is, contains no elements
  /// yet).
  ///
  /// Succeeds if all of the following are true:
  /// - the ppPropVal pointer is valid.
  ///
  /// If this method fails nothing will be written to *ppPropVal.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppPropVal arg is NULL.
  ///
  /// @param ppPropVal [out] newly-created empty property value
  ///
  STDMETHOD(CreateEmptyValue) (THIS_
    IAAFPropertyValue ** ppPropVal) PURE;


  //***********************************************************
  //
  // CreateValueFromValues()
  //
  /// Creates a property value which contains a variable array type.
  /// The array elements in the property value are initialized to
  /// contain the given values, passed in the pElementValues array.
  /// numElements, which indicates the size of the pElementValues
  /// array, determines the size of the array in the new array
  /// property value.
  ///
  /// Succeeds if all of the following are true:
  /// - the pElementValues pointer is valid.
  /// - the ppPropVal pointer is valid.
  ///
  /// If this method fails nothing will be written to *ppPropVal.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pElementValues or ppPropVal arg is NULL.
  ///
  /// @param pElementValues [in, size_is(numElements)] array of property values for elements of array value which
  /// is to be created.
  /// @param numElements [in] size of pElementValues array.
  /// @param ppPropVal [out] newly-created property value
  ///
  STDMETHOD(CreateValueFromValues) (THIS_
    IAAFPropertyValue ** pElementValues,
    aafUInt32  numElements,
    IAAFPropertyValue ** ppPropVal) PURE;


  //***********************************************************
  //
  // CreateValueFromCArray()
  //
  /// Creates a property value which contains a fixed array type.  The
  /// array elements in the property value are initialized from data in
  /// a C array which is pointed to by pInitData.  Requires that any
  /// structures declared within this array typedef have had their
  /// offsets registered with that type.  Returns the newly-created
  /// property value in ppPropVal.  The size of the newly-created array
  /// property value will be determined by the number of elements in
  /// the initialization C array, as communicated by initDataSize.
  ///
  /// Succeeds if all of the following are true:
  /// - the pInitData pointer is valid.
  /// - the ppPropVal pointer is valid.
  /// - compile-time struct has had its member offests registered.
  ///
  /// If this method fails nothing will be written to *ppPropVal.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pInitData or ppPropVal arg is NULL.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - any contained struct offsets have not yet been registered for
  ///    that typedef.
  ///
  /// @param pInitData [in, size_is(initDataSize)] pointer to compile-time C array containing data to use
  /// @param initDataSize [in] size of data in pInitData, in bytes
  /// @param ppPropVal [out] newly created property value
  ///
  STDMETHOD(CreateValueFromCArray) (THIS_
    aafMemPtr_t  pInitData,
    aafUInt32  initDataSize,
    IAAFPropertyValue ** ppPropVal) PURE;


  //***********************************************************
  //
  // GetElementValue()
  //
  /// Gets a single property value corresponding to the indexed array
  /// element.  Places a property value representing the array element
  /// identified by the index into ppOutPropval.  Index is zero-based,
  /// and must be less than the value returned by GetCount().
  /// 
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - the index exists in this array type def.
  /// - The pInPropVal pointer is valid.
  /// - The ppOutPropVal pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pInPropVal or ppOutPropVal arg is NULL.
  ///
  /// AAFRESULT_BAD_PARAM
  ///   - The given index is out of range for this array type def.
  ///
  /// @param pInPropVal [in] property value to read
  /// @param index [in] zero-based index into elements in this array type
  /// @param ppOutPropVal [out] value that is read
  ///
  STDMETHOD(GetElementValue) (THIS_
    IAAFPropertyValue * pInPropVal,
    aafUInt32  index,
    IAAFPropertyValue ** ppOutPropVal) PURE;


  //***********************************************************
  //
  // GetCArray()
  //
  /// Copies all the array data contained in the given property value,
  /// interpreted as a fixed array of this type, into the C array
  /// pointed to by pData.  Requires that any structures declared
  /// within this array typedef have had their offsets registered with
  /// that type.
  ///
  /// Succeeds if all of the following are true:
  /// - the pPropVal pointer is valid.
  /// - the pData pointer is valid.
  /// - dataSize indicates pData is large enough to hold the data.
  /// - compile-time struct has had its member offests registered.
  ///
  /// If this method fails nothing will be written to *ppPropVal.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pPropVal or pData arg is NULL.
  ///
  /// AAFRESULT_BAD_PARAM
  ///   - dataSize indicates pData is too small.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for this typedef.
  ///
  /// @param pPropVal [in] property value to read
  /// @param pData [out, size_is(dataSize)] buffer into which C array data should be written
  /// @param dataSize [in] size of pData buffer in bytes
  ///
  STDMETHOD(GetCArray) (THIS_
    IAAFPropertyValue * pPropVal,
    aafMemPtr_t  pData,
    aafUInt32  dataSize) PURE;


  //***********************************************************
  //
  // SetElementValue()
  //
  /// Sets the value of the single, indicated element of the fixed
  /// array contained in pPropVal, to the value contained in
  /// pMemberPropVal.  Index is zero-based, and must be less than the
  /// value returned by GetCount().  Property value must be of the
  /// same type as returned by GetType().
  /// 
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - the index exists in this array type def.
  /// - The pInPropVal pointer is valid.
  /// - The ppOutPropVal pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pInPropVal or ppOutPropVal arg is NULL.
  ///
  /// AAFRESULT_BAD_PARAM
  ///   - The given index is out of range for this array type def.
  ///
  /// @param pPropVal [in] property value to write
  /// @param index [in] zero-based index into members in this array type
  /// @param pMemberPropVal [in] value to be placed into this array
  ///
  STDMETHOD(SetElementValue) (THIS_
    IAAFPropertyValue * pPropVal,
    aafUInt32  index,
    IAAFPropertyValue * pMemberPropVal) PURE;


  //***********************************************************
  //
  // SetCArray()
  //
  /// Copies all the array data contained in the C array pointed to by
  /// pData into the given property value, interpreting the data as a
  /// fixed array of this type.  Requires that any structures declared
  /// within this typedef have had their offsets registered with that
  /// type.  If dataSize indicates an array size different from the
  /// size currently in the indicated array property value, that array
  /// property value will be resized.
  ///
  /// Succeeds if all of the following are true:
  /// - the pPropVal pointer is valid.
  /// - the pData pointer is valid.
  /// - any contained compile-time struct has had its member offests
  ///   registered.
  ///
  /// If this method fails nothing will be written to *ppPropVal.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pPropVal or pData arg is NULL.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - offsets of any contained struct have not yet been registered.
  ///
  /// @param pPropVal [in] property value to write
  /// @param pData [in, size_is(dataSize)] buffer from which C array data should be read
  /// @param dataSize [in] size of pData buffer in bytes
  ///
  STDMETHOD(SetCArray) (THIS_
    IAAFPropertyValue * pPropVal,
    aafMemPtr_t  pData,
    aafUInt32  dataSize) PURE;




  //***********************************************************
  //
  // GetElements()
  //
  /// Returns an enumerator across elements in this set.
  /// 
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - The PSetPropVal pointer is valid.
  /// - The ppEnum pointer is valid.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either PSetPropVal or ppEnum arg is NULL.
  ///
  /// @param PSetPropVal [in] property value to read
  /// @param ppEnum [out] enumerator across property values
  ///
  STDMETHOD(GetElements) (THIS_
    IAAFPropertyValue * PSetPropVal,
    IEnumAAFPropertyValues ** ppEnum) PURE;






  END_INTERFACE
};
#endif // __IAAFTypeDefVariableArray_INTERFACE_DEFINED__


// IAAFTypeDefWeakObjRef

// ************************
//
// Interface IAAFTypeDefWeakObjRef
//
// ************************





#ifndef __IAAFTypeDefWeakObjRef_INTERFACE_DEFINED__
#define __IAAFTypeDefWeakObjRef_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDefWeakObjRef;

#undef  INTERFACE
#define INTERFACE   IAAFTypeDefWeakObjRef

DECLARE_INTERFACE_(IAAFTypeDefWeakObjRef, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDefWeakObjRef methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes this type def to be a reference to objects of
  /// the given type, and assigns this object the given AUID.  pObjType
  /// points to the class definition of the least-derived class which
  /// is possible to be contained in property values of this type.
  /// 
  /// pTargetSet points to an array of Property Def AUIDs which
  /// indicate the location of the property containing the target of
  /// this weak reference.  The AUIDs indicate the containment path to
  /// the target property, starting at the root Header object.  For
  /// example, if the containment hierarchy is:
  ///
  /// Header->A->B->C
  ///
  /// then the first AUID corresponds to the Header's property which
  /// contains Object A; the second AUID corresponds to Object A's
  /// property which contains Object B; and the third AUID corresponds
  /// to Object B's property C which contans the target of this weak
  /// reference.  If any intermediate property is a vector or set,
  /// *all* objects in that vector or set are searched for the target.
  /// Note that the final AUID *must* correspond to a Set property.
  /// 
  /// The number of AUIDs in pTargetSet is noted by ids.
  /// 
  /// This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  /// - pObjType is a valid pointer.
  /// - pTargetSet is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - This object has already had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pObjType, pTypeName, or pTargetSet arg is NULL.
  ///
  /// @param id [in, ref] auid to be used to identify this type
  /// @param pObjType [in] class def of objects permitted to be referenced
  /// @param pTypeName [in, string] friendly name of this type definition
  /// @param ids [in] Number of property def IDs in pTargetSet
  /// @param pTargetSet [in, size_is(ids)] List of property definition IDs indicating the property where
  /// the target is to be found.
  ///
  STDMETHOD(Initialize) (THIS_
    aafUID_constref  id,
    IAAFClassDef * pObjType,
    aafCharacter_constptr  pTypeName,
    aafUInt32  ids,
    aafUID_constptr  pTargetSet) PURE;

  END_INTERFACE
};
#endif // __IAAFTypeDefWeakObjRef_INTERFACE_DEFINED__



// IAAFVaryingValue

// ************************
//
// Interface IAAFVaryingValue
//
// ************************








#ifndef __IAAFVaryingValue_INTERFACE_DEFINED__
#define __IAAFVaryingValue_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFVaryingValue;

#undef  INTERFACE
#define INTERFACE   IAAFVaryingValue

DECLARE_INTERFACE_(IAAFVaryingValue, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFVaryingValue methods *** */


  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a new varying value object to be identified with the
  /// given the given parameter definition and interpolation definition.
  ///
  /// This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  /// - pParameterDef and pInterpolation are a valid pointers.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - This object has already had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pParameterDef or pInterpolation arg is NULL.
  /// 
  ///
  /// @param pParameterDef [in] Parameter definition for this object (this determines the type of the varying value)
  /// @param pInterpolation [in] InterpolationDefinition object
  ///
  STDMETHOD(Initialize) (THIS_
    IAAFParameterDef * pParameterDef,
    IAAFInterpolationDef * pInterpolation) PURE;

  //***********************************************************
  //
  // AddControlPoint()
  //
  /// Adds a control point to the AAFVaryingValue object.
  /// The point will be sorted by time order, not the order in which
  /// the points were added.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pControlPoint pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pControlPoint is null.
  ///
  /// @param pControlPoint [in] pointer to IAAFControlPoint object
  ///
  STDMETHOD(AddControlPoint) (THIS_
    IAAFControlPoint * pControlPoint) PURE;


  //***********************************************************
  //
  // GetControlPoints()
  //
  /// Return an enumerator for the list of IAAFControlPoints.  The list
  /// will be returned in time order, not the order in which the
  /// points were added.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// @param ppEnum [out,retval] Parameter definition enumeration
  ///
  STDMETHOD(GetControlPoints) (THIS_
    IEnumAAFControlPoints ** ppEnum) PURE;


  //***********************************************************
  //
  // CountControlPoints()
  //
  /// This function returns the number of control points in the sequence.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails no state is changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  ///
  /// @param pResult [out] Number of control points
  ///
  STDMETHOD(CountControlPoints) (THIS_
    aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // GetControlPointAt()
  //
  /// This function retrieves the input control point at the given index in
  /// the given sequence.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the ppControlPoint pointer is valid.
  /// - index is less than the value returned by
  ///   CountControlPoints().
  /// 
  /// If this method fails nothing will be written to *ppControlPoint.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pControlPoint is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than or equal to the value returned by
  ///     CountControlPoints().
  ///
  /// @param index [in] index of control point to retrieve
  /// @param ppControlPoint [out, retval] Retrieved control point
  ///
  STDMETHOD(GetControlPointAt) (THIS_
    aafUInt32  index,
    IAAFControlPoint ** ppControlPoint) PURE;


  //***********************************************************
  //
  // RemoveControlPointAt()
  //
  /// This function removes the input control point at the given index in
  /// the given sequence.  Control points already existing at indices
  /// higher than the given index will be moved to the next lower index
  /// to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - index is less than the value returned by
  ///   CountControlPoints().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than or equal to the value returned by
  ///     CountControlPoints().
  ///
  /// @param index [in] index of control point to remove
  ///
  STDMETHOD(RemoveControlPointAt) (THIS_
    aafUInt32  index) PURE;


  //***********************************************************
  //
  // GetInterpolationDefinition()
  //
  /// Places the InterpolationDefinition object attached to this
  /// VaryingValue into the *ppInterpolation argument.  If none exists
  /// yet, NULL is placed into the *ppInterpolation argument.
  ///
  /// The returned InterpolationDefinition object, if it exists, is
  /// AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppInterpolation pointer is valid.
  /// - A valid InterpolationDefinition exists.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppInterpolation is null.
  ///
  /// @param ppInterpolation [out] Returned InterpolationDefinition object
  ///
  STDMETHOD(GetInterpolationDefinition) (THIS_
    IAAFInterpolationDef ** ppInterpolation) PURE;

  //***********************************************************
  //
  // GetValueBufLen()
  //
  /// Returns the length of buffer required for the
  /// GetInterpolatedValue() method.  The value is placed into the
  /// location specified by pLen.
  ///
  /// Succeeds if all of the following are true:
  /// - the pLen pointer is valid.
  ///
  /// If this method fails nothing will be written to *pLen.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLen arg is NULL.
  ///
  /// @param pLen [out] Mob Name
  ///
  STDMETHOD(GetValueBufLen) (THIS_
    aafInt32 *  pLen) PURE;


  //***********************************************************
  //
  // GetInterpolatedValue()
  //
  /// Writes the interpolated value of the IAAFVaryingValue at a given
  /// position into the pValue buffer.  The buffer is allocated by the
  /// caller, and the size of the buffer is given by valueSize.
  /// 
  /// Caller may call GetValueBufLen() to determine the
  /// required buffer size.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pValue pointer is valid.
  /// - valueSize indicates the buffer is large enough to hold the name.
  /// 
  /// If this method fails nothing will be written to *pValue.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pValue arg is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - valueSize indicates the buffer is too small to hold the value.
  ///
  /// @param inputValue [in] Position along the operation group
  /// @param valueSize [in] Size of preallocated buffer
  /// @param pValue [out,size_is(valueSize),length_is(*bytesRead)] Preallocated buffer to hold value
  /// @param bytesRead [out] Number of actual bytes read
  ///
  STDMETHOD(GetInterpolatedValue) (THIS_
    aafRational_t  inputValue,
    aafInt32  valueSize,
    aafDataBuffer_t  pValue,
    aafInt32 *  bytesRead) PURE;

  END_INTERFACE
};
#endif // __IAAFVaryingValue_INTERFACE_DEFINED__



// IAAFWAVEDescriptor

// ************************
//
// Interface IAAFWAVEDescriptor
//
// ************************



#ifndef __IAAFWAVEDescriptor_INTERFACE_DEFINED__
#define __IAAFWAVEDescriptor_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFWAVEDescriptor;

#undef  INTERFACE
#define INTERFACE   IAAFWAVEDescriptor

DECLARE_INTERFACE_(IAAFWAVEDescriptor, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFWAVEDescriptor methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty
  /// IAAFWaveDescriptor-supporting object.  This method must be
  /// called after allocation, and before any other method can be
  /// called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  STDMETHOD(Initialize) (THIS) PURE;


  //***********************************************************
  //
  // GetSummary()
  //
  /// Gets a copy of the WAVE file information without the media.
  /// 
  /// Succeeds if all of the following are true:
  /// - pSummary is a valid pointer.
  /// - The size of the buffer is large enough to hold the WAVE file
  ///   information.
  /// 
  /// If this method fails pSummary will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSummary arg is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - The buffer is too small to hold the WAVE file information.
  ///
  /// @param size [in] Size of preallocated buffer
  /// @param pSummary [out, size_is(size)] Preallocated buffer to hold the WAVE file information
  ///
  STDMETHOD(GetSummary) (THIS_
    aafUInt32  size,
    aafDataValue_t  pSummary) PURE;


  //***********************************************************
  //
  // GetSummaryBufferSize()
  //
  /// Returns the size of the buffer required for the GetSummary()
  /// method.  The value is placed into the location specified by pSize.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSize pointer is valid.
  ///
  /// If this method fails nothing will be written to *pSize.
  ///
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSize arg is NULL.
  ///
  /// @param pSize [out] required buffer size
  ///
  STDMETHOD(GetSummaryBufferSize) (THIS_
    aafUInt32 *  pSize) PURE;


  //***********************************************************
  //
  // SetSummary()
  //
  /// Sets the WAVE file information.
  /// 
  /// Succeeds if all of the following are true:
  /// - pSummary is a valid pointer
  /// 
  /// If this method fails the summary property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSummary arg is NULL.
  ///
  /// @param size [in] Size of preallocated buffer
  /// @param pSummary [in, size_is(size)] buffer containing value
  ///
  STDMETHOD(SetSummary) (THIS_
    aafUInt32  size,
    aafDataValue_t  pSummary) PURE;



  END_INTERFACE
};
#endif // __IAAFWAVEDescriptor_INTERFACE_DEFINED__



// IEnumAAFClassDefs

// ************************
//
// Interface IEnumAAFClassDefs
//
// ************************




#ifndef __IEnumAAFClassDefs_INTERFACE_DEFINED__
#define __IEnumAAFClassDefs_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFClassDefs;

#undef  INTERFACE
#define INTERFACE   IEnumAAFClassDefs

DECLARE_INTERFACE_(IEnumAAFClassDefs, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFClassDefs methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppClassDefs pointer is valid.
  /// - there are Class Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppClassDefs.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppClassDefs arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Class Definition objects remaining to be returned.
  ///
  /// @param ppClassDefs [out,retval] The Next Class Definition
  ///
  STDMETHOD(NextOne) (THIS_
    IAAFClassDef ** ppClassDefs) PURE;


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFClassDef pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppClassDefs pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are Class Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppClassDefs or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppClassDefs or pNumFetched arg is NULL.
  ///
  /// @param count [in] number of ClassDefs requested
  /// @param ppClassDefs [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual Class Definition objects fetched into ppClassDefs array
  ///
  STDMETHOD(Next) (THIS_
    aafUInt32  count,
    IAAFClassDef ** ppClassDefs,
    aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  ///
  /// @param count [in] Number of elements to skip
  ///
  STDMETHOD(Skip) (THIS_
    aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  ///
  /// @param ppEnum [out,retval] new enumeration
  ///
  STDMETHOD(Clone) (THIS_
    IEnumAAFClassDefs ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFClassDefs_INTERFACE_DEFINED__



// IEnumAAFCodecDefs

// ************************
//
// Interface IEnumAAFCodecDefs
//
// ************************




#ifndef __IEnumAAFCodecDefs_INTERFACE_DEFINED__
#define __IEnumAAFCodecDefs_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFCodecDefs;

#undef  INTERFACE
#define INTERFACE   IEnumAAFCodecDefs

DECLARE_INTERFACE_(IEnumAAFCodecDefs, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFCodecDefs methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppCodecDefs pointer is valid.
  /// - there are Codec Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppCodecDefs.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppCodecDefs arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Codec Definition objects remaining to be returned.
  ///
  /// @param ppCodecDefs [out,retval] The Next Codec Definition
  ///
  STDMETHOD(NextOne) (THIS_
    IAAFCodecDef ** ppCodecDefs) PURE;


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFCodecDef pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppCodecDefs pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are Codec Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppCodecDefs or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppCodecDefs or pNumFetched arg is NULL.
  ///
  /// @param count [in] number of CodecDefs requested
  /// @param ppCodecDefs [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual Codec Definition objects fetched into ppCodecDefs array
  ///
  STDMETHOD(Next) (THIS_
    aafUInt32  count,
    IAAFCodecDef ** ppCodecDefs,
    aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  ///
  /// @param count [in] Number of elements to skip
  ///
  STDMETHOD(Skip) (THIS_
    aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  ///
  /// @param ppEnum [out,retval] new enumeration
  ///
  STDMETHOD(Clone) (THIS_
    IEnumAAFCodecDefs ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFCodecDefs_INTERFACE_DEFINED__



// IEnumAAFCodecFlavours

// ************************
//
// Interface IEnumAAFCodecFlavours
//
// ************************



#ifndef __IEnumAAFCodecFlavours_INTERFACE_DEFINED__
#define __IEnumAAFCodecFlavours_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFCodecFlavours;

#undef  INTERFACE
#define INTERFACE   IEnumAAFCodecFlavours

DECLARE_INTERFACE_(IEnumAAFCodecFlavours, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFCodecFlavours methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for passing in a pointer to an aafUID_t,
  /// and retains control over the pointer.
  ///
  /// This is a just simplified version of the Next method. 
  ///
  /// @param pAAFCodecFlavour [out,retval] The Next flavour code
  ///
  STDMETHOD(NextOne) (THIS_
    aafUID_t *  pAAFCodecFlavour) PURE;


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (codec flavour IDs) in
  /// the enumerator's list, returning them in the given array along
  /// with the actual number of enumerated elements in pFetched. The
  /// caller is responsible for passing in a pointer to an array of
  /// aafUID_t, and retains control over the pointer.
  ///
  /// @param count [in] number of AAFPluggableDefs requested
  /// @param pAAFCodecFlavours [out, size_is(count), length_is(*pFetched)] array to receive flavour codes
  /// @param pFetched [out,ref] number of actual flavour IDs fetched into pAAFCodecFlavours array
  ///
  STDMETHOD(Next) (THIS_
    aafUInt32  count,
    aafUID_t *  pAAFCodecFlavours,
    aafUInt32 *  pFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to EnumAAFCodecFlavours::Next
  /// will not return those elements.
  ///
  /// @param count [in] Number of elements to skip
  ///
  STDMETHOD(Skip) (THIS_
    aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// There is no guarantee that the same set of elements will be
  /// enumerated on each pass through the list, nor will the elements
  /// necessarily be enumerated in the same order. The exact behavior
  /// depends on the collection being enumerated.
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another EnumAAFCodecFlavours enumerator with the same
  /// state as the current enumerator to iterate over the same
  /// list.  This method makes it possible to record a point in the
  /// enumeration sequence in order to return to that point at a later
  /// time.
  /// 
  /// The caller must release this new enumerator separately from the
  /// first enumerator.
  ///
  /// @param ppEnum [out,retval] new enumeration
  ///
  STDMETHOD(Clone) (THIS_
    IEnumAAFCodecFlavours ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFCodecFlavours_INTERFACE_DEFINED__



// IEnumAAFComponents

// ************************
//
// Interface IEnumAAFComponents
//
// ************************




#ifndef __IEnumAAFComponents_INTERFACE_DEFINED__
#define __IEnumAAFComponents_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFComponents;

#undef  INTERFACE
#define INTERFACE   IEnumAAFComponents

DECLARE_INTERFACE_(IEnumAAFComponents, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFComponents methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppComponent pointer is valid.
  /// - there are Component objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppComponent.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppComponent is null.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Components remaining to be returned.
  ///
  /// @param ppComponent [out,retval] The Next Component
  ///
  STDMETHOD(NextOne) (THIS_
    IAAFComponent ** ppComponent) PURE;


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFComponent pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppComponents pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched can be NULL.
  /// - There are Component objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppComponents or
  /// pNumFetched.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either ppComponents or pNumFetched is null.
  ///
  /// @param count [in] number of components requested
  /// @param ppComponents [out, size_is(count), length_is(*pNumFetched)] array to receive components
  /// @param pNumFetched [out,ref] number of actual Components fetched into ppComponents array
  ///
  STDMETHOD(Next) (THIS_
    aafUInt32  count,
    IAAFComponent ** ppComponents,
    aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not
  /// return those elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  ///
  /// @param count [in] Number of elements to skip
  ///
  STDMETHOD(Skip) (THIS_
    aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  /// 
  /// Always succeeds.
  /// 
  /// This method will return the following code:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another component enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// @param ppEnum [out,retval] new enumeration
  ///
  STDMETHOD(Clone) (THIS_
    IEnumAAFComponents ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFComponents_INTERFACE_DEFINED__



// IEnumAAFContainerDefs

// ************************
//
// Interface IEnumAAFContainerDefs
//
// ************************



#ifndef __IEnumAAFContainerDefs_INTERFACE_DEFINED__
#define __IEnumAAFContainerDefs_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFContainerDefs;

#undef  INTERFACE
#define INTERFACE   IEnumAAFContainerDefs

DECLARE_INTERFACE_(IEnumAAFContainerDefs, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFContainerDefs methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppContainerDefs pointer is valid.
  /// - there are Container Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppContainerDefs.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppContainerDefs arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Container Definition objects remaining to be returned.
  ///
  /// @param ppContainerDefs [out,retval] The Next Container Definition
  ///
  STDMETHOD(NextOne) (THIS_
    IAAFContainerDef ** ppContainerDefs) PURE;


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFContainerDef pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppContainerDefs pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are Container Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppContainerDefs or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppContainerDefs or pNumFetched arg is NULL.
  ///
  /// @param count [in] number of ContainerDefs requested
  /// @param ppContainerDefs [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual Container Definition objects fetched into ppContainerDefs array
  ///
  STDMETHOD(Next) (THIS_
    aafUInt32  count,
    IAAFContainerDef ** ppContainerDefs,
    aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  ///
  /// @param count [in] Number of elements to skip
  ///
  STDMETHOD(Skip) (THIS_
    aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  ///
  /// @param ppEnum [out,retval] new enumeration
  ///
  STDMETHOD(Clone) (THIS_
    IEnumAAFContainerDefs ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFContainerDefs_INTERFACE_DEFINED__



// IEnumAAFControlPoints

// ************************
//
// Interface IEnumAAFControlPoints
//
// ************************



#ifndef __IEnumAAFControlPoints_INTERFACE_DEFINED__
#define __IEnumAAFControlPoints_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFControlPoints;

#undef  INTERFACE
#define INTERFACE   IEnumAAFControlPoints

DECLARE_INTERFACE_(IEnumAAFControlPoints, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFControlPoints methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppControlPoints pointer is valid.
  /// - there are Control Point objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppControlPoints.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppControlPoints arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Control Point objects remaining to be returned.
  ///
  /// @param ppControlPoints [out,retval] The Next Control Point
  ///
  STDMETHOD(NextOne) (THIS_
    IAAFControlPoint ** ppControlPoints) PURE;


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFControlPoint pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppControlPoints pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are Control Point objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppControlPoints or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppControlPoints or pNumFetched arg is NULL.
  ///
  /// @param count [in] number of ControlPoints requested
  /// @param ppControlPoints [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual Control Point objects fetched into ppControlPoints array
  ///
  STDMETHOD(Next) (THIS_
    aafUInt32  count,
    IAAFControlPoint ** ppControlPoints,
    aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  ///
  /// @param count [in] Number of elements to skip
  ///
  STDMETHOD(Skip) (THIS_
    aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  ///
  /// @param ppEnum [out,retval] new enumeration
  ///
  STDMETHOD(Clone) (THIS_
    IEnumAAFControlPoints ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFControlPoints_INTERFACE_DEFINED__



// IEnumAAFDataDefs

// ************************
//
// Interface IEnumAAFDataDefs
//
// ************************



#ifndef __IEnumAAFDataDefs_INTERFACE_DEFINED__
#define __IEnumAAFDataDefs_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFDataDefs;

#undef  INTERFACE
#define INTERFACE   IEnumAAFDataDefs

DECLARE_INTERFACE_(IEnumAAFDataDefs, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFDataDefs methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppDataDefs pointer is valid.
  /// - there are Data Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppDataDefs.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDataDefs arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Data Definition objects remaining to be returned.
  ///
  /// @param ppDataDefs [out,retval] The Next Data Definition
  ///
  STDMETHOD(NextOne) (THIS_
    IAAFDataDef ** ppDataDefs) PURE;


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFDataDef pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppDataDefs pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are Data Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppDataDefs or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppDataDefs or pNumFetched arg is NULL.
  ///
  /// @param count [in] number of DataDefs requested
  /// @param ppDataDefs [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual Data Definition objects fetched into ppDataDefs array
  ///
  STDMETHOD(Next) (THIS_
    aafUInt32  count,
    IAAFDataDef ** ppDataDefs,
    aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  ///
  /// @param count [in] Number of elements to skip
  ///
  STDMETHOD(Skip) (THIS_
    aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  ///
  /// @param ppEnum [out,retval] new enumeration
  ///
  STDMETHOD(Clone) (THIS_
    IEnumAAFDataDefs ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFDataDefs_INTERFACE_DEFINED__



// IEnumAAFEssenceData

// ************************
//
// Interface IEnumAAFEssenceData
//
// ************************







#ifndef __IEnumAAFEssenceData_INTERFACE_DEFINED__
#define __IEnumAAFEssenceData_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFEssenceData;

#undef  INTERFACE
#define INTERFACE   IEnumAAFEssenceData

DECLARE_INTERFACE_(IEnumAAFEssenceData, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFEssenceData methods *** */


  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The caller is responsible for 
  /// properly releasing the returned pointer when it is no longer needed.
  /// @comm This is a just simplified version of the Next method. 
  ///
  /// @param ppEssenceData [out,retval] The Next EssenceData
  ///
  STDMETHOD(NextOne) (THIS_
    IAAFEssenceData ** ppEssenceData) PURE;

  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFEssenceData pointers) in 
  /// the enumerator's list, returning them in the given array along with the actual 
  /// number of enumerated elements in pcFetched. The caller is responsible for 
  /// properly releasing the returned pointers.
  ///
  /// @param count [in] number of essence data requested
  /// @param ppEssenceData [out, size_is(count), length_is(*pFetched)] array to receive EssenceData
  /// @param pFetched [out,ref] number of actual EssenceData fetched into ppEssenceData array
  ///
  STDMETHOD(Next) (THIS_
    aafUInt32  count,
    IAAFEssenceData ** ppEssenceData,
    aafUInt32 *  pFetched) PURE;

  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the enumeration so that 
  /// the next call to EnumAAFEssenceData::Next will not return 
  /// those elements.
  ///
  /// @param count [in] Number of elements to skip
  ///
  STDMETHOD(Skip) (THIS_
    aafUInt32  count) PURE;

  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of the list of elements. 
  /// @comm There is no guarantee that the same set of elements will be enumerated on 
  /// each pass through the list, nor will the elements necessarily be enumerated in 
  /// the same order. The exact behavior depends on the collection being enumerated.
  STDMETHOD(Reset) (THIS) PURE;

  //***********************************************************
  //
  // Clone()
  //
  /// Creates another essence data enumerator with the same state as the current 
  /// enumerator to iterate over the same list. This method makes it possible to 
  /// record a point in the enumeration sequence in order to return to that point 
  /// at a later time.
  /// @comm The caller must release this new enumerator separately from the first enumerator.
  ///
  /// @param ppEnum [out,retval] new enumeration
  ///
  STDMETHOD(Clone) (THIS_
    IEnumAAFEssenceData ** ppEnum) PURE;


  END_INTERFACE
};
#endif // __IEnumAAFEssenceData_INTERFACE_DEFINED__



// IEnumAAFFileDescriptors

// ************************
//
// Interface IEnumAAFFileDescriptors
//
// ************************




#ifndef __IEnumAAFFileDescriptors_INTERFACE_DEFINED__
#define __IEnumAAFFileDescriptors_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFFileDescriptors;

#undef  INTERFACE
#define INTERFACE   IEnumAAFFileDescriptors

DECLARE_INTERFACE_(IEnumAAFFileDescriptors, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFFileDescriptors methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppFileDescriptors pointer is valid.
  /// - there are FileDescriptor objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppFileDescriptors.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppFileDescriptors arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no FileDescriptor objects remaining to be returned.
  ///
  /// @param ppFileDescriptors [out,retval] The Next FileDescriptor
  ///
  STDMETHOD(NextOne) (THIS_
    IAAFFileDescriptor ** ppFileDescriptors) PURE;


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFFileDescriptor pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppFileDescriptors pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are FileDescriptor objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppFileDescriptors or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppFileDescriptors or pNumFetched arg is NULL.
  ///
  /// @param count [in] number of FileDescriptors requested
  /// @param ppFileDescriptors [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual FileDescriptor objects fetched into ppFileDescriptors array
  ///
  STDMETHOD(Next) (THIS_
    aafUInt32  count,
    IAAFFileDescriptor ** ppFileDescriptors,
    aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  ///
  /// @param count [in] Number of elements to skip
  ///
  STDMETHOD(Skip) (THIS_
    aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  ///
  /// @param ppEnum [out,retval] new enumeration
  ///
  STDMETHOD(Clone) (THIS_
    IEnumAAFFileDescriptors ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFFileDescriptors_INTERFACE_DEFINED__



// IEnumAAFFileEncodings

// ************************
//
// Interface IEnumAAFFileEncodings
//
// ************************




#ifndef __IEnumAAFFileEncodings_INTERFACE_DEFINED__
#define __IEnumAAFFileEncodings_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFFileEncodings;

#undef  INTERFACE
#define INTERFACE   IEnumAAFFileEncodings

DECLARE_INTERFACE_(IEnumAAFFileEncodings, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFFileEncodings methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppFileEncodings pointer is valid.
  /// - there are File Encoding objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppFileEncodings.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppFileEncodings arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no File Encoding objects remaining to be returned.
  ///
  /// @param ppFileEncodings [out,retval] The Next File Encoding
  ///
  STDMETHOD(NextOne) (THIS_
    IAAFFileEncoding ** ppFileEncodings) PURE;


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFFileEncoding pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppFileEncodings pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are File Encoding objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppFileEncodings or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppFileEncodings or pNumFetched arg is NULL.
  ///
  /// @param count [in] number of FileEncodings requested
  /// @param ppFileEncodings [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual File Encoding objects fetched into ppFileEncodings array
  ///
  STDMETHOD(Next) (THIS_
    aafUInt32  count,
    IAAFFileEncoding ** ppFileEncodings,
    aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  ///
  /// @param count [in] Number of elements to skip
  ///
  STDMETHOD(Skip) (THIS_
    aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  ///
  /// @param ppEnum [out,retval] new enumeration
  ///
  STDMETHOD(Clone) (THIS_
    IEnumAAFFileEncodings ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFFileEncodings_INTERFACE_DEFINED__



// IEnumAAFIdentifications

// ************************
//
// Interface IEnumAAFIdentifications
//
// ************************




#ifndef __IEnumAAFIdentifications_INTERFACE_DEFINED__
#define __IEnumAAFIdentifications_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFIdentifications;

#undef  INTERFACE
#define INTERFACE   IEnumAAFIdentifications

DECLARE_INTERFACE_(IEnumAAFIdentifications, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFIdentifications methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed. 
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppIdentification pointer is valid.
  /// - there are Identification objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppIdentification.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppIdentification is null.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Identifications remaining to be returned.
  ///
  /// @param ppIdentification [out, retval] The Next Identification
  ///
  STDMETHOD(NextOne) (THIS_
    IAAFIdentification ** ppIdentification) PURE;


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFIdentification pointers)
  /// in the enumerator's list, returning them in the given array
  /// along with the actual number of enumerated elements in
  /// pNumFetched. The caller is responsible for properly releasing the
  /// returned pointers when thery are no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppIdentifications pointer is valid.
  /// - the pNumFetched pointer is valid.
  /// - there are Identification objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppIdentifications or
  /// pNumFetched.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either ppIdentification or pNumFetched is null.
  ///
  /// @param count [in] number of identifications requested
  /// @param ppIdentifications [out, size_is(count), length_is(*pNumFetched)] array to receive identification objects
  /// @param pNumFetched [out] number of actual Identifications fetched into ppIdentifications array
  ///
  STDMETHOD(Next) (THIS_
    aafUInt32  count,
    IAAFIdentification ** ppIdentifications,
    aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to EnumAAFIdentifications::Next
  /// will not return those elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  ///
  /// @param count [in] Number of elements to skip
  ///
  STDMETHOD(Skip) (THIS_
    aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  /// 
  /// Always succeeds.
  /// 
  /// This method will return the following code:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another identification enumerator with the same state as
  /// the current enumerator to iterate over the same list. This method
  /// makes it possible to record a point in the enumeration sequence
  /// in order to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// @param ppEnum [out, retval] new enumeration
  ///
  STDMETHOD(Clone) (THIS_
    IEnumAAFIdentifications ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFIdentifications_INTERFACE_DEFINED__



// IEnumAAFInterpolationDefs

// ************************
//
// Interface IEnumAAFInterpolationDefs
//
// ************************



#ifndef __IEnumAAFInterpolationDefs_INTERFACE_DEFINED__
#define __IEnumAAFInterpolationDefs_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFInterpolationDefs;

#undef  INTERFACE
#define INTERFACE   IEnumAAFInterpolationDefs

DECLARE_INTERFACE_(IEnumAAFInterpolationDefs, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFInterpolationDefs methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppInterpolationDefs pointer is valid.
  /// - there are Interpolation Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppInterpolationDefs.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppInterpolationDefs arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Interpolation Definition objects remaining to be returned.
  ///
  /// @param ppInterpolationDefs [out,retval] The Next Interpolation Definition
  ///
  STDMETHOD(NextOne) (THIS_
    IAAFInterpolationDef ** ppInterpolationDefs) PURE;


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFInterpolationDef pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppInterpolationDefs pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are Interpolation Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppInterpolationDefs or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppInterpolationDefs or pNumFetched arg is NULL.
  ///
  /// @param count [in] number of InterpolationDefs requested
  /// @param ppInterpolationDefs [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual Interpolation Definition objects fetched into ppInterpolationDefs array
  ///
  STDMETHOD(Next) (THIS_
    aafUInt32  count,
    IAAFInterpolationDef ** ppInterpolationDefs,
    aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  ///
  /// @param count [in] Number of elements to skip
  ///
  STDMETHOD(Skip) (THIS_
    aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  ///
  /// @param ppEnum [out,retval] new enumeration
  ///
  STDMETHOD(Clone) (THIS_
    IEnumAAFInterpolationDefs ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFInterpolationDefs_INTERFACE_DEFINED__



// IEnumAAFKLVData

// ************************
//
// Interface IEnumAAFKLVData
//
// ************************



#ifndef __IEnumAAFKLVData_INTERFACE_DEFINED__
#define __IEnumAAFKLVData_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFKLVData;

#undef  INTERFACE
#define INTERFACE   IEnumAAFKLVData

DECLARE_INTERFACE_(IEnumAAFKLVData, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFKLVData methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppKLVData pointer is valid.
  /// - there are KLV Data objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppKLVData.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppKLVData arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no KLV Data objects remaining to be returned.
  ///
  /// @param ppKLVData [out,retval] The Next KLV Data
  ///
  STDMETHOD(NextOne) (THIS_
    IAAFKLVData ** ppKLVData) PURE;


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFKLVData pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppKLVData pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are KLV Data objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppKLVData or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppKLVData or pNumFetched arg is NULL.
  ///
  /// @param count [in] number of KLVData requested
  /// @param ppKLVData [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual KLV Data objects fetched into ppKLVData array
  ///
  STDMETHOD(Next) (THIS_
    aafUInt32  count,
    IAAFKLVData ** ppKLVData,
    aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  ///
  /// @param count [in] Number of elements to skip
  ///
  STDMETHOD(Skip) (THIS_
    aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  ///
  /// @param ppEnum [out,retval] new enumeration
  ///
  STDMETHOD(Clone) (THIS_
    IEnumAAFKLVData ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFKLVData_INTERFACE_DEFINED__



// IEnumAAFKLVDataDefs

// ************************
//
// Interface IEnumAAFKLVDataDefs
//
// ************************




#ifndef __IEnumAAFKLVDataDefs_INTERFACE_DEFINED__
#define __IEnumAAFKLVDataDefs_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFKLVDataDefs;


#undef  INTERFACE
#define INTERFACE   IEnumAAFKLVDataDefs

DECLARE_INTERFACE_(IEnumAAFKLVDataDefs, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFKLVDataDefs methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppKLVDataDefs pointer is valid.
  /// - there are KLVData Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppKLVDataDefs.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppKLVDataDefs arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no KLVData Definition objects remaining to be returned.
  ///
  /// @param ppKLVDataDefs [out,retval] The Next KLVData Definition
  ///
  STDMETHOD(NextOne) (THIS_
    IAAFKLVDataDefinition ** ppKLVDataDefs) PURE;


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFKLVDataDefinition pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppKLVDataDefs pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are KLVData Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppKLVDataDefs or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppKLVDataDefs or pNumFetched arg is NULL.
  ///
  /// @param count [in] number of KLVDataDefs requested
  /// @param ppKLVDataDefs [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual KLVData Definition objects fetched into ppKLVDataDefs array
  ///
  STDMETHOD(Next) (THIS_
    aafUInt32  count,
    IAAFKLVDataDefinition ** ppKLVDataDefs,
    aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  ///
  /// @param count [in] Number of elements to skip
  ///
  STDMETHOD(Skip) (THIS_
    aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  ///
  /// @param ppEnum [out,retval] new enumeration
  ///
  STDMETHOD(Clone) (THIS_
    IEnumAAFKLVDataDefs ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFKLVDataDefs_INTERFACE_DEFINED__



// IEnumAAFLoadedPlugins

// ************************
//
// Interface IEnumAAFLoadedPlugins
//
// ************************







#ifndef __IEnumAAFLoadedPlugins_INTERFACE_DEFINED__
#define __IEnumAAFLoadedPlugins_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFLoadedPlugins;

#undef  INTERFACE
#define INTERFACE   IEnumAAFLoadedPlugins

DECLARE_INTERFACE_(IEnumAAFLoadedPlugins, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFLoadedPlugins methods *** */


  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The caller is responsible 
  /// for properly releasing the returned pointer when it is no longer needed.
  /// @comm This is a just simplified version of the Next method. 
  ///
  /// @param ppAAFPluginID [out,retval] The Next AAFPluginID
  ///
  STDMETHOD(NextOne) (THIS_
    aafUID_t*  ppAAFPluginID) PURE;

  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFPluginDesc pointers) in 
  /// the enumerator's list, returning them in the given array along with the actual 
  /// number of enumerated elements in pFetched. The caller is responsible for 
  /// properly releasing the returned pointers.
  ///
  /// @param count [in] number of AAFPluginDef requested
  /// @param pAAFPluginIDs [out, size_is(count), length_is(*pFetched)] array to receive aafUID_t
  /// @param pFetched [out,ref] number of actual AAFPluginDef fetched into ppAAFPluginDef array
  ///
  STDMETHOD(Next) (THIS_
    aafUInt32  count,
    aafUID_t*  pAAFPluginIDs,
    aafUInt32 *  pFetched) PURE;

  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the enumeration so that 
  /// the next call to EnumAAFLoadedPlugins::Next will not return 
  /// those elements.
  ///
  /// @param count [in] Number of elements to skip
  ///
  STDMETHOD(Skip) (THIS_
    aafUInt32  count) PURE;

  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of the list of elements. 
  /// @comm There is no guarantee that the same set of elements will be enumerated on 
  /// each pass through the list, nor will the elements necessarily be enumerated in 
  /// the same order. The exact behavior depends on the collection being enumerated.
  STDMETHOD(Reset) (THIS) PURE;

  //***********************************************************
  //
  // Clone()
  //
  /// Creates another EnumAAFLoadedPlugins enumerator with the same state as the current 
  /// enumerator to iterate over the same list. This method makes it possible to 
  /// record a point in the enumeration sequence in order to return to that point 
  /// at a later time.
  /// @comm The caller must release this new enumerator separately from the first
  /// enumerator.
  ///
  /// @param ppEnum [out,retval] new enumeration
  ///
  STDMETHOD(Clone) (THIS_
    IEnumAAFLoadedPlugins ** ppEnum) PURE;


  END_INTERFACE
};
#endif // __IEnumAAFLoadedPlugins_INTERFACE_DEFINED__



// IEnumAAFLocators

// ************************
//
// Interface IEnumAAFLocators
//
// ************************




#ifndef __IEnumAAFLocators_INTERFACE_DEFINED__
#define __IEnumAAFLocators_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFLocators;

#undef  INTERFACE
#define INTERFACE   IEnumAAFLocators

DECLARE_INTERFACE_(IEnumAAFLocators, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFLocators methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppLocator pointer is valid.
  /// - there are Locator objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppLocator.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppLocator is null.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Locators remaining to be returned.
  ///
  /// @param ppLocator [out,retval] The Next Locator
  ///
  STDMETHOD(NextOne) (THIS_
    IAAFLocator ** ppLocator) PURE;


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFLocator pointers) in 
  /// the enumerator's list, returning them in the given array along
  /// with the actual number of enumerated elements in pcFetched. The
  /// caller is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppLocators pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched can be NULL.
  /// - There are Locator objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppLocators or
  /// pNumFetched.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either ppLocators or pNumFetched is null.
  ///
  /// @param count [in] number of locators requested
  /// @param ppLocators [out, size_is(count), length_is(*pFetched)] array to receive locators
  /// @param pFetched [out,ref] number of actual Locators fetched into ppLocators array
  ///
  STDMETHOD(Next) (THIS_
    aafUInt32  count,
    IAAFLocator ** ppLocators,
    aafUInt32 *  pFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to EnumAAFLocators::Next will
  /// not return those elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  ///
  /// @param count [in] Number of elements to skip
  ///
  STDMETHOD(Skip) (THIS_
    aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  /// 
  /// Always succeeds.
  /// 
  /// This method will return the following code:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another locator enumerator with the same state as the
  /// current enumerator to iterate over the same list. This method
  /// makes it possible to record a point in the enumeration sequence
  /// in order to return to that point at a later time.
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// @param ppEnum [out,retval] new enumeration
  ///
  STDMETHOD(Clone) (THIS_
    IEnumAAFLocators ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFLocators_INTERFACE_DEFINED__



// IEnumAAFMobSlots

// ************************
//
// Interface IEnumAAFMobSlots
//
// ************************




#ifndef __IEnumAAFMobSlots_INTERFACE_DEFINED__
#define __IEnumAAFMobSlots_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFMobSlots;

#undef  INTERFACE
#define INTERFACE   IEnumAAFMobSlots

DECLARE_INTERFACE_(IEnumAAFMobSlots, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFMobSlots methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppMobSlot pointer is valid.
  /// - there are Mob Slot objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppMobSlot.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppMobSlot is null.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - Hit the end of the list of slots being enumerated over.
  ///
  /// @param ppMobSlot [out,retval] The Next MobSlot
  ///
  STDMETHOD(NextOne) (THIS_
    IAAFMobSlot ** ppMobSlot) PURE;


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFMobSlot pointers) in 
  /// the enumerator's list, returning them in the given array along
  /// with the actual number of enumerated elements in pNumFetched. The
  /// caller is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppMobSlots pointer is valid.
  /// - the pNumFetched pointer is valid.
  /// - there are Mob Slot objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppMobSlots or
  /// pNumFetched.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either ppMob or pNumFetched is null.
  ///
  /// E_INVALIDARG
  ///   - Hit the end of the list of slots being enumerated over.
  ///
  /// @param count [in] number of mob slots requested
  /// @param ppMobSlots [out, size_is(count), length_is(*pNumFetched)] array to receive mob slots
  /// @param pNumFetched [out,ref] number of actual MobSlots fetched into ppMobSlots array
  ///
  STDMETHOD(Next) (THIS_
    aafUInt32  count,
    IAAFMobSlot ** ppMobSlots,
    aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to EnumAAFMobSlots::Next will
  /// not return those elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  ///
  /// @param count [in] Number of elements to skip
  ///
  STDMETHOD(Skip) (THIS_
    aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  /// 
  /// Always succeeds.
  /// 
  /// This method will return the following code:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another mob slot enumerator with the same state as the
  /// current enumerator to iterate over the same list. This method
  /// makes it possible to record a point in the enumeration sequence
  /// in order to return to that point at a later time.
  /// 
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// @param ppEnum [out,retval] new enumeration
  ///
  STDMETHOD(Clone) (THIS_
    IEnumAAFMobSlots ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFMobSlots_INTERFACE_DEFINED__



// IEnumAAFMobs

// ************************
//
// Interface IEnumAAFMobs
//
// ************************




#ifndef __IEnumAAFMobs_INTERFACE_DEFINED__
#define __IEnumAAFMobs_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFMobs;

#undef  INTERFACE
#define INTERFACE   IEnumAAFMobs

DECLARE_INTERFACE_(IEnumAAFMobs, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFMobs methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppMob pointer is valid.
  /// - there are Mob objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppMob.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppMob is null.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Mobs remaining to be returned.
  ///
  /// @param ppMob [out, retval] The Next Mob
  ///
  STDMETHOD(NextOne) (THIS_
    IAAFMob ** ppMob) PURE;


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFMob pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppMobs pointer is valid.
  /// - the pNumFetched pointer is valid.
  /// - there are Mob objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppMobs or
  /// pNumFetched.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either ppMob or pNumFetched is null.
  ///
  /// @param count [in] number of mobs requested
  /// @param ppMobs [out, size_is(count), length_is(*pNumFetched)] array to receive mobs
  /// @param pNumFetched [out] number of actual Mobs fetched into ppMobs array
  ///
  STDMETHOD(Next) (THIS_
    aafUInt32  count,
    IAAFMob ** ppMobs,
    aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to EnumAAFMobs::Next will not
  /// return those elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  ///
  /// @param count [in] Number of elements to skip
  ///
  STDMETHOD(Skip) (THIS_
    aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  /// 
  /// Always succeeds.
  /// 
  /// This method will return the following code:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another mob enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// @param ppEnum [out, retval] new enumeration
  ///
  STDMETHOD(Clone) (THIS_
    IEnumAAFMobs ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFMobs_INTERFACE_DEFINED__



// IEnumAAFOperationDefs

// ************************
//
// Interface IEnumAAFOperationDefs
//
// ************************



#ifndef __IEnumAAFOperationDefs_INTERFACE_DEFINED__
#define __IEnumAAFOperationDefs_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFOperationDefs;

#undef  INTERFACE
#define INTERFACE   IEnumAAFOperationDefs

DECLARE_INTERFACE_(IEnumAAFOperationDefs, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFOperationDefs methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppOperationDefs pointer is valid.
  /// - there are Operation Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppOperationDefs.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppOperationDefs arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Operation Definition objects remaining to be returned.
  ///
  /// @param ppOperationDefs [out,retval] The Next Operation Definition
  ///
  STDMETHOD(NextOne) (THIS_
    IAAFOperationDef ** ppOperationDefs) PURE;


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFOperationDef pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppOperationDefs pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are Operation Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppOperationDefs or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppOperationDefs or pNumFetched arg is NULL.
  ///
  /// @param count [in] number of OperationDefs requested
  /// @param ppOperationDefs [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual Operation Definition objects fetched into ppOperationDefs array
  ///
  STDMETHOD(Next) (THIS_
    aafUInt32  count,
    IAAFOperationDef ** ppOperationDefs,
    aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  ///
  /// @param count [in] Number of elements to skip
  ///
  STDMETHOD(Skip) (THIS_
    aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  ///
  /// @param ppEnum [out,retval] new enumeration
  ///
  STDMETHOD(Clone) (THIS_
    IEnumAAFOperationDefs ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFOperationDefs_INTERFACE_DEFINED__



// IEnumAAFParameterDefs

// ************************
//
// Interface IEnumAAFParameterDefs
//
// ************************






#ifndef __IEnumAAFParameterDefs_INTERFACE_DEFINED__
#define __IEnumAAFParameterDefs_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFParameterDefs;

#undef  INTERFACE
#define INTERFACE   IEnumAAFParameterDefs

DECLARE_INTERFACE_(IEnumAAFParameterDefs, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFParameterDefs methods *** */


  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppParameterDef pointer is valid.
  /// - there are ParameterDef objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppParameterDef.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppParameterDef is null.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no ParameterDefs remaining to be returned.
  ///
  /// @param ppParameterDef [out,retval] The Next ParameterDefinition
  ///
  STDMETHOD(NextOne) (THIS_
    IAAFParameterDef ** ppParameterDef) PURE;

  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFParameterDef pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppParameterDefs pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched can be NULL.
  /// - There are AAFParameterDef objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppComponents or
  /// pNumFetched.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either ppParameterDefs or pNumFetched is null.
  ///
  /// @param count [in] number of control code definitions requested
  /// @param ppParameterDefs [out, size_is(count), length_is(*pFetched)] array to receive control code definitions
  /// @param pFetched [out,ref] number of actual ParameterDefs fetched into ppParameterDefs array
  ///
  STDMETHOD(Next) (THIS_
    aafUInt32  count,
    IAAFParameterDef ** ppParameterDefs,
    aafUInt32 *  pFetched) PURE;

  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not
  /// return those elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  ///
  /// @param count [in] Number of elements to skip
  ///
  STDMETHOD(Skip) (THIS_
    aafUInt32  count) PURE;

  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  /// 
  /// Always succeeds.
  /// 
  /// This method will return the following code:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;
  /// @comm There is no guarantee that the same set of elements will be enumerated on 
  /// each pass through the list\, nor will the elements necessarily be enumerated in 
  /// the same order. The exact behavior depends on the collection being enumerated.)

  //***********************************************************
  //
  // Clone()
  //
  /// Creates another EnumAAFParameterDefs enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// @param ppEnum [out,retval] new enumeration
  ///
  STDMETHOD(Clone) (THIS_
    IEnumAAFParameterDefs ** ppEnum) PURE;


  END_INTERFACE
};
#endif // __IEnumAAFParameterDefs_INTERFACE_DEFINED__



// IEnumAAFParameters

// ************************
//
// Interface IEnumAAFParameters
//
// ************************




#ifndef __IEnumAAFParameters_INTERFACE_DEFINED__
#define __IEnumAAFParameters_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFParameters;

#undef  INTERFACE
#define INTERFACE   IEnumAAFParameters

DECLARE_INTERFACE_(IEnumAAFParameters, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFParameters methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppParameter pointer is valid.
  /// - there are Parameter objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppParameter.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppParameter is null.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Parameters remaining to be returned.
  ///
  /// @param ppParameter [out,retval] The Next Parameter
  ///
  STDMETHOD(NextOne) (THIS_
    IAAFParameter ** ppParameter) PURE;

  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFParameter pointers) in
  /// the enumerator's list, returning them in the given array along
  /// with the actual number of enumerated elements in pNumFetched. The
  /// caller is responsible for properly releasing the returned
  /// pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppParameters pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are AAFParameter objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppComponents or
  /// pNumFetched.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either ppParameters or pNumFetched is null.
  ///
  /// @param count [in] number of parameter objects requested
  /// @param ppParameters [out, size_is(count), length_is(*pFetched)] array to receive parameter objects
  /// @param pFetched [out,ref] number of actual Parameters fetched into ppParameters array
  ///
  STDMETHOD(Next) (THIS_
    aafUInt32  count,
    IAAFParameter ** ppParameters,
    aafUInt32 *  pFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not
  /// return those elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  ///
  /// @param count [in] Number of elements to skip
  ///
  STDMETHOD(Skip) (THIS_
    aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  /// 
  /// Always succeeds.
  /// 
  /// This method will return the following code:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// There is no guarantee that the same set of elements will be
  /// enumerated on each pass through the list, nor will the elements
  /// necessarily be enumerated in the same order. The exact behavior
  /// depends on the collection being enumerated.
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another EnumAAFParameters enumerator with the same state
  /// as the current enumerator to iterate over the same list. This
  /// method makes it possible to record a point in the enumeration
  /// sequence in order to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// @param ppEnum [out,retval] new enumeration
  ///
  STDMETHOD(Clone) (THIS_
    IEnumAAFParameters ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFParameters_INTERFACE_DEFINED__



// IEnumAAFPluginDefs

// ************************
//
// Interface IEnumAAFPluginDefs
//
// ************************




#ifndef __IEnumAAFPluginDefs_INTERFACE_DEFINED__
#define __IEnumAAFPluginDefs_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFPluginDefs;

#undef  INTERFACE
#define INTERFACE   IEnumAAFPluginDefs

DECLARE_INTERFACE_(IEnumAAFPluginDefs, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFPluginDefs methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppPluginDefs pointer is valid.
  /// - there are Plugin Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppPluginDefs.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppPluginDefs arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Plugin Definition objects remaining to be returned.
  ///
  /// @param ppPluginDefs [out,retval] The Next Plugin Definition
  ///
  STDMETHOD(NextOne) (THIS_
    IAAFPluginDef ** ppPluginDefs) PURE;


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFPluginDef pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppPluginDefs pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are Plugin Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppPluginDefs or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppPluginDefs or pNumFetched arg is NULL.
  ///
  /// @param count [in] number of PluginDefs requested
  /// @param ppPluginDefs [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual Plugin Definition objects fetched into ppPluginDefs array
  ///
  STDMETHOD(Next) (THIS_
    aafUInt32  count,
    IAAFPluginDef ** ppPluginDefs,
    aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  ///
  /// @param count [in] Number of elements to skip
  ///
  STDMETHOD(Skip) (THIS_
    aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  ///
  /// @param ppEnum [out,retval] new enumeration
  ///
  STDMETHOD(Clone) (THIS_
    IEnumAAFPluginDefs ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFPluginDefs_INTERFACE_DEFINED__



// IEnumAAFPluginLocators

// ************************
//
// Interface IEnumAAFPluginLocators
//
// ************************




#ifndef __IEnumAAFPluginLocators_INTERFACE_DEFINED__
#define __IEnumAAFPluginLocators_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFPluginLocators;

#undef  INTERFACE
#define INTERFACE   IEnumAAFPluginLocators

DECLARE_INTERFACE_(IEnumAAFPluginLocators, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFPluginLocators methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  ///
  /// @param ppAAFLocator [out,retval] The Next AAFLocator
  ///
  STDMETHOD(NextOne) (THIS_
    IAAFLocator ** ppAAFLocator) PURE;


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFLocator pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  ///
  /// @param count [in] number of AAFLocators requested
  /// @param ppAAFLocators [out, size_is(count), length_is(*pFetched)] array to receive AAFLocators
  /// @param pFetched [out,ref] number of actual AAFLocators fetched into ppAAFLocators array
  ///
  STDMETHOD(Next) (THIS_
    aafUInt32  count,
    IAAFLocator ** ppAAFLocators,
    aafUInt32 *  pFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to EnumAAFPluginLocators::Next
  /// will not return  those elements.
  ///
  /// @param count [in] Number of elements to skip
  ///
  STDMETHOD(Skip) (THIS_
    aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// There is no guarantee that the same set of elements will be
  /// enumerated on each pass through the list, nor will the elements
  /// necessarily be enumerated inthe same order. The exact behavior
  /// depends on the collection being enumerated.
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another AAFPluginLocators enumerator with the same state
  /// as the current enumerator to iterate over the same list. This
  /// method makes it possible to record a point in the enumeration
  /// sequence in order to return to that point at a later time.
  ///
  /// The caller must release this new enumerator separately from the
  /// first enumerator.
  ///
  /// @param ppEnum [out,retval] new enumeration
  ///
  STDMETHOD(Clone) (THIS_
    IEnumAAFPluginLocators ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFPluginLocators_INTERFACE_DEFINED__



// IEnumAAFProperties

// ************************
//
// Interface IEnumAAFProperties
//
// ************************




#ifndef __IEnumAAFProperties_INTERFACE_DEFINED__
#define __IEnumAAFProperties_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFProperties;

#undef  INTERFACE
#define INTERFACE   IEnumAAFProperties

DECLARE_INTERFACE_(IEnumAAFProperties, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFProperties methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppProperties pointer is valid.
  /// - there are Property objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppProperties.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppProperties arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Property objects remaining to be returned.
  ///
  /// @param ppProperties [out,retval] The Next Property
  ///
  STDMETHOD(NextOne) (THIS_
    IAAFProperty ** ppProperties) PURE;


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFProperty pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppProperties pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are Property objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppProperties or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppProperties or pNumFetched arg is NULL.
  ///
  /// @param count [in] number of Properties requested
  /// @param ppProperties [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual Property objects fetched into ppProperties array
  ///
  STDMETHOD(Next) (THIS_
    aafUInt32  count,
    IAAFProperty ** ppProperties,
    aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  ///
  /// @param count [in] Number of elements to skip
  ///
  STDMETHOD(Skip) (THIS_
    aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  ///
  /// @param ppEnum [out,retval] new enumeration
  ///
  STDMETHOD(Clone) (THIS_
    IEnumAAFProperties ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFProperties_INTERFACE_DEFINED__



// IEnumAAFPropertyDefs

// ************************
//
// Interface IEnumAAFPropertyDefs
//
// ************************




#ifndef __IEnumAAFPropertyDefs_INTERFACE_DEFINED__
#define __IEnumAAFPropertyDefs_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFPropertyDefs;

#undef  INTERFACE
#define INTERFACE   IEnumAAFPropertyDefs

DECLARE_INTERFACE_(IEnumAAFPropertyDefs, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFPropertyDefs methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppPropertyDefs pointer is valid.
  /// - there are Property Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppPropertyDefs.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppPropertyDefs arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Property Definition objects remaining to be returned.
  ///
  /// @param ppPropertyDefs [out,retval] The Next Property Definition
  ///
  STDMETHOD(NextOne) (THIS_
    IAAFPropertyDef ** ppPropertyDefs) PURE;


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFPropertyDef pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppPropertyDefs pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are Property Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppPropertyDefs or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppPropertyDefs or pNumFetched arg is NULL.
  ///
  /// @param count [in] number of PropertyDefs requested
  /// @param ppPropertyDefs [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual Property Definition objects fetched into ppPropertyDefs array
  ///
  STDMETHOD(Next) (THIS_
    aafUInt32  count,
    IAAFPropertyDef ** ppPropertyDefs,
    aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  ///
  /// @param count [in] Number of elements to skip
  ///
  STDMETHOD(Skip) (THIS_
    aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  ///
  /// @param ppEnum [out,retval] new enumeration
  ///
  STDMETHOD(Clone) (THIS_
    IEnumAAFPropertyDefs ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFPropertyDefs_INTERFACE_DEFINED__



// IEnumAAFPropertyValues

// ************************
//
// Interface IEnumAAFPropertyValues
//
// ************************




#ifndef __IEnumAAFPropertyValues_INTERFACE_DEFINED__
#define __IEnumAAFPropertyValues_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFPropertyValues;

#undef  INTERFACE
#define INTERFACE   IEnumAAFPropertyValues

DECLARE_INTERFACE_(IEnumAAFPropertyValues, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFPropertyValues methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppPropertyValue pointer is valid.
  /// - there are Property Values remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppPropertyValue.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppPropertyValue is null.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Components remaining to be returned.
  ///
  /// @param ppPropertyValue [out,retval] The Next Property Value
  ///
  STDMETHOD(NextOne) (THIS_
    IAAFPropertyValue ** ppPropertyValue) PURE;


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFPropertyValue pointers)
  /// in the enumerator's list, returning them in the given array
  /// along with the actual number of enumerated elements in
  /// pNumFetched. The caller is responsible for properly releasing the
  /// returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppMobs pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL. 
  /// - There are Property Value objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppPropertyValues or
  /// pNumFetched.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either ppCompoents or pNumFetched is null.
  ///
  /// @param count [in] number of objects requested
  /// @param ppPropertyValues [out, size_is(count), length_is(*pFetched)] array to receive Property Values
  /// @param pFetched [out,ref] number of actual Property Values fetched into ppPropertyValues
	/// array
  ///
  STDMETHOD(Next) (THIS_
    aafUInt32  count,
    IAAFPropertyValue ** ppPropertyValues,
    aafUInt32 *  pFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not
  /// return those elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  ///
  /// @param count [in] Number of elements to skip
  ///
  STDMETHOD(Skip) (THIS_
    aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// Always succeeds.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another Property Value enumerator with the same state as
  /// the current enumerator to iterate over the same list. This method
  /// makes it possible to record a point in the enumeration sequence
  /// in order to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// @param ppEnum [out,retval] new enumeration
  ///
  STDMETHOD(Clone) (THIS_
    IEnumAAFPropertyValues ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFPropertyValues_INTERFACE_DEFINED__



// IEnumAAFRIFFChunks

// ************************
//
// Interface IEnumAAFRIFFChunks
//
// ************************






#ifndef __IEnumAAFRIFFChunks_INTERFACE_DEFINED__
#define __IEnumAAFRIFFChunks_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFRIFFChunks;

#undef  INTERFACE
#define INTERFACE   IEnumAAFRIFFChunks

DECLARE_INTERFACE_(IEnumAAFRIFFChunks, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFRIFFChunks methods *** */


  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppRIFFChunks pointer is valid.
  /// - there are RIFFChunk objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppRIFFChunks.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppRIFFChunks arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no RIFFChunk objects remaining to be returned.
  ///
  /// @param ppRIFFChunks [out,retval] The Next RIFFChunk
  ///
  STDMETHOD(NextOne) (THIS_
    IAAFRIFFChunk ** ppRIFFChunks) PURE;


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFRIFFChunk pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppRIFFChunks pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are RIFFChunk objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppRIFFChunks or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppRIFFChunks or pNumFetched arg is NULL.
  ///
  /// @param count [in] number of RIFFChunks requested
  /// @param ppRIFFChunks [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual RIFFChunk objects fetched into ppRIFFChunks array
  ///
  STDMETHOD(Next) (THIS_
    aafUInt32  count,
    IAAFRIFFChunk ** ppRIFFChunks,
    aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  ///
  /// @param count [in] Number of elements to skip
  ///
  STDMETHOD(Skip) (THIS_
    aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  ///
  /// @param ppEnum [out,retval] new enumeration
  ///
  STDMETHOD(Clone) (THIS_
    IEnumAAFRIFFChunks ** ppEnum) PURE;


  END_INTERFACE
};
#endif // __IEnumAAFRIFFChunks_INTERFACE_DEFINED__



// IEnumAAFSegments

// ************************
//
// Interface IEnumAAFSegments
//
// ************************



#ifndef __IEnumAAFSegments_INTERFACE_DEFINED__
#define __IEnumAAFSegments_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFSegments;

#undef  INTERFACE
#define INTERFACE   IEnumAAFSegments

DECLARE_INTERFACE_(IEnumAAFSegments, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFSegments methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppSegments pointer is valid.
  /// - there are Segment objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppSegments.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppSegments arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Segment objects remaining to be returned.
  ///
  /// @param ppSegments [out,retval] The Next Segment
  ///
  STDMETHOD(NextOne) (THIS_
    IAAFSegment ** ppSegments) PURE;


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFSegment pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppSegments pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are Segment objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppSegments or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppSegments or pNumFetched arg is NULL.
  ///
  /// @param count [in] number of Segments requested
  /// @param ppSegments [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual Segment objects fetched into ppSegments array
  ///
  STDMETHOD(Next) (THIS_
    aafUInt32  count,
    IAAFSegment ** ppSegments,
    aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  ///
  /// @param count [in] Number of elements to skip
  ///
  STDMETHOD(Skip) (THIS_
    aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  ///
  /// @param ppEnum [out,retval] new enumeration
  ///
  STDMETHOD(Clone) (THIS_
    IEnumAAFSegments ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFSegments_INTERFACE_DEFINED__



// IEnumAAFTaggedValueDefs

// ************************
//
// Interface IEnumAAFTaggedValueDefs
//
// ************************




#ifndef __IEnumAAFTaggedValueDefs_INTERFACE_DEFINED__
#define __IEnumAAFTaggedValueDefs_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFTaggedValueDefs;


#undef  INTERFACE
#define INTERFACE   IEnumAAFTaggedValueDefs

DECLARE_INTERFACE_(IEnumAAFTaggedValueDefs, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFTaggedValueDefs methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppTaggedValueDefs pointer is valid.
  /// - there are TaggedValue Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppTaggedValueDefs.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTaggedValueDefs arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no TaggedValue Definition objects remaining to be returned.
  ///
  /// @param ppTaggedValueDefs [out,retval] The Next TaggedValue Definition
  ///
  STDMETHOD(NextOne) (THIS_
    IAAFTaggedValueDefinition ** ppTaggedValueDefs) PURE;


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFTaggedValueDefinition pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppTaggedValueDefs pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are TaggedValue Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppTaggedValueDefs or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppTaggedValueDefs or pNumFetched arg is NULL.
  ///
  /// @param count [in] number of TaggedValueDefs requested
  /// @param ppTaggedValueDefs [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual TaggedValue Definition objects fetched into ppTaggedValueDefs array
  ///
  STDMETHOD(Next) (THIS_
    aafUInt32  count,
    IAAFTaggedValueDefinition ** ppTaggedValueDefs,
    aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  ///
  /// @param count [in] Number of elements to skip
  ///
  STDMETHOD(Skip) (THIS_
    aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  ///
  /// @param ppEnum [out,retval] new enumeration
  ///
  STDMETHOD(Clone) (THIS_
    IEnumAAFTaggedValueDefs ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFTaggedValueDefs_INTERFACE_DEFINED__



// IEnumAAFTaggedValues

// ************************
//
// Interface IEnumAAFTaggedValues
//
// ************************



#ifndef __IEnumAAFTaggedValues_INTERFACE_DEFINED__
#define __IEnumAAFTaggedValues_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFTaggedValues;

#undef  INTERFACE
#define INTERFACE   IEnumAAFTaggedValues

DECLARE_INTERFACE_(IEnumAAFTaggedValues, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFTaggedValues methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppTaggedValues pointer is valid.
  /// - there are Tagged Value objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppTaggedValues.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTaggedValues arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Tagged Value objects remaining to be returned.
  ///
  /// @param ppTaggedValues [out,retval] The Next Tagged Value
  ///
  STDMETHOD(NextOne) (THIS_
    IAAFTaggedValue ** ppTaggedValues) PURE;


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFTaggedValue pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppTaggedValues pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are Tagged Value objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppTaggedValues or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppTaggedValues or pNumFetched arg is NULL.
  ///
  /// @param count [in] number of TaggedValues requested
  /// @param ppTaggedValues [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual Tagged Value objects fetched into ppTaggedValues array
  ///
  STDMETHOD(Next) (THIS_
    aafUInt32  count,
    IAAFTaggedValue ** ppTaggedValues,
    aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  ///
  /// @param count [in] Number of elements to skip
  ///
  STDMETHOD(Skip) (THIS_
    aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  ///
  /// @param ppEnum [out,retval] new enumeration
  ///
  STDMETHOD(Clone) (THIS_
    IEnumAAFTaggedValues ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFTaggedValues_INTERFACE_DEFINED__



// IEnumAAFTypeDefs

// ************************
//
// Interface IEnumAAFTypeDefs
//
// ************************



#ifndef __IEnumAAFTypeDefs_INTERFACE_DEFINED__
#define __IEnumAAFTypeDefs_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFTypeDefs;

#undef  INTERFACE
#define INTERFACE   IEnumAAFTypeDefs

DECLARE_INTERFACE_(IEnumAAFTypeDefs, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFTypeDefs methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  /// Enumerates to the next element in the enumerators list. The
  /// caller is responsible for properly releasing the returned pointer
  /// when it is no longer needed.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppTypeDefs pointer is valid.
  /// - there are Type Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppTypeDefs.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppTypeDefs arg is NULL.
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - no Type Definition objects remaining to be returned.
  ///
  /// @param ppTypeDefs [out,retval] The Next Type Definition
  ///
  STDMETHOD(NextOne) (THIS_
    IAAFTypeDef ** ppTypeDefs) PURE;


  //***********************************************************
  //
  // Next()
  //
  /// Enumerates the next count elements (AAFTypeDef pointers) in the
  /// enumerator's list, returning them in the given array along with
  /// the actual number of enumerated elements in pNumFetched. The caller
  /// is responsible for properly releasing the returned pointers.
  /// 
  /// Succeeds if all of the following are true:
  /// - The ppTypeDefs pointer is valid.
  /// - The pNumFetched pointer is valid. If count is 1, pNumFetched
  ///   can be NULL.
  /// - There are Type Definition objects remaining to be returned.
  /// 
  /// If this method fails nothing is written to *ppTypeDefs or
  /// pNumFetched.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either ppTypeDefs or pNumFetched arg is NULL.
  ///
  /// @param count [in] number of TypeDefs requested
  /// @param ppTypeDefs [out, size_is(count), length_is(*pNumFetched)] array to receive elements
  /// @param pNumFetched [out,ref] number of actual Type Definition objects fetched into ppTypeDefs array
  ///
  STDMETHOD(Next) (THIS_
    aafUInt32  count,
    IAAFTypeDef ** ppTypeDefs,
    aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  /// Instructs the enumerator to skip the next count elements in the
  /// enumeration so that the next call to Next will not return those
  /// elements.
  /// 
  /// Succeeds if all of the following are true:
  /// - count is less than or equal to the number of remaining objects.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NO_MORE_OBJECTS
  ///   - count exceeded number of remaining objects.
  ///
  /// @param count [in] Number of elements to skip
  ///
  STDMETHOD(Skip) (THIS_
    aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  /// Instructs the enumerator to position itself at the beginning of
  /// the list of elements.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  /// Creates another enumerator with the same state as the current
  /// enumerator to iterate over the same list. This method makes it
  /// possible to record a point in the enumeration sequence in order
  /// to return to that point at a later time.
  ///
  /// Note: The caller must release this new enumerator separately from
  /// the first enumerator.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  ///
  /// @param ppEnum [out,retval] new enumeration
  ///
  STDMETHOD(Clone) (THIS_
    IEnumAAFTypeDefs ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFTypeDefs_INTERFACE_DEFINED__



// IAAFAES3PCMDescriptor2

// ************************
//
// Interface IAAFAES3PCMDescriptor2
//
// ************************



#ifndef __IAAFAES3PCMDescriptor2_INTERFACE_DEFINED__
#define __IAAFAES3PCMDescriptor2_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFAES3PCMDescriptor2;

#undef  INTERFACE
#define INTERFACE   IAAFAES3PCMDescriptor2

DECLARE_INTERFACE_(IAAFAES3PCMDescriptor2, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFAES3PCMDescriptor2 methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, IAAFAES3PCMDescriptor-supporting
  /// object. This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  STDMETHOD(Initialize) (THIS) PURE;

  //***********************************************************
  //
  // GetEmphasis()
  //
  /// Gets the Emphasis type property.
  /// Succeeds if all of the following are true:
  /// - pEmphasisType is a valid pointer.
  ///
  /// If this method fails, *pEmphasisType will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEmphasisType arg is NULL.
  ///
  /// @param pEmphasisType [out] Address to store the emphasis type.
  ///
  STDMETHOD(GetEmphasis) (THIS_
    aafEmphasisType_t *  pEmphasisType) PURE;

  //***********************************************************
  //
  // SetEmphasis()
  //
  /// Gets the Emphasis type property.
  /// Succeeds if all of the following are true:
  /// 
  ///
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param EmphasisType [in] Sets the Emphasis type property.
  ///
  STDMETHOD(SetEmphasis) (THIS_
    aafEmphasisType_t  EmphasisType) PURE;

  //***********************************************************
  //
  // GetBlockStartOffset()
  //
  /// Gets the BlockStartOffset.
  /// Succeeds if all of the following are true:
  /// - pBlockStartOffset is a valid pointer.
  ///
  /// If this method fails, *pBlockStartOffset will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBlockStartOffset arg is NULL.
  ///
  /// @param pBlockStartOffset [out] Address to store the BlockStartOffset.
  ///
  STDMETHOD(GetBlockStartOffset) (THIS_
    aafUInt16 *  pBlockStartOffset) PURE;

  //***********************************************************
  //
  // SetBlockStartOffset()
  //
  /// Sets the BlockStartOffset.
  /// Succeeds if all of the following are true:
  /// 
  ///
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param BlockStartOffset [in] Sets the BlockStartOffset.
  ///
  STDMETHOD(SetBlockStartOffset) (THIS_
    aafUInt16  BlockStartOffset) PURE;

  //***********************************************************
  //
  // GetAuxBitsMode()
  //
  /// Gets the AuxBitsMode.
  /// Succeeds if all of the following are true:
  /// - pAuxBitsMode is a valid pointer.
  ///
  /// If this method fails, *pAuxBitsMode will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pAuxBitsMode arg is NULL.
  ///
  /// @param pAuxBitsMode [out] Address to store the AuxBitsMode.
  ///
  STDMETHOD(GetAuxBitsMode) (THIS_
    aafAuxBitsModeType_t *  pAuxBitsMode) PURE;

  //***********************************************************
  //
  // SetAuxBitsMode()
  //
  /// Sets the AuxBitsMode.
  /// Succeeds if all of the following are true:
  /// 
  ///
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param AuxBitsMode [in] Sets the AuxBitsMode.
  ///
  STDMETHOD(SetAuxBitsMode) (THIS_
    aafAuxBitsModeType_t  AuxBitsMode) PURE;

  //***********************************************************
  //
  // GetChannelStatusModeAt()
  //
  /// Gets the ChannelStatusMode for the channel referenced by the index
	/// Succeeds if all of the following are true:
	///	
	/// - pChannelStatusMode is a valid pointer
	/// - index is a valid index with the array of channels
	///
	/// this method will return the following codes
	///
	/// AAFRESULT_SUCCESS
	///   - succeeded.  (This is the only code indicating success.)
	///
	/// AAFRESULT_NOT_INITIALIZED
	///   - This object has not yet had Initialize() called on it.
	///
	/// AAFRESULT_NULL_PARAM
	///	 - pChannelStatusMode arg is NULL
	///
	///	AAFRESULT_BADINDEX
	///	 - index is not a valid index
  ///
  /// @param index [in] Index of the channel desired.
  /// @param pChannelStatusMode [out] Address to store ChannelStatusMode for the index given.
  ///
  STDMETHOD(GetChannelStatusModeAt) (THIS_
    aafUInt32  index,
    aafChannelStatusModeType_t *  pChannelStatusMode) PURE;

  //***********************************************************
  //
  // SetChannelStatusModeAt()
  //
  /// Sets the ChannelStatusMode for the channel referenced by the index
	/// Succeeds if all of the following are true:
	///	
	/// - index is a valid index with the array of channels
	///
	/// this method will return the following codes
	///
	/// AAFRESULT_SUCCESS
	///   - succeeded.  (This is the only code indicating success.)
	///
	/// AAFRESULT_NOT_INITIALIZED
	///   - This object has not yet had Initialize() called on it.
	///
	///	AAFRESULT_BADINDEX
	///	 - index is not a valid index
  ///
  /// @param index [in] Index of the channel desired.
  /// @param ChannelStatusMode [in] Set ChannelStatusMode for the index given.
  ///
  STDMETHOD(SetChannelStatusModeAt) (THIS_
    aafUInt32  index,
    aafChannelStatusModeType_t  ChannelStatusMode) PURE;

  //***********************************************************
  //
  // GetFixedChannelStatusDataAt()
  //
  /// Gets the FixedChannelStatusData for the channel referenced by the index
	///		each channel's status is a 24 byte array that gets copied into the 
	///		the address pointed to by pFixedChannelStatusData.
	/// Succeeds if all of the following are true:
	///	
	/// - pFixedChannelStatusData is a valid pointer
	/// - index is a valid index with the array of channels
	/// - sizeOfBuffer must be 24
	///
	/// this method will return the following codes
	///
	/// AAFRESULT_SUCCESS
	///   - succeeded.  (This is the only code indicating success.)
	///
	/// AAFRESULT_NOT_INITIALIZED
	///   - This object has not yet had Initialize() called on it.
	///
	/// AAFRESULT_NULL_PARAM
	///	 - pFixedChannelStatusData arg is NULL
	///
	///	AAFRESULT_BADINDEX
	///	 - index is not a valid index
	///
	/// AAFRESULT_WRONG_SIZE
	///  - buffer size is not correct
  ///
  /// @param index [in] Index of the channel desired.
  /// @param sizeOfBuffer [in] Size of pFixedChannelStatusData buffer in bytes.
  /// @param pFixedChannelStatusData [out] Address to store FixedChannelStatusData for the index given.
  ///
  STDMETHOD(GetFixedChannelStatusDataAt) (THIS_
    aafUInt32  index,
    aafUInt32  sizeOfBuffer,
    aafUInt8 *  pFixedChannelStatusData) PURE;

  //***********************************************************
  //
  // SetFixedChannelStatusDataAt()
  //
  /// Sets the FixedChannelStatusData for the channel referenced by the index
	///		each channel's status is a 24 byte array that gets copied from the 
	///		the address pointed to by pFixedChannelStatusData .
	/// Succeeds if all of the following are true:
	///	
	/// - pFixedChannelStatusData is a valid pointer
	/// - index is a valid index with the array of channels
	/// - sizeOfBuffer must be 24
	///
	/// this method will return the following codes
	///
	/// AAFRESULT_SUCCESS
	///   - succeeded.  (This is the only code indicating success.)
	///
	/// AAFRESULT_NOT_INITIALIZED
	///   - This object has not yet had Initialize() called on it.
	///
	/// AAFRESULT_NULL_PARAM
	///	 - pFixedChannelStatusData arg is NULL
	///
	///	AAFRESULT_BADINDEX
	///	 - index is not a valid index
	///
	/// AAFRESULT_WRONG_SIZE
	///  - buffer size is not correct
  ///
  /// @param index [in] Index of the channel desired.
  /// @param sizeOfBuffer [in] Size of pFixedChannelStatusData buffer in bytes.
  /// @param pFixedChannelStatusData [in] Set FixedChannelStatusData for the index given.
  ///
  STDMETHOD(SetFixedChannelStatusDataAt) (THIS_
    aafUInt32  index,
    aafUInt32  sizeOfBuffer,
    aafUInt8 *  pFixedChannelStatusData) PURE;

  //***********************************************************
  //
  // GetUserDataModeAt()
  //
  /// Gets the UserDataMode for the channel referenced by the index
	/// Succeeds if all of the following are true:
	///	
	/// - pUserDataMode is a valid pointer
	/// - index is a valid index with the array of channels
	///
	/// this method will return the following codes
	///
	/// AAFRESULT_SUCCESS
	///   - succeeded.  (This is the only code indicating success.)
	///
	/// AAFRESULT_NOT_INITIALIZED
	///   - This object has not yet had Initialize() called on it.
	///
	/// AAFRESULT_NULL_PARAM
	///	 - pUserDataMode arg is NULL
	///
	///	AAFRESULT_BADINDEX
	///	 - index is not a valid index
  ///
  /// @param index [in] Index of the channel desired.
  /// @param pUserDataMode [out] Address to store UserDataMode for the index given.
  ///
  STDMETHOD(GetUserDataModeAt) (THIS_
    aafUInt32  index,
    aafUserDataModeType_t *  pUserDataMode) PURE;

  //***********************************************************
  //
  // SetUserDataModeAt()
  //
  /// Sets the UserDataMode for the channel referenced by the index
	/// Succeeds if all of the following are true:
	///	
	/// - index is a valid index with the array of channels
	///
	/// this method will return the following codes
	///
	/// AAFRESULT_SUCCESS
	///   - succeeded.  (This is the only code indicating success.)
	///
	/// AAFRESULT_NOT_INITIALIZED
	///   - This object has not yet had Initialize() called on it.
	///
	///	AAFRESULT_BADINDEX
	///	 - index is not a valid index
  ///
  /// @param index [in] Index of the channel desired.
  /// @param UserDataMode [in] Set UserDataMode for the index given.
  ///
  STDMETHOD(SetUserDataModeAt) (THIS_
    aafUInt32  index,
    aafUserDataModeType_t  UserDataMode) PURE;

  //***********************************************************
  //
  // GetFixedUserDataAt()
  //
  /// Gets the FixedUserData for the channel referenced by the index
	///		each channel's status is a 24 byte array that gets copied into the 
	///		the address pointed to by pFixedUserData.
	/// Succeeds if all of the following are true:
	///	
	/// - pFixedUserData is a valid pointer
	/// - index is a valid index with the array of channels
	/// - sizeOfBuffer must be 24
	///
	/// this method will return the following codes
	///
	/// AAFRESULT_SUCCESS
	///   - succeeded.  (This is the only code indicating success.)
	///
	/// AAFRESULT_NOT_INITIALIZED
	///   - This object has not yet had Initialize() called on it.
	///
	/// AAFRESULT_NULL_PARAM
	///	 - pFixedUserData arg is NULL
	///
	///	AAFRESULT_BADINDEX
	///	 - index is not a valid index
	///
	/// AAFRESULT_WRONG_SIZE
	///  - buffer size is not correct
  ///
  /// @param index [in] Index of the channel desired.
  /// @param sizeOfBuffer [in] Size of pFixedUserData buffer in bytes.
  /// @param pFixedUserData [out] Address to store FixedUserData for the index given.
  ///
  STDMETHOD(GetFixedUserDataAt) (THIS_
    aafUInt32  index,
    aafUInt32  sizeOfBuffer,
    aafUInt8 *  pFixedUserData) PURE;

  //***********************************************************
  //
  // SetFixedUserDataAt()
  //
  /// Sets the FixedUserData for the channel referenced by the index
	///		each channel's status is a 24 byte array that gets copied from the 
	///		the address pointed to by pFixedUserData .
	/// Succeeds if all of the following are true:
	///	
	/// - pFixedUserData is a valid pointer
	/// - index is a valid index with the array of channels
	/// - sizeOfBuffer must be 24
	///
	/// this method will return the following codes
	///
	/// AAFRESULT_SUCCESS
	///   - succeeded.  (This is the only code indicating success.)
	///
	/// AAFRESULT_NOT_INITIALIZED
	///   - This object has not yet had Initialize() called on it.
	///
	/// AAFRESULT_NULL_PARAM
	///	 - pFixedUserData arg is NULL
	///
	///	AAFRESULT_BADINDEX
	///	 - index is not a valid index
	///
	/// AAFRESULT_WRONG_SIZE
	///  - buffer size is not correct
  ///
  /// @param index [in] Index of the channel desired.
  /// @param sizeOfBuffer [in] Size of pFixedUserData buffer in bytes.
  /// @param pFixedUserData [in] Set FixedUserData for the index given.
  ///
  STDMETHOD(SetFixedUserDataAt) (THIS_
    aafUInt32  index,
    aafUInt32  sizeOfBuffer,
    aafUInt8 *  pFixedUserData) PURE;


  END_INTERFACE
};
#endif // __IAAFAES3PCMDescriptor2_INTERFACE_DEFINED__



// IAAFCDCIDescriptor2

// ************************
//
// Interface IAAFCDCIDescriptor2
//
// ************************



#ifndef __IAAFCDCIDescriptor2_INTERFACE_DEFINED__
#define __IAAFCDCIDescriptor2_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFCDCIDescriptor2;

#undef  INTERFACE
#define INTERFACE   IAAFCDCIDescriptor2

DECLARE_INTERFACE_(IAAFCDCIDescriptor2, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFCDCIDescriptor2 methods *** */


  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty
  /// IAAFCDCIDescriptor2-supporting object.  This method must be called
  /// after allocation, and before any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  STDMETHOD(Initialize) (THIS) PURE;


  //***********************************************************
  //
  // SetComponentWidth()
  //
  /// Sets the ComponentWidth property.  Specifies the number of bits
  /// used to store each component.  Typical values can be 8, 10,
  /// 12, 14, or 16, but others are permitted by the reference
  /// implementation.  Each component in a sample is packed
  /// contiguously; the sample is filled with the number of bits
  /// specified by the optional PaddingBits property.  If  the
  /// PaddingBits property is omitted, samples are packed
  /// contiguously.
  ///
  /// If this method fails, the ComponentWidth property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param ComponentWidth [in] Number of bits.
  ///
  STDMETHOD(SetComponentWidth) (THIS_
    aafInt32  ComponentWidth) PURE;


  //***********************************************************
  //
  // GetComponentWidth()
  //
  /// Gets the ComponentWidth property.  Specifies the number of bits
  /// used to store each component.  Typical values can be 8, 10,
  /// 12, 14, or 16, but others are permitted by the reference
  /// implementation.  Each component in a sample is packed
  /// contiguously; the sample is filled with the number of bits
  /// specified by the optional PaddingBits property.  If the
  /// PaddingBits property is omitted, samples are packed
  /// contiguously.
  ///
  /// Succeeds if all of the following are true:
  /// - pComponentWidth is a valid pointer.
  /// 
  /// If this method fails, *pComponentWidth will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pComponentWidth arg is NULL.
  ///
  /// @param pComponentWidth [out] Address to store the number of bits.
  ///
  STDMETHOD(GetComponentWidth) (THIS_
    aafInt32 *  pComponentWidth) PURE;


  //***********************************************************
  //
  // SetHorizontalSubsampling()
  //
  /// Sets the HorizontalSubsampling property.  Specifies the ratio of
  /// luminance sampling to chrominance sampling in the horizontal direction.
  /// For 4:2:2 video, the value is 2, which means that there are twice as
  /// many luminance values as there are color-difference values.
  /// Another typical value is 1; however other values are permitted by
  /// the reference implementation.
  ///
  /// If this method fails, the HorizontalSubsampling property will
  /// not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param HorizontalSubsampling [in] Integer value.
  ///
  STDMETHOD(SetHorizontalSubsampling) (THIS_
    aafUInt32  HorizontalSubsampling) PURE;


  //***********************************************************
  //
  // GetHorizontalSubsampling()
  //
  /// Gets the HorizontalSubsampling property.  Specifies the ratio of
  /// luminance sampling to chrominance sampling in the horizontal
  /// direction.  For 4:2:2 video, the value is 2, which means that
  /// there are twice as many luminance values as there are
  /// color-difference values.  Another typical value is 1; however
  /// other values are permitted by the reference implementation.
  ///
  /// Succeeds if all of the following are true:
  /// - pHorizontalSubsampling is a valid pointer.
  /// 
  /// If this method fails, *pHorizontalSubsampling will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pHorizontalSubsampling arg is NULL.
  ///
  /// @param pHorizontalSubsampling [out] Address to store the integer value.
  ///
  STDMETHOD(GetHorizontalSubsampling) (THIS_
    aafUInt32 *  pHorizontalSubsampling) PURE;


  //***********************************************************
  //
  // SetVerticalSubsampling()
  //
  /// Sets the VerticalSubsampling property.  Specifies the ratio of
  /// luminance sampling to chrominance sampling in the vertical direction.
  /// For 4:2:2 video, the value is 2, which means that there are twice as
  /// many luminance values as there are color-difference values.
  /// Another typical value is 1; however other values are permitted by
  /// the reference implementation.
  ///
  /// If this method fails, the VerticalSubsampling property will
  /// not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param VerticalSubsampling [in] Integer value.
  ///
  STDMETHOD(SetVerticalSubsampling) (THIS_
    aafUInt32  VerticalSubsampling) PURE;


  //***********************************************************
  //
  // GetVerticalSubsampling()
  //
  /// Gets the VerticalSubsampling property.  Specifies the ratio of
  /// luminance sampling to chrominance sampling in the vertical
  /// direction.  For 4:2:2 video, the value is 2, which means that
  /// there are twice as many luminance values as there are
  /// color-difference values.  Another typical value is 1; however
  /// other values are permitted by the reference implementation.
  ///
  /// Succeeds if all of the following are true:
  /// - pVerticalSubsampling is a valid pointer.
  /// 
  /// If this method fails, *pVerticalSubsampling will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pVerticalSubsampling arg is NULL.
  ///
  /// @param pVerticalSubsampling [out] Address to store the integer value.
  ///
  STDMETHOD(GetVerticalSubsampling) (THIS_
    aafUInt32 *  pVerticalSubsampling) PURE;


  //***********************************************************
  //
  // SetColorSiting()
  //
  /// Sets the ColorSiting property.  Specifies how to compute subsampled
  /// chrominance values.
  ///
  /// Valid values are:
  ///
  ///     kCoSiting  - To calculate subsampled pixels, take the preceding's pixels
  ///                  color value, discard the other color values and cosite the
  ///                  color with the first luminance value.
  ///
  ///     kAveraging - To calculate subsampled pixels, take the average of the two
  ///                  adjacent pixels' color values and site the color in the center
  ///                  of the luminance pixels.
  ///
  ///     kThreeTap  - To calculate subsampled pixels, take 25 percent of the the previous
  ///                  pixel's color value, 50 percent of the first value and 25 percent
  ///                  of the second value.  For the first value in a row, use 75 percent
  ///                  of that value since there is no previous value.  The kThreeTap value
  ///                  is only meaningful when the HorizontalSubsampling propert has a value
  ///                  of 2.
  ///
  /// This property is optional.  The default value is kCoSiting.
  ///
  /// Succeeds if all of the following are true:
  /// - ColorSiting is valid
  ///
  /// If this method fails, the ColorSiting property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param ColorSiting [in] Color siting value.
  ///
  STDMETHOD(SetColorSiting) (THIS_
    aafColorSiting_t  ColorSiting) PURE;


  //***********************************************************
  //
  // GetColorSiting()
  //
  /// Gets the ColorSiting property.  Specifies how to compute
  /// subsampled chrominance values.
  ///
  /// Valid values are:
  ///
  ///     kCoSiting  - To calculate subsampled pixels, take the
  ///                  preceding's pixels color value, discard the
  ///                  other color values and cosite the color with the
  ///                  first luminance value.
  ///
  ///     kAveraging - To calculate subsampled pixels, take the
  ///                  average of the two adjacent pixels' color values
  ///                  and site the color in the center of the
  ///                  luminance pixels.
  ///
  ///     kThreeTap  - To calculate subsampled pixels, take 25 percent
  ///                  of the the previous pixel's color value, 50
  ///                  percent of the first value and 25 percent of the
  ///                  second value.  For the first value in a row,
  ///                  use 75 percent of that value since there is no
  ///                  previous value.  The kThreeTap value is only
  ///                  meaningful when the HorizontalSubsampling
  ///                  propert has a value of 2.
  ///
  /// Succeeds if all of the following are true:
  /// - pColorSiting is a valid pointer.
  ///
  /// If this method fails, *pColorSiting will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pColorSiting arg is NULL.
  ///
  /// @param pColorSiting [out] Address to store the color siting value.
  ///
  STDMETHOD(GetColorSiting) (THIS_
    aafColorSiting_t *  pColorSiting) PURE;


  //***********************************************************
  //
  // SetBlackReferenceLevel()
  //
  /// Sets the BlackReferenceLevel property.  Specifies the digital luminance
  /// component component value associated with black.
  ///
  /// For CCIR-601/2, the value is 16 for 8-bit video and 64 for
  /// 10-bit video.  For YUV, the value is 0.  These are typical
  /// values; other values will not be disallowed by the reference
  /// implementation.
  ///
  /// The same value is used in CDCI and RGBA when standard colorspace
  /// conversion is used.
  ///
  /// This property is optional.  The default value is 0.
  ///
  /// If this method fails, the BlackReferenceLevel property will not
  /// be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param BlackReferenceLevel [in] Integer value.
  ///
  STDMETHOD(SetBlackReferenceLevel) (THIS_
    aafUInt32  BlackReferenceLevel) PURE;


  //***********************************************************
  //
  // GetBlackReferenceLevel()
  //
  /// Gets the BlackReferenceLevel property.  Specifies the digital
  /// luminance component value associated with black.
  ///
  /// For CCIR-601/2, the value is 16 for 8-bit video and 64 for
  /// 10-bit video.  For YUV, the value is 0.  These are typical
  /// values; other values will not be disallowed by the reference
  /// implementation.
  ///
  /// The same value is used in CDCI and RGBA when standard colorspace
  /// conversion is used.
  ///
  /// Succeeds if all of the following are true:
  /// - pBlackReferenceLevel is a valid pointer.
  /// 
  /// If this method fails, *pBlackReferenceLevel will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBlackReferenceLevel arg is NULL.
  ///
  /// @param pBlackReferenceLevel [out] Address to store the integer value.
  ///
  STDMETHOD(GetBlackReferenceLevel) (THIS_
    aafUInt32 *  pBlackReferenceLevel) PURE;


  //***********************************************************
  //
  // SetWhiteReferenceLevel()
  //
  /// Sets the WhiteReferenceLevel property.  Specifies the digital
  /// luminance component component value associated with white.
  ///
  /// For CCIR-601/2, the value is 235 for 8-bit video and 940 for
  /// 10-bit video.  For YUV, the value is 255 for 8-bit video and
  /// 1023 for 10-bit video.  These are typical values; other values
  /// will not be disallowed by the reference implementation.
  ///
  /// This property is optional.  The default value is the maximum
  /// unsigned interger value for component size.
  ///
  /// If this method fails, the WhiteReferenceLevel property will not
  /// be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param WhiteReferenceLevel [in] Integer value.
  ///
  STDMETHOD(SetWhiteReferenceLevel) (THIS_
    aafUInt32  WhiteReferenceLevel) PURE;


  //***********************************************************
  //
  // GetWhiteReferenceLevel()
  //
  /// Gets the WhiteReferenceLevel property.  Specifies the digital
  /// luminance component component value associated with white.
  ///
  /// For CCIR-601/2, the value is 235 for 8-bit video and 940 for
  /// 10-bit video.  For YUV, the value is 255 for 8-bit video and
  /// 1023 for 10-bit video.  These are typical values; other values
  /// will not be disallowed by the reference implementation.
  ///
  /// Succeeds if all of the following are true:
  /// - pWhiteReferenceLevel is a valid pointer.
  /// 
  /// If this method fails, *pWhiteReferenceLevel will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pWhiteReferenceLevel arg is NULL.
  ///
  /// @param pWhiteReferenceLevel [out] Address to store the integer value.
  ///
  STDMETHOD(GetWhiteReferenceLevel) (THIS_
    aafUInt32 *  pWhiteReferenceLevel) PURE;


  //***********************************************************
  //
  // SetColorRange()
  //
  /// Sets the ColorRange property.  Specifies the range of allowable
  /// digital chrominance component values.  Chrominance values are
  /// unsigned and the range is centered on 128 for 8-bit video and 512
  /// for 10-bit video.  This value is used for both chrominance
  /// components.
  ///
  /// For CCIR-601/2, the range is 225 for 8-bit video and 897 for
  /// 10-bit video.  For YUV, the range is 255 for 8-bit video and
  /// 1023 for 10-bit video.  These are typical values; other values will
  /// not be disallowed by the reference implementation.
  ///
  /// This property is optional.  The default value is the maximum
  /// unsigned integer value for component size.
  ///
  /// Succeeds if all of the following are true:
  /// 
  /// If this method fails, the ColorRange property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param ColorRange [in] Integer value.
  ///
  STDMETHOD(SetColorRange) (THIS_
    aafUInt32  ColorRange) PURE;


  //***********************************************************
  //
  // GetColorRange()
  //
  /// Gets the ColorRange property.  Specifies the range of allowable
  /// digital chrominance component values.  Chrominance values are
  /// unsigned and the range is centered on 128 for 8-bit video and 512
  /// for 10-bit video.  This value is used for both chrominance
  /// components.
  ///
  /// For CCIR-601/2, the range is 225 for 8-bit video and 897 for
  /// 10-bit video.  For YUV, the range is 255 for 8-bit video and
  /// 1023 for 10-bit video.  These are typical values; other values will
  /// not be disallowed by the reference implementation.
  ///
  /// Succeeds if all of the following are true:
  /// - pColorRange is a valid pointer.
  /// 
  /// If this method fails, *pColorRange will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pColorRange arg is NULL.
  ///
  /// @param pColorRange [out] Address to store the integer value.
  ///
  STDMETHOD(GetColorRange) (THIS_
    aafUInt32 *  pColorRange) PURE;


  //***********************************************************
  //
  // SetPaddingBits()
  //
  /// Sets the PaddingBits property.  Specifies the number of bits
  /// padded to each pixel.
  ///
  /// This property is optional.  The default value is 0.
  ///
  /// If this method fails, the PaddingBits property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param PaddingBits [in] Number of bits.
  ///
  STDMETHOD(SetPaddingBits) (THIS_
    aafInt16  PaddingBits) PURE;


  //***********************************************************
  //
  // GetPaddingBits()
  //
  /// Gets the PaddingBits property.  Specifies the number of bits
  /// padded to each pixel.
  ///
  ///
  /// Succeeds if all of the following are true:
  /// - pPaddingBits is a valid pointer.
  /// 
  /// If this method fails, pPaddingBits will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPaddingBits arg is NULL.
  ///
  /// @param pPaddingBits [out] Address to store the number of bits.
  ///
  STDMETHOD(GetPaddingBits) (THIS_
    aafInt16 *  pPaddingBits) PURE;


  //***********************************************************
  //
  // SetAlphaSamplingWidth()
  //
  /// Sets the AlphaSamplingWidth property.
  ///
  /// Succeeds if all of the following are true:
  ///
  /// If this method fails, the AlphaSamplingWidth property will not be
  /// changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param alphaSamplingWidth [in] Optional.
  ///
  STDMETHOD(SetAlphaSamplingWidth) (THIS_
    aafUInt32  alphaSamplingWidth) PURE;

  //***********************************************************
  //
  // GetAlphaSamplingWidth()
  //
  /// Gets the AlphaSamplingWidth property.
  ///
  /// Succeeds if all of the following are true:
  /// - pAlphaSamplingWidth is a valid pointer
  /// - the property is present.
  ///
  /// If this method fails, pAlphaSamplingWidth will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pAlphaSamplingWidth is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pAlphaSamplingWidth [out] Optional.
  ///
  STDMETHOD(GetAlphaSamplingWidth) (THIS_
    aafUInt32 *  pAlphaSamplingWidth) PURE;

  //***********************************************************
  //
  // SetReversedByteOrder()
  //
  /// Sets the ReversedByteOrder property.
  ///
  /// Succeeds if all of the following are true:
  ///
  /// If this method fails, the ReversedByteOrder property will not be
  /// changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param reversedByteOrder [in] Optional.
  ///
  STDMETHOD(SetReversedByteOrder) (THIS_
    aafBoolean_t  reversedByteOrder) PURE;

  //***********************************************************
  //
  // GetReversedByteOrder()
  //
  /// Gets the ReversedByteOrder property.
  ///
  /// Succeeds if all of the following are true:
  /// - pReversedByteOrder is a valid pointer
  /// - the property is present.
  ///
  /// If this method fails, pReversedByteOrder will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pReversedByteOrder is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pReversedByteOrder [out] Optional.
  ///
  STDMETHOD(GetReversedByteOrder) (THIS_
    aafBoolean_t *  pReversedByteOrder) PURE;



  END_INTERFACE
};
#endif // __IAAFCDCIDescriptor2_INTERFACE_DEFINED__



// IAAFComponent2

// ************************
//
// Interface IAAFComponent2
//
// ************************








#ifndef __IAAFComponent2_INTERFACE_DEFINED__
#define __IAAFComponent2_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFComponent2;

#undef  INTERFACE
#define INTERFACE   IAAFComponent2

DECLARE_INTERFACE_(IAAFComponent2, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFComponent2 methods *** */




  //***********************************************************
  //
  // SetLength()
  //
  /// Sets the length property value on this component object.
  /// 
  /// Succeeds if all of the following are true:
  /// - the optional length property is present for this object.
  ///
  /// This method deals with an optional property, which will only be
  /// present for time-varying media.
  /// 
  /// If this method fails the length property will not be
  /// changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_BAD_PROP
  ///   - the optional length property is not present for this object.
  ///
  /// @param length [in] The duration in edit units of this component
  ///
  STDMETHOD(SetLength) (THIS_
    aafLength_constref  length) PURE;


  //***********************************************************
  //
  // GetLength()
  //
  /// Gets the duration in edit units of this component.
  ///	
  /// Succeeds if all of the following are true:
  /// - the pLength pointer is valid.
  /// - the optional length property is present for this object.
  ///
  /// This method deals with an optional property, which will only be
  /// present for time-varying media.
  /// 
  /// If this method fails nothing will be written to *pLength.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLength arg is NULL.
  ///
  /// AAFRESULT_BAD_PROP
  ///   - the optional length property is not present for this object.
  ///
  /// @param pLength [retval][out] Length of this component
  ///
  STDMETHOD(GetLength) (THIS_
    aafLength_t *  pLength) PURE;
	

  //***********************************************************
  //
  // SetDataDef()
  //
  /// Sets the data definition property AUID on this component.
  /// 
  /// If this method fails the Data Definition property will not be
  /// changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDataDef arg is NULL.
  ///
  /// @param pDataDef [in] DataDef of this object
  ///
  STDMETHOD(SetDataDef) (THIS_
    IAAFDataDef * pDataDef) PURE;


  //***********************************************************
  //
  // GetDataDef()
  //
  /// Returns data definition object.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppDatadef pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppDatadef.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDatadef arg is NULL.
  ///
  /// @param ppDatadef [out, retval] DataDef of this object
  ///
  STDMETHOD(GetDataDef) (THIS_
    IAAFDataDef ** ppDatadef) PURE;

  //***********************************************************
  //
  // AppendKLVData()
  //
  /// Appends a pre-existing KLV Data object to the specified
  /// component.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pKLV pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - the pData arg is NULL.
  ///
  /// @param pData [in] KLV object
  ///
  STDMETHOD(AppendKLVData) (THIS_
    IAAFKLVData * pData) PURE;


  //***********************************************************
  //
  // CountKLVData()
  //
  /// Return total number of KLV data objects attached to this component.
  ///
  /// Succeeds if all of the following are true:
  /// - the pNumData pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pNumComments.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumData arg is NULL.
  ///
  /// @param pNumData [out] Number of KLV data objects
  ///
  STDMETHOD(CountKLVData) (THIS_
    aafUInt32 *  pNumData) PURE;


  //***********************************************************
  //
  // GetKLVData()
  //
  /// Return the enumeration for all KLV data objects on this component.  The returned
  /// enumerator is AddRef()ed before it is returned.  The enumerator
  /// is implemented as a EnumAAFKLVData.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// @param ppEnum [out] KLV data objects
  ///
  STDMETHOD(GetKLVData) (THIS_
    IEnumAAFKLVData ** ppEnum) PURE;


  //***********************************************************
  //
  // RemoveKLVData()
  //
  /// Removes the given KLV data object from this component.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pData pointer is valid.
  /// - the given KLV data object is present in the component.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pData is null.
  ///
  /// AAFRESULT_OBJECT_NOT_FOUND
  ///   - the given KLV data object is not in this component.
  ///
  /// @param pData [in] KLV data object to remove
  ///
  STDMETHOD(RemoveKLVData) (THIS_
    IAAFKLVData * pData) PURE;



  //***********************************************************
  //
  // AppendComment()
  //
  /// Append an attribute name/value pair to the attribute list.
  ///
  /// Creates a new tagged value, initializes it with the specified comment
  /// name/value pair, and appends it to the comment list.
  ///
  /// Succeeds if:
  ///   - pName and pValue are valid pointers.
  ///
  /// Return codes:
  ///
  ///   AAFRESULT_SUCCESS
  ///
  ///   AAFRESULT_NULL_PARAM
  ///	     - pName or pValue is null.
  ///
  /// @param pName [in] The attribute name.
  /// @param pValue [in] The attribute value.
  ///
  STDMETHOD(AppendComment) (THIS_
    aafCharacter_constptr  pName,
    aafCharacter_constptr  pValue) PURE;

  //***********************************************************
  //
  // CountComments()
  //
  /// Return the number of comments contained in this component.
  ///
  /// Succeeds if:
  ///   - pNumComments is a valid pointer
  ///
  /// Return codes:
  ///
  ///   AAFRESULT_SUCCESS
  ///
  ///   AAFRESULT_NULL_PARAM
  ///	     - pNumComments is null.
  ///
  /// @param pNumComments [out] Pointer to comment count.
  ///
  STDMETHOD(CountComments) (THIS_
    aafUInt32*  pNumComments) PURE;
  

  //***********************************************************
  //
  // GetComments()
  //
  /// Return a comment enumerator for this component.
  ///
  /// Creates an enumerator for this component's comments.  The new enumerator is
  /// AddRef()ed before it is returned.
  ///
  /// Succeeds if:
  ///   - pName and pValue are valid pointers.
  ///
  /// Return codes:
  ///
  ///   AAFRESULT_SUCCESS
  ///
  ///   AAFRESULT_NULL_PARAM
  ///	     - pEnum was null.
  ///
  /// @param ppEnum [out] Pointer to the new enumerator object created by this method.
  ///
  STDMETHOD(GetComments) (THIS_
    IEnumAAFTaggedValues ** ppEnum) PURE;


  //***********************************************************
  //
  // RemoveComment()
  //
  /// Remove a component comment (tagged value).
  ///
  /// Succeeds if:
  ///   - pName and pValue are valid pointers.
  ///
  /// Return codes:
  ///
  ///   AAFRESULT_SUCCESS
  ///
  ///   AAFRESULT_NULL_PARAM
  ///	     - pName or pValue is null.
  ///
  /// @param pComment [in] Pointer to the tagged value comment.
  ///
  STDMETHOD(RemoveComment) (THIS_
    IAAFTaggedValue * pComment) PURE;

  //***********************************************************
  //
  // AppendAttribute()
  //
  /// Append an attribute name/value pair to the attribute list.
  ///
  /// Creates a new tagged value, initializes it with the specified attribute
  /// name/value pair, and appends it to the attribute list.
  ///
  /// Succeeds if:
  ///   - pName and pValue are valid pointers.
  ///
  /// Return codes:
  ///
  ///   AAFRESULT_SUCCESS
  ///
  ///   AAFRESULT_NULL_PARAM
  ///	     - pName or pValue is null.
  ///
  /// @param pName [in] The attribute name.
  /// @param pValue [in] The attribute value.
  ///
  STDMETHOD(AppendAttribute) (THIS_
    aafCharacter_constptr  pName,
    aafCharacter_constptr  pValue) PURE;

  //***********************************************************
  //
  // CountAttributes()
  //
  /// Return the number of attributes contained in this component.
  ///
  /// Succeeds if:
  ///   - pNumAttributes is a valid pointer
  ///
  /// Return codes:
  ///
  ///   AAFRESULT_SUCCESS
  ///
  ///   AAFRESULT_NULL_PARAM
  ///	     - pNumAttributes is null.
  ///
  /// @param pNumAttributes [out] Pointer to attribute count.
  ///
  STDMETHOD(CountAttributes) (THIS_
    aafUInt32*  pNumAttributes) PURE;
  

  //***********************************************************
  //
  // GetAttributes()
  //
  /// Return an attribute enumerator for this component.
  ///
  /// Creates an enumerator for this component's attributes.  The new enumerator is
  /// AddRef()ed before it is returned.
  ///
  /// Succeeds if:
  ///   - pName and pValue are valid pointers.
  ///
  /// Return codes:
  ///
  ///   AAFRESULT_SUCCESS
  ///
  ///   AAFRESULT_NULL_PARAM
  ///	     - pEnum was null.
  ///
  /// @param ppEnum [out] Pointer to the new enumerator object created by this method.
  ///
  STDMETHOD(GetAttributes) (THIS_
    IEnumAAFTaggedValues ** ppEnum) PURE;


  //***********************************************************
  //
  // RemoveAttribute()
  //
  /// Remove a component attribute (tagged value).
  ///
  /// Succeeds if:
  ///   - pName and pValue are valid pointers.
  ///
  /// Return codes:
  ///
  ///   AAFRESULT_SUCCESS
  ///
  ///   AAFRESULT_NULL_PARAM
  ///	     - pName or pValue is null.
  ///
  /// @param pAttribute [in] Pointer to the tagged value attribute.
  ///
  STDMETHOD(RemoveAttribute) (THIS_
    IAAFTaggedValue * pAttribute) PURE;


  END_INTERFACE
};
#endif // __IAAFComponent2_INTERFACE_DEFINED__



// IAAFCompositionMob2

// ************************
//
// Interface IAAFCompositionMob2
//
// ************************



#ifndef __IAAFCompositionMob2_INTERFACE_DEFINED__
#define __IAAFCompositionMob2_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFCompositionMob2;

#undef  INTERFACE
#define INTERFACE   IAAFCompositionMob2

DECLARE_INTERFACE_(IAAFCompositionMob2, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFCompositionMob2 methods *** */



  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes this object with the given name.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has not yet been initialized.
  /// - the pName pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName argument is NULL.
  ///
  /// @param pName [in, string] Mob name [optional]
  ///
  STDMETHOD(Initialize) (THIS_
    aafCharacter_constptr  pName) PURE;


  //***********************************************************
  //
  // GetDefaultFade()
  //
  /// Get the default fade for this composition.  If there is no
  /// default fade, this function returns with no error, but the VALID
  /// field of the structure is false.  This allows you to pass this
  /// struct to SourceClip::GetFade() in all cases.
  ///
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the pResult pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult argument is NULL.
  ///
  /// @param pResult [out] a default fade struct
  ///
  STDMETHOD(GetDefaultFade) (THIS_
    aafDefaultFade_t *  pResult) PURE;
	

  //***********************************************************
  //
  // SetDefaultFade()
  //
  /// Adds the default crossfade properties to the Mob.
  ///
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_BAD_TYPE
  ///   - invalid fadeType.
  ///
  /// AAFRESULT_BAD_LENGTH
  ///   - invalid fadeLength.
  ///
  /// @param fadeLength [in] Default fade length
  /// @param fadeType [in] default fade type
  /// @param fadeEditUnit [in] default fade edit unit
  ///
  STDMETHOD(SetDefaultFade) (THIS_
    aafLength_t  fadeLength,
    aafFadeType_t  fadeType,
    aafRational_t  fadeEditUnit) PURE;


  //***********************************************************
  //
  // SetRendering()
  //
  /// set the MobID of a rendering of this CompositionMob.

  /// This method will return the following codes:
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param mobID [in, ref] Rendering MobID
  ///
  STDMETHOD(SetRendering) (THIS_
    aafMobID_constref  mobID) PURE;

  //***********************************************************
  //
  // GetRendering()
  //
  /// return the MobID of a rendering of this CompositionMob.

  /// Succeeds if all of the following are true:
  /// - the pMobID pointer is valid.
  ///
  /// If this method fails nothing will be written to *pMobID.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMobID arg is NULL.
  ///
  /// @param pMobID [out] Rendering MobID
  ///
  STDMETHOD(GetRendering) (THIS_
    aafMobID_t *  pMobID) PURE;



  END_INTERFACE
};
#endif // __IAAFCompositionMob2_INTERFACE_DEFINED__



// IAAFDataDef2

// ************************
//
// Interface IAAFDataDef2
//
// ************************

#ifndef __IAAFDataDef2_INTERFACE_DEFINED__
#define __IAAFDataDef2_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFDataDef2;

#undef  INTERFACE
#define INTERFACE   IAAFDataDef2

DECLARE_INTERFACE_(IAAFDataDef2, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFDataDef2 methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Init all fields of a definition object.
  ///
  /// @param id [in, ref] AUID for new DefObject
  /// @param pName [in, string] Name for new DefObject
  /// @param pDescription [in, string] Description for new DefObject
  ///
  STDMETHOD(Initialize) (THIS_
    aafUID_constref  id,
    aafCharacter_constptr  pName,
    aafCharacter_constptr  pDescription) PURE;


  //***********************************************************
  //
  // IsPictureKind()
  //
  /// Sets return value to TRUE if DataDef is a picture.
  ///
  /// @param bIsPictureKind [retval,out] pointer to the return value
  ///
  STDMETHOD(IsPictureKind) (THIS_
    aafBoolean_t *  bIsPictureKind) PURE;


  //***********************************************************
  //
  // IsMatteKind()
  //
  /// Sets return value to TRUE if DataDef is a matte.
  ///
  /// @param bIsMatteKind [retval,out] pointer to the return value
  ///
  STDMETHOD(IsMatteKind) (THIS_
    aafBoolean_t *  bIsMatteKind) PURE;


  //***********************************************************
  //
  // IsPictureWithMatteKind()
  //
  /// Sets return value to TRUE if DataDef is a picture with matte.
  ///
  /// @param bIsPictureWithMatteKind [retval,out] pointer to the return value
  ///
  STDMETHOD(IsPictureWithMatteKind) (THIS_
    aafBoolean_t *  bIsPictureWithMatteKind) PURE;


  //***********************************************************
  //
  // IsSoundKind()
  //
  /// Sets return value to TRUE if DataDef is a sound.
  ///
  /// @param bIsSoundKind [retval,out] pointer to the return value
  ///
  STDMETHOD(IsSoundKind) (THIS_
    aafBoolean_t *  bIsSoundKind) PURE;


  //***********************************************************
  //
  // DoesDataDefConvertTo()
  //
  /// Sets return value to TRUE if the DataDef of the given object
  /// can be converted to the DataDef specified in the IN 
  /// parameter with the DataDefName string.
  ///
  /// @param id [in] data def to compare against
  /// @param bDoesConvertTo [retval, out] pointer to result
  ///
  STDMETHOD(DoesDataDefConvertTo) (THIS_
    IAAFDataDef * id,
    aafBoolean_t *  bDoesConvertTo) PURE;
		   

  //***********************************************************
  //
  // IsDataDefOf()
  //
  /// Sets the value to TRUE if the DataDef of the given object
  /// matches the DataDef specified in the IN parameter with the
  /// DataDefName string.
  ///
  /// @param pDataDef [in] data def to compare against
  /// @param bIsDataDefOf [retval, out] pointer to result
  ///
  STDMETHOD(IsDataDefOf) (THIS_
    IAAFDataDef * pDataDef,
    aafBoolean_t *  bIsDataDefOf) PURE;


  //***********************************************************
  //
  // DoesDataDefConvertFrom()
  //
  /// Sets return value to TRUE if the DataDef of the given object
  /// can be converted from the DataDef specified in the IN 
  /// parameter specified with the DataDefName string.
  ///
  /// @param pDataDef [in] data def to compare against
  /// @param bDoesConvertFrom [retval, out] pointer to result
  ///
  STDMETHOD(DoesDataDefConvertFrom) (THIS_
    IAAFDataDef * pDataDef,
    aafBoolean_t *  bDoesConvertFrom) PURE;


  //***********************************************************
  //
  // IsEdgecodeKind()
  //
  /// Sets return value to TRUE if DataDef is an edgecode.
  ///
  /// @param bIsEdgecodeKind [retval,out] pointer to the return value
  ///
  STDMETHOD(IsEdgecodeKind) (THIS_
    aafBoolean_t *  bIsEdgecodeKind) PURE;

  //***********************************************************
  //
  // IsTimecodeKind()
  //
  /// Sets return value to TRUE if DataDef is a timecode.
  ///
  /// @param bIsTimecodeKind [retval,out] pointer to the return value
  ///
  STDMETHOD(IsTimecodeKind) (THIS_
    aafBoolean_t *  bIsTimecodeKind) PURE;


  END_INTERFACE
};
#endif // __IAAFDataDef2_INTERFACE_DEFINED__



// IAAFDataDef3

// ************************
//
// Interface IAAFDataDef3
//
// ************************

#ifndef __IAAFDataDef3_INTERFACE_DEFINED__
#define __IAAFDataDef3_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFDataDef3;

#undef  INTERFACE
#define INTERFACE   IAAFDataDef3

DECLARE_INTERFACE_(IAAFDataDef3, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFDataDef3 methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Init all fields of a definition object.
  ///
  /// @param id [in, ref] AUID for new DefObject
  /// @param pName [in, string] Name for new DefObject
  /// @param pDescription [in, string] Description for new DefObject
  ///
  STDMETHOD(Initialize) (THIS_
    aafUID_constref  id,
    aafCharacter_constptr  pName,
    aafCharacter_constptr  pDescription) PURE;


  //***********************************************************
  //
  // IsPictureKind()
  //
  /// Sets return value to TRUE if DataDef is a picture.
  ///
  /// @param bIsPictureKind [retval,out] pointer to the return value
  ///
  STDMETHOD(IsPictureKind) (THIS_
    aafBoolean_t *  bIsPictureKind) PURE;


  //***********************************************************
  //
  // IsMatteKind()
  //
  /// Sets return value to TRUE if DataDef is a matte.
  ///
  /// @param bIsMatteKind [retval,out] pointer to the return value
  ///
  STDMETHOD(IsMatteKind) (THIS_
    aafBoolean_t *  bIsMatteKind) PURE;


  //***********************************************************
  //
  // IsPictureWithMatteKind()
  //
  /// Sets return value to TRUE if DataDef is a picture with matte.
  ///
  /// @param bIsPictureWithMatteKind [retval,out] pointer to the return value
  ///
  STDMETHOD(IsPictureWithMatteKind) (THIS_
    aafBoolean_t *  bIsPictureWithMatteKind) PURE;


  //***********************************************************
  //
  // IsSoundKind()
  //
  /// Sets return value to TRUE if DataDef is a sound.
  ///
  /// @param bIsSoundKind [retval,out] pointer to the return value
  ///
  STDMETHOD(IsSoundKind) (THIS_
    aafBoolean_t *  bIsSoundKind) PURE;


  //***********************************************************
  //
  // DoesDataDefConvertTo()
  //
  /// Sets return value to TRUE if the DataDef of the given object
  /// can be converted to the DataDef specified in the IN 
  /// parameter with the DataDefName string.
  ///
  /// @param id [in] data def to compare against
  /// @param bDoesConvertTo [retval, out] pointer to result
  ///
  STDMETHOD(DoesDataDefConvertTo) (THIS_
    IAAFDataDef * id,
    aafBoolean_t *  bDoesConvertTo) PURE;
		   

  //***********************************************************
  //
  // IsDataDefOf()
  //
  /// Sets the value to TRUE if the DataDef of the given object
  /// matches the DataDef specified in the IN parameter with the
  /// DataDefName string.
  ///
  /// @param pDataDef [in] data def to compare against
  /// @param bIsDataDefOf [retval, out] pointer to result
  ///
  STDMETHOD(IsDataDefOf) (THIS_
    IAAFDataDef * pDataDef,
    aafBoolean_t *  bIsDataDefOf) PURE;


  //***********************************************************
  //
  // DoesDataDefConvertFrom()
  //
  /// Sets return value to TRUE if the DataDef of the given object
  /// can be converted from the DataDef specified in the IN 
  /// parameter specified with the DataDefName string.
  ///
  /// @param pDataDef [in] data def to compare against
  /// @param bDoesConvertFrom [retval, out] pointer to result
  ///
  STDMETHOD(DoesDataDefConvertFrom) (THIS_
    IAAFDataDef * pDataDef,
    aafBoolean_t *  bDoesConvertFrom) PURE;


  //***********************************************************
  //
  // IsEdgecodeKind()
  //
  /// Sets return value to TRUE if DataDef is an edgecode.
  ///
  /// @param bIsEdgecodeKind [retval,out] pointer to the return value
  ///
  STDMETHOD(IsEdgecodeKind) (THIS_
    aafBoolean_t *  bIsEdgecodeKind) PURE;

  //***********************************************************
  //
  // IsTimecodeKind()
  //
  /// Sets return value to TRUE if DataDef is a timecode.
  ///
  /// @param bIsTimecodeKind [retval,out] pointer to the return value
  ///
  STDMETHOD(IsTimecodeKind) (THIS_
    aafBoolean_t *  bIsTimecodeKind) PURE;


  //***********************************************************
  //
  // IsAuxiliaryKind()
  //
  /// Sets return value to TRUE if DataDef is auxiliary.
  ///
  /// @param bIsAuxiliaryKind [retval,out] pointer to the return value
  ///
  STDMETHOD(IsAuxiliaryKind) (THIS_
    aafBoolean_t *  bIsAuxiliaryKind) PURE;

  //***********************************************************
  //
  // IsDescriptiveMetadataKind()
  //
  /// Sets return value to TRUE if DataDef is descriptive metadata.
  ///
  /// @param bIsDescriptiveMetadataKind [retval,out] pointer to the return value
  ///
  STDMETHOD(IsDescriptiveMetadataKind) (THIS_
    aafBoolean_t *  bIsDescriptiveMetadataKind) PURE;


  END_INTERFACE
};
#endif // __IAAFDataDef3_INTERFACE_DEFINED__



// IAAFDiagnosticOutput

// ************************
//
// Interface IAAFDiagnosticOutput
//
// ************************



#ifndef __IAAFDiagnosticOutput_INTERFACE_DEFINED__
#define __IAAFDiagnosticOutput_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFDiagnosticOutput;


#undef  INTERFACE
#define INTERFACE   IAAFDiagnosticOutput

DECLARE_INTERFACE_(IAAFDiagnosticOutput, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFDiagnosticOutput methods *** */


  //***********************************************************
  //
  // PutString()
  //
  /// This method is called by the AAF toolkit to write a string
  /// to this diagnostic output.
  ///
  /// @param pString [in, string] string to print out
  ///
  STDMETHOD(PutString) (THIS_
    aafCharacter_constptr  pString) PURE;


  END_INTERFACE
};
#endif // __IAAFDiagnosticOutput_INTERFACE_DEFINED__



// IAAFDictionary2

// ************************
//
// Interface IAAFDictionary2
//
// ************************

























#ifndef __IAAFDictionary2_INTERFACE_DEFINED__
#define __IAAFDictionary2_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFDictionary2;

#undef  INTERFACE
#define INTERFACE   IAAFDictionary2

DECLARE_INTERFACE_(IAAFDictionary2, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFDictionary2 methods *** */

  //***********************************************************
  //
  // CreateInstance()
  //
  /// Creates a single uninitialized AAF object of the class associated 
  /// with a specified stored object id. 
  ///
  /// @param id Class identifier (AUID) of the stored object. This is the
  ///           corresponding SMPTE identifier (as a GUID) for all predefined
  ///           built-in classes.
  /// @param riid Reference to the identifier of the interface
  /// @param ppvObject Address of output variable that receives the
  ///                  interface pointer requested in riid
  ///
  STDMETHOD(CreateInstance)(THIS_
    aafUID_constref id,
    REFIID riid,
    IUnknown ** ppvObject) PURE;


  //***********************************************************
  //
  // CreateMetaInstance()
  //
  /// Creates a single uninitialized AAF meta class or type associated 
  /// with a specified stored object id. 
  /// 
  /// @param id Identifier (id) of a  class or type definition. This is the
  ///           corresponding SMPTE identifier (as a GUID) for all predefined
  ///           built-in definitions.
  /// @param riid Reference to the identifier of the interface
  /// @param ppMetaDefinition Address of output variable that receives the
  ///                         interface pointer requested in riid
  ///
  STDMETHOD(CreateMetaInstance)(THIS_
    aafUID_constref id,
    REFIID riid,
    IUnknown ** ppMetaDefinition) PURE;




  //***********************************************************
  //
  // RegisterClassDef()
  //
  /// Add the class definition object to the dictionary.
  /// 
  /// Succeeds if:
  /// - The pClassDef pointer is valid.
  /// - the ID contained in the class def is not already been
  ///   registered.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pClassDef arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The class def ID has already been registered.
  ///
  /// @param pClassDef [in] Class Definition
  ///
  STDMETHOD(RegisterClassDef) (THIS_
    IAAFClassDef * pClassDef) PURE;


  //***********************************************************
  //
  // LookupClassDef()
  //
  /// Return the class definition with the given id.
  /// 
  /// Succeeds if:
  /// - The pClassID pointer is valid.
  /// - The ppClassDef pointer is valid.
  /// - the ID is a recognized id for a class definition.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pClassID or ppClassDef arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given ID is not recognized as a class definition ID.
  ///
  /// @param classId [in, ref] Class Unique ID
  /// @param ppClassDef [out,retval] Class Definition
  ///
  STDMETHOD(LookupClassDef) (THIS_
    aafUID_constref  classId,
    IAAFClassDef ** ppClassDef) PURE;


  //***********************************************************
  //
  // GetClassDefs()
  //
  /// Return an enumerator for all class definitions.
  ///
  /// Succeeds if:
  /// - The ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  ///
  /// @param ppEnum [out,retval] Class Definition Enumeration
  ///
  STDMETHOD(GetClassDefs) (THIS_
    IEnumAAFClassDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountClassDefs()
  //
  /// Writes the number of class definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  ///
  /// @param pResult [out, retval] Total number of class definition objects
  ///
  STDMETHOD(CountClassDefs) (THIS_
    aafUInt32 *  pResult) PURE;

  //***********************************************************
  //
  // CreateForwardClassReference()
  //
  /// Return the class definition with the given id.
  /// 
  /// Succeeds if:
  /// - The classId does not represent an existing forward class reference
  ///   or a class definition that has already been successfully registered.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given ID is not recognized as a class definition ID.
  ///
  /// @param classId [in, ref] Class Unique ID
  ///
  STDMETHOD(CreateForwardClassReference) (THIS_
    aafUID_constref  classId) PURE;

  //***********************************************************
  //
  // HasForwardClassReference()
  //
  /// Return kAAFTrue if the given class identification is a forward reference.
  /// 
  /// Succeeds if:
  /// - The pClassID pointer is valid.
  /// - The ppClassDef pointer is valid.
  /// - the ID is a recognized id for a class definition.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pClassID or ppClassDef arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given ID is not recognized as a class definition ID.
  ///
  /// @param classId [in, ref] Class Unique ID
  /// @param pResult [out,retval] true if forward class reference; false if not a forward class reference
  ///
  STDMETHOD(HasForwardClassReference) (THIS_
    aafUID_constref  classId,
    aafBoolean_t *  pResult) PURE;

  //***********************************************************
  //
  // RegisterTypeDef()
  //
  /// Add the type definition object to the dictionary.
  /// 
  /// Succeeds if:
  /// - The pTypeDef pointer is valid.
  /// - the ID is not already been registered.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pClassDef arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given type has already been registered.
  ///
  /// @param pTypeDef [in] Type Definition Object
  ///
  STDMETHOD(RegisterTypeDef) (THIS_
    IAAFTypeDef * pTypeDef) PURE;


  //***********************************************************
  //
  // LookupTypeDef()
  //
  /// Return the type definition object with the given id.
  /// 
  /// Succeeds if:
  /// - The pTypeID pointer is valid.
  /// - The ppTypeDef pointer is valid.
  /// - the ID is a recognized id for a type definition.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pTypeID or ppTypeDef arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given ID is not recognized as a type definition ID.
  ///
  /// @param typeId [in, ref] Type Unique ID
  /// @param ppTypeDef [out,retval] Type Definition Object
  ///
  STDMETHOD(LookupTypeDef) (THIS_
    aafUID_constref  typeId,
    IAAFTypeDef ** ppTypeDef) PURE;


  //***********************************************************
  //
  // GetTypeDefs()
  //
  /// Return an enumerator for all type definitions.
  ///
  /// Succeeds if:
  /// - The ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  ///
  /// @param ppEnum [out,retval] Type Def Enumeration
  ///
  STDMETHOD(GetTypeDefs) (THIS_
    IEnumAAFTypeDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountTypeDefs()
  //
  /// Writes the number of type definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  ///
  /// @param pResult [out, retval] Total number of type definition objects
  ///
  STDMETHOD(CountTypeDefs) (THIS_
    aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // RegisterOpaqueTypeDef()
  //
  /// Add the opaquetype definition object to the dictionary.
  /// 
  /// Succeeds if:
  /// - The pTypeDef pointer is valid.
  /// - the definition is not already been registered with RegisterTypeDef.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTypeDef arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given type has already been registered.
  ///
  /// @param pTypeDef [in] Type Definition Object
  ///
  STDMETHOD(RegisterOpaqueTypeDef) (THIS_
    IAAFTypeDef * pTypeDef) PURE;


  //***********************************************************
  //
  // LookupOpaqueTypeDef()
  //
  /// Return the opaque type definition object with the given id.
  /// 
  /// Succeeds if:
  /// - The pTypeID pointer is valid.
  /// - The ppTypeDef pointer is valid.
  /// - the ID is a recognized id for an opaque type definition.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either typeId or ppTypeDef arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given ID is not recognized as a type definition ID.
  ///
  /// @param typeId [in, ref] Type Unique ID
  /// @param ppTypeDef [out,retval] Type Definition Object
  ///
  STDMETHOD(LookupOpaqueTypeDef) (THIS_
    aafUID_constref  typeId,
    IAAFTypeDef ** ppTypeDef) PURE;


  //***********************************************************
  //
  // GetOpaqueTypeDefs()
  //
  /// Return an enumerator for all registered opaque type definitions.
  ///
  /// Succeeds if:
  /// - The ppEnum pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum arg is NULL.
  ///
  /// @param ppEnum [out,retval] Type Def Enumeration
  ///
  STDMETHOD(GetOpaqueTypeDefs) (THIS_
    IEnumAAFTypeDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountOpaqueTypeDefs()
  //
  /// Writes the number of opaque type definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  ///
  /// @param pResult [out, retval] Total number of opaque type definition objects
  ///
  STDMETHOD(CountOpaqueTypeDefs) (THIS_
    aafUInt32 *  pResult) PURE;

  //***********************************************************
  //
  // RegisterKLVDataKey()
  //
  /// Add the definition for the given KLV key to the runtime dictionary.
  /// The pTypeDef will often be kAAFTypeID_UInt8Array,
  /// but may be something else.
  /// 
  /// Succeeds if:
  /// - The pTypeDef pointer is valid.
  /// - the definition is not already been registered with RegisterTypeDef.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTypeDef arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given type has already been registered.
  ///
  /// @param pUID [in] Key to define
  /// @param pTypeDef [in] Type Definition Object
  ///
  STDMETHOD(RegisterKLVDataKey) (THIS_
    aafUID_t  pUID,
    IAAFTypeDef * pTypeDef) PURE;

  //***********************************************************
  //
  // RegisterDataDef()
  //
  /// Add the data definition object to the header's list of definitions.
  ///
  /// @param pDataDef [in] Data Definition Object
  ///
  STDMETHOD(RegisterDataDef) (THIS_
    IAAFDataDef * pDataDef) PURE;


  //***********************************************************
  //
  // LookupDataDef()
  //
  /// Return the data definition object with the given id.
  ///
  /// @param dataDefinitionId [in, ref] Data Definition Unique ID
  /// @param ppDataDef [out,retval] Data Definition Object
  ///
  STDMETHOD(LookupDataDef) (THIS_
    aafUID_constref  dataDefinitionId,
    IAAFDataDef ** ppDataDef) PURE;


  //***********************************************************
  //
  // GetDataDefs()
  //
  /// Return an enumerator for aff data definitions.
  ///
  /// @param ppEnum [out,retval] Definition Enumeration
  ///
  STDMETHOD(GetDataDefs) (THIS_
    IEnumAAFDataDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountDataDefs()
  //
  /// Writes the number of data definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  ///
  /// @param pResult [out, retval] Total number of data definition objects
  ///
  STDMETHOD(CountDataDefs) (THIS_
    aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // RegisterOperationDef()
  //
  /// Add the operation definition object to the header's list of definitions.
  ///
  /// @param pOperationDef [in] Operation Definition Object
  ///
  STDMETHOD(RegisterOperationDef) (THIS_
    IAAFOperationDef * pOperationDef) PURE;


  //***********************************************************
  //
  // LookupOperationDef()
  //
  /// Return the operation definition object with the given id.
  ///
  /// @param operationId [in, ref] Operation Def Unique ID
  /// @param ppOperationDef [out,retval] Operation definition object
  ///
  STDMETHOD(LookupOperationDef) (THIS_
    aafUID_constref  operationId,
    IAAFOperationDef ** ppOperationDef) PURE;


  //***********************************************************
  //
  // GetOperationDefs()
  //
  /// Return an enumerator for all operation definitions.
  ///
  /// @param ppEnum [out,retval] Definition Enumeration
  ///
  STDMETHOD(GetOperationDefs) (THIS_
    IEnumAAFOperationDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountOperationDefs()
  //
  /// Writes the number of operation definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  ///
  /// @param pResult [out, retval] Total number of operation definition objects
  ///
  STDMETHOD(CountOperationDefs) (THIS_
    aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // RegisterParameterDef()
  //
  /// Add the parameter definition object to the header's list of definitions.
  ///
  /// @param pParmDef [in] Parameter Definition Object
  ///
  STDMETHOD(RegisterParameterDef) (THIS_
    IAAFParameterDef * pParmDef) PURE;


  //***********************************************************
  //
  // LookupParameterDef()
  //
  /// Return the parameter definition object with the given id.
  ///
  /// @param parameterId [in, ref] Parameter Unique ID
  /// @param ppParmDef [out,retval] Parameter definition object
  ///
  STDMETHOD(LookupParameterDef) (THIS_
    aafUID_constref  parameterId,
    IAAFParameterDef ** ppParmDef) PURE;


  //***********************************************************
  //
  // GetParameterDefs()
  //
  /// Return an enumerator for all parameter definitions.
  ///
  /// @param ppEnum [out,retval] Definition Enumeration
  ///
  STDMETHOD(GetParameterDefs) (THIS_
    IEnumAAFParameterDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountParameterDefs()
  //
  /// Writes the number of parameter definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  ///
  /// @param pResult [out, retval] Total number of parameter definition objects
  ///
  STDMETHOD(CountParameterDefs) (THIS_
    aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // RegisterCodecDef()
  //
  /// Add the codec definition object to the header's list of definitions.
  ///
  /// @param pParmDef [in] Codec Definition Object
  ///
  STDMETHOD(RegisterCodecDef) (THIS_
    IAAFCodecDef * pParmDef) PURE;


  //***********************************************************
  //
  // LookupCodecDef()
  //
  /// Return the codec definition object with the given id.
  ///
  /// @param parameterId [in, ref] Parameter Unique ID
  /// @param ppParmDef [out,retval] Codec definition object
  ///
  STDMETHOD(LookupCodecDef) (THIS_
    aafUID_constref  parameterId,
    IAAFCodecDef ** ppParmDef) PURE;


  //***********************************************************
  //
  // GetCodecDefs()
  //
  /// Return an enumerator for all codec definitions.
  ///
  /// @param ppEnum [out,retval] Definition Enumeration
  ///
  STDMETHOD(GetCodecDefs) (THIS_
    IEnumAAFCodecDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountCodecDefs()
  //
  /// Writes the number of codec definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  ///
  /// @param pResult [out, retval] Total number of codec definition objects
  ///
  STDMETHOD(CountCodecDefs) (THIS_
    aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // RegisterContainerDef()
  //
  /// Add the container definition object to the header's list of definitions.
  ///
  /// @param pParmDef [in] Container Definition Object
  ///
  STDMETHOD(RegisterContainerDef) (THIS_
    IAAFContainerDef * pParmDef) PURE;


  //***********************************************************
  //
  // LookupContainerDef()
  //
  /// Return the container definition object with the given id.
  ///
  /// @param parameterId [in, ref] Parameter Unique ID
  /// @param ppParmDef [out,retval] Container definition object
  ///
  STDMETHOD(LookupContainerDef) (THIS_
    aafUID_constref  parameterId,
    IAAFContainerDef ** ppParmDef) PURE;


  //***********************************************************
  //
  // GetContainerDefs()
  //
  /// Return an enumerator for all container definitions.
  ///
  /// @param ppEnum [out,retval] Definition Enumeration
  ///
  STDMETHOD(GetContainerDefs) (THIS_
    IEnumAAFContainerDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountContainerDefs()
  //
  /// Writes the number of container definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  ///
  /// @param pResult [out, retval] Total number of container definition objects
  ///
  STDMETHOD(CountContainerDefs) (THIS_
    aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // RegisterInterpolationDef()
  //
  /// Add the Interpolation definition object to the header's list of definitions.
  ///
  /// @param pInterpolationDef [in] Interpolation Definition Object
  ///
  STDMETHOD(RegisterInterpolationDef) (THIS_
    IAAFInterpolationDef * pInterpolationDef) PURE;


  //***********************************************************
  //
  // LookupInterpolationDef()
  //
  /// Return the Interpolation definition object with the given id.
  ///
  /// @param parameterId [in, ref] Parameter Unique ID
  /// @param ppInterpolationDef [out,retval] Interpolation definition object
  ///
  STDMETHOD(LookupInterpolationDef) (THIS_
    aafUID_constref  parameterId,
    IAAFInterpolationDef ** ppInterpolationDef) PURE;


  //***********************************************************
  //
  // GetInterpolationDefs()
  //
  /// Return an enumerator for aff Interpolation definitions.
  ///
  /// @param ppEnum [out,retval] Definition Enumeration
  ///
  STDMETHOD(GetInterpolationDefs) (THIS_
    IEnumAAFInterpolationDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountInterpolationDefs()
  //
  /// Writes the number of interpolation definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  ///
  /// @param pResult [out, retval] Total number of interpolation definition objects
  ///
  STDMETHOD(CountInterpolationDefs) (THIS_
    aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // RegisterPluginDef()
  //
  /// Add the plugin definition object to the header's list of definitions.
  ///
  /// @param pPlugDef [in] plugin definition Object
  ///
  STDMETHOD(RegisterPluginDef) (THIS_
    IAAFPluginDef * pPlugDef) PURE;


  //***********************************************************
  //
  // LookupPluginDef()
  //
  /// Return the plugin descriptor object with the given id.
  ///
  /// @param parameterId [in, ref] Parameter Unique ID
  /// @param ppPlugDef [out,retval] plugin descriptor object
  ///
  STDMETHOD(LookupPluginDef) (THIS_
    aafUID_constref  parameterId,
    IAAFPluginDef ** ppPlugDef) PURE;


  //***********************************************************
  //
  // GetPluginDefs()
  //
  /// Return an enumerator for all plugin descriptors.
  ///
  /// @param ppEnum [out,retval] Definition Enumeration
  ///
  STDMETHOD(GetPluginDefs) (THIS_
    IEnumAAFPluginDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountPluginDefs()
  //
  /// Writes the number of plugin definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  ///
  /// @param pResult [out, retval] Total number of plugin definition objects
  ///
  STDMETHOD(CountPluginDefs) (THIS_
    aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // RegisterKLVDataDef()
  //
  /// Add the KLVData definition object to the header's list of definitions.
  ///
  /// @param pDef [in] plugin definition object
  ///
  STDMETHOD(RegisterKLVDataDef) (THIS_
    IAAFKLVDataDefinition * pDef) PURE;


  //***********************************************************
  //
  // LookupKLVDataDef()
  //
  /// Return the KLVData descriptor object with the given id.
  ///
  /// @param defId [in, ref] KLV data definition Unique ID
  /// @param ppDef [out,retval] KLVData descriptor object
  ///
  STDMETHOD(LookupKLVDataDef) (THIS_
    aafUID_constref  defId,
    IAAFKLVDataDefinition ** ppDef) PURE;


  //***********************************************************
  //
  // GetKLVDataDefs()
  //
  /// Return an enumerator for all KLVData descriptors.
  ///
  /// @param ppEnum [out,retval] Definition Enumeration
  ///
  STDMETHOD(GetKLVDataDefs) (THIS_
    IEnumAAFKLVDataDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountKLVDataDefs()
  //
  /// Writes the number of KLVData definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  ///
  /// @param pResult [out, retval] Total number of KLVData definition objects
  ///
  STDMETHOD(CountKLVDataDefs) (THIS_
    aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // RegisterTaggedValueDef()
  //
  /// Add the tagged value definition object to the header's list of definitions.
  ///
  /// @param pDef [in] tagged value definition Object
  ///
  STDMETHOD(RegisterTaggedValueDef) (THIS_
    IAAFTaggedValueDefinition * pDef) PURE;


  //***********************************************************
  //
  // LookupTaggedValueDef()
  //
  /// Return the tagged value descriptor object with the given id.
  ///
  /// @param defId [in, ref] tagged value definition ID
  /// @param ppDef [out,retval] tagged value descriptor object
  ///
  STDMETHOD(LookupTaggedValueDef) (THIS_
    aafUID_constref  defId,
    IAAFTaggedValueDefinition ** ppDef) PURE;


  //***********************************************************
  //
  // GetTaggedValueDefs()
  //
  /// Return an enumerator for all tagged value descriptors.
  ///
  /// @param ppEnum [out,retval] Definition Enumeration
  ///
  STDMETHOD(GetTaggedValueDefs) (THIS_
    IEnumAAFTaggedValueDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountTaggedValueDefs()
  //
  /// Writes the number of tagged value definition objects into the
  /// *pResult argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  ///
  /// @param pResult [out, retval] Total number of tagged value definition objects
  ///
  STDMETHOD(CountTaggedValueDefs) (THIS_
    aafUInt32 *  pResult) PURE;

  //***********************************************************
  //
  // LookupAuxiliaryDataDef()
  //
  /// Return the Auxiliary Data Definition Object.
  /// 
  /// Succeeds if:
  /// - The ppDataDef pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDataDef arg is NULL.
  ///
  /// @param ppDataDef [out,retval] Data Definition Object
  ///
  STDMETHOD(LookupAuxiliaryDataDef) (THIS_
    IAAFDataDef ** ppDataDef) PURE;

  //***********************************************************
  //
  // LookupDescriptiveMetadataDataDef()
  //
  /// Return the Descriptive Metadata Data Definition Object.
  /// 
  /// Succeeds if:
  /// - The ppDataDef pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDataDef arg is NULL.
  ///
  /// @param ppDataDef [out,retval] Data Definition Object
  ///
  STDMETHOD(LookupDescriptiveMetadataDataDef) (THIS_
    IAAFDataDef ** ppDataDef) PURE;


  //***********************************************************
  //
  // LookupEdgecodeDataDef()
  //
  /// Return the Edgecode Data Definition Object.
  /// 
  /// Succeeds if:
  /// - The ppDataDef pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDataDef arg is NULL.
  ///
  /// @param ppDataDef [out,retval] Data Definition Object
  ///
  STDMETHOD(LookupEdgecodeDataDef) (THIS_
    IAAFDataDef ** ppDataDef) PURE;


  //***********************************************************
  //
  // LookupLegacyPictureDataDef()
  //
  /// Return the legacy Picture Data Definition Object.
  /// 
  /// Succeeds if:
  /// - The ppDataDef pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDataDef arg is NULL.
  ///
  /// @param ppDataDef [out,retval] Data Definition Object
  ///
  STDMETHOD(LookupLegacyPictureDataDef) (THIS_
    IAAFDataDef ** ppDataDef) PURE;


  //***********************************************************
  //
  // LookupLegacySoundDataDef()
  //
  /// Return the legacy Sound Data Definition Object.
  /// 
  /// Succeeds if:
  /// - The ppDataDef pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDataDef arg is NULL.
  ///
  /// @param ppDataDef [out,retval] Data Definition Object
  ///
  STDMETHOD(LookupLegacySoundDataDef) (THIS_
    IAAFDataDef ** ppDataDef) PURE;


  //***********************************************************
  //
  // LookupLegacyTimecodeDataDef()
  //
  /// Return the legacy Timecode Data Definition Object.
  /// 
  /// Succeeds if:
  /// - The ppDataDef pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDataDef arg is NULL.
  ///
  /// @param ppDataDef [out,retval] Data Definition Object
  ///
  STDMETHOD(LookupLegacyTimecodeDataDef) (THIS_
    IAAFDataDef ** ppDataDef) PURE;


  //***********************************************************
  //
  // LookupMatteDataDef()
  //
  /// Return the Matte Data Definition Object.
  /// 
  /// Succeeds if:
  /// - The ppDataDef pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDataDef arg is NULL.
  ///
  /// @param ppDataDef [out,retval] Data Definition Object
  ///
  STDMETHOD(LookupMatteDataDef) (THIS_
    IAAFDataDef ** ppDataDef) PURE;


  //***********************************************************
  //
  // LookupPictureDataDef()
  //
  /// Return the Picture Data Definition Object.
  /// 
  /// Succeeds if:
  /// - The ppDataDef pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDataDef arg is NULL.
  ///
  /// @param ppDataDef [out,retval] Data Definition Object
  ///
  STDMETHOD(LookupPictureDataDef) (THIS_
    IAAFDataDef ** ppDataDef) PURE;


  //***********************************************************
  //
  // LookupPictureWithMatteDataDef()
  //
  /// Return the PictureWithMatte Data Definition Object.
  /// 
  /// Succeeds if:
  /// - The ppDataDef pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDataDef arg is NULL.
  ///
  /// @param ppDataDef [out,retval] Data Definition Object
  ///
  STDMETHOD(LookupPictureWithMatteDataDef) (THIS_
    IAAFDataDef ** ppDataDef) PURE;


  //***********************************************************
  //
  // LookupSoundDataDef()
  //
  /// Return the Sound Data Definition Object.
  /// 
  /// Succeeds if:
  /// - The ppDataDef pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDataDef arg is NULL.
  ///
  /// @param ppDataDef [out,retval] Data Definition Object
  ///
  STDMETHOD(LookupSoundDataDef) (THIS_
    IAAFDataDef ** ppDataDef) PURE;


  //***********************************************************
  //
  // LookupTimecodeDataDef()
  //
  /// Return the Timecode Data Definition Object.
  /// 
  /// Succeeds if:
  /// - The ppDataDef pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDataDef arg is NULL.
  ///
  /// @param ppDataDef [out,retval] Data Definition Object
  ///
  STDMETHOD(LookupTimecodeDataDef) (THIS_
    IAAFDataDef ** ppDataDef) PURE;



  END_INTERFACE
};
#endif // __IAAFDictionary2_INTERFACE_DEFINED__



// IAAFDigitalImageDescriptor2

// ************************
//
// Interface IAAFDigitalImageDescriptor2
//
// ************************




#ifndef __IAAFDigitalImageDescriptor2_INTERFACE_DEFINED__
#define __IAAFDigitalImageDescriptor2_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFDigitalImageDescriptor2;

#undef  INTERFACE
#define INTERFACE   IAAFDigitalImageDescriptor2

DECLARE_INTERFACE_(IAAFDigitalImageDescriptor2, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFDigitalImageDescriptor2 methods *** */


  //***********************************************************
  //
  // SetCompression()
  //
  /// ///
  /// Sets the kind of compression and format of compression
  /// information of the video essence data.  This property is
  /// optional.  If there is no compression, the property is omitted.
  /// 
  /// If this method fails the Data Definition property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param compression [in] Optional.
  ///
  STDMETHOD(SetCompression) (THIS_
    aafUID_constref  compression) PURE;


  //***********************************************************
  //
  // GetCompression()
  //
  /// /// Gets the kind of compression and format of compression
  /// information of the video essence data.  This property is
  /// optional.
  ///
  /// Succeeds if all of the following are true:
  /// - the pCompression pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pCompression.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pComporession arg is NULL.
  ///
  /// @param pCompression [out] Optional.
  ///
  STDMETHOD(GetCompression) (THIS_
    aafUID_t *  pCompression) PURE;


  //***********************************************************
  //
  // SetStoredView()
  //
  /// Sets the dimension of the stored view.  Typically this includes
  /// leading blank video lines, any VITC lines, as well as the active
  /// picture area.
  /// 
  /// If this method fails the Stored Height and Stored Width
  /// properties will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param StoredHeight [in] Number of pixels in vertical dimension of stored view.
  /// @param StoredWidth [in] Number of pixels in horizontal dimension of stored view.
  ///
  STDMETHOD(SetStoredView) (THIS_
    aafUInt32  StoredHeight,
    aafUInt32  StoredWidth) PURE;


  //***********************************************************
  //
  // GetStoredView()
  //
  /// Gets the dimension of the stored view.  Typically this includes
  /// leading blank video lines, any VITC lines, as well as the active
  /// picture area.
  /// 
  /// Succeeds if all of the following are true:
  /// - pStoredHieght and pStoredWidth are valid pointers.
  /// 
  /// If this method fails, the *pStoredHieght and *pStoredWidth will
  /// not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pStoredHeight or pStoredWidth is NULL.
  ///
  /// @param pStoredHeight [out] Number of pixels in vertical dimension of stored view.
  /// @param pStoredWidth [out] Number of pixels in horizontal dimension of stored view.
  ///
  STDMETHOD(GetStoredView) (THIS_
    aafUInt32 *  pStoredHeight,
    aafUInt32 *  pStoredWidth) PURE;


  //***********************************************************
  //
  // SetSampledView()
  //
  /// Sets the dimensions of sampled view.  Typically this includes
  /// any VITC lines as well as the active picture area, but excludes
  /// leading blank video lines.  The offset is specified relative to
  /// the rectangle specified by Set/GetStoredView().
  ///
  /// The following properties are optional:
  ///
  ///     SampledXOffset - The default value is 0.  Use a value of 0 to
  ///                      select the default.
  ///     SampledYOffset - The default value is 0.  Use a value of 0 to
  ///                      select the default.
  ///
  /// Succeeds if all of the following are true:
  /// - The given dimensions exist within the StoredView.
  /// 
  /// If this method fails, the SampledXOffset and SampledYOffset
  /// properties will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - The area specified by SampledHeight and SampledXOffset is
  ///     outside the StoredView, or the area specified by SampledWidth
  ///     and SampledYOffset is outside the StoredView.
  ///
  /// @param SampledHeight [in] Number of pixels in vertical dimension of sampled view.
  /// @param SampledWidth [in] Number of pixels in horizontal dimension of sampled view.
  /// @param SampledXOffset [in] Number of pixels from top left corner of sampled view. Optional.
  /// @param SampledYOffset [in] Number of pixels from top left corner of sampled view. Optional.
  ///
  STDMETHOD(SetSampledView) (THIS_
    aafUInt32  SampledHeight,
    aafUInt32  SampledWidth,
    aafInt32  SampledXOffset,
    aafInt32  SampledYOffset) PURE;


  //***********************************************************
  //
  // GetSampledView()
  //
  /// Gets the dimensions of sampled view.  Typically this includes
  /// any VITC lines as well as the active picture area, but excludes
  /// leading blank video lines.  The offset is specified relative to
  /// the rectangle specified by Set/GetStoredView().
  ///
  /// Succeeds if all of the following are true:
  /// - pSampledHeight, pSampledWidth, pSampledXOffset and
  ///   pSampledYOffset are valid pointers
  /// 
  /// If any of the input parameters are NULL, the property will not
  /// be returned.
  ///
  /// If this method fails, *pSampledHeight, *pSampledWidth,
  /// *pSampledXOffset, and *pSampledYOffset will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - any of pSampledHeight, pSampledWidth, pSampledXOffset, or
  ///     pSampledYOffset are NULL.
  ///
  /// @param pSampledHeight [out] Number of pixels in vertical dimension of sampled view.
  /// @param pSampledWidth [out] Number of pixels in horizontal dimension of sampled view.
  /// @param pSampledXOffset [out] Number of pixels from top left corner of sampled view. Optional.
  /// @param pSampledYOffset [out] Number of pixels from top left corner of sampled view. Optional.
  ///
  STDMETHOD(GetSampledView) (THIS_
    aafUInt32 *  pSampledHeight,
    aafUInt32 *  pSampledWidth,
    aafInt32 *  pSampledXOffset,
    aafInt32 *  pSampledYOffset) PURE;


  //***********************************************************
  //
  // SetDisplayView()
  //
  /// Sets the dimension of display view.  Typically this includes
  /// the active picture area, but excludes leading blank video lines
  /// and any VITC lines.  The offset is specified relative to the
  /// rectangle specified by Set/GetStoredView().
  /// 
  /// The following properties are optional:
  ///
  ///     DisplayHeight  - The default value is the storedHeight. Use
  ///                      storedHeight to select the default.
  ///     DisplayWidth   - The default value is the storedWidth. Use
  ///                      storedWidth to select the default.
  ///     DisplayXOffset - The default value is 0.  Use a value of 0 to
  ///                      select the default.
  ///     DisplayYOffset - The default value is 0.  Use a value of 0 to
  ///                      select the default.
  ///
  /// Note that The specified display rectangle may exist outside the
  /// SampledView or even the StoredView.
  ///
  /// If this method fails the DisplayHeight, DisplayWidth, DisplayXOffset and
  /// DisplayYOffset properties will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - The area specified by DisplayHeight and DisplayXOffset is
  ///     outside the StoredView, or the area specified by DisplayWidth
  ///     and DisplayYOffset is outside the StoredView.
  ///
  /// @param DisplayHeight [in] Number of pixels in vertical dimension of display view. Optional.
  /// @param DisplayWidth [in] Number of pixels in horizontal dimension of display view. Optional.
  /// @param DisplayXOffset [in] Number of pixels from the top-left corner of the display view. Optional.
  /// @param DisplayYOffset [in] Number pixels from the top-left corner of the display view. Optional.
  ///
  STDMETHOD(SetDisplayView) (THIS_
    aafUInt32  DisplayHeight,
    aafUInt32  DisplayWidth,
    aafInt32  DisplayXOffset,
    aafInt32  DisplayYOffset) PURE;


  //***********************************************************
  //
  // GetDisplayView()
  //
  /// Gets the dimension of display view.  Typically this includes
  /// the active picture area, but excludes leading blank video lines
  /// and any VITC lines.  The offset is specified relative to the
  /// rectangle specified by Set/GetStoredView().
  /// 
  /// Note that The specified display rectangle may exist outside the
  /// SampledView or even the StoredView.
  ///
  /// Succeeds if all of the following are true:
  /// - pDisplayHeight, pDisplayWidth, pDisplayXOffset and
  ///   pDisplayYOffset are valid pointers.
  /// 
  /// If this method fails, *pDisplayHeight, *pDisplayWidth,
  /// *pDisplayXOffset, and *pDisplayYOffset will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - any of pDisplayHeight, pDisplayWidth, pDisplayXOffset, or
  ///     pDisplayYOffset are NULL.
  ///
  /// @param pDisplayHeight [out] Number of pixels in vertical dimension of display view. Optional.
  /// @param pDisplayWidth [out] Number of pixels in horizontal dimension of display view. Optional.
  /// @param pDisplayXOffset [out] Number of pixels from the top-left corner of the display view. Optional.
  /// @param pDisplayYOffset [out] Number pixels from the top-left corner of the display view. Optional.
  ///
  STDMETHOD(GetDisplayView) (THIS_
    aafUInt32 *  pDisplayHeight,
    aafUInt32 *  pDisplayWidth,
    aafInt32 *  pDisplayXOffset,
    aafInt32 *  pDisplayYOffset) PURE;


  //***********************************************************
  //
  // SetFrameLayout()
  //
  /// Sets the frame layout.  The frame layout describes whether all
  /// data for a complete sample is in one frame or is split into more
  /// than/ one field.
  ///
  /// Values are:
  ///
  ///    kNoLayout       - Default; not a valid value.
  ///    kFullFrame      - Each frame contains a full sample in
  ///                      progressive scan lines.
  ///    kSeparateFields - Each sample consists of two fields, which
  ///                      when interlaced produce a full sample.
  ///    kOneField       - Each sample consists of two interlaced
  ///                      fields, but only one field is stored in the
  ///                      data stream.
  ///    kMixedFields    - Similar to FullFrame, except the two fields
  ///                      may have been sampled at different times.
  /// 
  /// Succeeds if all of the following are true:
  /// - frameLayout is a valid value
  /// 
  /// If this method fails, the Frame Layout property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - FrameLayout is not a valid value.
  ///
  /// @param FrameLayout [in] layout of the frame
  ///
  STDMETHOD(SetFrameLayout) (THIS_
    aafFrameLayout_t  FrameLayout) PURE;


  //***********************************************************
  //
  // GetFrameLayout()
  //
  /// Gets the frame layout.  The frame layout describes whether all
  /// data for a complete sample is in one frame or is split into more
  /// than one field.
  /// 
  /// Values are:
  ///
  ///    kNoLayout       - Default; not a valid value.
  ///    kFullFrame      - Each frame contains a full sample in
  ///                      progressive scan lines.
  ///    kSeparateFields - Each sample consists of two fields, which
  ///                      when interlaced produce a full sample.
  ///    kOneField       - Each sample consists of two interlaced
  ///                      fields, but only one field is stored in the
  ///                      data stream.
  ///    kMixedFields    - Similar to FullFrame, except the two fields
  ///                      may have been sampled at different times.
  /// 
  /// Succeeds if all of the following are true:
  /// - pFrameLayout is a valid pointer
  /// 
  /// If this method fails, *pFrameLayout will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFrameLayout is NULL.
  ///
  /// @param pFrameLayout [out] layout of the frame
  ///
  STDMETHOD(GetFrameLayout) (THIS_
    aafFrameLayout_t *  pFrameLayout) PURE;


  //***********************************************************
  //
  // SetVideoLineMap()
  //
  /// Sets the VideoLineMap property.  The video line map specifies the
  /// scan line in the analog source that corresponds to the beginning
  /// of each digitized field.  For single-field video, there is 1
  /// value in the array.  For interleaved video, there are 2 values
  /// in the array.
  /// 
  /// Succeeds if all of the following are true:
  /// - pVideoLineMap is a valid pointer
  /// 
  /// If this method fails, the Video Line Map property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pVideoLineMap is NULL.
  ///
  /// @param numberElements [in] The number of elements in the array
  /// @param pVideoLineMap [in, size_is(numberElements)] Array to hold the Video Line Map information
  ///
  STDMETHOD(SetVideoLineMap) (THIS_
    aafUInt32  numberElements,
    aafInt32 *  pVideoLineMap) PURE;


  //***********************************************************
  //
  // GetVideoLineMap()
  //
  /// Gets the VideoLineMap property.  The video line map specifies the
  /// scan line in the analog source that corresponds to the beginning of each
  /// digitized field.  For single-field video, there is 1 value in the array.
  /// For interleaved video, there are 2 values in the array.
  ///
  /// The values are written to the array specified by pVideoLineMap,
  /// which is of size numberElements.  The required size may be found
  /// by calling GetVideoLineMapSize().
  /// 
  /// Succeeds if all of the following are true:
  /// - pVideoLineMap is a valid pointer.
  /// - numberElements indicates the array is large enough to hold the
  ///   data.
  /// 
  /// If this method fails, videoLineMap will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumberElements is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - numberElements indicates that the array is too small to hold
  ///     the data.
  ///
  /// @param numberElements [in] The number of elements in the array
  /// @param pVideoLineMap [out, size_is(numberElements)] Array to hold the Video Line Map information
  ///
  STDMETHOD(GetVideoLineMap) (THIS_
    aafUInt32  numberElements,
    aafInt32 *  pVideoLineMap) PURE;


  //***********************************************************
  //
  // GetVideoLineMapSize()
  //
  /// Get the number of elements in the VideoLineMap property array.
  /// 
  /// Succeeds if all of the following are true:
  /// - pNumberElements is a valid pointer
  /// 
  /// If this method fails, *pNumberElements will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumberElements is NULL.
  ///
  /// @param pNumberElements [out] The number of elements in the array
  ///
  STDMETHOD(GetVideoLineMapSize) (THIS_
    aafUInt32 *  pNumberElements) PURE;


  //***********************************************************
  //
  // SetImageAspectRatio()
  //
  /// Sets the Image Aspect Ratio property.  This ratio describes the
  /// ratio between the horizontal size and the vertical size in the
  /// intended final image.
  ///
  /// Succeeds if all of the following are true:
  /// - 
  /// 
  /// If this method fails, the Image Access Ratio property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param ImageAspectRatio [in] Ratio between horizontal and vertical size
  ///
  STDMETHOD(SetImageAspectRatio) (THIS_
    aafRational_t  ImageAspectRatio) PURE;


  //***********************************************************
  //
  // GetImageAspectRatio()
  //
  /// Gets the Image Aspect Ratio property.  This ratio describes the
  /// ratio between the horizontal size and the vertical size in the
  /// intended final image.
  ///
  /// Succeeds if all of the following are true:
  /// - pImageAspectRatio is a valid pointer
  /// 
  /// If this method fails, *pImageAspectRatio will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pImageAspectRatio is NULL.
  ///
  /// @param pImageAspectRatio [out] Ratio between horizontal and vertical size
  ///
  STDMETHOD(GetImageAspectRatio) (THIS_
    aafRational_t *  pImageAspectRatio) PURE;


  //***********************************************************
  //
  // SetAlphaTransparency()
  //
  /// Sets the AlphaTransparency property.  This property is optional.
  ///
  /// Valid values:
  ///	kMaxValueTransparent - means the maximum Alpha value is
  ///                           transparent
  ///    kMinValueTransparent - means the minimum Alpha value is
  ///                           transparent
  ///
  /// Succeeds if all of the following are true:
  /// - AlphaTransparency is a valid value.
  /// 
  /// If this method fails, the AlphaTransparency property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - AlphaTransparency is not a valid value.
  ///
  /// @param AlphaTransparency [in] Alpha Transparency value.
  ///
  STDMETHOD(SetAlphaTransparency) (THIS_
    aafAlphaTransparency_t  AlphaTransparency) PURE;


  //***********************************************************
  //
  // GetAlphaTransparency()
  //
  /// Gets the AlphaTransparency property.  This property is optional.
  ///
  /// Valid values:
  ///	kMaxValueTransparent - means the maximum Alpha value is transparent
  ///    kMinValueTransparent - means the minimum Alpha value is transparent
  ///
  /// Succeeds if all of the following are true:
  /// - pAlphaTransparency is a valid pointer
  /// 
  /// If this method fails, pAlphaTransparency not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pAlphaTransparency is NULL.
  ///
  /// @param pAlphaTransparency [out] Alpha Transparency value.
  ///
  STDMETHOD(GetAlphaTransparency) (THIS_
    aafAlphaTransparency_t *  pAlphaTransparency) PURE;



  //***********************************************************
  //
  // SetImageAlignmentFactor()
  //
  /// Sets the ImageAlignmentFactor property.  Specifies the alignment
  /// when storing the digital essence.  For example, a value of 16
  /// means that the image is stored on 16-byte boundaries.  The
  /// starting point for a field will always be a multiple of 16 bytes.
  /// If the field does not end on a 16-byte boundary, it is padded
  /// out to the next 16-byte boundary.
  ///
  /// Succeeds if all of the following are true:
  /// 
  /// If this method fails, the ImageAlignmentFactor property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param ImageAlignmentFactor [in] Optional.
  ///
  STDMETHOD(SetImageAlignmentFactor) (THIS_
    aafUInt32  ImageAlignmentFactor) PURE;


  //***********************************************************
  //
  // GetImageAlignmentFactor()
  //
  /// Gets the ImageAlignmentFactor property.  Specifies the alignment when
  /// storing the digital essence.  For example, a value of 16 means that the image
  /// is stored on 16-byte boundaries.  The starting point for a field will always
  /// be a multiple of 16 bytes.  If the field does not end on a 16-byte boundary,
  /// it is padded out to the next 16-byte boundary.
  ///
  ///
  /// Succeeds if all of the following are true:
  /// - pImageAlignmentFactor is a valid pointer
  /// 
  /// If this method fails, pImageAlignmentFactor will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pImageAlignmentFactor is NULL.
  ///
  /// @param pImageAlignmentFactor [out] Optional.
  ///
  STDMETHOD(GetImageAlignmentFactor) (THIS_
    aafUInt32 *  pImageAlignmentFactor) PURE;


  //***********************************************************
  //
  // SetTransferCharacteristic()
  //
  /// Sets the TransferCharacteristic property.
  ///
  /// Succeeds if all of the following are true:
  /// - 
  /// 
  /// If this method fails, the TransferCharacteristic property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param transferCharacteristic [in] Optional
  ///
  STDMETHOD(SetTransferCharacteristic) (THIS_
    aafUID_constref  transferCharacteristic) PURE;


  //***********************************************************
  //
  // GetTransferCharacteristic()
  //
  /// Gets the TransferCharacteristic property.
  ///
  /// Succeeds if all of the following are true:
  /// - pTransferCharacteristic is a valid pointer
  /// 
  /// If this method fails, pTransferCharacteristic will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTransferCharacteristic is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pTransferCharacteristic [out] Optional.
  ///
  STDMETHOD(GetTransferCharacteristic) (THIS_
    aafUID_t *  pTransferCharacteristic) PURE;

  //***********************************************************
  //
  // SetCodingEquations()
  //
  /// Sets the CodingEquations property.
  ///
  /// Succeeds if all of the following are true:
  /// - 
  /// 
  /// If this method fails, the CodingEquations property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param codingEquations [in] Optional
  ///
  STDMETHOD(SetCodingEquations) (THIS_
    aafUID_constref  codingEquations) PURE;


  //***********************************************************
  //
  // GetCodingEquations()
  //
  /// Gets the CodingEquations property.
  ///
  /// Succeeds if all of the following are true:
  /// - pCodingEquations is a valid pointer
  /// 
  /// If this method fails, pCodingEquations will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCodingEquations is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pCodingEquations [out] Optional.
  ///
  STDMETHOD(GetCodingEquations) (THIS_
    aafUID_t *  pCodingEquations) PURE;

  //***********************************************************
  //
  // SetColorPrimaries()
  //
  /// Sets the ColorPrimaries property.
  ///
  /// Succeeds if all of the following are true:
  /// - 
  /// 
  /// If this method fails, the ColorPrimaries property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param colorPrimaries [in] Optional
  ///
  STDMETHOD(SetColorPrimaries) (THIS_
    aafUID_constref  colorPrimaries) PURE;


  //***********************************************************
  //
  // GetColorPrimaries()
  //
  /// Gets the ColorPrimaries property.
  ///
  /// Succeeds if all of the following are true:
  /// - pColorPrimaries is a valid pointer
  /// 
  /// If this method fails, pColorPrimaries will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pColorPrimaries is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pColorPrimaries [out] Optional.
  ///
  STDMETHOD(GetColorPrimaries) (THIS_
    aafUID_t *  pColorPrimaries) PURE;

  //***********************************************************
  //
  // SetFieldStartOffset()
  //
  /// Sets the FieldStartOffset property.
  ///
  /// Succeeds if all of the following are true:
  /// 
  /// If this method fails, the FieldStartOffset property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param fieldStartOffset [in] Optional.
  ///
  STDMETHOD(SetFieldStartOffset) (THIS_
    aafUInt32  fieldStartOffset) PURE;


  //***********************************************************
  //
  // GetFieldStartOffset()
  //
  /// Gets the FieldStartOffset property.
  ///
  /// Succeeds if all of the following are true:
  /// - pFieldStartOffset is a valid pointer
  /// 
  /// If this method fails, pFieldStartOffset will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFieldStartOffset is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pFieldStartOffset [out] Optional.
  ///
  STDMETHOD(GetFieldStartOffset) (THIS_
    aafUInt32 *  pFieldStartOffset) PURE;

  //***********************************************************
  //
  // SetFieldEndOffset()
  //
  /// Sets the FieldEndOffset property.
  ///
  /// Succeeds if all of the following are true:
  /// 
  /// If this method fails, the FieldEndOffset property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param fieldEndOffset [in] Optional.
  ///
  STDMETHOD(SetFieldEndOffset) (THIS_
    aafUInt32  fieldEndOffset) PURE;


  //***********************************************************
  //
  // GetFieldEndOffset()
  //
  /// Gets the FieldEndOffset property.
  ///
  /// Succeeds if all of the following are true:
  /// - pFieldEndOffset is a valid pointer
  /// 
  /// If this method fails, pFieldEndOffset will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFieldEndOffset is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pFieldEndOffset [out] Optional.
  ///
  STDMETHOD(GetFieldEndOffset) (THIS_
    aafUInt32 *  pFieldEndOffset) PURE;

  //***********************************************************
  //
  // SetFieldDominance()
  //
  /// Sets the FieldDominance property.
  ///
  /// Succeeds if all of the following are true:
  /// 
  /// If this method fails, the FieldDominance property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - FieldDominance is not a valid value.
  ///
  /// @param fieldDominance [in] Optional.
  ///
  STDMETHOD(SetFieldDominance) (THIS_
    aafFieldNumber_t  fieldDominance) PURE;


  //***********************************************************
  //
  // GetFieldDominance()
  //
  /// Gets the FieldDominance property.
  ///
  /// Succeeds if all of the following are true:
  /// - pFieldDominance is a valid pointer
  /// 
  /// If this method fails, pFieldDominance will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFieldDominance is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pFieldDominance [out] Optional.
  ///
  STDMETHOD(GetFieldDominance) (THIS_
    aafFieldNumber_t *  pFieldDominance) PURE;

  //***********************************************************
  //
  // SetDisplayF2Offset()
  //
  /// Sets the DisplayF2Offset property.
  ///
  /// Succeeds if all of the following are true:
  /// 
  /// If this method fails, the DisplayF2Offset property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - displayF2Offset is not a valid value.
  ///
  /// @param displayF2Offset [in] Optional.
  ///
  STDMETHOD(SetDisplayF2Offset) (THIS_
    aafInt32  displayF2Offset) PURE;


  //***********************************************************
  //
  // GetDisplayF2Offset()
  //
  /// Gets the DisplayF2Offset property.
  ///
  /// Succeeds if all of the following are true:
  /// - pDisplayF2Offset is a valid pointer
  /// 
  /// If this method fails, pDisplayF2Offset will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDisplayF2Offset is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pDisplayF2Offset [out] Optional.
  ///
  STDMETHOD(GetDisplayF2Offset) (THIS_
    aafInt32 *  pDisplayF2Offset) PURE;

  //***********************************************************
  //
  // SetStoredF2Offset()
  //
  /// Sets the StoredF2Offset property.
  ///
  /// Succeeds if all of the following are true:
  /// 
  /// If this method fails, the StoredF2Offset property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ILLEGAL_VALUE
  ///   - storedF2Offset is not a valid value.
  ///
  /// @param storedF2Offset [in] Optional.
  ///
  STDMETHOD(SetStoredF2Offset) (THIS_
    aafInt32  storedF2Offset) PURE;


  //***********************************************************
  //
  // GetStoredF2Offset()
  //
  /// Gets the StoredF2Offset property.
  ///
  /// Succeeds if all of the following are true:
  /// - pStoredF2Offset is a valid pointer
  /// 
  /// If this method fails, pStoredF2Offset will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pStoredF2Offset is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pStoredF2Offset [out] Optional.
  ///
  STDMETHOD(GetStoredF2Offset) (THIS_
    aafInt32 *  pStoredF2Offset) PURE;

  //***********************************************************
  //
  // SetActiveFormatDescriptor()
  //
  /// Sets the ActiveFormatDescriptor property.
  ///
  /// Succeeds if all of the following are true:
  /// 
  /// If this method fails, the ActiveFormatDescriptor property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param activeFormatDescriptor [in] Optional.
  ///
  STDMETHOD(SetActiveFormatDescriptor) (THIS_
    aafUInt8  activeFormatDescriptor) PURE;


  //***********************************************************
  //
  // GetActiveFormatDescriptor()
  //
  /// Gets the ActiveFormatDescriptor property.
  ///
  /// Succeeds if all of the following are true:
  /// - pActiveFormatDescriptor is a valid pointer
  /// 
  /// If this method fails, pActiveFormatDescriptor will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pActiveFormatDescriptor is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pActiveFormatDescriptor [out] Optional.
  ///
  STDMETHOD(GetActiveFormatDescriptor) (THIS_
    aafUInt8 *  pActiveFormatDescriptor) PURE;

  //***********************************************************
  //
  // SetSignalStandard()
  //
  /// Sets the SignalStandard property.  This property is optional.
  ///
  /// Succeeds if all of the following are true:
  /// 
  /// If this method fails, the SignalStandard property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_AAFRESULT_INVALID_ENUM_VALUE
  ///   - signalStandard is not a valid value.
  ///
  /// @param signalStandard [in] Signal standard value.
  ///
  STDMETHOD(SetSignalStandard) (THIS_
    aafSignalStandard_t  signalStandard) PURE;


  //***********************************************************
  //
  // GetSignalStandard()
  //
  /// Gets the SignalStandard property.  This property is optional.
  ///
  /// Succeeds if all of the following are true:
  /// - pSignalStandard is a valid pointer
  /// 
  /// If this method fails, pSignalStandard not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSignalStandard is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pSignalStandard [out] Signal standard value.
  ///
  STDMETHOD(GetSignalStandard) (THIS_
    aafSignalStandard_t *  pSignalStandard) PURE;


  END_INTERFACE
};
#endif // __IAAFDigitalImageDescriptor2_INTERFACE_DEFINED__



// IAAFEndian

// ************************
//
// Interface IAAFEndian
//
// ************************

#ifndef __IAAFEndian_INTERFACE_DEFINED__
#define __IAAFEndian_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFEndian;

#undef  INTERFACE
#define INTERFACE   IAAFEndian

DECLARE_INTERFACE_(IAAFEndian, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFEndian methods *** */

  //***********************************************************
  //
  // GetStoredByteOrder()
  //
  /// Returns the "Endian-ness" in which the current object was or will
  /// be stored.  If this is a transient object (i.e., one which has
  /// not been persisted) then it will return the native byte order of
  /// the platform on which this is running.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pOrder pointer is valid.
  /// 
  /// If this method fails nothing is written to *pOrder.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pOrder is null.
  ///
  /// @param pOrder [out] Pointer to place where byte order is to be put
  ///
  STDMETHOD(GetStoredByteOrder) (THIS_
    eAAFByteOrder_t *  pOrder) PURE;


  //***********************************************************
  //
  // GetNativeByteOrder()
  //
  /// Returns the native "Endian-ness" of the platform on which this is
  /// running.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pOrder pointer is valid.
  /// 
  /// If this method fails nothing is written to *pOrder.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pOrder is null.
  ///
  /// @param pOrder [out] Pointer to place where byte order is to be put
  ///
  STDMETHOD(GetNativeByteOrder) (THIS_
    eAAFByteOrder_t *  pOrder) PURE;

  END_INTERFACE
};
#endif // __IAAFEndian_INTERFACE_DEFINED__



// IAAFEssenceDataEx

// ************************
//
// Interface IAAFEssenceDataEx
//
// ************************





#ifndef __IAAFEssenceDataEx_INTERFACE_DEFINED__
#define __IAAFEssenceDataEx_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFEssenceDataEx;

#undef  INTERFACE
#define INTERFACE   IAAFEssenceDataEx

DECLARE_INTERFACE_(IAAFEssenceDataEx, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFEssenceDataEx methods *** */


  //***********************************************************
  //
  // Initialize()
  //
  /// Associates a weak reference to the given file mob with the
  /// essence data.
  ///
  /// Succeeds if all of the following are true:
  /// - the pFileMob pointer is valid and points to 
  /// a file mob (contains a file descriptor).
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFileMob is null.
  ///
  /// @param pFileMob [in] reference to a file mob
  ///
  STDMETHOD(Initialize) (THIS_
    IAAFSourceMob * pFileMob) PURE;

  //***********************************************************
  //
  // Write()
  //
  /// Write pre-interleaved data to a essence stream.
  ///
  /// @param bytes [in] write this many bytes to the data stream
  /// @param buffer [out, size_is(bytes)] here is the buffer
  /// @param bytesWritten [out,ref] 
  ///
  STDMETHOD(Write) (THIS_
    aafUInt32  bytes,
    aafDataBuffer_t  buffer,
    aafUInt32 *  bytesWritten) PURE;


  //***********************************************************
  //
  // Read()
  //
  /// Read pre-interleaved data from a essence stream.
  ///
  /// @param bytes [in] read this many bytes from the data stream
  /// @param buffer [out, size_is(bytes), length_is(*bytesRead)] here is the buffer
  /// @param bytesRead [out,ref] 
  ///
  STDMETHOD(Read) (THIS_
    aafUInt32  bytes,
    aafDataBuffer_t  buffer,
    aafUInt32 *  bytesRead) PURE;


  //***********************************************************
  //
  // SetPosition()
  //
  /// Seek to absolute position within the essence data.
  ///
  /// @param offset [in] offset from beginning of essence
  ///
  STDMETHOD(SetPosition) (THIS_
    aafPosition_t  offset) PURE;


  //***********************************************************
  //
  // GetPosition()
  //
  /// Get the absolute position within the essence data.
  ///
  /// @param pOffset [out] offset from beginning of essence
  ///
  STDMETHOD(GetPosition) (THIS_
    aafPosition_t*  pOffset) PURE;


  //***********************************************************
  //
  // GetSize()
  //
  /// Return the total size of the essence data.
  ///
  /// @param pSize  [out] size of essence data
  ///
  STDMETHOD(GetSize) (THIS_
    aafLength_t *  pSize ) PURE;

  //***********************************************************
  //
  // WriteSampleIndex()
  //
  /// Write pre-interleaved data to a sample index stream.
  ///
  /// @param bytes [in] write this many bytes to the sample index stream
  /// @param buffer [out, size_is(bytes)] here is the buffer
  /// @param bytesWritten [out,ref] 
  ///
  STDMETHOD(WriteSampleIndex) (THIS_
    aafUInt32  bytes,
    aafDataBuffer_t  buffer,
    aafUInt32 *  bytesWritten) PURE;


  //***********************************************************
  //
  // ReadSampleIndex()
  //
  /// Read pre-interleaved data from a sample index stream.
  ///
  /// @param bytes [in] read this many bytes from the sample index stream
  /// @param buffer [out, size_is(bytes), length_is(*bytesRead)] here is the buffer
  /// @param bytesRead [out,ref] 
  ///
  STDMETHOD(ReadSampleIndex) (THIS_
    aafUInt32  bytes,
    aafDataBuffer_t  buffer,
    aafUInt32 *  bytesRead) PURE;


  //***********************************************************
  //
  // SetSampleIndexPosition()
  //
  /// Seek to absolute position within the sample index data.
  ///
  /// @param offset [in] offset from beginning of sample index
  ///
  STDMETHOD(SetSampleIndexPosition) (THIS_
    aafPosition_t  offset) PURE;


  //***********************************************************
  //
  // GetSampleIndexPosition()
  //
  /// Get the absolute position within the sample index data.
  ///
  /// @param pOffset [out] offset from beginning of sample index
  ///
  STDMETHOD(GetSampleIndexPosition) (THIS_
    aafPosition_t*  pOffset) PURE;


  //***********************************************************
  //
  // GetSampleIndexSize()
  //
  /// Return the total size of the sample index data.
  ///
  /// @param pSize  [out] size of sample index data
  ///
  STDMETHOD(GetSampleIndexSize) (THIS_
    aafLength_t *  pSize ) PURE;


  //***********************************************************
  //
  // SetFileMob()
  //
  /// Associates a weak reference to the given file mob with the
  /// essence data.
  ///
  /// Succeeds if all of the following are true:
  /// - the pFileMob pointer is valid and points to 
  /// a file mob (contains a file descriptor).
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFileMob is null.
  ///
  /// @param pFileMob [in] reference to a file mob
  ///
  STDMETHOD(SetFileMob) (THIS_
    IAAFSourceMob * pFileMob) PURE;


  //***********************************************************
  //
  // GetFileMob()
  //
  /// Associates a weak reference to the given file mob with the
  /// essence data.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppFileMob pointer is valid and a weak
  /// reference to the associated file mob can be
  /// resolved.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppFileMob is null.
  ///
  /// @param ppFileMob [in] reference to a file mob
  ///
  STDMETHOD(GetFileMob) (THIS_
    IAAFSourceMob ** ppFileMob) PURE;


  //***********************************************************
  //
  // GetFileMobID()
  //
  /// Return the mob id used to find the file mob associated with this
  /// essence.  The file mob must exist in the same file as this
  /// essence data.
  ///
  /// @param pFileMobID [out] the file mob id associated with essence
  ///
  STDMETHOD(GetFileMobID) (THIS_
    aafMobID_t *  pFileMobID) PURE;


  END_INTERFACE
};
#endif // __IAAFEssenceDataEx_INTERFACE_DEFINED__



// IAAFEssenceData2

// ************************
//
// Interface IAAFEssenceData2
//
// ************************






#ifndef __IAAFEssenceData2_INTERFACE_DEFINED__
#define __IAAFEssenceData2_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFEssenceData2;

#undef  INTERFACE
#define INTERFACE   IAAFEssenceData2

DECLARE_INTERFACE_(IAAFEssenceData2, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFEssenceData2 methods *** */


  //***********************************************************
  //
  // Initialize()
  //
  /// Associates a weak reference to the given file mob with the
  /// essence data.
  ///
  /// Succeeds if all of the following are true:
  /// - the pFileMob pointer is valid and points to 
  /// a file mob (contains a file descriptor).
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFileMob is null.
  ///
  /// @param pFileMob [in] reference to a file mob
  ///
  STDMETHOD(Initialize) (THIS_
    IAAFSourceMob * pFileMob) PURE;

  //***********************************************************
  //
  // Write()
  //
  /// Write pre-interleaved data to a essence stream.
  ///
  /// @param bytes [in] write this many bytes to the data stream
  /// @param buffer [out, size_is(bytes)] here is the buffer
  /// @param bytesWritten [out,ref] 
  ///
  STDMETHOD(Write) (THIS_
    aafUInt32  bytes,
    aafDataBuffer_t  buffer,
    aafUInt32 *  bytesWritten) PURE;


  //***********************************************************
  //
  // Read()
  //
  /// Read pre-interleaved data from a essence stream.
  ///
  /// @param bytes [in] read this many bytes from the data stream
  /// @param buffer [out, size_is(bytes), length_is(*bytesRead)] here is the buffer
  /// @param bytesRead [out,ref] 
  ///
  STDMETHOD(Read) (THIS_
    aafUInt32  bytes,
    aafDataBuffer_t  buffer,
    aafUInt32 *  bytesRead) PURE;


  //***********************************************************
  //
  // SetPosition()
  //
  /// Seek to absolute position within the essence data.
  ///
  /// @param offset [in] offset from beginning of essence
  ///
  STDMETHOD(SetPosition) (THIS_
    aafPosition_t  offset) PURE;


  //***********************************************************
  //
  // GetPosition()
  //
  /// Get the absolute position within the essence data.
  ///
  /// @param pOffset [out] offset from beginning of essence
  ///
  STDMETHOD(GetPosition) (THIS_
    aafPosition_t*  pOffset) PURE;


  //***********************************************************
  //
  // GetSize()
  //
  /// Return the total size of the essence data.
  ///
  /// @param pSize  [out] size of essence data
  ///
  STDMETHOD(GetSize) (THIS_
    aafLength_t *  pSize ) PURE;

  //***********************************************************
  //
  // WriteSampleIndex()
  //
  /// Write pre-interleaved data to a sample index stream.
  ///
  /// @param bytes [in] write this many bytes to the sample index stream
  /// @param buffer [out, size_is(bytes)] here is the buffer
  /// @param bytesWritten [out,ref] 
  ///
  STDMETHOD(WriteSampleIndex) (THIS_
    aafUInt32  bytes,
    aafDataBuffer_t  buffer,
    aafUInt32 *  bytesWritten) PURE;


  //***********************************************************
  //
  // ReadSampleIndex()
  //
  /// Read pre-interleaved data from a sample index stream.
  ///
  /// @param bytes [in] read this many bytes from the sample index stream
  /// @param buffer [out, size_is(bytes), length_is(*bytesRead)] here is the buffer
  /// @param bytesRead [out,ref] 
  ///
  STDMETHOD(ReadSampleIndex) (THIS_
    aafUInt32  bytes,
    aafDataBuffer_t  buffer,
    aafUInt32 *  bytesRead) PURE;


  //***********************************************************
  //
  // SetSampleIndexPosition()
  //
  /// Seek to absolute position within the sample index data.
  ///
  /// @param offset [in] offset from beginning of sample index
  ///
  STDMETHOD(SetSampleIndexPosition) (THIS_
    aafPosition_t  offset) PURE;


  //***********************************************************
  //
  // GetSampleIndexPosition()
  //
  /// Get the absolute position within the sample index data.
  ///
  /// @param pOffset [out] offset from beginning of sample index
  ///
  STDMETHOD(GetSampleIndexPosition) (THIS_
    aafPosition_t*  pOffset) PURE;


  //***********************************************************
  //
  // GetSampleIndexSize()
  //
  /// Return the total size of the sample index data.
  ///
  /// @param pSize  [out] size of sample index data
  ///
  STDMETHOD(GetSampleIndexSize) (THIS_
    aafLength_t *  pSize ) PURE;


  //***********************************************************
  //
  // SetFileMob()
  //
  /// Associates a weak reference to the given file mob with the
  /// essence data.
  ///
  /// Succeeds if all of the following are true:
  /// - the pFileMob pointer is valid and points to 
  /// a file mob (contains a file descriptor).
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFileMob is null.
  ///
  /// @param pFileMob [in] reference to a file mob
  ///
  STDMETHOD(SetFileMob) (THIS_
    IAAFSourceMob * pFileMob) PURE;


  //***********************************************************
  //
  // GetFileMob()
  //
  /// Associates a weak reference to the given file mob with the
  /// essence data.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppFileMob pointer is valid and a weak
  /// reference to the associated file mob can be
  /// resolved.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppFileMob is null.
  ///
  /// @param ppFileMob [in] reference to a file mob
  ///
  STDMETHOD(GetFileMob) (THIS_
    IAAFSourceMob ** ppFileMob) PURE;


  //***********************************************************
  //
  // GetFileMobID()
  //
  /// Return the mob id used to find the file mob associated with this
  /// essence.  The file mob must exist in the same file as this
  /// essence data.
  ///
  /// @param pFileMobID [out] the file mob id associated with essence
  ///
  STDMETHOD(GetFileMobID) (THIS_
    aafMobID_t *  pFileMobID) PURE;


  //***********************************************************
  //
  // GetPlainEssenceData()
  //
  /// Creates an object which implements
  // the AAFPlainEssenceData interface and provides access to a file
  // encoding-independent essence data.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pPlainEssenceData is a valid pointer.
  // - reserved is 0.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPlainEssenceData arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - reserved is not 0.
  ///
  /// @param reserved [in] Reserved for future use
  /// @param pPlainEssenceData [out,retval] file encoding-independent essence data
  ///
  STDMETHOD(GetPlainEssenceData) (THIS_
    aafUInt32  reserved,
    IAAFPlainEssenceData ** pPlainEssenceData) PURE;


  END_INTERFACE
};
#endif // __IAAFEssenceData2_INTERFACE_DEFINED__



// IAAFEssenceMultiAccess

// ************************
//
// Interface IAAFEssenceMultiAccess
//
// ************************








#ifndef __IAAFEssenceMultiAccess_INTERFACE_DEFINED__
#define __IAAFEssenceMultiAccess_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFEssenceMultiAccess;

#undef  INTERFACE
#define INTERFACE   IAAFEssenceMultiAccess

DECLARE_INTERFACE_(IAAFEssenceMultiAccess, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFEssenceMultiAccess methods *** */

  //***********************************************************
  //
  // WriteMultiSamples()
  //
  /// Writes multiple channels worth of sample data to an interleaved
  /// data stream in the natural order for the CODEC.
  ///
  /// @param arrayElemCount [in] number of elements in the array of transfer operations
  /// @param xferArray [in,size_is(arrayElemCount)] Points to an array of transfer parameters.  All fields in this
  /// array except for bytesXferred must be set up before doing the
  /// transfer.  Some of the fields in the xferArray structure are
  /// status results like bytesXferred and samplesXferred.
  ///
  /// The multiXfer_t structure has the following fields, which
  /// specify one channel of data: 
  ///
  ///   essenceDef    [IN] -- The essence type definition
  ///   physical      [IN] -- The physical input-output channel
  ///   numSamples    [IN] -- The number of samples to transfer
  ///   buflen        [IN] -- The size of the buffer
  ///   buffer        [IN] -- The buffer for this
  /// @param resultArray [out,size_is(arrayElemCount)] Put results into this array.  It has the following fields,
  /// which return result for one channel of data:
  ///
  ///   bytesXfered   [OUT] -- The total number of bytes transferred
  ///   samplesXfered [OUT] -- The total number of samples transferred
  ///
  STDMETHOD(WriteMultiSamples) (THIS_
    aafUInt16  arrayElemCount,
    aafmMultiXfer_t *  xferArray,
    aafmMultiResult_t *  resultArray) PURE;


  //***********************************************************
  //
  // ReadMultiSamples()
  //
  /// Reads one or more channels from an interleaved data stream.
  /// Possible Errors:
  ///
  ///   Standard errors (see top of file).
  ///
  ///   AAFRESULT_END_OF_ESSENCE -- Hit the end of the essence (like
  ///                               EOF) while reading.
  ///
  /// @param elemCount [in] The size of the array for transfer operations.
  /// @param xferArray [in, size_is(elemCount)] Points to an array of transfer parameters.  All fields in this
  /// array except for bytesXferred must be set up before doing the
  /// transfer.  Some of the fields in the xferArray structure are
  /// status results like bytesXferred and samplesXferred.
  ///
  /// The multiXfer_t structure has the following fields, which
  /// specify one channel of data:
  ///
  ///   essenceDef  [IN] -- The essence type definition
  ///   physical    [IN] -- The physical input-output channel
  ///   numSamples  [IN] -- The number of samples to transfer
  ///   buflen      [IN] -- The size of the buffer
  ///   buffer      [IN] -- The buffer for this
  /// @param resultArray [out, size_is(elemCount)] Results go into this array.
  ///
  /// The aafmMultiResult_t structure has the following fields,
  /// which return result for one channel of data: 
  ///
  ///   bytesXfered   [OUT] -- The total number of bytes transferred
  ///   samplesXfered [OUT] -- The total number of samples transferred
  ///
  STDMETHOD(ReadMultiSamples) (THIS_
    aafUInt16  elemCount,
    aafmMultiXfer_t *  xferArray,
    aafmMultiResult_t *  resultArray) PURE;

  END_INTERFACE
};
#endif // __IAAFEssenceMultiAccess_INTERFACE_DEFINED__



// IAAFEventMobSlot2

// ************************
//
// Interface IAAFEventMobSlot2
//
// ************************




#ifndef __IAAFEventMobSlot2_INTERFACE_DEFINED__
#define __IAAFEventMobSlot2_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFEventMobSlot2;

#undef  INTERFACE
#define INTERFACE   IAAFEventMobSlot2

DECLARE_INTERFACE_(IAAFEventMobSlot2, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFEventMobSlot2 methods *** */

  //***********************************************************
  //
  // GetEditRate()
  //
  /// This method will get the edit rate for this mob slot.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pEditRate pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEditRate arg is NULL.
  ///
  /// @param pEditRate [out,retval] Edit rate property value
  ///
  STDMETHOD(GetEditRate) (THIS_
    aafRational_t *  pEditRate) PURE;


  //***********************************************************
  //
  // SetEditRate()
  //
  /// This method will get set edit rate for this mob slot.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pEditRate pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEditRate arg is NULL.
  ///
  /// @param pEditRate [in] Edit rate property value
  ///
  STDMETHOD(SetEditRate) (THIS_
    aafRational_t *  pEditRate) PURE;

  //***********************************************************
  //
  // GetEventSlotOrigin()
  //
  /// This method will return the EventSlotOrigin of this mob slot.
  /// The EventSlotOrigin is an optional property.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pEventSlotOrigin pointer is valid.
  /// - the EventSlotOrigin property is present.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - The EventSlotOrigin property is not present.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEventSlotOrigin arg is NULL.
  ///
  /// @param pEventSlotOrigin [out,retval] EventSlotOrigin property value
  ///
  STDMETHOD(GetEventSlotOrigin) (THIS_
    aafPosition_t *  pEventSlotOrigin) PURE;


  //***********************************************************
  //
  // SetEventSlotOrigin()
  //
  /// This method will set the EventSlotOrigin of this mob slot.
  /// EventSlotOrigin is an optional property.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.).
  ///
  /// @param eventSlotOrigin [in] EventSlotOrigin property value
  ///
  STDMETHOD(SetEventSlotOrigin) (THIS_
    aafPosition_t  eventSlotOrigin) PURE;




  END_INTERFACE
};
#endif // __IAAFEventMobSlot2_INTERFACE_DEFINED__



// IAAFFileDescriptor2

// ************************
//
// Interface IAAFFileDescriptor2
//
// ************************



#ifndef __IAAFFileDescriptor2_INTERFACE_DEFINED__
#define __IAAFFileDescriptor2_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFFileDescriptor2;

#undef  INTERFACE
#define INTERFACE   IAAFFileDescriptor2

DECLARE_INTERFACE_(IAAFFileDescriptor2, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFFileDescriptor2 methods *** */

  //***********************************************************
  //
  // SetLength()
  //
  /// Sets the length of the essence in samples [not edit units].
  /// 
  /// Always succeeds.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param length [in] length of the essence in samples
  ///
  STDMETHOD(SetLength) (THIS_
    aafLength_t  length) PURE;


  //***********************************************************
  //
  // GetLength()
  //
  /// Gets the length of the essence in samples [not edit units].
  ///
  /// Succeeds if all of the following are true:
  /// - the pLength pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pLength.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLength arg is NULL.
  ///
  /// @param pLength [out] returns length of the essence in samples
  ///
  STDMETHOD(GetLength) (THIS_
    aafLength_t *  pLength) PURE;


  //***********************************************************
  //
  // SetCodecDef()
  //
  /// Set to the exact codec which was used as a hint.
  /// 
  /// Always succeeds.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param codecDef [in] Which codec was used
  ///
  STDMETHOD(SetCodecDef) (THIS_
    IAAFCodecDef * codecDef) PURE;


  //***********************************************************
  //
  // GetCodecDef()
  //
  /// Get to the exact codec which was used as a hint.
  ///
  /// Succeeds if all of the following are true:
  /// - the pCodecDef pointer is valid.
  /// - the CodecDefinition identifying the codec is
  ///   present in the dictionary.
  /// 
  /// If this method fails nothing will be written to *pCodecDef.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCodecDef arg is NULL.
  ///
  /// AAFRESULT_OBJECT_NOT_FOUND
  ///   - the CodecDefinition identifying the codec is not
  ///     in the dictionary.
  ///
  /// @param pCodecDef [out] Which codec was used
  ///
  STDMETHOD(GetCodecDef) (THIS_
    IAAFCodecDef ** pCodecDef) PURE;


  //***********************************************************
  //
  // SetSampleRate()
  //
  /// Sets sample rate of the essence as opposed to the edit rate.
  /// 
  /// If this method fails the sample rate property will not be
  /// changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param rate [in] sample rate of the essence
  ///
  STDMETHOD(SetSampleRate) (THIS_
    aafRational_constref  rate) PURE;


  //***********************************************************
  //
  // GetSampleRate()
  //
  /// Gets sample rate of the essence as opposed to the edit rate. and
  /// writes it into the *pRate argument.
  ///
  /// Succeeds if all of the following are true:
  /// - the pRate pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pRate.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pRate arg is NULL.
  ///
  /// @param pRate [out] sample rate of the essence
  ///
  STDMETHOD(GetSampleRate) (THIS_
    aafRational_t*  pRate) PURE;


  //***********************************************************
  //
  // SetContainerFormat()
  //
  /// Identifies the file format.  The container format is an optional
  /// property.
  /// 
  /// If this method fails the container format property will not be
  /// changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param format [in] file format
  ///
  STDMETHOD(SetContainerFormat) (THIS_
    IAAFContainerDef * format) PURE;


  //***********************************************************
  //
  // GetContainerFormat()
  //
  /// Identifies the file format.
  ///
  /// Succeeds if all of the following are true:
  /// - the pFormat pointer is valid.
  /// - the ContainerDefinition identifying the file format is
  ///   present in the dictionary.
  /// 
  /// If this method fails nothing will be written to *pFormat.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFormat arg is NULL.
  ///
  /// AAFRESULT_OBJECT_NOT_FOUND
  ///   - the ContainerDefinition identifying the file format is not
  ///     in the dictionary.
  ///
  /// @param pFormat [out] Optional
  ///
  STDMETHOD(GetContainerFormat) (THIS_
    IAAFContainerDef ** pFormat) PURE;


  //***********************************************************
  //
  // SetLinkedSlotID()
  //
  /// Sets the LinkedSlotID property.  
  ///
  ///
  /// This property is optional.
  ///
  /// If this method fails, the LinkedSlotID property will not
  /// be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param LinkedSlotID [in] the linked slot id
  ///
  STDMETHOD(SetLinkedSlotID) (THIS_
    aafUInt32  LinkedSlotID) PURE;


  //***********************************************************
  //
  // GetLinkedSlotID()
  //
  /// Gets the LinkedSlotID property. 
  ///
  ///
  /// Succeeds if all of the following are true:
  /// - pLinkedSlotID is a valid pointer.
  /// 
  /// If this method fails, *pLinkedSlotID will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLinkedSlotID arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the LinkedSlotID property is not present.
  ///
  /// @param pLinkedSlotID [out] The linked slot id
  ///
  STDMETHOD(GetLinkedSlotID) (THIS_
    aafUInt32 *  pLinkedSlotID) PURE;


  END_INTERFACE
};
#endif // __IAAFFileDescriptor2_INTERFACE_DEFINED__



// IAAFHeader2

// ************************
//
// Interface IAAFHeader2
//
// ************************










#ifndef __IAAFHeader2_INTERFACE_DEFINED__
#define __IAAFHeader2_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFHeader2;

#undef  INTERFACE
#define INTERFACE   IAAFHeader2

DECLARE_INTERFACE_(IAAFHeader2, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFHeader2 methods *** */

  //***********************************************************
  //
  // LookupMob()
  //
  /// Looks up the Mob that matches the given mob id and puts it into
  /// the ppMob argument.  The returned mob interface is AddRef()ed
  /// before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppMob pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppMob.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppMob is null
  ///
  /// AAFRESULT_MOB_NOT_FOUND
  ///   - the requested mob wasn't found.
  ///
  /// @param mobID [in, ref] The Mob ID
  /// @param ppMob [out,retval] Matching Mob
  ///
  STDMETHOD(LookupMob) (THIS_
    aafMobID_constref  mobID,
    IAAFMob ** ppMob) PURE;


  //***********************************************************
  //
  // CountMobs()
  //
  /// Writes the number of matches for the given mob kind into the
  /// *pNumMobs argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pNumMobs pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pNumMobs.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumMobs is null.
  ///
  /// @param mobKind [in] The mob kind to count
  /// @param pResult [out, retval] Total number of mobs of kind mobKind
  ///
  STDMETHOD(CountMobs) (THIS_
    aafMobKind_t  mobKind,
    aafNumSlots_t *  pResult) PURE;


  //***********************************************************
  //
  // GetMobs()
  //
  /// Places an enumerator for mobs that apply to the criteria into the
  /// *ppEnum argument.  If pSearchCriteria is null, all mobs are
  /// returned.   The searchTag field of pSearchCriteria, and exactly
  /// ONE of the fields in the union (tags.mobID, tags.name, etc. )
  /// must be set.  Only one search criterion may be specified.  The
  /// returned enumerator is AddRef()ed before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// @param pSearchCriteria [in] Search Criteria for enumeration
  /// @param ppEnum [out, retval] Mob Enumeration
  ///
  STDMETHOD(GetMobs) (THIS_
    aafSearchCrit_t *  pSearchCriteria,
    IEnumAAFMobs ** ppEnum) PURE;


  //***********************************************************
  //
  // AddMob()
  //
  /// Appends the given mob to the header.  If the given mob is already
  /// contained this method will do nothing and will return success.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pMob pointer is valid.
  /// - the given mob is not already part of this collection.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMob is null.
  ///
  /// AAFRESULT_DUPLICATE_MOBID
  ///   - the given mob is already contained.
  ///
  /// @param pMob [in] Mob to add
  ///
  STDMETHOD(AddMob) (THIS_
    IAAFMob * pMob) PURE;


  //***********************************************************
  //
  // RemoveMob()
  //
  /// Removes the given mob from the header.
  ///
  /// Succeeds if all of the following are true:
  /// - the pMob pointer is valid.
  /// - the given mob is currently in the collection.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMob is null.
  ///
  /// AAFRESULT_MOB_NOT_FOUND
  ///   - the given mob is not already contained.
  ///
  /// @param pMob [in] Mob to remove
  ///
  STDMETHOD(RemoveMob) (THIS_
    IAAFMob * pMob) PURE;


  //***********************************************************
  //
  // CountEssenceData()
  //
  /// Writes the total number of essence data into the *pNumEssenceData
  /// argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pNumEssenceData pointer is valid.
  /// 
  /// If this method fails nothing will be written to
  /// *pNumEssenceData.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumEssenceData is null.
  ///
  /// @param pResult [out, retval] Total number of essence data
  ///
  STDMETHOD(CountEssenceData) (THIS_
    aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // IsEssenceDataPresent()
  //
  /// Returns true if the essence is found.
  ///
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  ///
  /// @param fileMobID [in, ref] A Unique File Mob ID
  /// @param fmt [in] The Essence File Format
  /// @param pResult [out,retval] True if the essence is found
  ///
  STDMETHOD(IsEssenceDataPresent) (THIS_
    aafMobID_constref  fileMobID,
    aafFileFormat_t  fmt,
    aafBoolean_t *  pResult) PURE;


  //***********************************************************
  //
  // EnumEssenceData()
  //
  /// Places an enumerator for essence that applies to the criteria
  /// into the *ppEnum argument.  The returned enumerator is
  /// AddRef()ed before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pMediaCriteria pointer is valid.
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pMediaCriteria or ppEnum is null.
  ///
  /// @param ppEnum [out,retval] Essence Enumeration
  ///
  STDMETHOD(EnumEssenceData) (THIS_
    IEnumAAFEssenceData ** ppEnum) PURE;


  //***********************************************************
  //
  // AddEssenceData()
  //
  /// Appends the given essence data object to the header.
  /// 
  /// NOTE! Stub only.   Implementation not yet added.
  ///
  /// Succeeds if all of the following are true:
  /// - the pEssenceData pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_DUPLICATE_MOBID
  ///   - The given mob has already been added.  The validation is done by comparing
  ///     mobIDs, which should be unique.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEssenceData is null.
  ///
  /// @param pEssenceData [in] Essence data object to append
  ///
  STDMETHOD(AddEssenceData) (THIS_
    IAAFEssenceData * pEssenceData) PURE;

  //***********************************************************
  //
  // RemoveEssenceData()
  //
  /// Removes the given EssenceData from the header.
  ///
  /// Succeeds if all of the following are true:
  /// - the pEssenceData pointer is valid.
  /// - the given EssenceData is currently in the collection.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEssenceData is null.
  ///
  /// AAFRESULT_ESSENCE_NOT_FOUND
  ///   - the given EssenceData is not already contained.
  ///
  /// @param pEssenceData [in] EssenceData to remove
  ///
  STDMETHOD(RemoveEssenceData) (THIS_
    IAAFEssenceData * pEssenceData) PURE;

  //***********************************************************
  //
  // LookupEssenceData()
  //
  /// Looks up the EssenceData that matches the given mob id and puts it into
  /// the ppEssenceData argument.  The returned EssenceData interface is AddRef()ed
  /// before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEssenceData pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEssenceData.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEssenceData is null
  ///
  /// AAFRESULT_MOB_NOT_FOUND
  ///   - the requested EssenceData wasn't found.
  ///
  /// @param mobID [in, ref] The Mob ID
  /// @param ppEssenceData [out,retval] Matching EssenceData
  ///
  STDMETHOD(LookupEssenceData) (THIS_
    aafMobID_constref  mobID,
    IAAFEssenceData ** ppEssenceData) PURE;

  //***********************************************************
  //
  // GetDictionary()
  //
  /// Places the dictionary that contains all types of aaf definition
  /// objects into the *ppDictionary argument.  The returned dictionary
  /// is AddRef()ed before it is returned.  Note that the dictionary
  /// is automatically created when the header object is created.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppDictionary pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDictionary is null.
  ///
  /// @param ppDictionary [out, retval] The AAF Dictionary
  ///
  STDMETHOD(GetDictionary) (THIS_
    IAAFDictionary ** ppDictionary) PURE;


  //***********************************************************
  //
  // GetLastIdentification()
  //
  /// Places the identification of the last entity that modified the
  /// file into the *ppIdentification argument.  The returned
  /// identification is AddRef()ed before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppIdentification pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppIdentification is null.
  ///
  /// @param ppIdentification [out,retval] Indentification Object
  ///
  STDMETHOD(GetLastIdentification) (THIS_
    IAAFIdentification ** ppIdentification) PURE;


  //***********************************************************
  //
  // LookupIdentification()
  //
  /// Places the Identification that matches the given generation into
  /// the *ppIdentification argument.  The returned identification is
  /// AddRef()ed before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppIdentification pointer is valid.
  /// - the given generation was found.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppIdentification is null.
  ///
  /// AAFRESULT_OBJECT_NOT_FOUND
  ///   - the given generation was not found..
  ///
  /// @param generation [in, ref] Unique Generation ID
  /// @param ppIdentification [out,retval] Indentification Object
  ///
  STDMETHOD(LookupIdentification) (THIS_
    aafUID_constref  generation,
    IAAFIdentification ** ppIdentification) PURE;


  //***********************************************************
  //
  // CountIdentifications()
  //
  /// Writes the number of identification objects into the *pResult
  /// argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  ///
  /// @param pResult [out, retval] Total number of identification objects
  ///
  STDMETHOD(CountIdentifications) (THIS_
    aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // GetIdentifications()
  //
  /// Places an enumerator for all Identifications criteria into	the
  /// *ppEnum argument.  The returned enumerator is AddRef()ed before
  /// it is returned.
  /// 
  /// NOTE! Stub only.   Implementation not yet added.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// @param ppEnum [out,retval] Indentification Enumeration
  ///
  STDMETHOD(GetIdentifications) (THIS_
    IEnumAAFIdentifications ** ppEnum) PURE;


  //***********************************************************
  //
  // AppendIdentification()
  //
  /// Appends the given Identification class to the header.  This
  /// method does not attempt to identify duplicate identifications, so
  /// it will succeed even if an identical identification has already
  /// been appended.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pIdent pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pIdent is null.
  ///
  /// @param pIdent [in] Identification to append
  ///
  STDMETHOD(AppendIdentification) (THIS_
    IAAFIdentification * pIdent) PURE;


  //***********************************************************
  //
  // GetIdentificationAt()
  //
  /// Retrieves the indexed identification from the header.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppIdentification pointer is valid.
  /// - index is less than the value returned by CountIdentifications().
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppIdent is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than or equal to result of
  ///     CountIdentifications().
  ///
  /// @param index [in] Index of identification to retrieve
  /// @param ppIdentification [out, retval] Retrieved identification
  ///
  STDMETHOD(GetIdentificationAt) (THIS_
    aafUInt32  index,
    IAAFIdentification ** ppIdentification) PURE;


  //***********************************************************
  //
  // GetRefImplVersion()
  //
  /// Return the version of the Reference Implementation currently
  /// running on this machine, which implements these interfaces.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pVersion pointer is valid.
  /// 
  /// If this method fails nothing is written to *pVersion.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pVersion is null.
  ///
  /// @param pVersion [out, retval] The Reference Implementation Version
  ///
  STDMETHOD(GetRefImplVersion) (THIS_
    aafProductVersion_t *  pVersion) PURE;


  //***********************************************************
  //
  // GetFileRevision()
  //
  /// Return the File Revision property.
  /// 
  /// NOTE! Stub only.   Implementation not yet added.
  ///
  /// Succeeds if all of the following are true:
  /// - the pRevision pointer is valid.
  /// 
  /// If this method fails nothing is written to *pRevision.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pRevision is null.
  ///
  /// @param pRevision [out, retval] The File Version
  ///
  STDMETHOD(GetFileRevision) (THIS_
    aafVersionType_t *  pRevision) PURE;


  //***********************************************************
  //
  // GetLastModified()
  //
  /// Return the Last Modified property.
  /// 
  /// NOTE! Stub only.   Implementation not yet added.
  ///
  /// Succeeds if all of the following are true:
  /// - the pTimeStamp pointer is valid.
  /// 
  /// If this method fails nothing is written to *pTimeStamp.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTimeStamp is null.
  ///
  /// @param pTimeStamp [out, retval] The modification date-time stamp
  ///
  STDMETHOD(GetLastModified) (THIS_
    aafTimeStamp_t *  pTimeStamp) PURE;


  //***********************************************************
  //
  // GetContentStorage()
  //
  /// Places the Content Storage object attached to the header into the
  /// *ppStorage argument.
  ///
  /// The returned content storage object is
  /// AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppStorage pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppStorage is null.
  ///
  /// @param ppStorage [out] Returned Content Storage object
  ///
  STDMETHOD(GetContentStorage) (THIS_
    IAAFContentStorage ** ppStorage) PURE;


  //***********************************************************
  //
  // GetPrimaryMob()
  //
  /// Returns this file's primary mob.
  ///
  /// Succeeds if all of the following are true:
  /// - the pPrimaryMob pointer is valid.
  ///
  /// The returned object is AddRef()ed before it is returned.
  ///
  /// If this method fails no state will be changed.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPrimaryMob arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - property not present.
  ///
  /// @param pPrimaryMob [out, retval] The primary mob
  ///
  STDMETHOD(GetPrimaryMob) (THIS_
    IAAFMob ** pPrimaryMob) PURE;


  //***********************************************************
  //
  // SetPrimaryMob()
  //
  /// Sets this file's primary mob.
  ///
  /// If this method fails, the property will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPrimaryMob arg is NULL.
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param pPrimaryMob [in] The primary mob
  ///
  STDMETHOD(SetPrimaryMob) (THIS_
    IAAFMob * pPrimaryMob) PURE;


  //***********************************************************
  //
  // GetOperationalPattern()
  //
  /// This method returns ID of the operational pattern this
  /// file complies to.
  ///
  /// Succeeds if all of the following are true:
  /// - the pOperationalPatternID pointer is valid.
  /// - the OperationalPattern property is present
  ///
  /// If this method fails nothing will be written to *pOperationalPatternID.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pOperationalPatternID arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - property not present.
  ///
  /// @param pOperationalPatternID [out] Operational pattern ID.
  ///
  STDMETHOD(GetOperationalPattern) (THIS_
    aafUID_t *  pOperationalPatternID) PURE;


  //***********************************************************
  //
  // SetOperationalPattern()
  //
  /// Sets operational pattern this file complies to.
  ///
  /// If this method fails, the property will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param operationalPatternID [in] Operational pattern ID.
  ///
  STDMETHOD(SetOperationalPattern) (THIS_
    aafUID_constref  operationalPatternID) PURE;


  //***********************************************************
  //
  // UpdateEssenceContainers()
  //
  /// Ensures that the contents of the EssenceContainers property
  /// is in sync with the file's metadata. If this method succeeds
  /// the property will contain IDs of all ContainerDefinitions referenced
  /// by source mobs in this file.
  /// If the property isn't present it will be created.
  /// This method must be called before any other EssenceContainers
  /// method can be called.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(UpdateEssenceContainers) (THIS) PURE;


  //***********************************************************
  //
  // CountEssenceContainers()
  //
  /// Gets the total number of essence containers present in the file.
  ///
  /// Succeeds if all of the following are true:
  /// - the pCount pointer is valid.
  /// - the EssenceContainers property is present
  ///
  /// If this method fails nothing will be written to *pCount.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCount arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - property not present.
  ///
  /// @param pCount [out, retval] Number of essence containers
  ///
  STDMETHOD(CountEssenceContainers) (THIS_
    aafUInt32*  pCount) PURE;


  //***********************************************************
  //
  // GetEssenceContainers()
  //
  /// Gets IDs of essence containers present in the file.
  ///
  /// The values are written to the array specified by pEssenceContainerIDs,
  /// which is of size maxEssenceContainersCount. The required size may be found
  /// by calling CountEssenceContainers().
  /// 
  /// Succeeds if all of the following are true:
  /// - pEssenceContainerIDs is a valid pointer.
  /// - maxEssenceContainersCount indicates the array is large enough to hold the
  ///   data.
  /// - the EssenceContainers property is present
  /// 
  /// If this method fails, the property will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEssenceContainerIDs is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - maxEssenceContainersCount indicates that the array is too small to hold
  ///     the data.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - property not present.
  ///
  /// @param maxEssenceContainersCount [in] The number of elements in the array
  /// @param pEssenceContainerIDs [out, size_is(maxEssenceContainersCount)] Array to hold the essence container IDs
  ///
  STDMETHOD(GetEssenceContainers) (THIS_
    aafUInt32  maxEssenceContainersCount,
    aafUID_t *  pEssenceContainerIDs) PURE;


  //***********************************************************
  //
  // IsEssenceContainerPresent()
  //
  /// Returns true if the essence container is present.
  ///
  /// Succeeds if all of the following are true:
  /// - the pIsPresent pointer is valid.
  /// - the EssenceContainers property is present
  ///
  /// If this method fails nothing will be written to *pIsPresent.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pIsPresent arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - property not present.
  ///
  /// @param essenceContainerID [in, ref] Essence container ID
  /// @param pIsPresent [out,retval] Is this essence container present
  ///
  STDMETHOD(IsEssenceContainerPresent) (THIS_
    aafUID_constref  essenceContainerID,
    aafBoolean_t*  pIsPresent) PURE;


  //***********************************************************
  //
  // CountDescriptiveSchemes()
  //
  /// Gets the total number of descriptive schemes present in the file.
  ///
  /// Succeeds if all of the following are true:
  /// - the pCount pointer is valid.
  /// - the DescriptiveSchemes property is present
  ///
  /// If this method fails nothing will be written to *pCount.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCount arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - property not present.
  ///
  /// @param pCount [out, retval] Number of descriptive schemes
  ///
  STDMETHOD(CountDescriptiveSchemes) (THIS_
    aafUInt32*  pCount) PURE;


  //***********************************************************
  //
  // GetDescriptiveSchemes()
  //
  /// Gets IDs of descriptive schemes present in the file.
  ///
  /// The values are written to the array specified by pDescriptiveSchemeIDs,
  /// which is of size maxDescriptiveSchemesCount. The required size may be found
  /// by calling CountDescriptiveSchemes().
  /// 
  /// Succeeds if all of the following are true:
  /// - pDescriptiveSchemeIDs is a valid pointer.
  /// - maxDescriptiveSchemesCount indicates the array is large enough to hold the
  ///   data.
  /// - the DescriptiveSchemes property is present
  /// 
  /// If this method fails, the property will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pDescriptiveSchemeIDs is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - maxDescriptiveSchemesCount indicates that the array is too small to hold
  ///     the data.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - property not present.
  ///
  /// @param maxDescriptiveSchemesCount [in] The number of elements in the array
  /// @param pDescriptiveSchemeIDs [out, size_is(maxDescriptiveSchemesCount)] Array to hold the descriptive scheme IDs
  ///
  STDMETHOD(GetDescriptiveSchemes) (THIS_
    aafUInt32  maxDescriptiveSchemesCount,
    aafUID_t *  pDescriptiveSchemeIDs) PURE;


  //***********************************************************
  //
  // IsDescriptiveSchemePresent()
  //
  /// Returns true if the descriptive scheme ID is present.
  ///
  ///
  /// Succeeds if all of the following are true:
  /// - the pIsPresent pointer is valid;
  /// - the DescriptiveSchemes property is present
  ///
  /// If this method fails nothing will be written to *pIsPresent.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pIsPresent arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - property not present.
  ///
  /// @param descriptiveSchemeID [in, ref] Descriptive scheme ID
  /// @param pIsPresent [out,retval] Is this descriptive scheme ID present
  ///
  STDMETHOD(IsDescriptiveSchemePresent) (THIS_
    aafUID_constref  descriptiveSchemeID,
    aafBoolean_t*  pIsPresent) PURE;


  //***********************************************************
  //
  // AddDescriptiveScheme()
  //
  /// Appends the given descriptive scheme ID to the list of
  /// descriptive schemes found in the file.
  ///
  /// Succeeds if all of the following are true:
  /// - the given descriptive scheme ID is not already contained.
  ///
  /// If this method fails, the property will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given descriptive scheme ID is already contained.
  ///
  /// @param descriptiveSchemeID [in] New descriptive scheme ID.
  ///
  STDMETHOD(AddDescriptiveScheme) (THIS_
    aafUID_constref  descriptiveSchemeID) PURE;


  //***********************************************************
  //
  // RemoveDescriptiveScheme()
  //
  /// Removes the given descriptive scheme ID from
  /// the list of descriptive schemes found in the file.
  ///
  /// Succeeds if all of the following are true:
  /// - the DescriptiveSchemes property is present;
  /// - the given descriptive scheme ID is present in the list
  ///   of descriptive schemes found in the file.
  ///
  /// If this method fails, the property will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - property not present.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - The given descriptive scheme ID is present in the list
  ///     of descriptive schemes found in the file.
  ///
  /// @param descriptiveSchemeID [in] Descriptive scheme to remove.
  ///
  STDMETHOD(RemoveDescriptiveScheme) (THIS_
    aafUID_constref  descriptiveSchemeID) PURE;


  END_INTERFACE
};
#endif // __IAAFHeader2_INTERFACE_DEFINED__



// IAAFKLVEssenceDataParameters

// ************************
//
// Interface IAAFKLVEssenceDataParameters
//
// ************************



#ifndef __IAAFKLVEssenceDataParameters_INTERFACE_DEFINED__
#define __IAAFKLVEssenceDataParameters_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFKLVEssenceDataParameters;

#undef  INTERFACE
#define INTERFACE   IAAFKLVEssenceDataParameters

DECLARE_INTERFACE_(IAAFKLVEssenceDataParameters, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFKLVEssenceDataParameters methods *** */


  //***********************************************************
  //
  // GetEssenceElementKey()
  //
  /// This method returns essence element key associated
  /// with the essence stream.
  ///
  /// Succeeds if all of the following are true:
  /// - pEssenceElementKey is a valid pointer.
  /// - the essence stream supports essence element keys.
  ///
  /// If this method fails nothing will be written to *pEssenceElementKey.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEssenceElementKey arg is NULL.
  ///
  /// AAFRESULT_OPERATION_NOT_PERMITTED
  ///   - the essence stream does not support essence element keys.
  ///
  /// @param pEssenceElementKey [out] Essence element key.
  ///
  STDMETHOD(GetEssenceElementKey) (THIS_
    aafUID_t *  pEssenceElementKey) PURE;


  //***********************************************************
  //
  // SetEssenceElementKey()
  //
  /// Set the essence element key on the essence stream.
  /// 
  /// Succeeds if all of the following are true:
  /// - the essence stream supports essence element keys.
  /// 
  /// If this method fails, the property will not be changed.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_OPERATION_NOT_PERMITTED
  ///   - the essence stream does not support essence element keys.
  ///
  /// @param key [in, ref] essence element key
  ///
  STDMETHOD(SetEssenceElementKey) (THIS_
    aafUID_constref  key) PURE;


  END_INTERFACE
};
#endif // __IAAFKLVEssenceDataParameters_INTERFACE_DEFINED__



// IAAFKLVStreamParameters

// ************************
//
// Interface IAAFKLVStreamParameters
//
// ************************




#ifndef __IAAFKLVStreamParameters_INTERFACE_DEFINED__
#define __IAAFKLVStreamParameters_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFKLVStreamParameters;

#undef  INTERFACE
#define INTERFACE   IAAFKLVStreamParameters

DECLARE_INTERFACE_(IAAFKLVStreamParameters, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFKLVStreamParameters methods *** */


  //***********************************************************
  //
  // GetEssenceElementKey()
  //
  /// This method returns essence element key associated
  /// with the specified stream.
  ///
  /// Succeeds if all of the following are true:
  /// - pStreamPropertyValue is a valid pointer.
  /// - pEssenceElementKey is a valid pointer.
  /// - the specified stream supports essence element keys.
  ///
  /// If this method fails nothing will be written to *pEssenceElementKey.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pStreamPropertyValue or pEssenceElementKey arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - the specified stream does not support essence element keys.
  ///
  /// @param pStreamPropertyValue [in] stream property value
  /// @param pEssenceElementKey [out] Essence element key.
  ///
  STDMETHOD(GetEssenceElementKey) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    aafUID_t *  pEssenceElementKey) PURE;


  //***********************************************************
  //
  // SetEssenceElementKey()
  //
  /// Set the essence element key on the specified stream.
  /// 
  /// Succeeds if all of the following are true:
  /// - pStreamPropertyValue is a valid pointer.
  /// - the specified stream supports essence element keys.
  /// 
  /// If this method fails, the property will not be changed.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pStreamPropertyValue arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - the specified stream does not support essence element keys.
  ///
  /// @param pStreamPropertyValue [in] stream property value
  /// @param key [in, ref] essence element key
  ///
  STDMETHOD(SetEssenceElementKey) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    aafUID_constref  key) PURE;


  END_INTERFACE
};
#endif // __IAAFKLVStreamParameters_INTERFACE_DEFINED__



// IAAFMasterMob2

// ************************
//
// Interface IAAFMasterMob2
//
// ************************










#ifndef __IAAFMasterMob2_INTERFACE_DEFINED__
#define __IAAFMasterMob2_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFMasterMob2;

#undef  INTERFACE
#define INTERFACE   IAAFMasterMob2

DECLARE_INTERFACE_(IAAFMasterMob2, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFMasterMob2 methods *** */



  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty IAAFMasterMob-supporting
  /// object.  This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  STDMETHOD(Initialize) (THIS) PURE;


  //***********************************************************
  //
  // AddMasterSlot()
  //
  /// This function adds a slot to the specified Master Mob that
  /// references the specified a slot in the specified Source Mob. The
  /// new slot in the Master Mob contains a Source Clip that specifies
  /// the Source Mob in its source reference properties.  Typically this
  /// is done automatically by passing the Master Mob handle to
  /// AAFMedia::Create, but this function allows you to add it later.
  ///
  /// Note: If pSlotName is passed in with zero length, then the
  /// slot is not assigned a name.  Slot names are not used by the
  /// SDK, and exist only so the user can name slots.
  /// 
  /// Succeeds if all of the following are true:
  /// (more conditions here)
  /// 
  /// If this method fails no state is changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - One or more of the following parameters are NULL pSourceMob,
  ///     pSlotName, and pDataDef.
  ///
  /// AAFRESULT_INVALID_DATADEF
  ///   - The data kind of the source MOB slot to be added to the Master
  ///     Mob does not match what is specfied in pDataDef.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The specified Source Mob slot was not found.
  ///
  /// AAFRESULT_SLOT_EXISTS
  ///   - The specified Master slot ID already exists.
  ///
  /// @param pDataDef [in] Data kind of new slot.  Requires a data kind valid for a media
  /// stream. Valid data kinds are:
  /// - Picture
  /// - Sound
  /// @param sourceSlotID [in] Slot ID of the Source Mob slot to be added to the Master Mob
  /// @param pSourceMob [in] Source Mob containing the slot to be added to the Master Mob
  /// @param masterSlotID [in] SlotID assigned to the new Master Mob slot
  /// @param pSlotName [in, string] Name to assign to new slot in Master Mob
  ///
  STDMETHOD(AddMasterSlot) (THIS_
    IAAFDataDef * pDataDef,
    aafSlotID_t  sourceSlotID,
    IAAFSourceMob * pSourceMob,
    aafSlotID_t  masterSlotID,
    aafCharacter_constptr  pSlotName) PURE;


  //***********************************************************
  //
  // GetTapeName()
  //
  /// Finds the tape Source Mob associated with a Master Mob slot
  /// and writes the name of the tape, which is stored in the
  /// Mobs Name property, into the pTapeName buffer.  The buffer is
  /// allocated by the caller.  The size of the buffer is given by
  /// bufSize.  If the property name has not yet been set, a
  /// zero-length string will be written (that is, only the trailing
  /// null character).
  /// 
  /// Caller may call GetTapeNameBufLen() to determine the required
  /// buffer size.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pTapeName pointer is valid.
  /// - the specified master slot was found.
  /// - the specified master slot contains a tape mob.
  /// - bufSize indicates the buffer is large enough to hold the name.
  /// 
  /// If this method fails nothing will be written to *pTapeName.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTapeName arg is NULL.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The specified Master Slot was not found.
  ///
  /// AAFRESULT_NOT_TAPEMOB
  ///   - The specified Master Slot does not contain a Tape MOB.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - bufSize indicates the buffer is too small to hold the string.
  ///
  /// @param masterSlotID [in] SlotID of the Master Mob slot
  /// @param pTapeName [out, size_is(bufSize), string] The returned name
  /// @param bufSize [in] the size of the pTapeName buffer
  ///
  STDMETHOD(GetTapeName) (THIS_
    aafUInt32  masterSlotID,
    aafCharacter *  pTapeName,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetTapeNameBufLen()
  //
  /// Returns the length of buffer required for the GetTapeName()
  /// method.  The value is placed into the location specified by
  /// pLen.  The value will include space required for the trailing
  /// null character.
  ///
  /// Succeeds if all of the following are true:
  /// - the pLen pointer is valid.
  ///
  /// If this method fails nothing will be written to *pLen.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLen arg is NULL.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The specified Master Slot was not found.
  ///
  /// AAFRESULT_NOT_TAPEMOB
  ///   - The specified Master Slot does not contain a Tape MOB.
  ///
  /// @param masterSlotID [in] SlotID of the Master Mob slot
  /// @param pLen [out] required buffer length
  ///
  STDMETHOD(GetTapeNameBufLen) (THIS_
    aafUInt32  masterSlotID,
    aafUInt32 *  pLen) PURE;


  //***********************************************************
  //
  // GetNumRepresentations()
  //
  /// This function returns the number of media representations
  /// available for the specified SlotID on a specified Master
  /// Mob. This function is meant to work with
  /// GetRepresentationSourceClip, so that you can iterate through
  /// all of the choices yourself.  In most cases, you can use
  /// GetCriteriaSourceClip to handle multiple
  /// representations.  This function and
  /// GetRepresentationSourceClip are lower-level functions.
  ///
  /// Succeeds if all of the following are true:
  /// - the pNumReps pointer is valid.
  ///
  /// If this method fails nothing will be written to *pNumReps.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumReps arg is NULL.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The Master Slot specified by slotID was not found.
  ///
  /// @param slotID [in] SlotID
  /// @param pNumReps [out, retval] number of representations
  ///
  STDMETHOD(GetNumRepresentations) (THIS_
    aafSlotID_t  slotID,
    aafNumSlots_t *  pNumReps) PURE;


  //***********************************************************
  //
  // GetRepresentation()
  //
  /// This method returns the indexed media representation for the
  /// specified Master Mob, SlotID, and index.  This call is meant to
  /// work with GetNumRepresentations, so that you can iterate through
  /// all of the choices yourself.  This method uses an integer index,
  /// not an iterator.  The function GetRepresentationSourceClip takes
  /// an index between 1 and the number of representations
  /// [inclusive], and returns the indexed Source Mob. You can make
  /// calls to functions such as AAFMedia::GetVideoInfo and
  /// AAFMedia::IsMediaContiguous to determine which media is the best
  /// fit.
  ///
  /// The returned source clip is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppSourceClip pointer is valid.
  ///
  /// If this method fails nothing will be written to *ppSourceClip.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppSourceClip arg is NULL.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The specified Master Slot was not found.
  ///
  /// AAFRESULT_BADINDEX
  ///   - No Source Mob at specified index.
  ///
  /// @param slotID [in] Slot ID
  /// @param index [in] Index of requested representation
  /// @param ppSourceClip [out] Requested Source Clip
  ///
  STDMETHOD(GetRepresentation) (THIS_
    aafSlotID_t  slotID,
    aafUInt32  index,
    IAAFSegment ** ppSourceClip) PURE;


  //***********************************************************
  //
  // GetCriteriaSegment()
  //
  /// Returns the Segment on the specified slot of a Master Mob
  /// that references the Source Mob that best meets the specified
  /// criteria.  This function will work whether multiple media
  /// representations exist or not.
  ///
  /// The returned segment is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppSegment pointer is valid.
  ///
  /// If this method fails nothing will be written to *ppSegment.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppSegment arg is NULL.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The specified Master Slot was not found.
  ///
  /// @param slotID [in] Slot ID
  /// @param pCriteria [in] Index of requested representation.  Note: the
  /// aafMediaCriteria_t is defined as the following structure:
  /// typedef struct
  /// {
  ///	aafCriteriaType_t type;
  ///	aafCriteriaProc_t proc;
  /// } aafMediaCriteria_t;
  ///
  /// The type field can have one of the following values:
  /// typedef enum
  /// {
  ///	kAAFAnyRepresentation = 0,
  ///	kAAFFastestRepresentation,
  ///	kAAFBestFidelityRepresentation,
  ///	kAAFSmallestRepresentation,
  ///	kAAFUseRepresentationProc
  /// } aafCriteriaType_t;
  /// @param ppSegment [out] Requested Segment
  ///
  STDMETHOD(GetCriteriaSegment) (THIS_
    aafSlotID_t  slotID,
    aafMediaCriteria_t *  pCriteria,
    IAAFSegment ** ppSegment) PURE;


  //***********************************************************
  //
  // AppendPhysSourceRef()
  //
  /// Connects this Source Mob with the physical Source Mob that
  /// describes the previous generation of essence, appending it to
  /// existing Mob data.  If a physical Source Mob, such as a File
  /// Source Mob or tape Source Mob, references another physical
  /// Source Mob as its ancestor, with no pulldown, then this
  /// function makes the connection between the two.
  ///
  /// Functionally, this is a helper function to create a slot with an
  /// AAFSourceClip referencing a particular piece of media.  This
  /// function takes many parameters because the components of an
  /// aafSourceRef_t have been broken out as separate parameters.
  ///
  /// The ancestor of an AAFSourceMob with an AAFFileDescriptor is often an
  /// AAFTapeDescriptor or NIL.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSourceRefObj pointer is valid.
  /// - the pEssenceKind pointer is valid.
  /// (other conditions here)
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSourceRefObj or pEssenceKind is null.
  ///
  /// (other codes here.)
  ///
  /// @param editrate [in] Edit rate of slot to contain reference
  /// @param aMobSlot [in] SlotID of slot to contain reference
  /// @param pEssenceKind [in] Data kind of slot to contain reference.  Requires a data kind
  /// valid for a essence stream.  Valid data kinds are:
  /// - Picture
  /// - Sound
  /// @param ref [in] Reference to a Physical Source Mob
  /// @param srcRefLength [in] Length of the Source Clip
  ///
  STDMETHOD(AppendPhysSourceRef) (THIS_
    aafRational_t  editrate,
    aafSlotID_t  aMobSlot,
    IAAFDataDef * pEssenceKind,
    aafSourceRef_t  ref,
    aafLength_t  srcRefLength) PURE;


  //***********************************************************
  //
  // NewPhysSourceRef()
  //
  /// Connects this Source Mob with the physical Source Mob that
  /// describes the previous generation of essence, replacing any
  /// existing Mob data.  If a physical Source Mob, such as a File
  /// Source Mob or tape Source Mob, references another physical
  /// Source Mob as its ancestor, with no pulldown, then this
  /// function makes the connection between the two.
  ///
  /// Functionally, this is a helper function to create a slot with an
  /// AAFSourceClip referencing a particular piece of media.  This
  /// function takes many parameters because the components of an
  /// aafSourceRef_t have been broken out as separate parameters.
  ///
  /// The ancestor of an AAFSourceMob with an AAFFileDescriptor is often an
  /// AAFTapeDescriptor or NIL.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSourceRefObj pointer is valid.
  /// - the pEssenceKind pointer is valid.
  /// (other conditions here)
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSourceRefObj or pEssenceKind is null.
  ///
  /// (other codes here.)
  ///
  /// @param editrate [in] Edit rate of slot to contain reference
  /// @param aMobSlot [in] SlotID of slot to contain reference
  /// @param pEssenceKind [in] Data kind of slot to contain reference.  Requires a data kind
  /// valid for a essence stream.  Valid data kinds are:
  /// - Picture
  /// - Sound
  /// @param ref [in] Reference to a Physical Source Mob
  /// @param srcRefLength [in] Length of the Source Clip
  ///
  STDMETHOD(NewPhysSourceRef) (THIS_
    aafRational_t  editrate,
    aafSlotID_t  aMobSlot,
    IAAFDataDef * pEssenceKind,
    aafSourceRef_t  ref,
    aafLength_t  srcRefLength) PURE;


  //***********************************************************
  //
  // CreateEssence()
  //
  /// Creates a single channel stream of essence.  Convenience
  /// functions exist to create audio or video essence, and a separate
  /// call (MultiCreate) exists to create interleaved audio and video
  /// data.
  ///
  /// The essence handle from this call can be used with
  /// WriteDataSamples  and possibly WriteDataLines, but NOT with
  /// WriteMultiSamples.
  /// 
  /// If you are creating the essence, and then attaching it to a
  /// master mob, then the "masterMob" field may be left NULL.  For
  /// video, the sampleRate should be the edit rate of the file mob.
  /// For audio, the sample rate should be the actual samples per
  /// second.
  ///
  /// @param masterSlotID [in] 
  /// @param pMediaKind [in] create essence of this type
  /// @param codecID [in, ref] using this codec
  /// @param editRate [in] with this edit rate
  /// @param samplerate [in] with this sample rate
  /// @param Enable [in] optionally compressing it
  /// @param destination [in] Optionally create the file HERE.
  /// @param fileFormat objPass with this format
  /// @param access objOut Return an essence access on the essence.
  ///
  STDMETHOD(CreateEssence) (THIS_
    aafSlotID_t  masterSlotID,
    IAAFDataDef * pMediaKind,
    aafUID_constref  codecID,
    aafRational_t  editRate,
    aafRational_t  samplerate,
    aafCompressEnable_t  Enable,
    IAAFLocator * destination,
    aafUID_constref  fileFormat,
    IAAFEssenceAccess ** access) PURE;


  //***********************************************************
  //
  // CreateMultiEssence()
  //
  /// Creates a multi-channel interleaved stream of essence.  The
  /// essence handle from this call can be used with WriteDataSamples
  /// or WriteMultiSamples but NOT with or WriteDataLines.
  /// 
  /// If you are creating the essence, and then attaching it to a
  /// master mob, then the "masterMob" field may be left NULL.
  ///
  /// @param codecID [in, ref] using this codec
  /// @param arrayElemCount [in] this many channels
  /// @param mediaArray [in,ref,size_is(arrayElemCount)] using these definitions
  /// @param Enable [in] optionally compressing it
  /// @param destination [in] Optionally create the file HERE.
  /// @param fileFormat [in, ref] with this format
  /// @param access [out] Return an essence access on the essence.
  ///
  STDMETHOD(CreateMultiEssence) (THIS_
    aafUID_constref  codecID,
    aafUInt16  arrayElemCount,
    aafmMultiCreate_t *  mediaArray,
    aafCompressEnable_t  Enable,
    IAAFLocator * destination,
    aafUID_constref  fileFormat,
    IAAFEssenceMultiAccess**  access) PURE;


  //***********************************************************
  //
  // OpenEssence()
  //
  /// Opens a single channel of a file mob.  If the essence is
  /// interleaved, then it will be di-interleaved when samples are
  /// read.  This routine follows the locator, and may call the locator
  /// failure callback if the essence can not be found.  If the failure
  /// callback finds the essence, then this routine will return
  /// normally.
  /// 
  /// The essence handle from this call can be used with
  /// ReadDataSamples  and possibly ReadDataLines, but NOT with
  /// ReadMultiSamples.
  /// 
  /// NOTE: If a locator is followed, then essencePtr may reference
  /// ANOTHER file object, which must be closed on file close.
  ///
  /// @param slotID [in] On this slot
  /// @param mediaCrit [in] using this essence criteria
  /// @param openMode [in] ReadOnly or Append
  /// @param compEnable [in] optionally decompressing
  /// @param access [out] Return an essence access on the essence.
  ///
  STDMETHOD(OpenEssence) (THIS_
    aafSlotID_t  slotID,
    aafMediaCriteria_t*  mediaCrit,
    aafMediaOpenMode_t  openMode,
    aafCompressEnable_t  compEnable,
    IAAFEssenceAccess ** access) PURE;
	

  //***********************************************************
  //
  // OpenMultiEssence()
  //
  /// Opens a all channels associated with a file mob.  This routine
  /// follows the locator, and may call the locator failure callback if
  /// the essence can not be found.  If the failure callback finds the
  /// essence, then this routine will return normally.
  ///
  /// The essence handle from this call can be used with
  /// WriteMultiSamples but NOT with WriteDataSamples.
  ///
  /// @param slotID [in] On this slot
  /// @param mediaCrit [in] using this essence criteria
  /// @param openMode [in] ReadOnly or Append
  /// @param compEnable [in] optionally decompressing
  /// @param access [out] Return an essence access on the essence.
  ///
  STDMETHOD(OpenMultiEssence) (THIS_
    aafSlotID_t  slotID,
    aafMediaCriteria_t*  mediaCrit,
    aafMediaOpenMode_t  openMode,
    aafCompressEnable_t  compEnable,
    IAAFEssenceMultiAccess**  access) PURE;


  //***********************************************************
  //
  // CountChannels()
  //
  /// Takes an opaque handle, a master mob reference, and a slot ID
  /// so that it may be called before the essence is opened.
  ///
  /// Returns the number of interleaved essence channels of a given
  /// type in the essence stream referenced by the given file mob.
  ///
  /// If the data format is not interleaved, then the answer will
  /// always be zero or one.  This function correctly returns zero for
  /// essence types not handled by a given codec, and handles codecs
  /// which work with multiple essence types.
  ///
  /// @param slotID [in] On this slot
  /// @param mediaCrit [in] using this essence criteria
  /// @param pMediaKind [in] for this essence type
  /// @param numCh [out] How many channels?
  ///
  STDMETHOD(CountChannels) (THIS_
    aafSlotID_t  slotID,
    aafMediaCriteria_t*  mediaCrit,
    IAAFDataDef * pMediaKind,
    aafUInt16*  numCh) PURE;




  //***********************************************************
  //
  // ExtendEssence()
  //
  /// Extends a single stream of essence that was originally created using
  /// IAAFMasterMob::CreateEssence.  Extended essence is represented by
  /// a Sequence of SourceClip objects.  The first call to ExtendEssence will cause the
  /// TimelineMobSlot's SourceClip object to be replaced by a
  /// Sequence.  The initial SourceClip becomes the first
  /// component of the new Sequence.
  ///
  /// @param masterSlotID [in] 
  /// @param pMediaKind [in] create essence of this type
  /// @param codecID [in, ref] using this codec
  /// @param editRate [in] with this edit rate
  /// @param samplerate [in] with this sample rate
  /// @param Enable [in] optionally compressing it
  /// @param destination [in] Optionally create the file HERE.
  /// @param fileFormat objPass with this format
  /// @param access objOut Return an essence access on the essence.
  ///
  STDMETHOD(ExtendEssence) (THIS_
    aafSlotID_t  masterSlotID,
    IAAFDataDef * pMediaKind,
    aafUID_constref  codecID,
    aafRational_t  editRate,
    aafRational_t  samplerate,
    aafCompressEnable_t  Enable,
    IAAFLocator * destination,
    aafUID_constref  fileFormat,
    IAAFEssenceAccess ** access) PURE;


  //***********************************************************
  //
  // ExtendMultiEssence()
  //
  /// Extends a multi-channel interleaved stream of essence that was
  /// originally created using IAAFMasterMob::CreateMultiEssence.
  /// Extended essence is represented by a Sequence of SourceClip objects.
  /// The first call to ExtendEssence will cause the TimelineMobSlot's SourceClip
  /// object to be replaced by a Sequence.  The initial SourceClip becomes the first
  /// component of the new Sequence.
  ///
  /// @param codecID [in, ref] using this codec
  /// @param arrayElemCount [in] this many channels
  /// @param mediaArray [in,ref,size_is(arrayElemCount)] using these definitions
  /// @param Enable [in] optionally compressing it
  /// @param destination [in] Optionally create the file HERE.
  /// @param fileFormat [in, ref] with this format
  /// @param access [out] Return an essence access on the essence.
  ///
  STDMETHOD(ExtendMultiEssence) (THIS_
    aafUID_constref  codecID,
    aafUInt16  arrayElemCount,
    aafmMultiCreate_t *  mediaArray,
    aafCompressEnable_t  Enable,
    IAAFLocator * destination,
    aafUID_constref  fileFormat,
    IAAFEssenceMultiAccess**  access) PURE;


  //***********************************************************
  //
  // CreateStaticEssence()
  //
  /// Creates and initializes the objects required to represent static essence.
  ///
  /// @param masterSlotID [in] 
  /// @param pMediaKind [in] create essence of this type
  /// @param codecID [in, ref] using this codec
  /// @param Enable [in] optionally compressing it
  /// @param destination [in] Optionally create the file HERE.
  /// @param fileFormat [in, ref] with this format
  /// @param access [out] Return an essence access on the essence.
  ///
  STDMETHOD(CreateStaticEssence) (THIS_
    aafSlotID_t  masterSlotID,
    IAAFDataDef * pMediaKind,
    aafUID_constref  codecID,
    aafCompressEnable_t  Enable,
    IAAFLocator * destination,
    aafUID_constref  fileFormat,
    IAAFEssenceAccess ** access) PURE;
  /// This function is broadly similar to CreateEssence except that the essence is 
  /// Created in a static slot in the MasterMob
  ///
  /// The essence handle from this call can be used with
  /// WriteDataSamples  and possibly WriteDataLines\, but NOT with
  /// WriteMultiSamples.
  /// 


  //***********************************************************
  //
  // CreateEventEssence()
  //
  /// Creates and initializes the objects required to represent stream of events.
  ///
  /// @param masterSlotID [in] 
  /// @param pMediaKind [in] create essence of this type
  /// @param codecID [in, ref] using this codec
  /// @param editRate [in] with this edit rate
  /// @param samplerate [in] with this sample rate
  /// @param Enable [in] optionally compressing it
  /// @param destination [in] Optionally create the file HERE.
  /// @param fileFormat objPass with this format
  /// @param access objOut Return an essence access on the essence.
  ///
  STDMETHOD(CreateEventEssence) (THIS_
    aafSlotID_t  masterSlotID,
    IAAFDataDef * pMediaKind,
    aafUID_constref  codecID,
    aafRational_t  editRate,
    aafRational_t  samplerate,
    aafCompressEnable_t  Enable,
    IAAFLocator * destination,
    aafUID_constref  fileFormat,
    IAAFEssenceAccess ** access) PURE;
  /// This function is broadly similar to CreateEssence except that the essence is 
  /// Created in a event slot in the MasterMob
  ///
  /// 
  /// The essence handle from this call can be used with
  /// WriteDataSamples  and possibly WriteDataLines\, but NOT with
  /// WriteMultiSamples.
  /// 


  END_INTERFACE
};
#endif // __IAAFMasterMob2_INTERFACE_DEFINED__




// IAAFMasterMob3

// ************************
//
// Interface IAAFMasterMob3
//
// ************************










#ifndef __IAAFMasterMob3_INTERFACE_DEFINED__
#define __IAAFMasterMob3_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFMasterMob3;

#undef  INTERFACE
#define INTERFACE   IAAFMasterMob3

DECLARE_INTERFACE_(IAAFMasterMob3, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFMasterMob3 methods *** */



  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty IAAFMasterMob-supporting
  /// object.  This method must be called after allocation, and before
  /// any other method can be called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  STDMETHOD(Initialize) (THIS) PURE;


  //***********************************************************
  //
  // AddMasterSlot()
  //
  /// This function adds a slot to the specified Master Mob that
  /// references the specified a slot in the specified Source Mob. The
  /// new slot in the Master Mob contains a Source Clip that specifies
  /// the Source Mob in its source reference properties.  Typically this
  /// is done automatically by passing the Master Mob handle to
  /// AAFMedia::Create, but this function allows you to add it later.
  ///
  /// Note: If pSlotName is passed in with zero length, then the
  /// slot is not assigned a name.  Slot names are not used by the
  /// SDK, and exist only so the user can name slots.
  /// 
  /// Succeeds if all of the following are true:
  /// (more conditions here)
  /// 
  /// If this method fails no state is changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - One or more of the following parameters are NULL pSourceMob,
  ///     pSlotName, and pDataDef.
  ///
  /// AAFRESULT_INVALID_DATADEF
  ///   - The data kind of the source MOB slot to be added to the Master
  ///     Mob does not match what is specfied in pDataDef.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The specified Source Mob slot was not found.
  ///
  /// AAFRESULT_SLOT_EXISTS
  ///   - The specified Master slot ID already exists.
  ///
  /// @param pDataDef [in] Data kind of new slot.  Requires a data kind valid for a media
  /// stream. Valid data kinds are:
  /// - Picture
  /// - Sound
  /// @param sourceSlotID [in] Slot ID of the Source Mob slot to be added to the Master Mob
  /// @param pSourceMob [in] Source Mob containing the slot to be added to the Master Mob
  /// @param masterSlotID [in] SlotID assigned to the new Master Mob slot
  /// @param pSlotName [in, string] Name to assign to new slot in Master Mob
  ///
  STDMETHOD(AddMasterSlot) (THIS_
    IAAFDataDef * pDataDef,
    aafSlotID_t  sourceSlotID,
    IAAFSourceMob * pSourceMob,
    aafSlotID_t  masterSlotID,
    aafCharacter_constptr  pSlotName) PURE;


  //***********************************************************
  //
  // GetTapeName()
  //
  /// Finds the tape Source Mob associated with a Master Mob slot
  /// and writes the name of the tape, which is stored in the
  /// Mobs Name property, into the pTapeName buffer.  The buffer is
  /// allocated by the caller.  The size of the buffer is given by
  /// bufSize.  If the property name has not yet been set, a
  /// zero-length string will be written (that is, only the trailing
  /// null character).
  /// 
  /// Caller may call GetTapeNameBufLen() to determine the required
  /// buffer size.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pTapeName pointer is valid.
  /// - the specified master slot was found.
  /// - the specified master slot contains a tape mob.
  /// - bufSize indicates the buffer is large enough to hold the name.
  /// 
  /// If this method fails nothing will be written to *pTapeName.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pTapeName arg is NULL.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The specified Master Slot was not found.
  ///
  /// AAFRESULT_NOT_TAPEMOB
  ///   - The specified Master Slot does not contain a Tape MOB.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - bufSize indicates the buffer is too small to hold the string.
  ///
  /// @param masterSlotID [in] SlotID of the Master Mob slot
  /// @param pTapeName [out, size_is(bufSize), string] The returned name
  /// @param bufSize [in] the size of the pTapeName buffer
  ///
  STDMETHOD(GetTapeName) (THIS_
    aafUInt32  masterSlotID,
    aafCharacter *  pTapeName,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetTapeNameBufLen()
  //
  /// Returns the length of buffer required for the GetTapeName()
  /// method.  The value is placed into the location specified by
  /// pLen.  The value will include space required for the trailing
  /// null character.
  ///
  /// Succeeds if all of the following are true:
  /// - the pLen pointer is valid.
  ///
  /// If this method fails nothing will be written to *pLen.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLen arg is NULL.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The specified Master Slot was not found.
  ///
  /// AAFRESULT_NOT_TAPEMOB
  ///   - The specified Master Slot does not contain a Tape MOB.
  ///
  /// @param masterSlotID [in] SlotID of the Master Mob slot
  /// @param pLen [out] required buffer length
  ///
  STDMETHOD(GetTapeNameBufLen) (THIS_
    aafUInt32  masterSlotID,
    aafUInt32 *  pLen) PURE;


  //***********************************************************
  //
  // GetNumRepresentations()
  //
  /// This function returns the number of media representations
  /// available for the specified SlotID on a specified Master
  /// Mob. This function is meant to work with
  /// GetRepresentationSourceClip, so that you can iterate through
  /// all of the choices yourself.  In most cases, you can use
  /// GetCriteriaSourceClip to handle multiple
  /// representations.  This function and
  /// GetRepresentationSourceClip are lower-level functions.
  ///
  /// Succeeds if all of the following are true:
  /// - the pNumReps pointer is valid.
  ///
  /// If this method fails nothing will be written to *pNumReps.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumReps arg is NULL.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The Master Slot specified by slotID was not found.
  ///
  /// @param slotID [in] SlotID
  /// @param pNumReps [out, retval] number of representations
  ///
  STDMETHOD(GetNumRepresentations) (THIS_
    aafSlotID_t  slotID,
    aafNumSlots_t *  pNumReps) PURE;


  //***********************************************************
  //
  // GetRepresentation()
  //
  /// This method returns the indexed media representation for the
  /// specified Master Mob, SlotID, and index.  This call is meant to
  /// work with GetNumRepresentations, so that you can iterate through
  /// all of the choices yourself.  This method uses an integer index,
  /// not an iterator.  The function GetRepresentationSourceClip takes
  /// an index between 1 and the number of representations
  /// [inclusive], and returns the indexed Source Mob. You can make
  /// calls to functions such as AAFMedia::GetVideoInfo and
  /// AAFMedia::IsMediaContiguous to determine which media is the best
  /// fit.
  ///
  /// The returned source clip is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppSourceClip pointer is valid.
  ///
  /// If this method fails nothing will be written to *ppSourceClip.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppSourceClip arg is NULL.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The specified Master Slot was not found.
  ///
  /// AAFRESULT_BADINDEX
  ///   - No Source Mob at specified index.
  ///
  /// @param slotID [in] Slot ID
  /// @param index [in] Index of requested representation
  /// @param ppSourceClip [out] Requested Source Clip
  ///
  STDMETHOD(GetRepresentation) (THIS_
    aafSlotID_t  slotID,
    aafUInt32  index,
    IAAFSegment ** ppSourceClip) PURE;


  //***********************************************************
  //
  // GetCriteriaSegment()
  //
  /// Returns the Segment on the specified slot of a Master Mob
  /// that references the Source Mob that best meets the specified
  /// criteria.  This function will work whether multiple media
  /// representations exist or not.
  ///
  /// The returned segment is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppSegment pointer is valid.
  ///
  /// If this method fails nothing will be written to *ppSegment.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppSegment arg is NULL.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The specified Master Slot was not found.
  ///
  /// @param slotID [in] Slot ID
  /// @param pCriteria [in] Index of requested representation.  Note: the
  /// aafMediaCriteria_t is defined as the following structure:
  /// typedef struct
  /// {
  ///	aafCriteriaType_t type;
  ///	aafCriteriaProc_t proc;
  /// } aafMediaCriteria_t;
  ///
  /// The type field can have one of the following values:
  /// typedef enum
  /// {
  ///	kAAFAnyRepresentation = 0,
  ///	kAAFFastestRepresentation,
  ///	kAAFBestFidelityRepresentation,
  ///	kAAFSmallestRepresentation,
  ///	kAAFUseRepresentationProc
  /// } aafCriteriaType_t;
  /// @param ppSegment [out] Requested Segment
  ///
  STDMETHOD(GetCriteriaSegment) (THIS_
    aafSlotID_t  slotID,
    aafMediaCriteria_t *  pCriteria,
    IAAFSegment ** ppSegment) PURE;


  //***********************************************************
  //
  // AppendPhysSourceRef()
  //
  /// Connects this Source Mob with the physical Source Mob that
  /// describes the previous generation of essence, appending it to
  /// existing Mob data.  If a physical Source Mob, such as a File
  /// Source Mob or tape Source Mob, references another physical
  /// Source Mob as its ancestor, with no pulldown, then this
  /// function makes the connection between the two.
  ///
  /// Functionally, this is a helper function to create a slot with an
  /// AAFSourceClip referencing a particular piece of media.  This
  /// function takes many parameters because the components of an
  /// aafSourceRef_t have been broken out as separate parameters.
  ///
  /// The ancestor of an AAFSourceMob with an AAFFileDescriptor is often an
  /// AAFTapeDescriptor or NIL.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSourceRefObj pointer is valid.
  /// - the pEssenceKind pointer is valid.
  /// (other conditions here)
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSourceRefObj or pEssenceKind is null.
  ///
  /// (other codes here.)
  ///
  /// @param editrate [in] Edit rate of slot to contain reference
  /// @param aMobSlot [in] SlotID of slot to contain reference
  /// @param pEssenceKind [in] Data kind of slot to contain reference.  Requires a data kind
  /// valid for a essence stream.  Valid data kinds are:
  /// - Picture
  /// - Sound
  /// @param ref [in] Reference to a Physical Source Mob
  /// @param srcRefLength [in] Length of the Source Clip
  ///
  STDMETHOD(AppendPhysSourceRef) (THIS_
    aafRational_t  editrate,
    aafSlotID_t  aMobSlot,
    IAAFDataDef * pEssenceKind,
    aafSourceRef_t  ref,
    aafLength_t  srcRefLength) PURE;


  //***********************************************************
  //
  // NewPhysSourceRef()
  //
  /// Connects this Source Mob with the physical Source Mob that
  /// describes the previous generation of essence, replacing any
  /// existing Mob data.  If a physical Source Mob, such as a File
  /// Source Mob or tape Source Mob, references another physical
  /// Source Mob as its ancestor, with no pulldown, then this
  /// function makes the connection between the two.
  ///
  /// Functionally, this is a helper function to create a slot with an
  /// AAFSourceClip referencing a particular piece of media.  This
  /// function takes many parameters because the components of an
  /// aafSourceRef_t have been broken out as separate parameters.
  ///
  /// The ancestor of an AAFSourceMob with an AAFFileDescriptor is often an
  /// AAFTapeDescriptor or NIL.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSourceRefObj pointer is valid.
  /// - the pEssenceKind pointer is valid.
  /// (other conditions here)
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSourceRefObj or pEssenceKind is null.
  ///
  /// (other codes here.)
  ///
  /// @param editrate [in] Edit rate of slot to contain reference
  /// @param aMobSlot [in] SlotID of slot to contain reference
  /// @param pEssenceKind [in] Data kind of slot to contain reference.  Requires a data kind
  /// valid for a essence stream.  Valid data kinds are:
  /// - Picture
  /// - Sound
  /// @param ref [in] Reference to a Physical Source Mob
  /// @param srcRefLength [in] Length of the Source Clip
  ///
  STDMETHOD(NewPhysSourceRef) (THIS_
    aafRational_t  editrate,
    aafSlotID_t  aMobSlot,
    IAAFDataDef * pEssenceKind,
    aafSourceRef_t  ref,
    aafLength_t  srcRefLength) PURE;


  //***********************************************************
  //
  // CreateEssence()
  //
  /// Creates a single channel stream of essence.  Convenience
  /// functions exist to create audio or video essence, and a separate
  /// call (MultiCreate) exists to create interleaved audio and video
  /// data.
  ///
  /// The essence handle from this call can be used with
  /// WriteDataSamples  and possibly WriteDataLines, but NOT with
  /// WriteMultiSamples.
  /// 
  /// If you are creating the essence, and then attaching it to a
  /// master mob, then the "masterMob" field may be left NULL.  For
  /// video, the sampleRate should be the edit rate of the file mob.
  /// For audio, the sample rate should be the actual samples per
  /// second.
  ///
  /// @param masterSlotID [in] 
  /// @param pMediaKind [in] create essence of this type
  /// @param codecID [in, ref] using this codec
  /// @param editRate [in] with this edit rate
  /// @param samplerate [in] with this sample rate
  /// @param Enable [in] optionally compressing it
  /// @param destination [in] Optionally create the file HERE.
  /// @param fileFormat objPass with this format
  /// @param access objOut Return an essence access on the essence.
  ///
  STDMETHOD(CreateEssence) (THIS_
    aafSlotID_t  masterSlotID,
    IAAFDataDef * pMediaKind,
    aafUID_constref  codecID,
    aafRational_t  editRate,
    aafRational_t  samplerate,
    aafCompressEnable_t  Enable,
    IAAFLocator * destination,
    aafUID_constref  fileFormat,
    IAAFEssenceAccess ** access) PURE;


  //***********************************************************
  //
  // CreateMultiEssence()
  //
  /// Creates a multi-channel interleaved stream of essence.  The
  /// essence handle from this call can be used with WriteDataSamples
  /// or WriteMultiSamples but NOT with or WriteDataLines.
  /// 
  /// If you are creating the essence, and then attaching it to a
  /// master mob, then the "masterMob" field may be left NULL.
  ///
  /// @param codecID [in, ref] using this codec
  /// @param arrayElemCount [in] this many channels
  /// @param mediaArray [in,ref,size_is(arrayElemCount)] using these definitions
  /// @param Enable [in] optionally compressing it
  /// @param destination [in] Optionally create the file HERE.
  /// @param fileFormat [in, ref] with this format
  /// @param access [out] Return an essence access on the essence.
  ///
  STDMETHOD(CreateMultiEssence) (THIS_
    aafUID_constref  codecID,
    aafUInt16  arrayElemCount,
    aafmMultiCreate_t *  mediaArray,
    aafCompressEnable_t  Enable,
    IAAFLocator * destination,
    aafUID_constref  fileFormat,
    IAAFEssenceMultiAccess**  access) PURE;


  //***********************************************************
  //
  // OpenEssence()
  //
  /// Opens a single channel of a file mob.  If the essence is
  /// interleaved, then it will be di-interleaved when samples are
  /// read.  This routine follows the locator, and may call the locator
  /// failure callback if the essence can not be found.  If the failure
  /// callback finds the essence, then this routine will return
  /// normally.
  /// 
  /// The essence handle from this call can be used with
  /// ReadDataSamples  and possibly ReadDataLines, but NOT with
  /// ReadMultiSamples.
  /// 
  /// NOTE: If a locator is followed, then essencePtr may reference
  /// ANOTHER file object, which must be closed on file close.
  ///
  /// @param slotID [in] On this slot
  /// @param mediaCrit [in] using this essence criteria
  /// @param openMode [in] ReadOnly or Append
  /// @param compEnable [in] optionally decompressing
  /// @param access [out] Return an essence access on the essence.
  ///
  STDMETHOD(OpenEssence) (THIS_
    aafSlotID_t  slotID,
    aafMediaCriteria_t*  mediaCrit,
    aafMediaOpenMode_t  openMode,
    aafCompressEnable_t  compEnable,
    IAAFEssenceAccess ** access) PURE;
	

  //***********************************************************
  //
  // OpenMultiEssence()
  //
  /// Opens a all channels associated with a file mob.  This routine
  /// follows the locator, and may call the locator failure callback if
  /// the essence can not be found.  If the failure callback finds the
  /// essence, then this routine will return normally.
  ///
  /// The essence handle from this call can be used with
  /// WriteMultiSamples but NOT with WriteDataSamples.
  ///
  /// @param slotID [in] On this slot
  /// @param mediaCrit [in] using this essence criteria
  /// @param openMode [in] ReadOnly or Append
  /// @param compEnable [in] optionally decompressing
  /// @param access [out] Return an essence access on the essence.
  ///
  STDMETHOD(OpenMultiEssence) (THIS_
    aafSlotID_t  slotID,
    aafMediaCriteria_t*  mediaCrit,
    aafMediaOpenMode_t  openMode,
    aafCompressEnable_t  compEnable,
    IAAFEssenceMultiAccess**  access) PURE;


  //***********************************************************
  //
  // CountChannels()
  //
  /// Takes an opaque handle, a master mob reference, and a slot ID
  /// so that it may be called before the essence is opened.
  ///
  /// Returns the number of interleaved essence channels of a given
  /// type in the essence stream referenced by the given file mob.
  ///
  /// If the data format is not interleaved, then the answer will
  /// always be zero or one.  This function correctly returns zero for
  /// essence types not handled by a given codec, and handles codecs
  /// which work with multiple essence types.
  ///
  /// @param slotID [in] On this slot
  /// @param mediaCrit [in] using this essence criteria
  /// @param pMediaKind [in] for this essence type
  /// @param numCh [out] How many channels?
  ///
  STDMETHOD(CountChannels) (THIS_
    aafSlotID_t  slotID,
    aafMediaCriteria_t*  mediaCrit,
    IAAFDataDef * pMediaKind,
    aafUInt16*  numCh) PURE;




  //***********************************************************
  //
  // ExtendEssence()
  //
  /// Extends a single stream of essence that was originally created using
  /// IAAFMasterMob::CreateEssence.  Extended essence is represented by
  /// a Sequence of SourceClip objects.  The first call to ExtendEssence will cause the
  /// TimelineMobSlot's SourceClip object to be replaced by a
  /// Sequence.  The initial SourceClip becomes the first
  /// component of the new Sequence.
  ///
  /// @param masterSlotID [in] 
  /// @param pMediaKind [in] create essence of this type
  /// @param codecID [in, ref] using this codec
  /// @param editRate [in] with this edit rate
  /// @param samplerate [in] with this sample rate
  /// @param Enable [in] optionally compressing it
  /// @param destination [in] Optionally create the file HERE.
  /// @param fileFormat objPass with this format
  /// @param access objOut Return an essence access on the essence.
  ///
  STDMETHOD(ExtendEssence) (THIS_
    aafSlotID_t  masterSlotID,
    IAAFDataDef * pMediaKind,
    aafUID_constref  codecID,
    aafRational_t  editRate,
    aafRational_t  samplerate,
    aafCompressEnable_t  Enable,
    IAAFLocator * destination,
    aafUID_constref  fileFormat,
    IAAFEssenceAccess ** access) PURE;


  //***********************************************************
  //
  // ExtendMultiEssence()
  //
  /// Extends a multi-channel interleaved stream of essence that was
  /// originally created using IAAFMasterMob::CreateMultiEssence.
  /// Extended essence is represented by a Sequence of SourceClip objects.
  /// The first call to ExtendEssence will cause the TimelineMobSlot's SourceClip
  /// object to be replaced by a Sequence.  The initial SourceClip becomes the first
  /// component of the new Sequence.
  ///
  /// @param codecID [in, ref] using this codec
  /// @param arrayElemCount [in] this many channels
  /// @param mediaArray [in,ref,size_is(arrayElemCount)] using these definitions
  /// @param Enable [in] optionally compressing it
  /// @param destination [in] Optionally create the file HERE.
  /// @param fileFormat [in, ref] with this format
  /// @param access [out] Return an essence access on the essence.
  ///
  STDMETHOD(ExtendMultiEssence) (THIS_
    aafUID_constref  codecID,
    aafUInt16  arrayElemCount,
    aafmMultiCreate_t *  mediaArray,
    aafCompressEnable_t  Enable,
    IAAFLocator * destination,
    aafUID_constref  fileFormat,
    IAAFEssenceMultiAccess**  access) PURE;


  //***********************************************************
  //
  // CreateStaticEssence()
  //
  /// Creates and initializes the objects required to represent static essence.
  ///
  /// @param masterSlotID [in] 
  /// @param pMediaKind [in] create essence of this type
  /// @param codecID [in, ref] using this codec
  /// @param Enable [in] optionally compressing it
  /// @param destination [in] Optionally create the file HERE.
  /// @param fileFormat [in, ref] with this format
  /// @param access [out] Return an essence access on the essence.
  ///
  STDMETHOD(CreateStaticEssence) (THIS_
    aafSlotID_t  masterSlotID,
    IAAFDataDef * pMediaKind,
    aafUID_constref  codecID,
    aafCompressEnable_t  Enable,
    IAAFLocator * destination,
    aafUID_constref  fileFormat,
    IAAFEssenceAccess ** access) PURE;
  /// This function is broadly similar to CreateEssence except that the essence is 
  /// Created in a static slot in the MasterMob
  ///
  /// The essence handle from this call can be used with
  /// WriteDataSamples  and possibly WriteDataLines\, but NOT with
  /// WriteMultiSamples.
  /// 


  //***********************************************************
  //
  // CreateEventEssence()
  //
  /// Creates and initializes the objects required to represent stream of events.
  ///
  /// @param masterSlotID [in] 
  /// @param pMediaKind [in] create essence of this type
  /// @param codecID [in, ref] using this codec
  /// @param editRate [in] with this edit rate
  /// @param samplerate [in] with this sample rate
  /// @param Enable [in] optionally compressing it
  /// @param destination [in] Optionally create the file HERE.
  /// @param fileFormat objPass with this format
  /// @param access objOut Return an essence access on the essence.
  ///
  STDMETHOD(CreateEventEssence) (THIS_
    aafSlotID_t  masterSlotID,
    IAAFDataDef * pMediaKind,
    aafUID_constref  codecID,
    aafRational_t  editRate,
    aafRational_t  samplerate,
    aafCompressEnable_t  Enable,
    IAAFLocator * destination,
    aafUID_constref  fileFormat,
    IAAFEssenceAccess ** access) PURE;
  /// This function is broadly similar to CreateEssence except that the essence is 
  /// Created in a event slot in the MasterMob
  ///
  /// 
  /// The essence handle from this call can be used with
  /// WriteDataSamples  and possibly WriteDataLines\, but NOT with
  /// WriteMultiSamples.
  /// 


  //***********************************************************
  //
  // AddMasterSlotWithSequence()
  //
  /// This function is similar to AddMasterSlot but creates the structure
  /// MobSlot - Sequence - SourceClip instead of MobSlot - SourceClip.
  /// This arrangement is required for MXF compliance.
  ///
  /// This function adds a slot to the specified Master Mob that
  /// references the specified a slot in the specified Source Mob. The
  /// new slot in the Master Mob has a Sequence containing the Source Clip
  /// that specifies the Source Mob in its source reference properties.
  ///
  /// Note: If pSlotName is passed in with zero length, then the
  /// slot is not assigned a name.  Slot names are not used by the
  /// SDK, and exist only so the user can name slots.
  /// 
  /// Succeeds if all of the following are true:
  /// (more conditions here)
  /// 
  /// If this method fails no state is changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - One or more of the following parameters are NULL pSourceMob,
  ///     pSlotName, and pDataDef.
  ///
  /// AAFRESULT_INVALID_DATADEF
  ///   - The data kind of the source MOB slot to be added to the Master
  ///     Mob does not match what is specfied in pDataDef.
  ///
  /// AAFRESULT_SLOT_NOTFOUND
  ///   - The specified Source Mob slot was not found.
  ///
  /// AAFRESULT_SLOT_EXISTS
  ///   - The specified Master slot ID already exists.
  ///
  /// @param pDataDef [in] Data kind of new slot.  Requires a data kind valid for a media
  /// stream. Valid data kinds are:
  /// - Picture
  /// - Sound
  /// @param sourceSlotID [in] Slot ID of the Source Mob slot to be added to the Master Mob
  /// @param pSourceMob [in] Source Mob containing the slot to be added to the Master Mob
  /// @param masterSlotID [in] SlotID assigned to the new Master Mob slot
  /// @param pSlotName [in, string] Name to assign to new slot in Master Mob
  ///
  STDMETHOD(AddMasterSlotWithSequence) (THIS_
    IAAFDataDef * pDataDef,
    aafSlotID_t  sourceSlotID,
    IAAFSourceMob * pSourceMob,
    aafSlotID_t  masterSlotID,
    aafCharacter_constptr  pSlotName) PURE;


  END_INTERFACE
};
#endif // __IAAFMasterMob3_INTERFACE_DEFINED__




// IAAFMasterMobEx

// ************************
//
// Interface IAAFMasterMobEx
//
// ************************







#ifndef __IAAFMasterMobEx_INTERFACE_DEFINED__
#define __IAAFMasterMobEx_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFMasterMobEx;

#undef  INTERFACE
#define INTERFACE   IAAFMasterMobEx

DECLARE_INTERFACE_(IAAFMasterMobEx, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFMasterMobEx methods *** */


  //***********************************************************
  //
  // ExtendEssence()
  //
  /// Extends a single stream of essence that was originally created using
  /// IAAFMasterMob::CreateEssence.  Extended essence is represented by
  /// a Sequence of SourceClip objects.  The first call to ExtendEssence will cause the
  /// TimelineMobSlot's SourceClip object to be replaced by a
  /// Sequence.  The initial SourceClip becomes the first
  /// component of the new Sequence.
  ///
  /// @param masterSlotID [in] 
  /// @param pMediaKind [in] create essence of this type
  /// @param codecID [in, ref] using this codec
  /// @param editRate [in] with this edit rate
  /// @param samplerate [in] with this sample rate
  /// @param Enable [in] optionally compressing it
  /// @param destination [in] Optionally create the file HERE.
  /// @param fileFormat objPass with this format
  /// @param access objOut Return an essence access on the essence.
  ///
  STDMETHOD(ExtendEssence) (THIS_
    aafSlotID_t  masterSlotID,
    IAAFDataDef * pMediaKind,
    aafUID_constref  codecID,
    aafRational_t  editRate,
    aafRational_t  samplerate,
    aafCompressEnable_t  Enable,
    IAAFLocator * destination,
    aafUID_constref  fileFormat,
    IAAFEssenceAccess ** access) PURE;


  //***********************************************************
  //
  // ExtendMultiEssence()
  //
  /// Extends a multi-channel interleaved stream of essence that was
  /// originally created using IAAFMasterMob::CreateMultiEssence.
  /// Extended essence is represented by a Sequence of SourceClip objects.
  /// The first call to ExtendEssence will cause the TimelineMobSlot's SourceClip
  /// object to be replaced by a Sequence.  The initial SourceClip becomes the first
  /// component of the new Sequence.
  ///
  /// @param codecID [in, ref] using this codec
  /// @param arrayElemCount [in] this many channels
  /// @param mediaArray [in,ref,size_is(arrayElemCount)] using these definitions
  /// @param Enable [in] optionally compressing it
  /// @param destination [in] Optionally create the file HERE.
  /// @param fileFormat [in, ref] with this format
  /// @param access [out] Return an essence access on the essence.
  ///
  STDMETHOD(ExtendMultiEssence) (THIS_
    aafUID_constref  codecID,
    aafUInt16  arrayElemCount,
    aafmMultiCreate_t *  mediaArray,
    aafCompressEnable_t  Enable,
    IAAFLocator * destination,
    aafUID_constref  fileFormat,
    IAAFEssenceMultiAccess**  access) PURE;


  END_INTERFACE
};
#endif // __IAAFMasterMobEx_INTERFACE_DEFINED__



// IAAFMob2

// ************************
//
// Interface IAAFMob2
//
// ************************














#ifndef __IAAFMob2_INTERFACE_DEFINED__
#define __IAAFMob2_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFMob2;

#undef  INTERFACE
#define INTERFACE   IAAFMob2

DECLARE_INTERFACE_(IAAFMob2, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFMob2 methods *** */








  //***********************************************************
  //
  // GetMobID()
  //
  /// This method returns the unique Mob ID associated with this mob.
  ///
  /// Succeeds if all of the following are true:
  /// - the pMobID pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pMobID.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMobID arg is NULL.
  ///
  /// @param pMobID [out] The unique media object id
  ///
  STDMETHOD(GetMobID) (THIS_
    aafMobID_t *  pMobID) PURE;


  //***********************************************************
  //
  // SetMobID()
  //
  /// When a mob is initially created, the Reference Implementation
  /// internally creates a mobID for the new mob.  This method should
  /// be used to change the mob's identity to an explicit mobID.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param mobID [in, ref] New Mob ID
  ///
  STDMETHOD(SetMobID) (THIS_
    aafMobID_constref  mobID) PURE;


  //***********************************************************
  //
  // SetName()
  //
  /// Sets the Mob Name string property.
  ///
  /// Set the Name property to the value specified in
  /// pName.  A copy is made of the data so the caller
  /// retains ownership of the *pName buffer and is
  /// responsible for de-allocating it.  There is no pre-set limit to
  /// the length of the name, other than available system memory or
  /// disk space.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pName pointer is valid.
  /// 
  /// If this method fails the Name property will not be
  /// changed.
  /// 
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  ///
  /// @param pName [in, string] buffer from which Name is to be read
  ///
  STDMETHOD(SetName) (THIS_
    aafCharacter_constptr  pName) PURE;


  //***********************************************************
  //
  // GetName()
  //
  /// Gets the Mob Name string property.
  /// 
  /// Writes the Name property, with a trailing null
  /// character, into the pName buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.  If the Name property has not yet
  /// been set, a zero-length string will be written (that is,
  /// only the trailing null character). 
  /// 
  /// Caller may call GetNameBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pName.
  /// 
  /// Succeeds if:
  /// - The pName pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   Name.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pName arg is NULL.
  ///
  /// AAFRESULT_SMALL_BUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold Name.
  ///
  /// @param pName [out, string, size_is(bufSize)] buffer into which Name is to be written
  /// @param bufSize [in] size of *pName buffer in bytes
  ///
  STDMETHOD(GetName) (THIS_
    aafCharacter *  pName,
    aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetNameBufLen()
  //
  /// Returns size of buffer (in bytes) required for GetName().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  ///
  STDMETHOD(GetNameBufLen) (THIS_
    aafUInt32 *  pBufSize) PURE;


  //***********************************************************
  //
  // CountSlots()
  //
  /// This method returns the number of slots contained by this mob.
  ///
  /// Succeeds if all of the following are true:
  /// - the pNumSlots pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pNumSlots.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumSlots arg is NULL.
  ///
  /// @param pNumSlots [out] Number of slots
  ///
  STDMETHOD(CountSlots) (THIS_
    aafNumSlots_t *  pNumSlots) PURE;


  //***********************************************************
  //
  // AppendSlot()
  //
  /// Appends the given mob slot to the mob.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pSlot pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSlot is null.
  ///
  /// @param pSlot [in] slot to append
  ///
  STDMETHOD(AppendSlot) (THIS_
    IAAFMobSlot * pSlot) PURE;


  //***********************************************************
  //
  // PrependSlot()
  //
  /// Prepends the given mob slot to the mob.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pSlot pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSlot is null.
  ///
  /// @param pSlot [in] slot to prepend
  ///
  STDMETHOD(PrependSlot) (THIS_
    IAAFMobSlot * pSlot) PURE;


  //***********************************************************
  //
  // InsertSlotAt()
  //
  /// Inserts the given slot into this mob at the given index.  All
  /// existing slots at the given and higher index will be moved up one
  /// index to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pSlot pointer is valid.
  /// - index is less than or equal to the result obtained by
  ///   CountSlots().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSlot is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is greater than the result obtained from CountSlots().
  ///
  /// @param index [in] index where slot is to be inserted
  /// @param pSlot [in] slot to insert
  ///
  STDMETHOD(InsertSlotAt) (THIS_
    aafUInt32  index,
    IAAFMobSlot * pSlot) PURE;


  //***********************************************************
  //
  // RemoveSlotAt()
  //
  /// Removes the slot at the given index.  All existing slots at
  /// indices higher than the given index will be moved down one index
  /// to accommodate.
  /// 
  /// Succeeds if all of the following are true:
  /// - index is less than the result obtained by CountSlots().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is not less than the result obtained from
  ///     CountSlots().
  ///
  /// @param index [in] index of slot to be removed
  ///
  STDMETHOD(RemoveSlotAt) (THIS_
    aafUInt32  index) PURE;


  //***********************************************************
  //
  // GetSlotAt()
  //
  /// Returns the indexed slot in *ppSlot.
  /// 
  /// Succeeds if all of the following are true:
  /// - ppSlot is a valid pointer.
  /// - index is less than the result obtained by CountSlots().
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppSlot is null.
  ///
  /// AAFRESULT_BADINDEX
  ///   - index is not less than the result obtained from
  ///     CountSlots().
  ///
  /// @param index [in] index of slot to be obtained
  /// @param ppSlot [out, retval] the returned slot
  ///
  STDMETHOD(GetSlotAt) (THIS_
    aafUInt32  index,
    IAAFMobSlot ** ppSlot) PURE;


  //***********************************************************
  //
  // GetSlots()
  //
  /// Return an enumeration for all mob slots.  The returned
  /// enumerator is AddRef()ed before it is returned.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// @param ppEnum [out] Mob Slot Enumeration
  ///
  STDMETHOD(GetSlots) (THIS_
    IEnumAAFMobSlots ** ppEnum) PURE;


  //***********************************************************
  //
  // GetModTime()
  //
  /// This method will return the modification time for this mob.
  ///
  /// Succeeds if all of the following are true:
  /// - the pLastModified pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pLastModified.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLastModified arg is NULL.
  ///
  /// @param pLastModified [out] Modified Time
  ///
  STDMETHOD(GetModTime) (THIS_
    aafTimeStamp_t *  pLastModified) PURE;


  //***********************************************************
  //
  // SetModTime()
  //
  /// This method sets the modification time on a mob.  The
  /// modification time is initially set to the time that the mob
  /// was created.  The Reference Implementation does not maintain the
  /// modification time every time that a mob has been updated.
  /// Therefore, this method should be called explicitly to change the
  /// modification time.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param modTime [in, ref] New Modification Time
  ///
  STDMETHOD(SetModTime) (THIS_
    aafTimeStamp_constref  modTime) PURE;


  //***********************************************************
  //
  // GetCreateTime()
  //
  /// This method will return the creation time for this mob.
  ///
  /// Succeeds if all of the following are true:
  /// - the pCreationTime pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pCreationTime.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pCreationTime arg is NULL.
  ///
  /// @param pCreationTime [out] Creation Time
  ///
  STDMETHOD(GetCreateTime) (THIS_
    aafTimeStamp_t *  pCreationTime) PURE;


  //***********************************************************
  //
  // SetCreateTime()
  //
  /// This method sets the creation time on a mob.  The
  /// creation time is initially set to the time that the mob
  /// was created.
  /// Therefore, this method should be called explicitly to change the
  /// creation time.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param createTime [in, ref] New Creation Time
  ///
  STDMETHOD(SetCreateTime) (THIS_
    aafTimeStamp_constref  createTime) PURE;


  //***********************************************************
  //
  // AppendComment()
  //
  /// Creates a user-defined comment and appends it to the specified
  /// Mob.  A Mob comment is implemented as a AAFTaggedValue object of type 
  /// WCharString.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pCategory pointer is valid.
  /// - the pComment pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pCategory or pComment args is NULL.
  ///
  /// @param pCategory [in,string] Comment heading
  /// @param pComment [in, string] Comment value
  ///
  STDMETHOD(AppendComment) (THIS_
    aafCharacter *  pCategory,
    aafCharacter_constptr  pComment) PURE;


  //***********************************************************
  //
  // CountComments()
  //
  /// return total number of comments attached to this mob.
  ///
  /// Succeeds if all of the following are true:
  /// - the pNumComments pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pNumComments.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumComments arg is NULL.
  ///
  /// @param pNumComments [out] Number  of Mob Comments
  ///
  STDMETHOD(CountComments) (THIS_
    aafUInt32 *  pNumComments) PURE;


  //***********************************************************
  //
  // GetComments()
  //
  /// Return the enumeration for all mob comments.  The returned
  /// enumerator is AddRef()ed before it is returned.  Mob comments are 
  /// implemented as AAFTaggedValue of type WCharString.   The enumerator
  /// is implemented as a EnumAAAFTaggedValues.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// @param ppEnum [out] Mob Comments
  ///
  STDMETHOD(GetComments) (THIS_
    IEnumAAFTaggedValues ** ppEnum) PURE;


  //***********************************************************
  //
  // RemoveComment()
  //
  /// Removes the given comment from this mob.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pComment pointer is valid.
  /// - the given comment is present in the mob.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pComment is null.
  ///
  /// AAFRESULT_OBJECT_NOT_FOUND
  ///   - the given comment is not in this mob.
  ///
  /// @param pComment [in] Comment to remove
  ///
  STDMETHOD(RemoveComment) (THIS_
    IAAFTaggedValue * pComment) PURE;


  //***********************************************************
  //
  // AppendNewTimelineSlot()
  //
  /// This method creates a new timeline mob slot with the given
  /// property values and appends it to the input mob.
  /// 
  /// The returned mob slot is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSegment pointer is valid.
  /// - the pSlotName pointer is valid.
  /// - the ppNewSlot pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - any of pSegment, pSlotName, or ppNewSlot arguments is null.
  ///
  /// @param editRate [in] Edit rate property value
  /// @param pSegment [in] Segment to append as slot component
  /// @param slotID [in] new slot ID
  /// @param pSlotName [in, string] new slot name
  /// @param origin [in] The slot origin
  /// @param ppNewSlot [out] Newly created slot
  ///
  STDMETHOD(AppendNewTimelineSlot) (THIS_
    aafRational_t  editRate,
    IAAFSegment * pSegment,
    aafSlotID_t  slotID,
    aafCharacter_constptr  pSlotName,
    aafPosition_t  origin,
    IAAFTimelineMobSlot ** ppNewSlot) PURE;


  //***********************************************************
  //
  // GetMobInfo()
  //
  /// This method will get all mob property information is a single call.
  ///
  /// Caller may call GetNameBufLen() to determine the required pName
  /// buffer size.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pLastModified pointer is valid.
  /// - the pCreationTime pointer is valid.
  /// - the pName pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pLastModified,
  /// *pCreationTime, or *pName.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - any of pLastModified, pCreationTime, or pName arguments is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - bufSize indicates the buffer is too small to hold the string.
  ///
  /// @param pLastModified [out] Modified Time
  /// @param pCreationTime [out] Creation Time
  /// @param pName [out, size_is(bufSize), string] Mob Name
  /// @param bufSize [in] size of the supplied buffer.
  ///
  STDMETHOD(GetMobInfo) (THIS_
    aafTimeStamp_t *  pLastModified,
    aafTimeStamp_t *  pCreationTime,
    aafCharacter *  pName,
    aafInt32  bufSize) PURE;


  //***********************************************************
  //
  // OffsetToMobTimecode()
  //
  /// This method will determine the timecode at the given offset into
  /// the given timecode segment, and will return it in *pResult.  If
  /// pTcSeg is NULL, will search for the slot containing a timecode
  /// segment and will use that instead.
  ///
  /// Succeeds if all of the following are true:
  /// - the pTcSeg pointer is valid.
  /// - the pOffset pointer is valid.
  /// - the pResult pointer is valid.
  /// - Timecode track exists.
  /// 
  /// If this method fails nothing will be written to *pResult.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pOffset or pResult argument is NULL.
  ///
  /// AAFRESULT_TIMECODE_NOT_FOUND
  ///   - timecode track wasn't found.
  ///
  /// @param pTcSeg [in] Timecode Segment
  /// @param pOffset [in] Offset into segment in edit units for that segment's mob slot
  /// @param pResult [out] The resulting timecode
  ///
  STDMETHOD(OffsetToMobTimecode) (THIS_
    IAAFSegment * pTcSeg,
    aafPosition_t *  pOffset,
    aafTimecode_t *  pResult) PURE;


  //***********************************************************
  //
  // LookupSlot()
  //
  /// The method will find the mob slot for the given slot id.
  ///
  /// The returned mob slot is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the ppDestSlot pointer is valid.
  /// - the given slot ID is found.
  /// 
  /// If this method fails nothing will be written to *ppDestSlot.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppDestSlot arg is NULL.
  ///
  /// @param slotId [in] The requested slot id
  /// @param ppDestSlot [out] The requested slot
  ///
  STDMETHOD(LookupSlot) (THIS_
    aafSlotID_t  slotId,
    IAAFMobSlot ** ppDestSlot) PURE;


  //***********************************************************
  //
  // ChangeRef()
  //
  /// Finds all Source Clips in the specified Mob that refer to the
  /// specified old Mob, and changes the references to point to the
  /// new Mob.
  ///
  /// This function traverses through the entire structure of the input
  /// Mob looking for Source Clips, and changes the sourceID property
  /// on all Source Clips with oldMobID to newMobID.
  ///
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param oldMobID [in, ref] Old Mob ID reference in source clip
  /// @param newMobID [in, ref] New Mob ID reference in source clip
  ///
  STDMETHOD(ChangeRef) (THIS_
    aafMobID_constref  oldMobID,
    aafMobID_constref  newMobID) PURE;


  //***********************************************************
  //
  // CloneExternal()
  //
  /// Clones the specified Source Mob, and optionally all dependent
  /// Mobs, to an external file, keeping the same MobID.  A pointer
  /// to the newly created destination mob is returned in *ppDestMob.
  /// 
  /// This function clones the specified Source Mob in the source file
  /// into a destination Mob, with the same MobID, in the destination
  /// file.  If resolveDependencies is kFollowDepend, the function
  /// also clones all Mobs referenced by the specified Source Mob.  If
  /// includeMedia is kIncludeMedia, the function also copies the
  /// media data associated with the Source Mob, returns the
  /// destination Mob, and clones all private data.
  ///
  /// If the media data is not in the file, the function does not
  /// attempt to find it in another file and clone it.  Both AAF files
  /// must be open before you call this function and both must have the
  /// same AAF Version number.
  ///
  /// The returned mob is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the pDestFile pointer is valid.
  /// - the ppDestMob pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pDestFile or ppDestMob arguments is NULL.
  ///
  /// @param resolveDependencies [in] Whether to clone dependent mobs
  /// @param includeMedia [in] Whether to include media data
  /// @param pDestFile [in] Destination AAF File
  /// @param ppDestMob [out] Destination Mob
  ///
  STDMETHOD(CloneExternal) (THIS_
    aafDepend_t  resolveDependencies,
    aafIncMedia_t  includeMedia,
    IAAFFile * pDestFile,
    IAAFMob ** ppDestMob) PURE;


  //***********************************************************
  //
  // Copy()
  //
  /// This function copies the specified Mob into a destination Mob in
  /// the same AAF file. The new Mob is returned through the destMob
  /// parameter. The function gives the destination Mob a new MobID and
  /// the name specified in the destMobName parameter. The function
  /// also copies all private data.
  /// 
  /// The returned mob is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the pDestMobName pointer is valid.
  /// - the ppDestMob pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pDestMobName or pDestMob arguments is NULL.
  ///
  /// @param pDestMobName [in, string] Optional Input. The name to be assigned to the new copy of the
  /// Mob.  The destMobName argument is optional. Specify a NULL
  /// value if no destination Mob name is desired.
  /// @param ppDestMob [out] Destination Mob
  ///
  STDMETHOD(Copy) (THIS_
    aafCharacter_constptr  pDestMobName,
    IAAFMob ** ppDestMob) PURE;
  ///

  //***********************************************************
  //
  // AppendKLVData()
  //
  /// Appends a pre-existing KLV Data object to the specified
  /// Mob.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pKLV pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - the pData arg is NULL.
  ///
  /// @param pData [in] KLV object
  ///
  STDMETHOD(AppendKLVData) (THIS_
    IAAFKLVData * pData) PURE;


  //***********************************************************
  //
  // CountKLVData()
  //
  /// Return total number of KLV data objects attached to this mob.
  ///
  /// Succeeds if all of the following are true:
  /// - the pNumData pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pNumComments.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumData arg is NULL.
  ///
  /// @param pNumData [out] Number  of KLV data objects
  ///
  STDMETHOD(CountKLVData) (THIS_
    aafUInt32 *  pNumData) PURE;


  //***********************************************************
  //
  // GetKLVData()
  //
  /// Return the enumeration for all KLV data objects on this mob.  The returned
  /// enumerator is AddRef()ed before it is returned.  The enumerator
  /// is implemented as a EnumAAFKLVData.
  /// 
  /// Succeeds if all of the following are true:
  /// - the ppEnum pointer is valid.
  /// 
  /// If this method fails nothing will be written to *ppEnum.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppEnum is null.
  ///
  /// @param ppEnum [out] KLV data objects
  ///
  STDMETHOD(GetKLVData) (THIS_
    IEnumAAFKLVData ** ppEnum) PURE;


  //***********************************************************
  //
  // RemoveKLVData()
  //
  /// Removes the given KLV data object from this mob.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pData pointer is valid.
  /// - the given KLV data object is present in the mob.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pData is null.
  ///
  /// AAFRESULT_OBJECT_NOT_FOUND
  ///   - the given KLV data object is not in this mob.
  ///
  /// @param pData [in] KLV data object to remove
  ///
  STDMETHOD(RemoveKLVData) (THIS_
    IAAFKLVData * pData) PURE;


  //***********************************************************
  //
  // AppendAttribute()
  //
  /// Append an attribute name/value pair to the attribute list.
  ///
  /// Creates a new tagged value, initializes it with the specified attribute
  /// name/value pair, and appends it to the attribute list.
  ///
  /// Succeeds if:
  ///   - pName and pValue are valid pointers.
  ///
  /// Return codes:
  ///
  ///   AAFRESULT_SUCCESS
  ///
  ///   AAFRESULT_NULL_PARAM
  ///	     - pName or pValue is null.
  ///
  /// @param pName [in] The attribute name.
  /// @param pValue [in] The attribute value.
  ///
  STDMETHOD(AppendAttribute) (THIS_
    aafCharacter_constptr  pName,
    aafCharacter_constptr  pValue) PURE;

  //***********************************************************
  //
  // CountAttributes()
  //
  /// Return the number of attributes contained in this mob.
  ///
  /// Succeeds if:
  ///   - pNumAttributes is a valid pointer
  ///
  /// Return codes:
  ///
  ///   AAFRESULT_SUCCESS
  ///
  ///   AAFRESULT_NULL_PARAM
  ///	     - pNumAttributes is null.
  ///
  /// @param pNumAttributes [out] Pointer to attribute count.
  ///
  STDMETHOD(CountAttributes) (THIS_
    aafUInt32*  pNumAttributes) PURE;
  

  //***********************************************************
  //
  // GetAttributes()
  //
  /// Return an attribute enumerator for this mob.
  ///
  /// Creates an enumerator for this mobs attributes.  The new enumerator is
  /// AddRef()ed before it is returned.
  ///
  /// Succeeds if:
  ///   - pName and pValue are valid pointers.
  ///
  /// Return codes:
  ///
  ///   AAFRESULT_SUCCESS
  ///
  ///   AAFRESULT_NULL_PARAM
  ///	     - pEnum was null.
  ///
  /// @param ppEnum [out] Pointer to the new enumerator object created by this method.
  ///
  STDMETHOD(GetAttributes) (THIS_
    IEnumAAFTaggedValues ** ppEnum) PURE;


  //***********************************************************
  //
  // RemoveAttribute()
  //
  /// Remove a mob attribute (tagged value).
  ///
  /// Succeeds if:
  ///   - pName and pValue are valid pointers.
  ///
  /// Return codes:
  ///
  ///   AAFRESULT_SUCCESS
  ///
  ///   AAFRESULT_NULL_PARAM
  ///	     - pName or pValue is null.
  ///
  /// @param pAttribute [in] Pointer to the tagged value attribute.
  ///
  STDMETHOD(RemoveAttribute) (THIS_
    IAAFTaggedValue * pAttribute) PURE;
	
  //***********************************************************
  //
  // SetUsageCode()
  //
  /// Set this mob's usage code. Usage codes are documented in the
  /// AAF Edit Protocol, and related specifications.
  ///
  /// Return codes:
  ///
  ///   AAFRESULT_SUCCESS
  ///
  /// @param usageCode [in] The usage code value.
  ///
  STDMETHOD(SetUsageCode) (THIS_
    aafUID_constref  usageCode) PURE;

  //***********************************************************
  //
  // GetUsageCode()
  //
  /// Get this mob's usage code. Usage codes are documented in the
  /// AAF Edit Protocol, and related specifications.
  ///
  /// Succeeds if:
  ///   - pUsageCode is a valid pointer
  ///
  /// Return codes:
  ///
  ///   AAFRESULT_PROP_NOT_PRESENT
  ///        - no usage code is present on this mob
  ///
  ///   AAFRESULT_NULL_PARAM
  ///	     - pUsageCode is null
  ///	
  ///   AAFRESULT_SUCCESS
  ///        - succeeded (This is the only code indicating success.)
  ///
  /// @param pUsageCode [out] Pointer to usage code.
  ///
  STDMETHOD(GetUsageCode) (THIS_
    aafUID_t*  pUsageCode) PURE;


  //***********************************************************
  //
  // AppendNewStaticSlot()
  //
  /// This method creates a new static mob slot with the given
  /// property values and appends it to the input mob.
  /// 
  /// The returned mob slot is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSegment pointer is valid.
  /// - the pSlotName pointer is valid.
  /// - the ppNewSlot pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - any of pSegment, pSlotName, or ppNewSlot arguments is null.
  ///
  /// @param pSegment [in] Segment to append as slot component
  /// @param slotID [in] new slot ID
  /// @param pSlotName [in, string] new slot name
  /// @param ppNewSlot [out] Newly created slot
  ///
  STDMETHOD(AppendNewStaticSlot) (THIS_
    IAAFSegment * pSegment,
    aafSlotID_t  slotID,
    aafCharacter_constptr  pSlotName,
    IAAFStaticMobSlot ** ppNewSlot) PURE;


  //***********************************************************
  //
  // AppendNewEventSlot()
  //
  /// This method creates a new event mob slot with the given
  /// property values and appends it to the input mob.
  /// 
  /// The returned mob slot is AddRef()ed before it is returned.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSegment pointer is valid.
  /// - the pSlotName pointer is valid.
  /// - the ppNewSlot pointer is valid.
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - any of pSegment, pSlotName, or ppNewSlot arguments is null.
  ///
  /// @param editRate [in] Edit rate property value
  /// @param pSegment [in] Segment to append as slot component
  /// @param slotID [in] new slot ID
  /// @param pSlotName [in, string] new slot name
  /// @param origin [in] The slot origin
  /// @param ppNewSlot [out] Newly created slot
  ///
  STDMETHOD(AppendNewEventSlot) (THIS_
    aafRational_t  editRate,
    IAAFSegment * pSegment,
    aafSlotID_t  slotID,
    aafCharacter_constptr  pSlotName,
    aafPosition_t  origin,
    IAAFEventMobSlot ** ppNewSlot) PURE;
	     


  END_INTERFACE
};
#endif // __IAAFMob2_INTERFACE_DEFINED__



// IAAFProgress

// ************************
//
// Interface IAAFProgress
//
// ************************



#ifndef __IAAFProgress_INTERFACE_DEFINED__
#define __IAAFProgress_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFProgress;


#undef  INTERFACE
#define INTERFACE   IAAFProgress

DECLARE_INTERFACE_(IAAFProgress, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFProgress methods *** */


  //***********************************************************
  //
  // ProgressCallback()
  //
  /// Called frequently during OM load/save operations.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(ProgressCallback) (THIS) PURE;

  END_INTERFACE
};
#endif // __IAAFProgress_INTERFACE_DEFINED__



// IAAFRGBADescriptor2

// ************************
//
// Interface IAAFRGBADescriptor2
//
// ************************







#ifndef __IAAFRGBADescriptor2_INTERFACE_DEFINED__
#define __IAAFRGBADescriptor2_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFRGBADescriptor2;

#undef  INTERFACE
#define INTERFACE   IAAFRGBADescriptor2

DECLARE_INTERFACE_(IAAFRGBADescriptor2, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFRGBADescriptor2 methods *** */


  //***********************************************************
  //
  // SetPixelLayout()
  //
  /// Sets the layout and structure of the components in a single pixel.
  /// The layout array is an Array of 8 aafRGBAComponent_t.  The 'Code' field of the struct is
  /// from the set:
  ///   	- kAAFCompNone
  /// 	- kAAFCompAlpha
  /// 	- kAAFCompBlue
  /// 	- kAAFCompFill
  /// 	- kAAFCompGreen
  /// 	- kAAFCompPalette
  /// 	- kAAFCompRed
  ///
  /// The 'Size' field of the struct is the component size in bits.
  /// 
  /// If you set less than 8 entries, the remaining entries will be padded with kAAFCompNone and a size of zero.
  /// If this method fails the PixelLayout property will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param numberElements [in] The number of elements in each array
  /// @param PixelLayoutArray [in] Array of up to 8 aafRGBAComponent_t indicating component order and size.
  ///
  STDMETHOD(SetPixelLayout) (THIS_
    aafUInt32  numberElements,
    aafRGBAComponent_t*  PixelLayoutArray) PURE;

  //***********************************************************
  //
  // CountPixelLayoutElements()
  //
  /// This function returns the number of components in a pixel.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails no state is changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  ///
  /// @param pResult [out] Number of components
  ///
  STDMETHOD(CountPixelLayoutElements) (THIS_
    aafUInt32 *  pResult) PURE;

  //***********************************************************
  //
  // GetPixelLayout()
  //
  /// Gets the layout and structure of the components in a single pixel.
  /// The layout array is an Array of 8 aafRGBAComponent_t.  The 'Code' field of the struct is
  /// from the set:
  ///   	- kAAFCompNone
  /// 	- kAAFCompAlpha
  /// 	- kAAFCompBlue
  /// 	- kAAFCompFill
  /// 	- kAAFCompGreen
  /// 	- kAAFCompPalette
  /// 	- kAAFCompRed
  ///
  /// The 'Size' field of the struct is the component size in bits.
  /// 
  /// If you Get more entries than were set, the extra entries will be padded with kAAFCompNone and a size of zero.
  ///
  /// If this method fails, PixelLayoutArray will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumberElements or PixelLayoutArray or PixelStructureArray is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - numberElements indicates that the array is too small to hold
  ///     the data.
  ///
  /// @param numberElements [in] The number of elements in the array
  /// @param PixelLayoutArray [out, size_is(numberElements)] Array to hold up to 8 aafRGBAComponent_t indicating component order and size.
  ///
  STDMETHOD(GetPixelLayout) (THIS_
    aafUInt32  numberElements,
    aafRGBAComponent_t*  PixelLayoutArray) PURE;

  //***********************************************************
  //
  // SetPalette()
  //
  /// Sets the palette property.  The palette must be in the form specified
  /// by the palette layout and palette structure parameters.
  /// 
  /// Succeeds if all of the following are true:
  /// - pPalette is a valid pointer
  /// 
  /// If this method fails, the palette property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPalette is NULL.
  ///
  /// @param numberElements [in] The number of bytes in the array
  /// @param pPalette [in, size_is(numberElements)] Array to hold the palette information
  ///
  STDMETHOD(SetPalette) (THIS_
    aafUInt32  numberElements,
    aafUInt8*  pPalette) PURE;


  //***********************************************************
  //
  // GetPalette()
  //
  /// Sets the palette property.  The palette must be in the form specified
  /// by the palette layout and palette structure parameters.
  /// The values are written to the array specified by pPalette,
  /// which is of size numberElements.  The required size may be found
  /// by calling GetPaletteSize().
  /// 
  /// Succeeds if all of the following are true:
  /// - pPalette is a valid pointer.
  /// - numberElements indicates the array is large enough to hold the
  ///   data.
  /// 
  /// If this method fails, pPalette will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumberElements is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - numberElements indicates that the array is too small to hold
  ///     the data.
  ///
  /// @param numberRecords [in] The number of bytes in the array
  /// @param pPalette [out, size_is(numberRecords)] Array to hold the palette information
  ///
  STDMETHOD(GetPalette) (THIS_
    aafUInt32  numberRecords,
    aafUInt8*  pPalette) PURE;


  //***********************************************************
  //
  // GetPaletteSize()
  //
  /// Get the number of bytes in the VideoLineMap property array.
  /// 
  /// Succeeds if all of the following are true:
  /// - pNumberBytes is a valid pointer
  /// 
  /// If this method fails, *pNumberBytes will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumberBytes is NULL.
  ///
  /// @param pNumberBytes [out] The number of bytes in the array
  ///
  STDMETHOD(GetPaletteSize) (THIS_
    aafUInt32 *  pNumberBytes) PURE;

  //***********************************************************
  //
  // CountPaletteLayoutElements()
  //
  /// This function returns the number of components in a pixel.
  /// 
  /// Succeeds if all of the following are true:
  /// - this object has already been initialized.
  /// - the pResult pointer is valid.
  /// 
  /// If this method fails no state is changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - Initialize() has already been called on this object.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResult is null.
  ///
  /// @param pResult [out] Number of components
  ///
  STDMETHOD(CountPaletteLayoutElements) (THIS_
    aafUInt32 *  pResult) PURE;

  //***********************************************************
  //
  // SetPaletteLayout()
  //
  /// Sets the layout and structure of the components in a single pixel.
  /// The layout array is an Array of 8 aafRGBAComponent_t.  The 'Code' field of the struct is
  /// from the set:
  ///   	- kAAFCompNone
  /// 	- kAAFCompAlpha
  /// 	- kAAFCompBlue
  /// 	- kAAFCompFill
  /// 	- kAAFCompGreen
  /// 	- kAAFCompPalette
  /// 	- kAAFCompRed
  ///
  /// The 'Size' field of the struct is the component size in bits.
  /// 
  /// If you set less than 8 entries, the remaining entries will be padded with kAAFCompNone and a size of zero.
  /// If this method fails the PaletteLayout property will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param numberElements [in] The number of elements in the array
  /// @param PaletteLayoutArray [in] Array of up to 8 bytes indicating component size, matching layout, and terminated by a zero byte.
  ///
  STDMETHOD(SetPaletteLayout) (THIS_
    aafUInt32  numberElements,
    aafRGBAComponent_t*  PaletteLayoutArray) PURE;

  //***********************************************************
  //
  // GetPaletteLayout()
  //
  /// /// The layout array is an Array of 8 aafRGBAComponent_t.  The 'Code' field of the struct is
  /// from the set:
  ///   	- kAAFCompNone
  /// 	- kAAFCompAlpha
  /// 	- kAAFCompBlue
  /// 	- kAAFCompFill
  /// 	- kAAFCompGreen
  /// 	- kAAFCompPalette
  /// 	- kAAFCompRed
  ///
  /// The 'Size' field of the struct is the component size in bits.
  /// 
  /// If you Get more entries than were set, the extra entries will be padded with kAAFCompNone and a size of zero.
  ///
  /// If this method fails, PaletteLayoutArray will not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pNumberElements or PaletteLayoutArray is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - numberElements indicates that the array is too small to hold
  ///     the data.
  ///
  /// @param numberElements [in] The number of elements in each array
  /// @param PaletteLayoutArray [out, size_is(numberElements)] Array to hold 8 aafRGBAComponent_t indicating component order and size.
  ///
  STDMETHOD(GetPaletteLayout) (THIS_
    aafUInt32  numberElements,
    aafRGBAComponent_t*  PaletteLayoutArray) PURE;


  //***********************************************************
  //
  // SetComponentMaxRef()
  //
  /// Sets the ComponentMaxRef property.
  ///
  /// Succeeds if all of the following are true:
  /// 
  /// If this method fails, the ComponentMaxRef property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param componentMaxRef [in] Optional.
  ///
  STDMETHOD(SetComponentMaxRef) (THIS_
    aafUInt32  componentMaxRef) PURE;


  //***********************************************************
  //
  // GetComponentMaxRef()
  //
  /// Gets the ComponentMaxRef property.
  ///
  /// Succeeds if all of the following are true:
  /// - pComponentMaxRef is a valid pointer
  /// - the property is present.
  ///
  /// If this method fails, pComponentMaxRef will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pComponentMaxRef is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pComponentMaxRef [out] Optional.
  ///
  STDMETHOD(GetComponentMaxRef) (THIS_
    aafUInt32 *  pComponentMaxRef) PURE;


  //***********************************************************
  //
  // SetComponentMinRef()
  //
  /// Sets the ComponentMinRef property.
  ///
  /// Succeeds if all of the following are true:
  /// 
  /// If this method fails, the ComponentMinRef property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param componentMinRef [in] Optional.
  ///
  STDMETHOD(SetComponentMinRef) (THIS_
    aafUInt32  componentMinRef) PURE;


  //***********************************************************
  //
  // GetComponentMinRef()
  //
  /// Gets the ComponentMinRef property.
  ///
  /// Succeeds if all of the following are true:
  /// - pComponentMinRef is a valid pointer
  /// - the property is present.
  ///
  /// If this method fails, pComponentMinRef will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pComponentMinRef is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pComponentMinRef [out] Optional.
  ///
  STDMETHOD(GetComponentMinRef) (THIS_
    aafUInt32 *  pComponentMinRef) PURE;


  //***********************************************************
  //
  // SetAlphaMaxRef()
  //
  /// Sets the AlphaMaxRef property.
  ///
  /// Succeeds if all of the following are true:
  /// 
  /// If this method fails, the AlphaMaxRef property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param alphaMaxRef [in] Optional.
  ///
  STDMETHOD(SetAlphaMaxRef) (THIS_
    aafUInt32  alphaMaxRef) PURE;


  //***********************************************************
  //
  // GetAlphaMaxRef()
  //
  /// Gets the AlphaMaxRef property.
  ///
  /// Succeeds if all of the following are true:
  /// - pAlphaMaxRef is a valid pointer
  /// - the property is present.
  ///
  /// If this method fails, pAlphaMaxRef will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pAlphaMaxRef is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pAlphaMaxRef [out] Optional.
  ///
  STDMETHOD(GetAlphaMaxRef) (THIS_
    aafUInt32 *  pAlphaMaxRef) PURE;


  //***********************************************************
  //
  // SetAlphaMinRef()
  //
  /// Sets the AlphaMinRef property.
  ///
  /// Succeeds if all of the following are true:
  /// 
  /// If this method fails, the AlphaMinRef property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param alphaMinRef [in] Optional.
  ///
  STDMETHOD(SetAlphaMinRef) (THIS_
    aafUInt32  alphaMinRef) PURE;


  //***********************************************************
  //
  // GetAlphaMinRef()
  //
  /// Gets the AlphaMinRef property.
  ///
  /// Succeeds if all of the following are true:
  /// - pAlphaMinRef is a valid pointer
  /// - the property is present.
  ///
  /// If this method fails, pAlphaMinRef will not be changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pAlphaMinRef is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pAlphaMinRef [out] Optional.
  ///
  STDMETHOD(GetAlphaMinRef) (THIS_
    aafUInt32 *  pAlphaMinRef) PURE;


  //***********************************************************
  //
  // SetScanningDirection()
  //
  /// Sets the ScanningDirection property.  This property is optional.
  ///
  /// Succeeds if all of the following are true:
  /// - scanningDirection is a value value.
  /// 
  /// If this method fails, the ScanningDirection property will not be
  /// changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_AAFRESULT_INVALID_ENUM_VALUE
  ///   - scanningDirection is not a valid value.
  ///
  /// @param scanningDirection [in] Scanning direction value.
  ///
  STDMETHOD(SetScanningDirection) (THIS_
    aafScanningDirection_t  scanningDirection) PURE;


  //***********************************************************
  //
  // GetScanningDirection()
  //
  /// Gets the ScanningDirection property.  This property is optional.
  ///
  /// Succeeds if all of the following are true:
  /// - pScanningDirection is a valid pointer
  /// - the property is present.
  /// 
  /// If this method fails, pScanningDirection not be changed.
  /// 
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pScanningDirection is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param pScanningDirection [out] Scanning direction value.
  ///
  STDMETHOD(GetScanningDirection) (THIS_
    aafScanningDirection_t *  pScanningDirection) PURE;



  END_INTERFACE
};
#endif // __IAAFRGBADescriptor2_INTERFACE_DEFINED__



// IAAFSearchSource

// ************************
//
// Interface IAAFSearchSource
//
// ************************

#ifndef __IAAFSearchSource_INTERFACE_DEFINED__
#define __IAAFSearchSource_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFSearchSource;

#undef  INTERFACE
#define INTERFACE   IAAFSearchSource

DECLARE_INTERFACE_(IAAFSearchSource, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFSearchSource methods *** */

  //***********************************************************
  //
  // SearchSource()
  //
  /// This function returns the source information for a slot in a
  /// Master Mob or Source Mob.  It follows the Source Clip references
  /// in the specified slot until it encounters the kind of Mob
  /// specified in the mobKind parameter.  This function cannot be used
  /// on a Composition Mob and is not intended to be called
  /// iteratively; use the MobOpenSearch, MobGetNextSource,
  /// MobGetThisSource, and MobCloseSearch functions for those
  /// purposes. 
  ///
  /// The returned component and find source info are AddRef()ed
  /// before they are returned.
  ///
  /// Succeeds if all of the following are true:
  /// - ppSourceInfo is non-NULL
  /// - a Mob of the requested kind is found
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppCpnt is null.
  ///
  /// OM_ERR_INVALID_MOBTYPE
  ///	- The enumerator is out of range (bad cast, or writing
  ///      toolkit newer than reader)
  ///
  /// OM_ERR_TRAVERSAL_NOT_POSS
  ///	- Can not find a mob of the given kind.
  ///
  /// @param slotID [in] Slot ID
  /// @param offset [in] Offset
  /// @param mobKind [in] Mob Kind
  /// @param pMediaCrit [in] Media Criteria
  /// @param pOperationChoice [in] Operation Choice
  /// @param ppSourceInfo [out] Source Information
  ///
  STDMETHOD(SearchSource) (THIS_
    aafSlotID_t  slotID,
    aafPosition_t  offset,
    aafMobKind_t  mobKind,
    aafMediaCriteria_t *  pMediaCrit,
    aafOperationChoice_t *  pOperationChoice,
    IAAFFindSourceInfo ** ppSourceInfo) PURE;

  END_INTERFACE
};
#endif // __IAAFSearchSource_INTERFACE_DEFINED__



// IAAFSourceReference2

// ************************
//
// Interface IAAFSourceReference2
//
// ************************




#ifndef __IAAFSourceReference2_INTERFACE_DEFINED__
#define __IAAFSourceReference2_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFSourceReference2;

#undef  INTERFACE
#define INTERFACE   IAAFSourceReference2

DECLARE_INTERFACE_(IAAFSourceReference2, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFSourceReference2 methods *** */



  //***********************************************************
  //
  // GetSourceID()
  //
  /// Gets the SourceID and places it into the pSourceID argument.
  ///
  /// Succeeds if all of the following are true:
  /// - the pSourceID pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pSourceID.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSourceID arg is NULL.
  ///
  /// @param pSourceID [retval][out] Place to put source ID
  ///
  STDMETHOD(GetSourceID) (THIS_
    aafMobID_t *  pSourceID) PURE;


  //***********************************************************
  //
  // SetSourceID()
  //
  /// Sets the SourceID using the sourceID argument.
  /// 
  /// Always succeeds.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// @param sourceID [in] Source ID to set
  ///
  STDMETHOD(SetSourceID) (THIS_
    aafMobID_constref   sourceID) PURE;


  //***********************************************************
  //
  // GetSourceMobSlotID()
  //
  /// Gets the Mob Slot ID and places it into the pMobSlotID argument.
  ///
  /// Succeeds if all of the following are true:
  /// - the pMobSlotID pointer is valid.
  /// 
  /// If this method fails nothing will be written to *pMobSlotID.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMobSlotID arg is NULL.
  ///
  /// @param pMobSlotID [retval][out] Place to put source mob slot ID
  ///
  STDMETHOD(GetSourceMobSlotID) (THIS_
    aafSlotID_t *  pMobSlotID) PURE;


  //***********************************************************
  //
  // SetSourceMobSlotID()
  //
  /// Sets the mob slot ID using the mobSlotID argument.
  /// 
  /// Succeeds if all of the following are true:
  /// - (preconditions here)
  /// 
  /// If this method fails no state will be changed.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// (other error codes here.)
  ///
  /// @param mobSlotID [in] Source Mob ID to set
  ///
  STDMETHOD(SetSourceMobSlotID) (THIS_
    aafSlotID_t   mobSlotID) PURE;



  //***********************************************************
  //
  // SetChannelIDs()
  //
  /// Specify the channels in a slot that are referenced. The first channel has
  /// and ID of 1, the N'th channel has an ID of N.  The number of channel IDs
  /// shall equal the number of channels being described the bht MobSlot containing
  /// the SourceReference, e.g. 1 element for a mono audio slot, 6 elements for a 5.1
  /// multi-channel audio slot.
  /// 
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pChannelIDs is null 
  ///
  /// @param numberElements [in] Number of elements in the pChannelIDs array
  /// @param pChannelIDs [in] Array of channel IDs
  ///
  STDMETHOD(SetChannelIDs) (THIS_
    aafUInt32  numberElements,
    aafUInt32*  pChannelIDs) PURE;


  //***********************************************************
  //
  // GetChannelIDs()
  //
  /// Get the channels in a slot that are referenced.  Refer to
  /// SetChannelIDs for channel IDs description.
  ///
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pChannelIDs is null
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present
  ///
  /// AAFRESULT_SMALLBUF
  ///   - pChannelIDs is too small
  ///
  /// @param numberElements [in] Number of elements in the pChannelIDs array
  /// @param pChannelIDs [in] Array of channel IDs
  ///
  STDMETHOD(GetChannelIDs) (THIS_
    aafUInt32  numberElements,
    aafUInt32*  pChannelIDs) PURE;

  //***********************************************************
  //
  // GetChannelIDsSize()
  //
  /// Returns the size in bytes of the buffer required to hold the array
  /// returned by GetChannelIDs().
  ///
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSize is null
  ///
  /// @param pSize [out] required buffer size to hold the ChannelIDs array
  ///
  STDMETHOD(GetChannelIDsSize) (THIS_
    aafUInt32 *  pSize) PURE;

  //***********************************************************
  //
  // SetMonoSourceSlotIDs()
  //
  /// For reference from a multi-channel MobSlot to multiple mono MobSlots.
  /// pMonoSourceSlotIDs identifies the mono slots referenced by this SourceReference
  /// object.
  /// 
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMonoSourceSlotIDs is null 
  ///
  /// @param numberElements [in] Number of elements in the pMonoSourceSlotIDs array
  /// @param pMonoSourceSlotIDs [in] Array of slot IDs
  ///
  STDMETHOD(SetMonoSourceSlotIDs) (THIS_
    aafUInt32  numberElements,
    aafUInt32*  pMonoSourceSlotIDs) PURE;


  //***********************************************************
  //
  // GetMonoSourceSlotIDs()
  //
  /// Get the mono slot IDs that are referenced by this object.  Refer to
  /// SetMonoSourceSlotIDs for a description of pMonoSourceSlotIDs.
  ///
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMonoSourceSlotIDs is null
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present
  ///
  /// AAFRESULT_SMALLBUF
  ///   - pMonoSourceSlotIDs is too small
  ///
  /// @param numberElements [in] Number of elements in the pMonoSourceSlotIDs array
  /// @param pMonoSourceSlotIDs [in] Array of channel IDs
  ///
  STDMETHOD(GetMonoSourceSlotIDs) (THIS_
    aafUInt32  numberElements,
    aafUInt32*  pMonoSourceSlotIDs) PURE;

  //***********************************************************
  //
  // GetMonoSourceSlotIDsSize()
  //
  /// Returns the size in bytes of the buffer required to hold the array
  /// returned by GetMonoSourceSlotIDs().
  ///
  /// Return codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pSize is null
  ///
  /// @param pSize [out] required buffer size to hold the MonoSourceSlotIDs array
  ///
  STDMETHOD(GetMonoSourceSlotIDsSize) (THIS_
    aafUInt32 *  pSize) PURE;


  END_INTERFACE
};
#endif // __IAAFSourceReference2_INTERFACE_DEFINED__



// IAAFStreamAccess

// ************************
//
// Interface IAAFStreamAccess
//
// ************************



#ifndef __IAAFStreamAccess_INTERFACE_DEFINED__
#define __IAAFStreamAccess_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFStreamAccess;


#undef  INTERFACE
#define INTERFACE   IAAFStreamAccess

DECLARE_INTERFACE_(IAAFStreamAccess, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFStreamAccess methods *** */


  //***********************************************************
  //
  // WriteStream()
  //
  /// This method is called back by the AAF toolkit when a previously
  /// defined stream property is actually being written, so that you
  /// may write the data.
  ///  IAAFTypeDef *pTypeDef;
  ///  IAAFTypeDefStream *pTypeDefStream;
  /// 
  ///  propertyValue->GetType(&pTypeDef));
  ///  pTypeDef->QueryInterface(IID_IAAFTypeDefStream,(void **)&pTypeDefStream));
  ///  pTypeDefStream->Write(pStreamPropertyValue, ...);
  ///  
  ///
  /// @param propertyValue [in] One which will this data be written
  /// @param pUserData [in] A client-supplied pointer used to extract the data
  ///
  STDMETHOD(WriteStream) (THIS_
    IAAFPropertyValue * propertyValue,
    aafMemPtr_t  pUserData) PURE;


  END_INTERFACE
};
#endif // __IAAFStreamAccess_INTERFACE_DEFINED__



// IAAFTimelineMobSlot2

// ************************
//
// Interface IAAFTimelineMobSlot2
//
// ************************



#ifndef __IAAFTimelineMobSlot2_INTERFACE_DEFINED__
#define __IAAFTimelineMobSlot2_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTimelineMobSlot2;

#undef  INTERFACE
#define INTERFACE   IAAFTimelineMobSlot2

DECLARE_INTERFACE_(IAAFTimelineMobSlot2, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTimelineMobSlot2 methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  /// Initializes a newly allocated, empty
  /// IAAFTimelineMobSlot2-supporting object.  This method must be
  /// called after allocation, and before any other method can be
  /// called.
  ///
  /// Succeeds if:
  /// - Initialize() has not yet been called on this object.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_ALREADY_INITIALIZED
  ///   - Initialize() has already been called on this object.
  STDMETHOD(Initialize) (THIS) PURE;


  //***********************************************************
  //
  // GetEditRate()
  //
  /// This method will get the edit rate for this mob slot.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pEditRate pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pEditRate arg is NULL.
  ///
  /// @param pEditRate [out,retval] Edit rate property value
  ///
  STDMETHOD(GetEditRate) (THIS_
    aafRational_t *  pEditRate) PURE;


  //***********************************************************
  //
  // SetEditRate()
  //
  /// This method will get set edit rate for this mob slot.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param editRate [in] Edit rate property value
  ///
  STDMETHOD(SetEditRate) (THIS_
    aafRational_constref  editRate) PURE;


  //***********************************************************
  //
  // GetOrigin()
  //
  /// This method will return the origin of this mob slot.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pOrigin pointer is valid.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pOrigin arg is NULL.
  ///
  /// @param pOrigin [out,retval] Origin property value
  ///
  STDMETHOD(GetOrigin) (THIS_
    aafPosition_t *  pOrigin) PURE;


  //***********************************************************
  //
  // SetOrigin()
  //
  /// This method will set the origin of this mob slot.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.).
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// @param origin [in] Origin property value
  ///
  STDMETHOD(SetOrigin) (THIS_
    aafPosition_t  origin) PURE;

  //***********************************************************
  //
  // GetMarkIn()
  //
  /// Gets the MarkIn property of this TimelineMobSlot.
  /// This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the result pointer is valid.
  /// - the property is present.
  /// 
  /// If this method fails nothing will be written to *result.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMarkIn arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param result [out,retval] MarkIn property value
  ///
  STDMETHOD(GetMarkIn) (THIS_
    aafPosition_t *  result) PURE;

  //***********************************************************
  //
  // SetMarkIn()
  //
  /// Sets the MarkIn property of this TimelineMobSlot.
  /// This property is optional.
  ///
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  ///
  /// If this method fails the MarkIn property will not be
  /// changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// @param value [in] MarkIn property value
  ///
  STDMETHOD(SetMarkIn) (THIS_
    aafPosition_t  value) PURE;

  //***********************************************************
  //
  // GetMarkOut()
  //
  /// Gets the MarkOut property of this TimelineMobSlot.
  /// This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the result pointer is valid.
  /// - the property is present.
  /// 
  /// If this method fails nothing will be written to *result.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pMarkIn arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param result [out,retval] MarkOut property value
  ///
  STDMETHOD(GetMarkOut) (THIS_
    aafPosition_t *  result) PURE;

  //***********************************************************
  //
  // SetMarkOut()
  //
  /// Sets the MarkOut property of this TimelineMobSlot.
  /// This property is optional.
  ///
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  ///
  /// If this method fails the MarkOut property will not be
  /// changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// @param value [in] MarkOut property value
  ///
  STDMETHOD(SetMarkOut) (THIS_
    aafPosition_t  value) PURE;

  //***********************************************************
  //
  // GetUserPos()
  //
  /// Gets the UserPos property of this TimelineMobSlot.
  /// This property is optional.
  /// 
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  /// - the result pointer is valid.
  /// - the property is present.
  /// 
  /// If this method fails nothing will be written to *result.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - result arg is NULL.
  ///
  /// AAFRESULT_PROP_NOT_PRESENT
  ///   - the property is not present.
  ///
  /// @param result [out,retval] UserPos property value
  ///
  STDMETHOD(GetUserPos) (THIS_
    aafPosition_t *  result) PURE;

  //***********************************************************
  //
  // SetUserPos()
  //
  /// Sets the UserPos property of this TimelineMobSlot.
  /// This property is optional.
  ///
  /// Succeeds if all of the following are true:
  /// - the object is initialized.
  ///
  /// If this method fails the UserPos property will not be
  /// changed.
  ///
  /// This method will return the following codes:
  ///
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - the object is not initialized.
  ///
  /// @param value [in] UserPos property value
  ///
  STDMETHOD(SetUserPos) (THIS_
    aafPosition_t  value) PURE;


  END_INTERFACE
};
#endif // __IAAFTimelineMobSlot2_INTERFACE_DEFINED__



// IAAFTypeDefStreamEx

// ************************
//
// Interface IAAFTypeDefStreamEx
//
// ************************





#ifndef __IAAFTypeDefStreamEx_INTERFACE_DEFINED__
#define __IAAFTypeDefStreamEx_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDefStreamEx;


#undef  INTERFACE
#define INTERFACE   IAAFTypeDefStreamEx

DECLARE_INTERFACE_(IAAFTypeDefStreamEx, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDefStreamEx methods *** */



  //***********************************************************
  //
  // SetCallback()
  //
  /// Sets a callback interface to be called when a stream is written to or
  /// read from the file.  This allows the stream property to be built bottom up.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pPropertyValue pointer is valid.
  /// - pCallbackIF pointer is valid.
  /// - pUserData pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pPropertyValue or pCallbackIF or pUserData arg is NULL.
  ///
  /// @param pPropertyValue [in] Issue the callback for this property
  /// @param pCallbackIF [in] Interface of the callback object
  /// @param pUserData [in] Client-specific data passed through to the callback
  ///
  STDMETHOD(SetCallback) (THIS_
    IAAFPropertyValue * pPropertyValue,
    IAAFStreamAccess*  pCallbackIF,
    aafMemPtr_t  pUserData) PURE;


  END_INTERFACE
};
#endif // __IAAFTypeDefStreamEx_INTERFACE_DEFINED__





// IAAFTypeDefStream3

// ************************
//
// Interface IAAFTypeDefStream3
//
// ************************





#ifndef __IAAFTypeDefStream3_INTERFACE_DEFINED__
#define __IAAFTypeDefStream3_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDefStream3;


#undef  INTERFACE
#define INTERFACE   IAAFTypeDefStream3

DECLARE_INTERFACE_(IAAFTypeDefStream3, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDefStream3 methods *** */



  //***********************************************************
  //
  // GetSize()
  //
  /// Returns number of bytes contained in the referenced property
  /// value.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  /// - pSize is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pStreamPropertyValue or pSize arg is NULL.
  ///
  /// @param pStreamPropertyValue [in] stream property value
  /// @param pSize [out] count of bytes in the specified stream property value
  ///
  STDMETHOD(GetSize) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    aafInt64 *  pSize) PURE;

  //***********************************************************
  //
  // SetSize()
  //
  /// Set the number of bytes contained in the give stream property value
  /// to newElementCount
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - If pStreamPropertyValue arg is NULL.
  ///
  /// @param pStreamPropertyValue [in] stream property value
  /// @param newSize [in] new count of bytes in the specified stream property value
  ///
  STDMETHOD(SetSize) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    aafInt64  newSize) PURE;

  //***********************************************************
  //
  // GetPosition()
  //
  /// Returns the byte position of the current element in the stream. 
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  /// - pPosition is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pStreamPropertyValue or pPosition arg is NULL.
  ///
  /// @param pStreamPropertyValue [in] stream property value
  /// @param pPosition [out] current byte position in the specified stream property value
  ///
  STDMETHOD(GetPosition) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    aafInt64 *  pPosition) PURE;

  //***********************************************************
  //
  // SetPosition()
  //
  /// Make the current byte position to the one at newPosition in the stream 
  /// property value. 
  ///
  /// Succeeds if:
  /// - pStreamPropertyValue is a valid pointer.
  /// - the new position is valid
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - If pStreamPropertyValue arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - newPosition is outside the bounds of the stream.
  ///
  /// @param pStreamPropertyValue [in] stream property value
  /// @param newPosition [in] the new position in the specified stream property value
  ///
  STDMETHOD(SetPosition) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    aafInt64  newPosition) PURE;


  //***********************************************************
  //
  // Read()
  //
  /// Sequential access.
  /// Copies the data at the position of the stream to the given
  /// buffer.
  ///
  /// Succeeds if all of the following are true:
  /// - the pStreamPropertyValue pointer is valid.
  /// - the pData pointer is valid.
  /// - the indicated bytes exist in the stream.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pStreamPropertyValue or pData arg is NULL.
  ///
  /// @param pStreamPropertyValue [in] stream property value to read
  /// @param dataSize [in] number of bytes to read
  /// @param pData [out, size_is(dataSize), length_is(*bytesRead)] buffer into which one element from the stream should be written
  /// @param bytesRead [out,ref] number of bytes actually read (will be either dataSize or 0 if there 
  /// is in error)
  ///
  STDMETHOD(Read) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    aafUInt32  dataSize,
    aafMemPtr_t  pData,
    aafUInt32 *  bytesRead) PURE;

  //***********************************************************
  //
  // Write()
  //
  /// Sequential access.
  /// Copies the data in the given buffer into the stream at the 
  /// current position of the stream..
  ///
  /// Succeeds if all of the following are true:
  /// - the pStreamPropertyValue pointer is valid.
  /// - the pData pointer is valid.
  /// - the indicated bytes could be written to the stream.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pStreamPropertyValue or pData arg is NULL.
  ///
  /// @param pStreamPropertyValue [in] stream property value to modify
  /// @param dataSize [in] number of bytes to write
  /// @param pData [in, ref, size_is(dataSize)] buffer into which should contain one element to be written to the stream
  ///
  STDMETHOD(Write) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    aafUInt32  dataSize,
    aafMemPtr_t  pData) PURE;

  //***********************************************************
  //
  // Append()
  //
  /// Extending the stream.
  /// Copies the data in the given buffer into the stream at the 
  /// end of the stream.
  ///
  /// Succeeds if all of the following are true:
  /// - the pStreamPropertyValue pointer is valid.
  /// - the pData pointer is valid.
  /// - the indicated bytes could be appended to the stream.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pStreamPropertyValue or pData arg is NULL.
  ///
  /// @param pStreamPropertyValue [in] stream property value to modify
  /// @param dataSize [in] number of bytes to write (must be equal to the element type length)
  /// @param pData [in, ref, size_is(dataSize)] buffer into which should contain one element to be written to the stream
  ///
  STDMETHOD(Append) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    aafUInt32  dataSize,
    aafMemPtr_t  pData) PURE;


  //***********************************************************
  //
  // HasStoredByteOrder()
  //
  /// Returns kAAFTrue if the stream has a stored byte order or 
  /// kAAFFalse otherwise.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  /// - pHasByteOrder is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pStreamPropertyValue or pHasByteOrder arg is NULL.
  ///
  /// @param pStreamPropertyValue [in] stream property value
  /// @param pHasByteOrder [out] kAAFTrue if this stream has a stored byte order
  ///
  STDMETHOD(HasStoredByteOrder) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    aafBoolean_t *  pHasByteOrder) PURE;

  //***********************************************************
  //
  // GetStoredByteOrder()
  //
  /// Access byte order of the stream.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  /// - pByteOrder is a valid pointer.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - Either pStreamPropertyValue or pByteOrder arg is NULL.
  ///
  /// @param pStreamPropertyValue [in] stream property value
  /// @param pByteOrder [out] Pointer to variable where byte order is to be copied
  ///
  STDMETHOD(GetStoredByteOrder) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    eAAFByteOrder_t *  pByteOrder) PURE;

  //***********************************************************
  //
  // SetStoredByteOrder()
  //
  /// Sets the byte order to be associated with this stream. Note: the stream
  /// must be empty.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  /// - stream is empty.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - If pStreamPropertyValue arg is NULL.
  ///
  /// @param pStreamPropertyValue [in] stream property value
  /// @param byteOrder [in] byte order is to be stored with the stream
  ///
  STDMETHOD(SetStoredByteOrder) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    eAAFByteOrder_t  byteOrder) PURE;

  //***********************************************************
  //
  // ClearStoredByteOrder()
  //
  /// Clears the byte order to be associated with this stream. Note: the stream
  /// must be empty.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pStreamPropertyValue is a valid pointer.
  /// - stream is empty.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - If pStreamPropertyValue arg is NULL.
  ///
  /// @param pStreamPropertyValue [in] stream property value
  ///
  STDMETHOD(ClearStoredByteOrder) (THIS_
    IAAFPropertyValue * pStreamPropertyValue) PURE;

  //***********************************************************
  //
  // ReadElements()
  //
  /// Access in typed chunks of Elements.
  /// Copies the data at the current position of the stream to the given
  /// buffer. Requires that any structures declared within element 
  /// typedef have had their offsets registered with that type.
  ///
  /// Succeeds if all of the following are true:
  /// - the pStreamPropertyValue pointer is valid.
  /// - the pElementType pointer is valid.
  /// - the pData pointer is valid.
  /// - dataSize indicates pData is large enough to hold the data.
  /// - compile-time struct has had its member offests registered.
  /// - the indicated elements exist in this stream type def.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pStreamPropertyValue or pElementType or pBytesRead or pData arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - dataSize indicates pData is too small.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for element typedef.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - there are not dataSize bytes left in the stream.
  ///
  /// @param pStreamPropertyValue [in] stream property value to read
  /// @param pElementType [in] the type definition of the elements to read
  /// @param dataSize [in] number of bytes to read (must be evenly divisible by the element 
  /// type length)
  /// @param pData [out, size_is(dataSize), length_is(*pBytesRead)] buffer into which elements from the stream should be written
  /// @param pBytesRead [out,ref] number of bytes actually read (will be either dataSize or 0 if 
  /// there is in error)
  ///
  STDMETHOD(ReadElements) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    IAAFTypeDef * pElementType,
    aafUInt32  dataSize,
    aafMemPtr_t  pData,
    aafUInt32 *  pBytesRead) PURE;

  //***********************************************************
  //
  // WriteElements()
  //
  /// Access in typed chunks of Elements.
  /// Copies the data in the given buffer into the stream at the  
  /// current position of the stream. Requires that any structures 
  /// declared within element 
  /// typedef have had their offsets registered with that type..
  ///
  /// Succeeds if all of the following are true:
  /// - the pStreamPropertyValue pointer is valid.
  /// - the pElementType pointer is valid.
  /// - the pData pointer is valid.
  /// - dataSize indicates pData is large enough to hold the data.
  /// - compile-time struct has had its member offests registered.
  /// - the indicated elements exist in this stream type def.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pStreamPropertyValue or pElementType or pData arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - dataSize indicates pData is an even multiple of the given 
  ///     element type size.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for the element typedef.
  ///
  /// @param pStreamPropertyValue [in] stream property value to modify
  /// @param pElementType [in] the type definition of the elements to read
  /// @param dataSize [in] number of bytes to write (must be evenly divisible by the element type 
  /// length)
  /// @param pData [in, ref, size_is(dataSize)] buffer into which elements from the stream should be written
  ///
  STDMETHOD(WriteElements) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    IAAFTypeDef * pElementType,
    aafUInt32  dataSize,
    aafMemPtr_t  pData) PURE;


  /// Extend in chunks of typed Elements

  //***********************************************************
  //
  // AppendElements()
  //
  /// Access in typed chunks of Elements.
  /// Copies the data in the given buffer onto the end of the stream. 
  /// Requires that any structures declared within element 
  /// typedef have had their offsets registered with that type..
  ///
  /// Succeeds if all of the following are true:
  /// - the pStreamPropertyValue pointer is valid.
  /// - the pElementType pointer is valid.
  /// - the pData pointer is valid.
  /// - dataSize indicates pData is large enough to hold the data.
  /// - compile-time struct has had its member offests registered.
  /// - the indicated elements exist in this stream type def.
  ///
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pStreamPropertyValue or pElementType or pData arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - dataSize indicates pData is an even multiple of the given 
  ///     element type size.
  ///
  /// AAFRESULT_NOT_REGISTERED
  ///  - struct offsets have not yet been registered for the element typedef.
  ///
  /// @param pStreamPropertyValue [in] stream property value to modify
  /// @param pElementType [in] the type definition of the elements to read
  /// @param dataSize [in] number of bytes to write (must be evenly divisible by the element type 
  /// length)
  /// @param pData [in, ref, size_is(dataSize)] buffer into which elements from the stream should be written
  ///
  STDMETHOD(AppendElements) (THIS_
    IAAFPropertyValue * pStreamPropertyValue,
    IAAFTypeDef * pElementType,
    aafUInt32  dataSize,
    aafMemPtr_t  pData) PURE;

  //***********************************************************
  //
  // SetCallback()
  //
  /// Sets a callback interface to be called when a stream is written to or
  /// read from the file.  This allows the stream property to be built bottom up.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pPropertyValue pointer is valid.
  /// - pCallbackIF pointer is valid.
  /// - pUserData pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pPropertyValue or pCallbackIF or pUserData arg is NULL.
  ///
  /// @param pPropertyValue [in] Issue the callback for this property
  /// @param pCallbackIF [in] Interface of the callback object
  /// @param pUserData [in] Client-specific data passed through to the callback
  ///
  STDMETHOD(SetCallback) (THIS_
    IAAFPropertyValue * pPropertyValue,
    IAAFStreamAccess*  pCallbackIF,
    aafMemPtr_t  pUserData) PURE;

  //***********************************************************
  //
  // GetPlainStreamData()
  //
  /// Creates an object which implements the IAAFPlainStreamData
  // interface and provides access to the file encoding-independent
  // stream data.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pPlainStreamData is a valid pointer.
  // - reserved is 0.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pPlainStreamData arg is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  ///   - reserved is not 0.
  ///
  /// @param reserved [in] Reserved for future use
  /// @param pPlainStreamData [out,retval] file encoding-independent stream data
  ///
  STDMETHOD(GetPlainStreamData) (THIS_
    aafUInt32  reserved,
    IAAFPlainStreamData ** pPlainStreamData) PURE;


  END_INTERFACE
};
#endif // __IAAFTypeDefStream3_INTERFACE_DEFINED__



// IAAFTypeDefVariableArrayEx

// ************************
//
// Interface IAAFTypeDefVariableArrayEx
//
// ************************





#ifndef __IAAFTypeDefVariableArrayEx_INTERFACE_DEFINED__
#define __IAAFTypeDefVariableArrayEx_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDefVariableArrayEx;


#undef  INTERFACE
#define INTERFACE   IAAFTypeDefVariableArrayEx

DECLARE_INTERFACE_(IAAFTypeDefVariableArrayEx, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDefVariableArrayEx methods *** */



  //***********************************************************
  //
  // PrependElement()
  //
  /// Prepends an element to the end of the array, setting it to the
  /// value given in pMemberPropVal.
  ///
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - pInPropVal pointer is valid.
  /// - pMemberPropVal pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pInPropVal or pMemberPropVal arg is NULL.
  ///
  /// @param pInPropVal [in] property value corresponding to array to which element is prepended
  /// @param pMemberPropVal [in] value to be prepended to this array
  ///
  STDMETHOD(PrependElement) (THIS_
    IAAFPropertyValue * pInPropVal,
    IAAFPropertyValue * pMemberPropVal) PURE;




  //***********************************************************
  //
  // RemoveElement()
  //
  /// Remove an element from the Array, given an index.
  /// Index is zero-based,
  /// and must be less than the value returned by GetCount().
  /// 
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - the index exists in this array type def.
  /// - The pInPropVal pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pInPropVal arg is NULL.
  ///
  /// AAFRESULT_BADINDEX
  ///   - The given index is out of range for this array type def.
  ///
  /// @param pInPropVal [in] property value corresponding to array
  /// @param index [in] zero-based index into elements in this array type
  ///
  STDMETHOD(RemoveElement) (THIS_
    IAAFPropertyValue * pInPropVal,
    aafUInt32  index) PURE;




  //***********************************************************
  //
  // InsertElement()
  //
  /// Inserts the value of the single, indicated element of the fixed
  /// array contained in pInPropVal, to the value contained in
  /// pMemberPropVal.  Index is zero-based, and must be less than the
  /// value returned by GetCount().  Property value must be of the
  /// same type as returned by GetType().
  /// 
  /// Succeeds if:
  /// - Initialize() has already been called on this object.
  /// - the index exists in this array type def.
  /// - The pInPropVal pointer is valid.
  /// - The ppOutPropVal pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pInPropVal or ppOutPropVal arg is NULL.
  ///
  /// AAFRESULT_BADINDEX
  ///   - The given index is out of range for this array type def.
  ///
  /// @param pInPropVal [in] property value corresponding to array
  /// @param index [in] zero-based index into elements in this array type
  /// @param pMemberPropVal [in] value to be inserted into this array
  ///
  STDMETHOD(InsertElement) (THIS_
    IAAFPropertyValue * pInPropVal,
    aafUInt32  index,
    IAAFPropertyValue * pMemberPropVal) PURE;





  END_INTERFACE
};
#endif // __IAAFTypeDefVariableArrayEx_INTERFACE_DEFINED__











  ///***********************************************************
  /// Functions used to dynamically load and unload the AAF dll
  /// without statically linking to the dll's export library.
  /// To use these functions link to the stub library aaf.lib
  /// (or aafd.lib for the debugging version). 
  /// If the client is statically linking to the AAF dll's export
  /// library then the following functions will always succeed:
  ///***********************************************************

  //***********************************************************
  //
  // AAFLoad()
  //
  /// Attempts to load the given implementation of AAF into
  /// the processes address space. Only one implementation
  /// of AAF can be active. Note: once AAFUnload has been
  /// called all subsequent access to AAF interfaces will fail
  ///
  /// To use this function link to the stub library aaf.lib
  /// (or aafd.lib for the debugging version). 
  /// If the client is statically linking to the AAF dll's export
  /// library then the function will always succeed.
  ///
  /// @param dllname [in] Pointer to the name of AAF dll to load.
  /// If this pointer is NULL the function will attempt to load the
  /// default AAF dll.
  /// 
  STDAPI AAFLoad (
    const char *  dllname);


  //***********************************************************
  //
  // AAFUnload()
  //
  /// Attempts to unload the current AAF dll loaded with a
  /// previous call to AAFLoad.
  /// 
  STDAPI AAFUnload ();


  ///***********************************************************
  /// Factory functions for AAF files:.
  ///***********************************************************

  //***********************************************************
  //
  // AAFFileOpenExistingRead()
  //
  /// Creates an object associated with with an existing filesystem
  /// file that contains data which is only to be read.
  /// Does the following:
  ///
  /// - Opens the existing named file in the filesystem for reading.
  /// - Associates an object with that filesystem file.
  /// - Places the object into the Open-read-only state.
  /// - This AAFFile object then can be used as the root of the
  ///   containment tree representing all AAF objects contained within the file.
  ///
  /// Succeeds if:
  /// - The pFileName argument is valid.
  /// - Only valid flags have been specified.
  /// - A valid combination of flags has been specified.
  /// - The named file exists in the filesystem.
  /// - The named filesystem file is readable.
  /// - The named file represents itself as a valid AAF file.  Even if
  ///   this succeeds, it is not guaranteed that the named file is in fact a valid AAF file.
  ///
  /// This function will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - the pFileName pointer arg is NULL.
  ///
  /// AAFRESULT_BAD_FLAGS
  ///   - one or more illegal flags were specified.
  ///
  /// AAFRESULT_BAD_FLAG_COMBINATION
  ///   - illegal combination of otherwise valid flags was specified.
  ///
  /// AAFRESULT_FILE_NOT_FOUND
  ///   - The named file does not exist in the filesystem.
  ///
  /// AAFRESULT_NOT_READABLE
  ///   - The named file cannot be read.
  ///
  /// AAFRESULT_NOT_AAF_FILE
  ///   - The named file does not claim to be a valid AAF file.
  /// 
  /// @param pFileName [in, string] Null-terminated string containing name of filesystem file to be
  /// opened for reading. The file name has no restrictions other than those imposed by
  /// the underlying file system. AAF files that use structured storage encoding typically
  /// use the extension .aaf or .isr. AAF files that use XML encoding typically use the .xml
  /// extension. AAF files that use KLV encoding typically use use the extension .mxf or .klv.
  /// @param modeFlags [in] File open mode flags.  May be any of the following ORed
  /// together.  All other bits must be set to zero.
  ///
  ///  - kAAFFileModeUnbuffered - to indicate buffered mode.  Default
  ///    is buffered.
  /// @param ppFile [out] Pointer to buffer to receive pointer to new file.
  /// 
  STDAPI AAFFileOpenExistingRead (
    aafCharacter_constptr  pFileName,
    aafUInt32  modeFlags,
    IAAFFile ** ppFile);


  //***********************************************************
  //
  // AAFFileOpenExistingModify()
  //
  /// Creates an object associated with with an existing
  /// filesystem file that contains data which is to be read and
  /// written.  Associates the given identification with it.
  /// Does the following:
  ///
  /// - Opens the existing named file in the filesystem for reading and
  ///   writing.
  /// - Associates an object with that filesystem file.
  /// - Places the object into the Open-read-write  state.
  /// - This AAFFile object then can be used as the root of the
  ///   containment tree representing all AAF objects contained within the file.
  ///
  /// Succeeds if:
  /// - This object is currently Closed.
  /// - The pFileName argument is valid.
  /// - The pIdent argument is valid.
  /// - Only valid flags have been specified.
  /// - A valid combination of flags has been specified.
  /// - The named file exists in the filesystem.
  /// - The named filesystem file is readable.
  /// - The named filesystem file is writable.
  /// - The named file represents itself as a valid AAF file.  Even if
  ///   this succeeds, it is not guaranteed that the named file is in fact a valid AAF file.
  ///
  /// This function will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pFileName or pIdent pointer argument is NULL.
  ///
  /// AAFRESULT_BAD_FLAGS
  ///   - one or more illegal flags were specified.
  ///
  /// AAFRESULT_BAD_FLAG_COMBINATION
  ///   - illegal combination of otherwise valid flags was specified.
  ///
  /// AAFRESULT_FILE_NOT_FOUND
  ///   - The named file does not exist in the filesystem.
  ///
  /// AAFRESULT_NOT_READABLE
  ///   - The named file cannot be read.
  ///
  /// AAFRESULT_NOT_WRITEABLE
  ///   - The named file cannot be written.
  ///
  /// AAFRESULT_NOTAAFFILE
  ///   - The named file is not a valid AAF file.
  /// 
  /// @param pFileName [in, string] Null-terminated string containing name of filesystem file to be
  /// opened for modification. The file name has no restrictions other than those imposed by
  /// the underlying file system. AAF files that use structured storage encoding typically
  /// use the extension .aaf or .isr. AAF files that use XML encoding typically use the .xml
  /// extension. AAF files that use KLV encoding typically use use the extension .mxf or .klv.
  /// @param modeFlags [in] File open mode flags.  May be any of the following ORed together.
  /// All other bits must be set to zero.
  ///
  ///  - kAAFFileModeUnbuffered
  ///    to indicate unbuffered mode. Default is buffered.
  ///  - kAAFFileModeRevertable
  ///    to indicate that Revert is possible on this file (for all changes except those to essence).
  /// @param pIdent [in] Identification of the application which is modifying this file.
  /// @param ppFile [out] Pointer to buffer to receive pointer to new file.
  /// 
  STDAPI AAFFileOpenExistingModify (
    aafCharacter_constptr  pFileName,
    aafUInt32  modeFlags,
    aafProductIdentification_t *  pIdent,
    IAAFFile ** ppFile);


  //***********************************************************
  //
  // AAFFileOpenNewModify()
  //
  /// Creates an object associated with with a new
  /// filesystem file that contains data which is to be read and
  /// written.  Associates the given identification with it.
  /// Does the following:
  ///
  /// - Creates a new file in the filesystem with the given name.
  /// - Opens the filesystem file for reading and writing.
  /// - Associates this object with that filesystem file.
  /// - Places this object into the Open state.
  /// - This AAFFile object then can be used as the root of the
  ///   containment tree representing all AAF objects contained within the file.
  ///
  /// Succeeds if:
  /// - The pFileName argument is valid.
  /// - The pIdent argument is valid.
  /// - Only valid flags have been specified.
  /// - A valid combination of flags has been specified.
  /// - The named file does not exists in the filesystem.
  /// - There is sufficient space in the filesystem to create the file.
  ///
  /// This function will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pFileName or pIdent pointer argument is NULL.
  ///
  /// AAFRESULT_BAD_FLAGS
  ///   - one or more illegal flags were specified.
  ///
  /// AAFRESULT_BAD_FLAG_COMBINATION
  ///   - illegal combination of otherwise valid flags was specified.
  ///
  /// AAFRESULT_FILE_EXISTS
  ///   - The named file already exists in the filesystem.
  ///
  /// AAFRESULT_INSUFFICIENT_SPACE
  ///   - There is insufficient space in the filesystem to create this
  ///     file.
  /// 
  /// @param pFileName [in, string] Null-terminated string containing name of filesystem file to be
  /// opened for modification. The file name has no restrictions other than those imposed by
  /// the underlying file system. AAF files that use structured storage encoding typically
  /// use the extension .aaf or .isr. AAF files that use XML encoding typically use the .xml
  /// extension. AAF files that use KLV encoding typically use use the extension .mxf or .klv.
  /// @param modeFlags [in] File open mode flags.  May be any of the following ORed together.
  /// All other bits must be set to zero.
  ///
  ///  - kAAFFileModeUnbuffered
  ///    to indicate unbuffered mode. Default is buffered.
  ///  - kAAFFileModeRevertable
  ///    to indicate that Revert is possible on this file (for all changes except those to essence).
  /// @param pIdent [in] Identification of the application which is creating this file.
  /// @param ppFile [out] Pointer to buffer to receive pointer to new file.
  /// 
  STDAPI AAFFileOpenNewModify (
    aafCharacter_constptr  pFileName,
    aafUInt32  modeFlags,
    aafProductIdentification_t *  pIdent,
    IAAFFile ** ppFile);


  //***********************************************************
  //
  // AAFFileOpenNewModifyEx()
  //
  /// Creates an object associated with with a new
  /// filesystem file that contains data which is to be read and
  /// written.  Associates the given identification with it.
  /// Does the following:
  ///
  /// - Creates a new file in the filesystem with the given name.
  /// - Opens the filesystem file for reading and writing.
  /// - Associates this object with that filesystem file.
  /// - Places this object into the Open state.
  /// - This AAFFile object then can be used as the root of the
  ///   containment tree representing all AAF objects contained within the file.
  ///
  /// Succeeds if:
  /// - The pFileName argument is valid.
  /// - The pFileKind argument is valid.
  /// - The pIdent argument is valid.
  /// - Only valid flags have been specified.
  /// - A valid combination of flags has been specified.
  /// - The named file does not exists in the filesystem.
  /// - There is sufficient space in the filesystem to create the file.
  ///
  /// This function will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pFileName or pIdent pointer argument is NULL.
  ///
  /// AAFRESULT_BAD_FLAGS
  ///   - one or more illegal flags were specified.
  ///
  /// AAFRESULT_BAD_FLAG_COMBINATION
  ///   - illegal combination of otherwise valid flags was specified.
  ///
  /// AAFRESULT_FILE_EXISTS
  ///   - The named file already exists in the filesystem.
  ///
  /// AAFRESULT_INSUFFICIENT_SPACE
  ///   - There is insufficient space in the filesystem to create this
  ///     file.
  /// 
  /// @param pFileName [in, string] Null-terminated string containing name of filesystem file to be
  /// opened for modification. The file name has no restrictions other than those imposed by
  /// the underlying file system. AAF files that use structured storage encoding typically
  /// use the extension .aaf or .isr. AAF files that use XML encoding typically use the .xml
  /// extension. AAF files that use KLV encoding typically use use the extension .mxf or .klv.
  /// @param pFileKind [in] kind of file to be created
  /// @param modeFlags [in] File open mode flags
  /// @param pIdent [in] Identification of the application which is creating this file.
  /// @param ppFile [out] Pointer to buffer to receive pointer to new file.
  /// 
  STDAPI AAFFileOpenNewModifyEx (
    aafCharacter_constptr  pFileName,
    aafUID_constptr  pFileKind,
    aafUInt32  modeFlags,
    aafProductIdentification_t *  pIdent,
    IAAFFile ** ppFile);


  //***********************************************************
  //
  // AAFFileOpenTransient()
  //
  /// Creates an object associated with with a transient file,
  /// meaning that it is not associated with any filesystem file but
  /// may still be used to contain AAF objects as if it was associated
  /// with a filesystem file.  Associates the given identification with
  /// this file.
  ///
  /// Transient files are never considered Revertable.
  ///
  /// Succeeds if:
  /// - This object has already been Initialize()d.
  /// - The pIdent argument is valid.
  /// - This object is currently closed.
  ///
  /// This function will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NOT_INITIALIZED
  ///   - This object has not yet had Initialize() called on it.
  ///
  /// AAFRESULT_ALREADY_OPEN
  ///   - This object is already open.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - the pIdent pointer argument is NULL.
  /// 
  /// @param pIdent [in] Identification which is to be associated with this file.
  /// @param ppFile [out] Pointer to buffer to receive pointer to new file.
  /// 
  STDAPI AAFFileOpenTransient (
    aafProductIdentification_t *  pIdent,
    IAAFFile ** ppFile);


  //***********************************************************
  //
  // AAFFileIsAAFFile()
  //
  /// Is the named file an AAF file ?
  ///
  /// Note that the function result is returned via the pFileIsAAFFile argument.
  /// If this function succeeds it returns AAFRESULT_SUCCESS even if the named
  /// file is not an AAF file.
  ///
  /// This function will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - at least one of the pointer arguments is NULL.
  ///
  /// AAFRESULT_FILE_NOT_FOUND
  ///   - the file named by pFileName cannot be found.
  /// 
  /// @param pFileName [in, string] Null-terminated string containing name of filesystem file.
  /// @param pAAFFileKind [out] Pointer to an AUID indicating the file kind
  /// @param pFileIsAAFFile [out,retval] Returns AAFTrue if the given file is an AAF file, returns AAFFalse otherwise.
  /// 
  STDAPI AAFFileIsAAFFile (
    aafCharacter_constptr  pFileName,
    aafUID_t *  pAAFFileKind,
    aafBool *  pFileIsAAFFile);

  //***********************************************************
  //
  // AAFRawStorageIsAAFFile()
  //
  /// Does the storage contain an AAF file ?
  ///
  /// Note that the function result is returned via the pRawStorageIsAAFFile argument.
  /// If this function succeeds it returns AAFRESULT_SUCCESS even if the storage
  /// is not an AAF file.
  ///
  /// This function will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - at least one of the pointer arguments is NULL.
  /// 
  /// @param pRawStorage [in] storage containing the purported file
  /// @param pAAFFileKind [out] Pointer to an AUID indicating the file kind
  /// @param pRawStorageIsAAFFile [out,retval] Returns AAFTrue if the given storage contains an AAF file, returns AAFFalse otherwise.
  /// 
  STDAPI AAFRawStorageIsAAFFile (
    IAAFRawStorage *  pRawStorage,
    aafUID_t *  pAAFFileKind,
    aafBool *  pRawStorageIsAAFFile);


  //***********************************************************
  //
  // AAFFileIsAAFFileKind()
  //
  /// Is the named file an AAF file ?
  ///
  /// Note that the function result is returned via the pFileIsAAFFile argument.
  /// If this function succeeds it returns AAFRESULT_SUCCESS even if the named
  /// file is not an AAF file of the specified kind.
  ///
  /// This function will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - at least one of the pointer arguments is NULL.
  ///
  /// AAFRESULT_FILEKIND_NOT_REGISTERED
  ///   - the specified file kind is not supported by the toolkit.
  /// 
  /// @param pFileName [in, string] Null-terminated string containing name of filesystem file.
  /// @param pAAFFileKind [in] Pointer to an AUID indicating the file kind to check for
  /// @param pFileIsAAFFile [out,retval] Returns AAFTrue if the given file is an AAF file of the specified kind,
  /// returns AAFFalse otherwise.
  /// 
  STDAPI AAFFileIsAAFFileKind (
    aafCharacter_constptr  pFileName,
    aafUID_constptr  pAAFFileKind,
    aafBool *  pFileIsAAFFile);


  //***********************************************************
  //
  // AAFRawStorageIsAAFFileKind()
  //
  /// Does the storage contain an AAF file ?
  ///
  /// Note that the function result is returned via the pRawStorageIsAAFFile argument.
  /// If this function succeeds it returns AAFRESULT_SUCCESS even if the storage
  /// is not an AAF file of the specified kind.
  ///
  /// This function will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - at least one of the pointer arguments is NULL.
  ///
  /// AAFRESULT_FILEKIND_NOT_REGISTERED
  ///   - the specified file kind is not supported by the toolkit.
  /// 
  /// @param pRawStorage [in] storage containing the purported file
  /// @param pAAFFileKind [in] Pointer to an AUID indicating the file kind to check for
  /// @param pRawStorageIsAAFFile [out,retval] Returns AAFTrue if the given storage contains an AAF file of the
  /// specified kind, returns AAFFalse otherwise.
  /// 
  STDAPI AAFRawStorageIsAAFFileKind (
    IAAFRawStorage *  pRawStorage,
    aafUID_constptr  pAAFFileKind,
    aafBool *  pRawStorageIsAAFFile);


  //***********************************************************
  //
  // AAFGetPluginManager()
  //
  /// Returns an interface of the plugin manager, which is used to
  /// select plugins for exporting.
  ///
  /// @param ppPluginManager [out] Pointer to the interface of the plugin manager.
  /// 
  STDAPI AAFGetPluginManager (
    IAAFPluginManager ** ppPluginManager);


  //***********************************************************
  //
  // AAFCreateRawStorageMemory()
  //
  /// Create a raw storage providing a built-in implementation of
  /// IAAFRawStorage on memory.
  ///
  /// This is considered a value-added function since clients could
  /// actually create their own.
  ///
  /// Succeeds if:
  /// - The ppNewRawStorage pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppNewRawStorage arg is NULL.
  /// 
  /// @param access [in] Governs whether stream may be read from and/or written
  /// to.
  /// @param ppNewRawStorage [out] Newly created storage
  /// 
  STDAPI AAFCreateRawStorageMemory (
    aafFileAccess_t  access,
    IAAFRawStorage ** ppNewRawStorage);


  //***********************************************************
  //
  // AAFCreateRawStorageDisk()
  //
  /// Create a raw storage providing a built-in implementation of
  /// IAAFRawStorage on a file on disk.
  ///
  /// Note that it is illegal to specify existence and access as "New"
  /// "Read".
  ///
  /// This is considered a value-added function since clients could
  /// actually create their own.
  ///
  /// Succeeds if:
  /// - The pFilename pointer is valid.
  /// - The ppNewRawStorage pointer is valid.
  /// - If the open mode is one of read, write, or modify.
  /// - If the file existence is one of new or existing.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFilename or ppNewRawStorage arg is NULL.
  ///
  /// AAFRESULT_WRONG_OPENMODE
  /// - If none of read, modify, or write are specified as open
  ///   mode, or if neither new or existing is specified for the
  ///   existence.
  /// 
  /// @param pFilename [in] Name of file to be associated with this storage
  /// @param existence [in] Governs whether storage is on pre-existing data, or is
  ///  newly created.
  /// @param access [in] Governs whether stream may be read from and/or written
  ///  to.
  /// @param ppNewRawStorage [out] Newly created storage
  /// 
  STDAPI AAFCreateRawStorageDisk (
    aafCharacter_constptr  pFilename,
    aafFileExistence_t  existence,
    aafFileAccess_t  access,
    IAAFRawStorage ** ppNewRawStorage);


  //***********************************************************
  //
  // AAFCreateRawStorageCachedDisk()
  //
  /// Create a raw storage providing a built-in implementation of
  /// IAAFRawStorage on a file on disk with caching.
  ///
  /// Note that it is illegal to specify existence and access as "New"
  /// "Read".
  ///
  /// This is considered a value-added function since clients could
  /// actually create their own.
  ///
  /// Succeeds if:
  /// - The pFilename pointer is valid.
  /// - The ppNewRawStorage pointer is valid.
  /// - If the open mode is one of read, write, or modify.
  /// - If the file existence is one of new or existing.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pFilename or ppNewRawStorage arg is NULL.
  ///
  /// AAFRESULT_WRONG_OPENMODE
  /// - If none of read, modify, or write are specified as open
  ///   mode, or if neither new or existing is specified for the
  ///   existence.
  /// 
  /// @param pFilename [in] Name of file to be associated with this storage
  /// @param existence [in] Governs whether storage is on pre-existing data, or is
  ///  newly created.
  /// @param access [in] Governs whether stream may be read from and/or written
  ///  to.
  /// @param pageCount [in] Count of cache pages
  /// @param pageSize [in] Cache page size in bytes
  /// @param ppNewRawStorage [out] Newly created storage
  /// 
  STDAPI AAFCreateRawStorageCachedDisk (
    aafCharacter_constptr  pFilename,
    aafFileExistence_t  existence,
    aafFileAccess_t  access,
    aafUInt32  pageCount,
    aafUInt32  pageSize,
    IAAFRawStorage ** ppNewRawStorage);

  //***********************************************************
  //
  // AAFCreateRawStorageCached()
  //
  /// Create a new cached raw storage from an
  /// existing raw storage.
  ///
  /// Succeeds if:
  /// - The pRawStorage pointer is valid.
  /// - The ppNewRawStorage pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pRawStorage or ppNewRawStorage arg is NULL.
  ///
  ///   
  /// 
  /// @param pRawStorage [in] Existing raw storage
  /// @param pageCount [in] Count of cache pages
  /// @param pageSize [in] Cache page size in bytes
  /// @param ppNewRawStorage [out] Newly created cached storage
  /// 
  STDAPI AAFCreateRawStorageCached (
    IAAFRawStorage *  pRawStorage,
    aafUInt32  pageCount,
    aafUInt32  pageSize,
    IAAFRawStorage ** ppNewRawStorage);

  //***********************************************************
  //
  // AAFCreateRawStorageCached2()
  //
  /// Create a new cached raw storage from an
  /// existing raw storage with control over how the cache pages are allocated.
  ///
  /// Note that pages are allocated as needed so that the toolkit calls
  /// Allocate() a maximum of pageCount times (fewer than pageCount calls
  /// will be made if the data fits entirely within the cache).
  /// 
  /// Succeeds if:
  /// - The pRawStorage pointer is valid.
  /// - The pCachePageAllocator pointer is valid.
  /// - The ppNewRawStorage pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - either pRawStorage, pCachePageAllocator or ppNewRawStorage arg is NULL.
  ///
  ///
  /// 
  /// @param pRawStorage [in] Existing raw storage
  /// @param pageCount [in] Count of cache pages
  /// @param pageSize [in] Cache page size in bytes
  /// @param pCachePageAllocator [in] Cache page memory allocator
  /// @param ppNewRawStorage [out] Newly created cached storage
  /// 
  STDAPI AAFCreateRawStorageCached2 (
    IAAFRawStorage *  pRawStorage,
    aafUInt32  pageCount,
    aafUInt32  pageSize,
    IAAFCachePageAllocator*  pCachePageAllocator,
    IAAFRawStorage ** ppNewRawStorage);

  //***********************************************************
  //
  // AAFCreateAAFFileOnRawStorage()
  //
  /// Given an IAAFRawStorage, create an IAAFFile.  If pRawStorage is
  /// actually an IAAFRandomRawStorage, the created file will be an
  /// IAAFRandomFile.
  ///
  /// Note that AAF files based on Binary Structured Storage will
  /// require the underlying IAAFRawStorage to be at least readable,
  /// even in the case of write-only AAF files.
  ///
  /// Note also that only the following combinations of access and
  /// existence are legal:
  ///
  ///          existence   access   Legal?
  ///          ---------   ------   ------
  ///          existing    read     yes
  ///          existing    write    no
  ///          existing    modify   yes
  ///            new       read     no
  ///            new       write    yes
  ///            new       modify   yes
  ///
  /// This method will succeed if the following are true:
  /// - The pRawStorage pointer is valid.
  /// - The ppNewFile pointer is valid.
  /// - The accessibility of the specified raw storage matches that of the desired AAF File; additionally, if the file kind is
  ///   Structured Storage Binary, the raw storage is also required to be at least readable. 
  /// - A legal combination of existence and access flags is given.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pRawStorage or ppNewFile arg is NULL.
  ///
  /// AAFRESULT_NOT_READABLE
  /// - The access parameter specifies readability or if this file is
  ///   Binary Structured Storage, but the specified raw storage is
  ///   not readable.
  ///
  /// AAFRESULT_NOT_WRITEABLE
  /// - The access parameter specifies writeability but the specified
  ///   raw storage is not writeable.
  ///
  /// AAFRESULT_NULL_PARAM
  /// - existence is new, and pFileKind is NULL.
  ///
  /// AAFRESULT_INVALID_PARAM
  /// - The access or existence parameters are not set to a legal
  ///   combination of values.
  /// 
  /// @param pRawStorage [in] storage to be associated with this file
  /// @param existence [in] Governs whether storage is on pre-existing data, or is
  ///  newly created.
  /// @param access [in] Governs whether stream may be read from and/or written
  ///  to.
  /// @param pFileKind [in] kind of file to be created; only used for new files
  /// @param modeFlags [in] File mode flags
  /// @param pIdent [in] Identification to be associated with this file; only
  ///  used for new files
  /// @param ppNewFile [out] newly-created file
  /// 
  STDAPI AAFCreateAAFFileOnRawStorage (
    IAAFRawStorage *  pRawStorage,
    aafFileExistence_t  existence,
    aafFileAccess_t  access,
    aafUID_constptr  pFileKind,
    aafUInt32  modeFlags,
    aafProductIdentification_constptr  pIdent,
    IAAFFile ** ppNewFile);

  //***********************************************************
  //
  // AAFSetProgressCallback()
  //
  /// Sets a progress callback, called back during load and save.
  ///
  /// @param pProgress [in] Pointer to the interface of the progress interface callback.
  /// 
  STDAPI AAFSetProgressCallback (
    IAAFProgress*  pProgress);

  //***********************************************************
  //
  // AAFGetFileEncodings()
  //
  /// Returns an enumeration of file encodings supported by this version
  /// of the library.
  ///
  /// This method will succeed if the following are true:
  /// - The ppFileEncodings pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - ppFileEncodings arg is NULL.
  ///
  /// @param ppFileEncodings [out] Available file encodings.
  /// 
  STDAPI AAFGetFileEncodings (
    IEnumAAFFileEncodings ** ppFileEncodings);

  //***********************************************************
  //
  // AAFSetDiagnosticOutput()
  //
  /// Make the specified diagnostic output stream the AAF Toolkit's diagnostic output stream.
  /// By default the diagnostic output goes to stderr. The passed in pointer is AddRefed.
  /// The pointer will be Released the next time AAFSetDiagnosticOutput is called or when
  /// the AAF DLL is unloaded.
  /// 
  ///
  /// This method will succeed if the following are true:
  /// - The pOutput pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pStream arg is NULL.
  ///
  /// @param pOutput [in] New diagnostic output.
  /// 
  STDAPI AAFSetDiagnosticOutput (
    IAAFDiagnosticOutput*  pOutput);

  //***********************************************************
  //
  // AAFGetLibraryVersion()
  //
  /// Return the version of the AAF library currently
  /// running on this machine, which implements these interfaces.
  /// 
  /// Succeeds if all of the following are true:
  /// - the pVersion pointer is valid.
  /// 
  /// If this method fails nothing is written to *pVersion.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pVersion is null.
  ///
  /// @param pVersion [out, retval] The library version
  /// 
  STDAPI AAFGetLibraryVersion (
    aafProductVersion_t *  pVersion);

  //***********************************************************
  //
  // AAFGetStaticLibraryVersion()
  //
  /// Return the version of the static (aaflib) library
  /// linked against the calling appplication. This version may be the same as
  /// or different from the version of the (dynamically linked) AAF Library
  /// containing the implementation of the various interfaces.  The version
  /// of the AAF Library may be obtained by calling AAFGetLibraryVersion().
  /// 
  /// Succeeds if all of the following are true:
  /// - the pVersion pointer is valid.
  /// 
  /// If this method fails nothing is written to *pVersion.
  /// 
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pVersion is null.
  ///
  /// @param pVersion [out, retval] The static library version
  /// 
  STDAPI AAFGetStaticLibraryVersion (
    aafProductVersion_t *  pVersion);

  //***********************************************************
  //
  // AAFGetLibraryPathNameBufLen()
  //
  /// Returns size of buffer (in bytes) required for AAFGetLibraryPathName().
  /// 
  /// Succeeds if:
  /// - The pBufSize pointer is valid.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pBufSize arg is NULL.
  ///
  /// @param pBufSize [out] size of required buffer, in bytes
  /// 
  STDAPI AAFGetLibraryPathNameBufLen (
    aafUInt32 *  pBufSize);

  //***********************************************************
  //
  // AAFGetLibraryPathName()
  //
  /// Get the pathname of the AAF library.
  /// 
  /// Writes the LibraryPathName, with a trailing null
  /// character, into the pLibraryPathName buffer.  The
  /// buffer is allocated by the caller.  The size of the buffer is
  /// given by bufSize.
  /// 
  /// Caller may call AAFGetLibraryPathNameBufLen() to determine the
  /// required buffer size.
  /// 
  /// If this method fails nothing will be written to
  /// *pLibraryPathName.
  /// 
  /// Succeeds if:
  /// - The pLibraryPathName pointer is valid.
  /// - bufSize indicates that the buffer is large enough to hold
  ///   LibraryPathName.
  ///
  /// This method will return the following codes.  If more than one of
  /// the listed errors is in effect, it will return the first one
  /// encountered in the order given below:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.  (This is the only code indicating success.)
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pLibraryPathName arg is NULL.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - bufSize indicates that the allocated buffer is not large
  ///     enough to hold LibraryPathName.
  /// 
  /// @param pLibraryPathName [out, string, size_is(bufSize)] buffer into which LibraryPathName is to be written
  /// @param bufSize [in] size of *pLibraryPathName buffer in bytes
  /// 
  STDAPI AAFGetLibraryPathName (
    aafCharacter *  pLibraryPathName,
    aafUInt32  bufSize);

  //***********************************************************
  //
  // AAFResultToTextBufLen()
  //
  /// Returns the size of the buffer, in bytes, required for the AAFResultToText() function.
  ///
  /// Succeeds if all of the following are true:
  /// - the pResultTextSize pointer is valid.
  /// - the result is an AAFRESULT.
  /// - the result is a recognized AAFRESULT.
  ///
  /// If this method fails nothing will be written to *pResultTextSize.
  ///
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResultTextSize arg is NULL.
  ///
  /// AAFRESULT_RESULT_NOT_AAF
  ///   - result is not an AAFRESULT.
  ///
  /// AAFRESULT_RESULT_NOT_RECOGNIZED
  ///   - result is not a recognized AAFRESULT.
  /// 
  /// @param result [in] The result
  /// @param pResultTextSize [out] The size of the required buffer, in bytes.
  /// 
  STDAPI AAFResultToTextBufLen (
    AAFRESULT  result,
    aafUInt32 *   pResultTextSize);


  //***********************************************************
  //
  // AAFResultToText()
  //
  /// /// Returns the text representation of an AAFRESULT.
  ///
  /// Succeeds if all of the following are true:
  /// - the pResultText pointer is valid.
  /// - the result is an AAFRESULT.
  /// - the result is a recognized AAFRESULT.
  /// - the buffer is large enough to hold the result text.
  ///
  /// If this method fails nothing will be written to resultText.
  ///
  /// This method will return the following codes:
  /// 
  /// AAFRESULT_SUCCESS
  ///   - succeeded.
  ///
  /// AAFRESULT_NULL_PARAM
  ///   - pResultText arg is NULL.
  ///
  /// AAFRESULT_RESULT_NOT_AAF
  ///   - result is not an AAFRESULT.
  ///
  /// AAFRESULT_RESULT_NOT_RECOGNIZED
  ///   - result is not a recognized AAFRESULT.
  ///
  /// AAFRESULT_SMALLBUF
  ///   - pResultText is too small to hold the result text.
  /// 
  /// @param result [in] The result
  /// @param pResultText [out, string, size_is(resultTextSize)] The text representation of the result
  /// @param resultTextSize [in] The size, in bytes, of pResultText
  /// 
  STDAPI AAFResultToText (
    AAFRESULT  result,
    aafCharacter *  pResultText,
    aafUInt32  resultTextSize);


#endif // __AAF_h__
